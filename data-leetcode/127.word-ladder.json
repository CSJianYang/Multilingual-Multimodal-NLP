[
    {
        "title": "Remove Element",
        "question_content": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\n\tChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\n\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n&nbsp;\nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n&nbsp;\nConstraints:\n\n\t0 <= nums.length <= 100\n\t0 <= nums[i] <= 50\n\t0 <= val <= 100",
        "solutions": [
            {
                "id": 3670940,
                "title": "best-100-c-java-python-beginner-friendly",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe intuition behind this solution is to iterate through the array and keep track of two pointers: `index` and `i`. The `index` pointer represents the position where the next non-target element should be placed, while the `i` pointer iterates through the array elements. By overwriting the target elements with non-target elements, the solution effectively removes all occurrences of the target value from the array.\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. Initialize `index` to 0, which represents the current position for the next non-target element.\\r\\n2. Iterate through each element of the input array using the `i` pointer.\\r\\n3. For each element `nums[i]`, check if it is equal to the target value.\\r\\n    - If `nums[i]` is not equal to `val`, it means it is a non-target element.\\r\\n    - Set `nums[index]` to `nums[i]` to store the non-target element at the current `index` position.\\r\\n    - Increment `index` by 1 to move to the next position for the next non-target element.\\r\\n4. Continue this process until all elements in the array have been processed.\\r\\n5. Finally, return the value of `index`, which represents the length of the modified array.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$ O(n) $$\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$ O(1) $$\\r\\n\\r\\n# Code\\r\\n```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    int removeElement(vector<int>& nums, int val) {\\r\\n        int index = 0;\\r\\n        for(int i = 0; i< nums.size(); i++){\\r\\n            if(nums[i] != val){\\r\\n                nums[index] = nums[i];\\r\\n                index++;\\r\\n            }\\r\\n        }\\r\\n        return index;\\r\\n    }\\r\\n};\\r\\n```\\r\\n```Java []\\r\\nclass Solution {\\r\\n    public int removeElement(int[] nums, int val) {\\r\\n        int index = 0;\\r\\n        for (int i = 0; i < nums.length; i++) {\\r\\n            if (nums[i] != val) {\\r\\n                nums[index] = nums[i];\\r\\n                index++;\\r\\n            }\\r\\n        }\\r\\n        return index;\\r\\n    }\\r\\n}\\r\\n```\\r\\n```Python3 []\\r\\nclass Solution:\\r\\n    def removeElement(self, nums: List[int], val: int) -> int:\\r\\n        index = 0\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] != val:\\r\\n                nums[index] = nums[i]\\r\\n                index += 1\\r\\n        return index\\r\\n```\\r\\n\\r\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/f1c3c890-6ac9-41a0-8a97-b0bae10570c2_1687458739.4610858.png)\\r\\n\\r\\n\\r\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\r\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\r\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\r\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\r\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\r\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\r\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\r\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\r\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\r\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\r\\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\\r\\n\\r\\n\\r\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\r\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    int removeElement(vector<int>& nums, int val) {\\r\\n        int index = 0;\\r\\n        for(int i = 0; i< nums.size(); i++){\\r\\n            if(nums[i] != val){\\r\\n                nums[index] = nums[i];\\r\\n                index++;\\r\\n            }\\r\\n        }\\r\\n        return index;\\r\\n    }\\r\\n};\\r\\n```\n```Java []\\r\\nclass Solution {\\r\\n    public int removeElement(int[] nums, int val) {\\r\\n        int index = 0;\\r\\n        for (int i = 0; i < nums.length; i++) {\\r\\n            if (nums[i] != val) {\\r\\n                nums[index] = nums[i];\\r\\n                index++;\\r\\n            }\\r\\n        }\\r\\n        return index;\\r\\n    }\\r\\n}\\r\\n```\n```Python3 []\\r\\nclass Solution:\\r\\n    def removeElement(self, nums: List[int], val: int) -> int:\\r\\n        index = 0\\r\\n        for i in range(len(nums)):\\r\\n            if nums[i] != val:\\r\\n                nums[index] = nums[i]\\r\\n                index += 1\\r\\n        return index\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102906,
                "title": "java-best-solution-o-n-time-complexity",
                "content": "# Approach\\n- I am using Two pointers method\\n- After shifting the val to the right side of the array.\\n- Just return the value of k which is length of array excluding val.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                i++;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                i++;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12584,
                "title": "6-line-python-solution-48-ms",
                "content": "    def removeElement(self, nums, val):\\n        i = 0\\n        for x in nums:\\n            if x != val:\\n                nums[i] = x\\n                i += 1\\n        return i",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def removeElement(self, nums, val):\\n        i = 0\\n        for x in nums:\\n            if x != val:\\n                nums[i] = x\\n                i += 1\\n        return i",
                "codeTag": "Python3"
            },
            {
                "id": 12289,
                "title": "my-solution-for-your-reference",
                "content": "    int removeElement(int A[], int n, int elem) {\\n        int begin=0;\\n        for(int i=0;i<n;i++) if(A[i]!=elem) A[begin++]=A[i];\\n        return begin;\\n    }",
                "solutionTags": [],
                "code": "    int removeElement(int A[], int n, int elem) {\\n        int begin=0;\\n        for(int i=0;i<n;i++) if(A[i]!=elem) A[begin++]=A[i];\\n        return begin;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 12286,
                "title": "accepted-java-solution",
                "content": "public class Solution {\\n\\n    public int removeElement(int[] A, int elem) {\\n       int m = 0;    \\n       for(int i = 0; i < A.length; i++){\\n           \\n           if(A[i] != elem){\\n               A[m] = A[i];\\n               m++;\\n           }\\n       }\\n       \\n       return m;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int removeElement(int[] A, int elem) {\\n       int m = 0;    \\n       for(int i = 0; i < A.length; i++){\\n           \\n           if(A[i] != elem){\\n               A[m] = A[i];\\n               m++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 12306,
                "title": "simple-python-o-n-two-pointer-in-place-solution",
                "content": "Starting from the left every time we find a value that is the target value we swap it out with an item starting from the right.  We decrement end each time as we know that the final item is the target value and only increment start once we know the value is ok.  Once start reaches end we know all items after that point are the target value so we can stop there.\\n\\n\\n      def removeElement(self, nums, val):\\n        start, end = 0, len(nums) - 1\\n        while start <= end:\\n            if nums[start] == val:\\n                nums[start], nums[end], end = nums[end], nums[start], end - 1\\n            else:\\n                start +=1\\n        return start",
                "solutionTags": [
                    "Python"
                ],
                "code": "Starting from the left every time we find a value that is the target value we swap it out with an item starting from the right.  We decrement end each time as we know that the final item is the target value and only increment start once we know the value is ok.  Once start reaches end we know all items after that point are the target value so we can stop there.\\n\\n\\n      def removeElement(self, nums, val):\\n        start, end = 0, len(nums) - 1\\n        while start <= end:\\n            if nums[start] == val:\\n                nums[start], nums[end], end = nums[end], nums[start], end - 1\\n            else:\\n                start +=1\\n        return start",
                "codeTag": "Python3"
            },
            {
                "id": 12299,
                "title": "very-simple-and-optimal-c-solution",
                "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        for(int i = 0 ; i < nums.size() ; ++i) {\\n            if(nums[i] == val)\\n                cnt++;\\n            else\\n                nums[i-cnt] = nums[i];\\n        }\\n        return nums.size()-cnt;\\n    }",
                "solutionTags": [],
                "code": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        for(int i = 0 ; i < nums.size() ; ++i) {\\n            if(nums[i] == val)\\n                cnt++;\\n            else\\n                nums[i-cnt] = nums[i];\\n        }\\n        return nums.size()-cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2785400,
                "title": "c-faster-than-100-two-pointer-simple-code",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        return j;        \\n    }\\n};\\n```\\n\\n**<--Upvote If Helpful!!!!!-->**",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        return j;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263550,
                "title": "2-lines-of-code-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n#please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n#please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791353,
                "title": "python-3-one-liner",
                "content": "Runtime: 32 ms, faster than 80.15% of Python3 online submissions for Remove Element.\\nMemory Usage: 13.7 MB, less than 85.60% of Python3 online submissions for Remove Element.\\n\\n```python\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums: nums.remove(val)\\n```\\n\\nIf you like this solution, please, upvote so that others can see it too. Thanks!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums: nums.remove(val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814712,
                "title": "simple-java-solution-1ms",
                "content": "upvote if it works\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        \\n        int c = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] != val){\\n                nums[c] = nums[i];\\n                c++;\\n                \\n            }\\n            \\n        }\\n        \\n        return c;\\n    }\\n    \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        \\n        int c = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] != val){\\n                nums[c] = nums[i];\\n                c++;\\n                \\n            }\\n            \\n        }\\n        \\n        return c;\\n    }\\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430881,
                "title": "this-is-how-you-solve-all-in-place-questions-simple-easy-to-understand-js-solution",
                "content": "I have been stuck on \"in place\" problems for too long..  \\n1. if index[i] == val. zeroStartIdx ++, then you get your number! \\n\\n```\\nvar removeElement = function(nums, val) {\\n    var zeroStartIdx = 0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]!==val){\\n            nums[zeroStartIdx]=nums[i];\\n            zeroStartIdx++\\n        }\\n    }\\n    return zeroStartIdx; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElement = function(nums, val) {\\n    var zeroStartIdx = 0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]!==val){\\n            nums[zeroStartIdx]=nums[i];\\n            zeroStartIdx++\\n        }\\n    }\\n    return zeroStartIdx; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12282,
                "title": "fast-short-java-solution",
                "content": "    public int removeElement(int[] A, int elem) {\\n        int l = A.length;\\n        for (int i=0; i<l; i++) {\\n            if (A[i] == elem) {\\n                A[i--] = A[l-- -1];\\n            }\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int removeElement(int[] A, int elem) {\\n        int l = A.length;\\n        for (int i=0; i<l; i++) {\\n            if (A[i] == elem) {\\n                A[i--] = A[l-- -1];\\n            }\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1189866,
                "title": "javascript-solution-two-pointers",
                "content": "```\\nvar removeElement = function(nums, val) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while (left <= right) {\\n        if (nums[left] === val) {\\n            nums[left] = nums[right];\\n            right--;\\n        }\\n        else {\\n            left++;\\n        }\\n    }\\n    \\n    return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar removeElement = function(nums, val) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while (left <= right) {\\n        if (nums[left] === val) {\\n            nums[left] = nums[right];\\n            right--;\\n        }\\n        else {\\n            left++;\\n        }\\n    }\\n    \\n    return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12405,
                "title": "9-line-java-solution",
                "content": "The basic idea is when elem is found at index i, let A[i] = the last element in the modifying array, then repeat searching until elem is not found.\\n\\n\\n    public int removeElement(int[] A, int elem) {\\n        int len = A.length;\\n        for (int i = 0 ; i< len; ++i){\\n            while (A[i]==elem && i< len) {\\n                A[i]=A[--len];\\n            }\\n        }\\n        return len;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is when elem is found at index i, let A[i] = the last element in the modifying array, then repeat searching until elem is not found.\\n\\n\\n    public int removeElement(int[] A, int elem) {\\n        int len = A.length;\\n        for (int i = 0 ; i< len; ++i){\\n            while (A[i]==elem && i< len) {\\n                A[i]=A[--len];\\n            }\\n        }\\n        return len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3416598,
                "title": "c-java-python-js-fully-explained-easy-to-understand",
                "content": "# Intuition:\\nThe problem requires removing all occurrences of a given value val from a given integer array nums and returning the new length of the resulting array after the removal.\\n\\n# Approach:\\nThe approach taken here is to keep a counter variable count for keeping track of elements other than val and then loop through all the elements of the array. For each element, if it\\'s not equal to val, it is placed at index count of the array, and count is incremented.\\n\\nFinally, the length of the new array is equal to count. This approach modifies the input array in-place without using any additional space.\\n\\n# Complexity:\\n- Time Complexity: The time complexity of this approach is O(n) since we are traversing the entire array once.\\n- Space Complexity: The space complexity of this approach is O(1) since we are not using any additional space.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n         // Counter for keeping track of elements other than val\\n        int count = 0;\\n        // Loop through all the elements of the array\\n        for (int i = 0; i < nums.size(); i++) {\\n            // If the element is not val\\n            if (nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n# JAVASCRIPT\\n```\\nfunction removeElement(nums, val) {\\n    // Counter for keeping track of elements other than val\\n    let count = 0;\\n    // Loop through all the elements of the array\\n    for (let i = 0; i < nums.length; i++) {\\n        // If the element is not val\\n        if (nums[i] !== val) {\\n            nums[count++] = nums[i];\\n        }\\n    }\\n    return count;\\n}\\n\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        // Counter for keeping track of elements other than val\\n        int count = 0;\\n        // Loop through all the elements of the array\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the element is not val\\n            if (nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        # Counter for keeping track of elements other than val\\n        count = 0\\n        # Loop through all the elements of the array\\n        for i in range(len(nums)):\\n            # If the element is not val\\n            if nums[i] != val:\\n                nums[count] = nums[i]\\n                count += 1\\n        return count\\n\\n```\\n\\n***THANK YOU***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n         // Counter for keeping track of elements other than val\\n        int count = 0;\\n        // Loop through all the elements of the array\\n        for (int i = 0; i < nums.size(); i++) {\\n            // If the element is not val\\n            if (nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\n```\\nfunction removeElement(nums, val) {\\n    // Counter for keeping track of elements other than val\\n    let count = 0;\\n    // Loop through all the elements of the array\\n    for (let i = 0; i < nums.length; i++) {\\n        // If the element is not val\\n        if (nums[i] !== val) {\\n            nums[count++] = nums[i];\\n        }\\n    }\\n    return count;\\n}\\n\\n```\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        // Counter for keeping track of elements other than val\\n        int count = 0;\\n        // Loop through all the elements of the array\\n        for (int i = 0; i < nums.length; i++) {\\n            // If the element is not val\\n            if (nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        # Counter for keeping track of elements other than val\\n        count = 0\\n        # Loop through all the elements of the array\\n        for i in range(len(nums)):\\n            # If the element is not val\\n            if nums[i] != val:\\n                nums[count] = nums[i]\\n                count += 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048331,
                "title": "c-c-0-ms-faster-than-100-00-cool-clear-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint removeElement(vector<int>& nums, int val) {\\n\\t\\t\\tint length = nums.size(), index = 0;\\n\\t\\t\\twhile ( index < length )\\n\\t\\t\\t{\\n\\t\\t\\t\\t if ( nums[index] == val )\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t\\t nums[index] = nums[length - 1];\\n\\t\\t\\t\\t\\t -- length;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse ++index;\\n\\t\\t\\t}\\n\\t\\t\\t return length;  \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint removeElement(vector<int>& nums, int val) {\\n\\t\\t\\tint length = nums.size(), index = 0;\\n\\t\\t\\twhile ( index < length )\\n\\t\\t\\t{\\n\\t\\t\\t\\t if ( nums[index] == val )\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t\\t nums[index] = nums[length - 1];\\n\\t\\t\\t\\t\\t -- length;\\n\\t\\t\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 12662,
                "title": "java-short-and-clean",
                "content": "    public class Solution {\\n\\tpublic int removeElement(int[] nums, int val) {\\n\\t\\tint i = 0;\\n\\t\\tfor (int n : nums)\\n\\t\\t\\tif (n != val)\\n\\t\\t\\t\\tnums[i++] = n;\\n\\t\\treturn i;\\n\\t} }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\tpublic int removeElement(int[] nums, int val) {\\n\\t\\tint i = 0;\\n\\t\\tfor (int n : nums)\\n\\t\\t\\tif (n != val)\\n\\t\\t\\t\\tnums[i++] = n;\\n\\t\\treturn i;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1656827,
                "title": "solution-swift-remove-element-test-cases",
                "content": "```swift\\nclass Solution {\\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\\n        nums = nums.filter { $0 != val }\\n        return nums.count\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n\\t/// Your function should return k = 2, with the first two elements of nums being 2.\\n    /// It does not matter what you leave beyond the returned k (hence they are underscores).\\n    func test0() {\\n        var array = [3,2,2,3]\\n        solution.removeElement(&array, 3)\\n        XCTAssertEqual(array, [2,2])\\n    }\\n    \\n    /// Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\\n    /// Note that the five elements can be returned in any order.\\n    /// It does not matter what you leave beyond the returned k (hence they are underscores).\\n    func test1() {\\n        var array = [0,1,2,2,3,0,4,2]\\n        solution.removeElement(&array, 2)\\n        XCTAssertEqual(array, [0,1,3,0,4])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\\n        nums = nums.filter { $0 != val }\\n        return nums.count\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n\\t/// Your function should return k = 2, with the first two elements of nums being 2.\\n    /// It does not matter what you leave beyond the returned k (hence they are underscores).\\n    func test0() {\\n        var array = [3,2,2,3]\\n        solution.removeElement(&array, 3)\\n        XCTAssertEqual(array, [2,2])\\n    }\\n    \\n    /// Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\\n    /// Note that the five elements can be returned in any order.\\n    /// It does not matter what you leave beyond the returned k (hence they are underscores).\\n    func test1() {\\n        var array = [0,1,2,2,3,0,4,2]\\n        solution.removeElement(&array, 2)\\n        XCTAssertEqual(array, [0,1,3,0,4])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327006,
                "title": "c-simple-and-clean-4-line-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int ptr = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] != val) nums[ptr++] = nums[i];\\n        \\n        return ptr;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int ptr = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] != val) nums[ptr++] = nums[i];\\n        \\n        return ptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363153,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        while val in nums:\\n            nums.remove(val)\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        while val in nums:\\n            nums.remove(val)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12757,
                "title": "6-lines-of-c-solution",
                "content": "    int removeElement(int a[], int n, int elem) {\\n            int count = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (a[i] != elem) {\\n                    a[count++] = a[i];\\n                }\\n            }\\n            return count;\\n        }",
                "solutionTags": [],
                "code": "    int removeElement(int a[], int n, int elem) {\\n            int count = 0;\\n            for (int i = 0; i < n; ++i) {\\n                if (a[i] != elem) {\\n                    a[count++] = a[i];\\n                }\\n            }\\n            return count;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3300181,
                "title": "clear-c-solution-let-s-find-best-solution-together",
                "content": "**`If you have any thought feel free leave a comment below...`** \\n```\\nint removeElement(int *nums, int numsSize, int val) {\\n    int count = 0;\\n\\n    for (int i = 0; i < numsSize; i++)\\n        if (nums[i] == val) \\n            count++;\\n        else \\n            nums[i - count] = nums[i];\\n    return (numsSize - count);\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeElement(int *nums, int numsSize, int val) {\\n    int count = 0;\\n\\n    for (int i = 0; i < numsSize; i++)\\n        if (nums[i] == val) \\n            count++;\\n        else \\n            nums[i - count] = nums[i];\\n    return (numsSize - count);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664999,
                "title": "python-easy-solution-in-7-lines-faster-than-92-35-users",
                "content": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k=0\\n        for i in range(len(nums)):\\n            if nums[i]==val:\\n                continue\\n            nums[k]=nums[i]\\n            k+=1\\n        return k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k=0\\n        for i in range(len(nums)):\\n            if nums[i]==val:\\n                continue\\n            nums[k]=nums[i]\\n            k+=1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902470,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        var i = 0\\n\\n        for num in nums {\\n            guard num != val else { continue }\\n            nums[i] = num\\n            i += 1\\n        }\\n\\n        return i\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n\\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        var i = 0\\n\\n        for num in nums {\\n            guard num != val else { continue }\\n            nums[i] = num\\n            i += 1\\n        }\\n\\n        return i\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753281,
                "title": "c-easy-approach",
                "content": "Kindly **upvote** if you find it helpful **: )**\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i]==val){\\n                c++;\\n                nums[i]=51; // as constraints mention: 0 <= nums[i] <= 50 \\n            }\\n        }\\n        sort(nums.begin(), nums.end()); // sorting array\\n        nums.erase(nums.end()-c, nums.end()); // erasing 51 values\\n        return nums.size();\\n    }\\n};\\n```\\nLet me know in the comments if you have any different approach...",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i]==val){\\n                c++;\\n                nums[i]=51; // as constraints mention: 0 <= nums[i] <= 50 \\n            }\\n        }\\n        sort(nums.begin(), nums.end()); // sorting array\\n        nums.erase(nums.end()-c, nums.end()); // erasing 51 values\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762818,
                "title": "python-no-built-ins-pure-logic",
                "content": "```\\ndef removeElement(self, nums, val):\\n    i = 0\\n    for x in nums:\\n        if x != val:\\n            nums[i] = x\\n            i += 1\\n    return i\\n```",
                "solutionTags": [],
                "code": "```\\ndef removeElement(self, nums, val):\\n    i = 0\\n    for x in nums:\\n        if x != val:\\n            nums[i] = x\\n            i += 1\\n    return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222376,
                "title": "javascript",
                "content": "```\\nvar removeElement = function(nums, val) {\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === val) {\\n      nums.splice(i, 1);\\n      i--;\\n    }\\n  }\\n  return nums.length;\\n};\\n```\\n\\n```\\nvar removeElement = function(nums, val) {\\n  let i = 0;\\n  for (let j = 0; j < nums.length; j++) {\\n    if (nums[j] !== val) {\\n      nums[i] = nums[j];\\n      i++;\\n    }\\n  }\\n  return i;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeElement = function(nums, val) {\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === val) {\\n      nums.splice(i, 1);\\n      i--;\\n    }\\n  }\\n  return nums.length;\\n};\\n```\n```\\nvar removeElement = function(nums, val) {\\n  let i = 0;\\n  for (let j = 0; j < nums.length; j++) {\\n    if (nums[j] !== val) {\\n      nums[i] = nums[j];\\n      i++;\\n    }\\n  }\\n  return i;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602507,
                "title": "python3-fastest-and-easiest-faster-than-95-solutions",
                "content": "```\\nwhile val in nums :\\n\\t        nums.remove(val)\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nwhile val in nums :\\n\\t        nums.remove(val)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283692,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        \\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        \\n        return k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        \\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        \\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12680,
                "title": "a-simple-c-solution",
                "content": "    int removeElement(vector<int>& nums, int val) {\\n        int idx=0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]!=val) {\\n                nums[idx] = nums[i];\\n                idx ++;\\n            }\\n        }\\n        return idx;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int removeElement(vector<int>& nums, int val) {\\n        int idx=0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]!=val) {\\n                nums[idx] = nums[i];\\n                idx ++;\\n            }\\n        }\\n        return idx;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3250750,
                "title": "java-script-3-line-solution-beats-99",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    while(nums.indexOf(val) !== -1) {\\n        nums.splice(nums.indexOf(val), 1)\\n    }\\n    return nums.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    while(nums.indexOf(val) !== -1) {\\n        nums.splice(nums.indexOf(val), 1)\\n    }\\n    return nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389895,
                "title": "go-simple-solution",
                "content": "iterate through nums keeping a separate pointer to our insert location.  If the value in nums isn\\'t the val we\\'re removing, then insert it at the insert location and increment the insert location.  Since the insert location is always the next available spot, it is also keeping the length of the returned array.\\n```\\nfunc removeElement(nums []int, val int) int {\\n    i := 0\\n    for _, v := range nums {\\n        if v != val {\\n            nums[i] = v\\n            i++\\n        }\\n    }\\n    return i\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeElement(nums []int, val int) int {\\n    i := 0\\n    for _, v := range nums {\\n        if v != val {\\n            nums[i] = v\\n            i++\\n        }\\n    }\\n    return i\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001449,
                "title": "java-runtime-0ms-beats-100-00",
                "content": "# Intuition\\nThe problem at hand requires the removal of all instances of a specified value, `val`, from an integer array `nums`. My initial thoughts gravitate towards a straightforward approach that effectively eliminates the target value while maintaining the relative order of the remaining elements.\\n\\n# Approach\\nThe chosen approach relies on a two-pointer technique to efficiently handle the task of removing elements equal to `val` from the array `nums`. The two pointers, `i` and `newLength`, serve the following purposes:\\n- `i` traverses through the array to identify elements equal to `val`.\\n- `newLength` keeps track of the length of the modified array, excluding elements equal to `val`.\\n\\nThe algorithm unfolds as follows:\\n1. Initialize `newLength` to 0, indicating the initial length of the modified array.\\n2. Iterate through the `nums` array with the pointer `i`:\\n   - If `nums[i]` is not equal to the target value `val`, it implies a non-target element:\\n     - Assign `nums[i]` to `nums[newLength]`, effectively overwriting any potential `val` occurrence with the non-target value.\\n     - Increment `newLength` to reflect the modified array\\'s length.\\n3. After the iteration concludes, `newLength` holds the length of the modified array with the target values removed.\\n\\nThe algorithm excels at efficiently removing all instances of the specified value while preserving the original relative order of the remaining elements.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm traverses through the `nums` array once, performing constant-time operations at each step.\\n\\n- Space complexity: O(1)\\n  The algorithm utilizes a fixed amount of additional memory space for variables, ensuring a constant space complexity.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        \\n        int newLength = 0 ; \\n\\n         for (int i = 0; i < nums.length; i++) {\\n           \\n            if (nums[i] != val) {\\n                nums[newLength] = nums[i];\\n                newLength++;\\n            }\\n        }\\n\\n        return newLength;\\n        \\n    }\\n}\\n```\\n\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/6b19a218-ec92-4be8-8cd9-ab9268421080_1693835202.9284575.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        \\n        int newLength = 0 ; \\n\\n         for (int i = 0; i < nums.length; i++) {\\n           \\n            if (nums[i] != val) {\\n                nums[newLength] = nums[i];\\n                newLength++;\\n            }\\n        }\\n\\n        return newLength;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682609,
                "title": "faster-than-100-memory-usage-less-than-94-submissions",
                "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            (nums[i]==val)?count++:nums[i-count]=nums[i];\\n        }\\n        return nums.size()-count;\\n    }\\n};\\n**UPVOTE IF U FOUND IT HELPFUL**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            (nums[i]==val)?count++:nums[i-count]=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1424545,
                "title": "easiest-one-liner-c-solution",
                "content": "Simple STL solution. Sometimes, one-liners also need to be appreciated....! Please upvote, if you learned something from it.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {                \\n        nums.erase(remove(nums.begin(), nums.end(), val), nums.end());        \\n        //This has to be done to remove all the occurences.\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {                \\n        nums.erase(remove(nums.begin(), nums.end(), val), nums.end());        \\n        //This has to be done to remove all the occurences.\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947483,
                "title": "python-simple-solutions",
                "content": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        for n in nums:\\n            if n!=val:\\n                nums[i]=n\\n                i+=1\\n        return i\\n```\\n\\n```\\n    \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        for n in nums:\\n            if n!=val:\\n                nums[i]=n\\n                i+=1\\n        return i\\n```\n```\\n    \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500524,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\\n        nums.retain(|&x| x != val);\\n        return nums.len() as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\\n        nums.retain(|&x| x != val);\\n        return nums.len() as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974530,
                "title": "super-easy-c-o-n",
                "content": "***DO UPVOTE, IF IT HELPS !!!***\\n\\n\\tint removeElement(vector<int>& nums, int val) {\\n        \\n        int j=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                nums[j]=nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "***DO UPVOTE, IF IT HELPS !!!***\\n\\n\\tint removeElement(vector<int>& nums, int val) {\\n        \\n        int j=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                nums[j]=nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 12677,
                "title": "really-concise-one-pass-java-code",
                "content": "    public int removeElement(int[] A, int elem) {\\n        int next = 0;\\n        for(int i = 0; i < A.length; i++) {\\n            if(A[i] != elem) {\\n                A[next++] = A[i];\\n            }\\n        }\\n        return next;\\n    }\\n\\nI use \"next\" to track the position to put the next \"non-elem\" integer.",
                "solutionTags": [],
                "code": "    public int removeElement(int[] A, int elem) {\\n        int next = 0;\\n        for(int i = 0; i < A.length; i++) {\\n            if(A[i] != elem) {\\n                A[next++] = A[i];\\n            }\\n        }\\n        return next;\\n    }\\n\\nI use \"next\" to track the position to put the next \"non-elem\" integer.",
                "codeTag": "Unknown"
            },
            {
                "id": 1890581,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction removeElement(nums: number[], val: number): number {\\n  for (let i = 0; i < nums.length; i++) {\\n       if (nums[i] === val) { nums.splice(i, 1); i-- }\\n  }\\n\\n  return nums.length\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction removeElement(nums: number[], val: number): number {\\n  for (let i = 0; i < nums.length; i++) {\\n       if (nums[i] === val) { nums.splice(i, 1); i-- }\\n  }\\n\\n  return nums.length\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529351,
                "title": "java-tc-o-n-sc-o-1-optimized-two-pointers-solution-followup",
                "content": "**Using Two Pointers**\\n\\n```java\\n/**\\n * Using Two Pointers. Output array maintains the order of the input array.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        int insertPos = -1;\\n        for (int n : nums) {\\n            if (n != val) {\\n                nums[++insertPos] = n;\\n            }\\n        }\\n        return insertPos + 1;\\n    }\\n}\\n```\\n\\n---\\n**Follow Up: When elements to remove are rare**\\n\\n```java\\n/**\\n * Using Two Pointers - when elements to remove are rare.\\n *\\n * Here whenever we find val, we replace it with num at len-1 and reduce the\\n * length of the array by one. Total number of assignment operations required\\n * are less.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        int i = 0;\\n        while (i < len) {\\n            if (nums[i] == val) {\\n                nums[i] = nums[len - 1];\\n                // Reduce Array length by one\\n                len--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Remove Element questions on LeetCode:\\n- [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/discuss/1529341/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution)\\n- [80. Remove Duplicates from Sorted Array II + Follow Up](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/discuss/1529357/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n/**\\n * Using Two Pointers. Output array maintains the order of the input array.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        int insertPos = -1;\\n        for (int n : nums) {\\n            if (n != val) {\\n                nums[++insertPos] = n;\\n            }\\n        }\\n        return insertPos + 1;\\n    }\\n}\\n```\n```java\\n/**\\n * Using Two Pointers - when elements to remove are rare.\\n *\\n * Here whenever we find val, we replace it with num at len-1 and reduce the\\n * length of the array by one. Total number of assignment operations required\\n * are less.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        int i = 0;\\n        while (i < len) {\\n            if (nums[i] == val) {\\n                nums[i] = nums[len - 1];\\n                // Reduce Array length by one\\n                len--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12578,
                "title": "7-lines-java-solution",
                "content": "    public class Solution {\\n        public int removeElement(int[] nums, int val) {\\n            int idx = 0;\\n            for (int i = 0; i < nums.length; i++){\\n                if (nums[i] != val){\\n                    nums[idx++] = nums[i]; \\n                }\\n            }\\n            return idx;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int removeElement(int[] nums, int val) {\\n            int idx = 0;\\n            for (int i = 0; i < nums.length; i++){\\n                if (nums[i] != val){\\n                    nums[idx++] = nums[i]; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 12582,
                "title": "share-my-3-lines-c-code",
                "content": "        int removeElement(int A[], int n, int elem) {\\n                int i=0;\\n                while(i<n)A[i]==elem?A[i]=A[--n]:i++;\\n                return n;\\n        }",
                "solutionTags": [],
                "code": "        int removeElement(int A[], int n, int elem) {\\n                int i=0;\\n                while(i<n)A[i]==elem?A[i]=A[--n]:i++;\\n                return n;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2674727,
                "title": "c-two-pointer-approach-beginner-friendly-faster-then-100",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n            int n = nums.size();\\n            int j = 0;\\n            for(int i = 0; i<n; i++){\\n                    if(nums[i]!= val){\\n                        nums[j] = nums[i];\\n                            j++;\\n                    }\\n                   \\n            }\\n            return j;\\n        \\n    }\\n1. };``",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041826,
                "title": "kotlin-simple",
                "content": "```\\n    fun removeElement(nums: IntArray, num: Int): Int {\\n        var counter = 0\\n        nums.forEach { if (it != num) nums[counter++] = it }\\n\\n        return counter\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun removeElement(nums: IntArray, num: Int): Int {\\n        var counter = 0\\n        nums.forEach { if (it != num) nums[counter++] = it }\\n\\n        return counter\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328306,
                "title": "javascript-36ms-100-97-34",
                "content": "var removeElement = function(nums, val) {\\n    while(nums.indexOf(val,0) >= 0) {\\n        nums.splice(nums.indexOf(val,0), 1);\\n    }\\n    return nums.length;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var removeElement = function(nums, val) {\\n    while(nums.indexOf(val,0) >= 0) {\\n        nums.splice(nums.indexOf(val,0), 1);\\n    }\\n    return nums.length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 12377,
                "title": "short-python-solution",
                "content": "    def removeElement(self, nums, val):\\n        try:\\n            while True:\\n                nums.remove(val)\\n        except:\\n            return len(nums)",
                "solutionTags": [],
                "code": "    def removeElement(self, nums, val):\\n        try:\\n            while True:\\n                nums.remove(val)\\n        except:\\n            return len(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 3691033,
                "title": "3-lines-of-optimized-code-detailed-explanation",
                "content": "# Intuition\\nThe intuition behind this approach is to iterate through the array and keep track of two pointers: j and n. The pointer j represents the index of the current element we want to keep in the modified array, and the pointer n iterates through the original array elements.\\n\\n# Approach\\nThe approach involves iterating through each element of the array nums. If the current element n is not equal to the target value val, we update the element at index j in the array to be the current element n, and then increment j by 1. By doing this, we effectively remove any occurrences of val from the array and compact the elements towards the beginning.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(n), where n is the length of the input array nums. We need to iterate through each element of the array once.\\n- Space complexity: The space complexity is O(1) since we are modifying the input array in place and not using any additional space that scales with the input size.\\n\\n# Code\\n```\\nfunction removeElement(nums: number[], val: number): number {\\n    let j = 0;\\n    for( let n of nums )if( n !== val ) nums[j++] = n\\n    return j\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nfunction removeElement(nums: number[], val: number): number {\\n    let j = 0;\\n    for( let n of nums )if( n !== val ) nums[j++] = n\\n    return j\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516083,
                "title": "java-best-intuition-o-n-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially question is little confusing. But idea is simple remove the element asked in variable `val` and place another varible suppose `k` which is not equal to `val` i.e. `k != val` in it\\'s position and return the count of k in array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce you understand the question, approach become simple \\nJust take any variable to count all `k` in array. Then one by iterate through each element of array and skip the element equal to `val` and place the element `!= val` in it\\'s place and increase the count. Finally return the count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int l = nums.length;\\n        for(int a=0;a<l;a++){\\n            if(nums[a]==val){\\n                continue;\\n            }\\n            nums[i] = nums[a];\\n            i++;\\n        }\\n\\n        return i;\\n    }\\n}\\n```\\n# \\n\\n---\\n\\nPlease do upvote, It keeps me motivated to upload many problem optimal code solutions. Do comment if you need solution in any other language.\\nThank you...**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int l = nums.length;\\n        for(int a=0;a<l;a++){\\n            if(nums[a]==val){\\n                continue;\\n            }\\n            nums[i] = nums[a];\\n            i++;\\n        }\\n\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410533,
                "title": "best-solution-in-java-runtime-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n          int k = 0;\\n        for (int i = 0; i < nums.length ; i++) {\\n            if (nums[i] != val) {\\n                nums[k] = nums[i];\\n                k++;\\n            }\\n        }\\n\\n        return k;\\n    }\\n}\\n```\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/21bed395-f430-44c2-a88d-9a5f0f1345ee_1681339826.985599.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n          int k = 0;\\n        for (int i = 0; i < nums.length ; i++) {\\n            if (nums[i] != val) {\\n                nums[k] = nums[i];\\n                k++;\\n            }\\n        }\\n\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226460,
                "title": "beginner-friendly-0ms-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA simple, two pointer method approach will do the need. You can take a look at this problem before solving this for better understanding,  [Move Zeros](https://leetcode.com/problems/move-zeroes/). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Declare a second variable, that will help to shift value(val) to the end. \\n\\nStep 2: Just after shifting the values to the end, you can compare return the size of array that excludes shifted value.\\n\\nStep 3: Upvote this solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) \\n    {\\n        int count = 0, res = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                swap(nums[i],nums[res]);\\n                res++;\\n            }\\n            else if(nums[i]==val)\\n            count++;\\n        }\\n        return n-count;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) \\n    {\\n        int count = 0, res = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<n; i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                swap(nums[i],nums[res]);\\n                res++;\\n            }\\n            else if(nums[i]==val)\\n            count++;\\n        }\\n        return n-count;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750567,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1646997,
                "title": "100-faster-c-solution-beat-100-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]!=val){\\n                nums[j]=nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\\nPlease Upvote If you find this solution helpful",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]!=val){\\n                nums[j]=nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326109,
                "title": "c-solution",
                "content": "```csharp\\npublic int RemoveElement(int[] nums, int val)\\n{\\n\\tint res = 0;\\n\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tif (nums[i] != val)\\n\\t\\t{\\n\\t\\t\\tnums[res] = nums[i];\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n\\nAdvice from **Malurth**, shorter writing.\\n\\n```csharp\\npublic int RemoveElement(int[] nums, int val)\\n{\\n    int res = 0;\\n\\n    for (int i = 0; i < nums.Length; i++)\\n        if (nums[i] != val)\\n            nums[res++] = nums[i];\\n\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic int RemoveElement(int[] nums, int val)\\n{\\n\\tint res = 0;\\n\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tif (nums[i] != val)\\n\\t\\t{\\n\\t\\t\\tnums[res] = nums[i];\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```\n```csharp\\npublic int RemoveElement(int[] nums, int val)\\n{\\n    int res = 0;\\n\\n    for (int i = 0; i < nums.Length; i++)\\n        if (nums[i] != val)\\n            nums[res++] = nums[i];\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976242,
                "title": "o-n-time-very-simple-java-sol",
                "content": "# Intuition\\nWe are given an array and need to remove given value fro the array. After eliminating every occurrence of the given value, we must return the length of the items that remain.<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will take a variable count, it will count the elements except given value. We will iterate through array and check if element match with given value and add the next element at that place which is not equal to value.<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497134,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint removeElement(vector<int>& nums, int val) {\\n\\n\\t\\t\\tint idx = 0;\\n\\n\\t\\t\\tfor(int i=0 ; i<nums.size() ; i++){\\n\\t\\t\\t\\tif(nums[i] != val){\\n\\t\\t\\t\\t\\tnums[idx++] = nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn idx;\\n\\t\\t}\\n\\t}\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint removeElement(vector<int>& nums, int val) {\\n\\n\\t\\t\\tint idx = 0;\\n\\n\\t\\t\\tfor(int i=0 ; i<nums.size() ; i++){\\n\\t\\t\\t\\tif(nums[i] != val){\\n\\t\\t\\t\\t\\tnums[idx++] = nums[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1507118,
                "title": "c-faster-than-100-00",
                "content": "Runtime: 128 ms, faster than 100.00% of C# online submissions for Remove Element.\\nMemory Usage: 40.7 MB, less than 6.17% of C# online submissions for Remove Element.\\n\\n```\\n    public int RemoveElement(int[] nums, int val) {\\n        int j = 0;\\n        \\n        for(int i = 0; i< nums.Length; i++)\\n        {\\n            if(nums[i] != val)\\n            {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n                \\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int RemoveElement(int[] nums, int val) {\\n        int j = 0;\\n        \\n        for(int i = 0; i< nums.Length; i++)\\n        {\\n            if(nums[i] != val)\\n            {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n                \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410532,
                "title": "best-solution-in-java-runtime-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n          int k = 0;\\n        for (int i = 0; i < nums.length ; i++) {\\n            if (nums[i] != val) {\\n                nums[k++] = nums[i];\\n            }\\n        }\\n\\n        return k;\\n    }\\n}\\n```\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/21bed395-f430-44c2-a88d-9a5f0f1345ee_1681339826.985599.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n          int k = 0;\\n        for (int i = 0; i < nums.length ; i++) {\\n            if (nums[i] != val) {\\n                nums[k++] = nums[i];\\n            }\\n        }\\n\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765338,
                "title": "one-liner",
                "content": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums: nums.remove(val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums: nums.remove(val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312664,
                "title": "100-java-c-c-python-js-python3-fully-explained-with-comments-very-very-easy-code",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        // Initialize a variable c which will count the number of elements except val...\\n        int c = 0;\\n        // Loop through all the elements of the array from left to right...\\n        for(int i = 0; i < nums.length; i++) {\\n            // If the element is not val...\\n            if(nums[i] != val) {\\n                nums[c++] = nums[i];     // Add that element to the place of c..\\n            }        \\n        }\\n        return c;    // Return the number...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        // Initialize a variable c which will count the number of elements except val...\\n        int c = 0;\\n        // Loop through all the elements of the array from left to right...\\n        for(int i = 0; i < nums.size(); i++) {\\n            // If the element is not val...\\n            if(nums[i] != val) {\\n                nums[c++] = nums[i];     // Add that element to the place of c..\\n            }        \\n        }\\n        return c;    // Return the number...\\n    }\\n};\\n```\\n\\n# **C Language:**\\n```\\nint removeElement(int* nums, int numsSize, int val){\\n    // Initialize a variable c which will count the number of elements except val...\\n    int c = 0;\\n    // Loop through all the elements of the array from left to right...\\n    for(int i = 0; i < numsSize; i++) {\\n        // If the element is not val...\\n        if(nums[i] != val) {\\n            nums[c++] = nums[i];     // Add that element to the place of c..\\n        }        \\n    }\\n    return c;    // Return the number...\\n}\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        # Initialize a variable c which will count the number of elements except val...\\n        c = 0\\n        # Loop through all the elements of the array from left to right...\\n        for i in range(len(nums)):\\n            # If the element is not val...\\n            if(nums[i] != val):\\n                # Add that element to the place of c..\\n                nums[c] = nums[i]\\n                c += 1\\n        return c    # Return the number...\\n```\\n\\n# **JavaScript Solution:**\\n```\\nvar removeElement = function(nums, val) {\\n    // Initialize a variable c which will count the number of elements except val...\\n    let c = 0;\\n    // Loop through all the elements of the array from left to right...\\n    for(let i = 0; i < nums.length; i++) {\\n        // If the element is not val...\\n        if(nums[i] != val) {\\n            nums[c++] = nums[i];     // Add that element to the place of c..\\n        }        \\n    }\\n    return c;    // Return the number...\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        # Initialize a variable c which will count the number of elements except val...\\n        c = 0\\n        # Loop through all the elements of the array from left to right...\\n        for i in range(len(nums)):\\n            # If the element is not val...\\n            if(nums[i] != val):\\n                # Add that element to the place of c..\\n                nums[c] = nums[i]\\n                c += 1\\n        return c    # Return the number...\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        // Initialize a variable c which will count the number of elements except val...\\n        int c = 0;\\n        // Loop through all the elements of the array from left to right...\\n        for(int i = 0; i < nums.length; i++) {\\n            // If the element is not val...\\n            if(nums[i] != val) {\\n                nums[c++] = nums[i];     // Add that element to the place of c..\\n            }        \\n        }\\n        return c;    // Return the number...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        // Initialize a variable c which will count the number of elements except val...\\n        int c = 0;\\n        // Loop through all the elements of the array from left to right...\\n        for(int i = 0; i < nums.size(); i++) {\\n            // If the element is not val...\\n            if(nums[i] != val) {\\n                nums[c++] = nums[i];     // Add that element to the place of c..\\n            }        \\n        }\\n        return c;    // Return the number...\\n    }\\n};\\n```\n```\\nint removeElement(int* nums, int numsSize, int val){\\n    // Initialize a variable c which will count the number of elements except val...\\n    int c = 0;\\n    // Loop through all the elements of the array from left to right...\\n    for(int i = 0; i < numsSize; i++) {\\n        // If the element is not val...\\n        if(nums[i] != val) {\\n            nums[c++] = nums[i];     // Add that element to the place of c..\\n        }        \\n    }\\n    return c;    // Return the number...\\n}\\n```\n```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        # Initialize a variable c which will count the number of elements except val...\\n        c = 0\\n        # Loop through all the elements of the array from left to right...\\n        for i in range(len(nums)):\\n            # If the element is not val...\\n            if(nums[i] != val):\\n                # Add that element to the place of c..\\n                nums[c] = nums[i]\\n                c += 1\\n        return c    # Return the number...\\n```\n```\\nvar removeElement = function(nums, val) {\\n    // Initialize a variable c which will count the number of elements except val...\\n    let c = 0;\\n    // Loop through all the elements of the array from left to right...\\n    for(let i = 0; i < nums.length; i++) {\\n        // If the element is not val...\\n        if(nums[i] != val) {\\n            nums[c++] = nums[i];     // Add that element to the place of c..\\n        }        \\n    }\\n    return c;    // Return the number...\\n};\\n```\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        # Initialize a variable c which will count the number of elements except val...\\n        c = 0\\n        # Loop through all the elements of the array from left to right...\\n        for i in range(len(nums)):\\n            # If the element is not val...\\n            if(nums[i] != val):\\n                # Add that element to the place of c..\\n                nums[c] = nums[i]\\n                c += 1\\n        return c    # Return the number...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12545,
                "title": "accepted-java-solution",
                "content": "    public int removeElement(int[] nums, int val) {\\n        int start = 0, end = nums.length-1;\\n        while(start<=end){\\n            if(nums[start] == val){\\n                if(nums[end] == val)\\n                    end--;    \\n                else{\\n                    nums[start] = nums[end];\\n                    start++; end --;\\n                }\\n            }else{\\n                start++;\\n            }\\n        }\\n        return start;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int removeElement(int[] nums, int val) {\\n        int start = 0, end = nums.length-1;\\n        while(start<=end){\\n            if(nums[start] == val){\\n                if(nums[end] == val)\\n                    end--;    \\n                else{\\n                    nums[start] = nums[end];\\n                    start++; end --;\\n                }\\n            }else{\\n                start++;\\n            }\\n        }\\n        return start;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 12790,
                "title": "my-o-n-solution",
                "content": "    class Solution {\\n    public:\\n        int removeElement(int A[], int n, int elem) {\\n            int index = 0;\\n            int tail = n - 1;\\n            \\n            while(index <= tail){\\n                if(A[index] == elem){\\n                    A[index] = A[tail];\\n                    tail -= 1;\\n                }else{\\n                    index++;\\n                }     \\n            }\\n            \\n            return tail + 1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeElement(int A[], int n, int elem) {\\n            int index = 0;\\n            int tail = n - 1;\\n            \\n            while(index <= tail){\\n                if(A[index] == elem){\\n                    A[index] = A[tail];\\n                    tail -= 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3345323,
                "title": "python-two-pointer-beats-99",
                "content": "```\\nGiven : val = 2\\n1 2 2 2 5 2 5 \\ni           j\\nFirst Start from the far end \\n1 2 2 2 5 2 5 \\n  i         j\\nwhen nums[i] == val , nums[i] = nums[j]\\n1 2 2 2 5 2 5 \\n    i     j \\nif(num[j]) is also val then move it left till its not\\n1 5 5 2 2 2 5 \\n    i   j  \\nwhen i==j.. stop\\n1 5 5  2  2 2 5 \\n      i,j\\nyou see that i can still be val, \\nso we check before returning the answer  \\n\\n\\n\\n```\\n\\n\\n```\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n\\n        i,j=0,len(nums)-1;\\n        if(j==-1): return 0\\n        while(i<j):\\n            if(nums[i]==val):\\n                while(i<j and nums[j]==val): \\n                    j-=1\\n                nums[i]=nums[j];\\n                j-=1\\n                continue;\\n            i+=1\\n        return i+1 if nums[i]!=val else i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nGiven : val = 2\\n1 2 2 2 5 2 5 \\ni           j\\nFirst Start from the far end \\n1 2 2 2 5 2 5 \\n  i         j\\nwhen nums[i] == val , nums[i] = nums[j]\\n1 2 2 2 5 2 5 \\n    i     j \\nif(num[j]) is also val then move it left till its not\\n1 5 5 2 2 2 5 \\n    i   j  \\nwhen i==j.. stop\\n1 5 5  2  2 2 5 \\n      i,j\\nyou see that i can still be val, \\nso we check before returning the answer  \\n\\n\\n\\n```\n```\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n\\n        i,j=0,len(nums)-1;\\n        if(j==-1): return 0\\n        while(i<j):\\n            if(nums[i]==val):\\n                while(i<j and nums[j]==val): \\n                    j-=1\\n                nums[i]=nums[j];\\n                j-=1\\n                continue;\\n            i+=1\\n        return i+1 if nums[i]!=val else i\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3323084,
                "title": "c-best-100-solution-remove-with-in-place-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Find the first value in the sequence\\n2) Remember it index\\n3) Start with it index, insert all not equal vaue elements \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint removeElement(int* nums, int numsSize, int val){\\n    \\n    int appendIndex = 0;\\n    bool find = false;\\n    int k = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == val && !find) {\\n            appendIndex = i;\\n            find = true;\\n        }\\n        if (nums[i] != val) {\\n            nums[appendIndex] = nums[i];\\n            appendIndex++;\\n            k++;\\n        }\\n    }\\n\\n    return k;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeElement(int* nums, int numsSize, int val){\\n    \\n    int appendIndex = 0;\\n    bool find = false;\\n    int k = 0;\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        if (nums[i] == val && !find) {\\n            appendIndex = i;\\n            find = true;\\n        }\\n        if (nums[i] != val) {\\n            nums[appendIndex] = nums[i];\\n            appendIndex++;\\n            k++;\\n        }\\n    }\\n\\n    return k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716210,
                "title": "java-100-straight-forward",
                "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        \\n        int nextPosition = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] != val) {\\n                nums[nextPosition] = nums[i];\\n                nextPosition++;\\n            }\\n        }\\n        return nextPosition;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        \\n        int nextPosition = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            if(nums[i] != val) {\\n                nums[nextPosition] = nums[i];\\n                nextPosition++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2323444,
                "title": "c-java-python3-javascript-solution-faster-than-90-100",
                "content": "\\nSee the code : **\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-from-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-from-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**Submissioon detail**\\n![image](https://assets.leetcode.com/users/images/6597b2b3-0b26-474c-bab7-3d32f2966e9e_1658281607.6561923.png)\\n![image](https://assets.leetcode.com/users/images/1051fb48-dc5e-41f1-9037-90054323227b_1658281610.4712868.png)\\n![image](https://assets.leetcode.com/users/images/b0f22bbe-8ebb-4602-8047-35d71f2d2185_1658281612.8284416.png)\\n![image](https://assets.leetcode.com/users/images/a217d9dc-486e-4993-a2c3-ad0756c1f1a3_1658392948.3180606.png)\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "\\nSee the code : **\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-from-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-from-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\n**Submissioon detail**\\n![image](https://assets.leetcode.com/users/images/6597b2b3-0b26-474c-bab7-3d32f2966e9e_1658281607.6561923.png)\\n![image](https://assets.leetcode.com/users/images/1051fb48-dc5e-41f1-9037-90054323227b_1658281610.4712868.png)\\n![image](https://assets.leetcode.com/users/images/b0f22bbe-8ebb-4602-8047-35d71f2d2185_1658281612.8284416.png)\\n![image](https://assets.leetcode.com/users/images/a217d9dc-486e-4993-a2c3-ad0756c1f1a3_1658392948.3180606.png)\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "codeTag": "Unknown"
            },
            {
                "id": 1787879,
                "title": "javascript-solution-using-filter",
                "content": "\\n```\\nvar removeElement = function(nums, val) {\\n    newNums = nums.filter(x=> x!=val)\\n    for(i = 0; i<newNums.length; i++){\\n        nums[i] = newNums[i]\\n    }\\n    \\n    return newNums.length\\n}\\n```\\nSince JavaScript is a pass by value language just saying: \\n\\n```\\nnums = nums.filter(x => x!=val)\\n```\\n\\nwill not work. But you can still change the references of specific members of objects in javascript and have these peresist outside the function. So this solution simply reassigns the first values of nums to the values of the filtered array.\\n\\nHope this helps anyone that tried to use the \"filter\" function in their solution.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElement = function(nums, val) {\\n    newNums = nums.filter(x=> x!=val)\\n    for(i = 0; i<newNums.length; i++){\\n        nums[i] = newNums[i]\\n    }\\n    \\n    return newNums.length\\n}\\n```\n```\\nnums = nums.filter(x => x!=val)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150204,
                "title": "python-solution-beats-100",
                "content": "Python solution beats 100%.Since the modification is inplace, we only need to rearrange the elements `in place` .We keep two pointers `j` and `i` .So everytime we get an element which is not equal to the val, we just add it at the least possible index.\\n```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        j = 0\\n        \\n        for i in nums:\\n            if i !=val:\\n                nums[j] = i\\n                j+=1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        j = 0\\n        \\n        for i in nums:\\n            if i !=val:\\n                nums[j] = i\\n                j+=1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 12279,
                "title": "my-easy-python-solution",
                "content": "```\\nwhile val in nums:\\n    nums.remove(val)\\nreturn len(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nwhile val in nums:\\n    nums.remove(val)\\nreturn len(nums)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12592,
                "title": "6lines-java-solution",
                "content": "    \\n    public class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int len = 0;\\n        for(int num: nums) {\\n            if(num != val) {\\n                nums[len] = num;\\n                len++;\\n            }\\n        }\\n        return len;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int len = 0;\\n        for(int num: nums) {\\n            if(num != val) {\\n                nums[len] = num;\\n                len++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 12621,
                "title": "0ms-and-clean-java-solution",
                "content": "    public class Solution {\\n        public int removeElement(int[] nums, int val) {\\n            int lastIndex = nums.length - 1;\\n            \\n            for (int i = 0; i < lastIndex + 1; i++)\\n            {\\n                if (nums[i] == val)\\n                {\\n                    nums[i] = nums[lastIndex];\\n                    lastIndex--;\\n                    i--;\\n                }\\n            }\\n            \\n            return lastIndex + 1;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int removeElement(int[] nums, int val) {\\n            int lastIndex = nums.length - 1;\\n            \\n            for (int i = 0; i < lastIndex + 1; i++)\\n            {\\n                if (nums[i] == val)\\n                {\\n                    nums[i] = nums[lastIndex];\\n                    lastIndex--;\\n                    i--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 12644,
                "title": "4ms-c-solution",
                "content": "    int removeElement(vector<int>& nums, int val) {\\n        int i=0;\\n        \\n        for (int j=0; j<nums.size(); j++){\\n            \\n            if (nums[j]!=val) nums[i++]=nums[j];\\n        }\\n     return i;   \\n    }",
                "solutionTags": [],
                "code": "    int removeElement(vector<int>& nums, int val) {\\n        int i=0;\\n        \\n        for (int j=0; j<nums.size(); j++){\\n            \\n            if (nums[j]!=val) nums[i++]=nums[j];\\n        }\\n     return i;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 12307,
                "title": "beat-90-fast-java-simple-solution-with-explanation",
                "content": "The basic idea is to use two pointers, one left and one right. Left pointer starts from the beginning and right pointer starts from ending. While right pointer is pointing to the target value, move it to left until it is not pointing the target value or meets the left pointer. If the left pointer is pointing to the target value, change the value to what the right pointer is pointing, and move right pointer one step to left. Then move left pointer to right. Repeat that process until the two pointers meet.\\n\\n    if (nums.length < 1)\\n\\t\\t\\treturn 0;\\n\\t\\tint left = 0, right = nums.length - 1;\\n\\n\\t\\twhile (left <= right) {\\n\\n\\t\\t\\twhile (right > left && nums[right] == val)\\n\\t\\t\\t\\tright--;\\n\\t\\t\\tif (nums[left] == val) {\\n\\t\\t\\t\\tnums[left] = nums[right];\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t\\tleft++;\\n\\t\\t}\\n\\n\\t\\treturn right + 1;",
                "solutionTags": [],
                "code": "The basic idea is to use two pointers, one left and one right. Left pointer starts from the beginning and right pointer starts from ending. While right pointer is pointing to the target value, move it to left until it is not pointing the target value or meets the left pointer. If the left pointer is pointing to the target value, change the value to what the right pointer is pointing, and move right pointer one step to left. Then move left pointer to right. Repeat that process until the two pointers meet.\\n\\n    if (nums.length < 1)\\n\\t\\t\\treturn 0;\\n\\t\\tint left = 0, right = nums.length - 1;\\n\\n\\t\\twhile (left <= right) {\\n\\n\\t\\t\\twhile (right > left && nums[right] == val)\\n\\t\\t\\t\\tright--;\\n\\t\\t\\tif (nums[left] == val) {\\n\\t\\t\\t\\tnums[left] = nums[right];\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t\\tleft++;\\n\\t\\t}\\n\\n\\t\\treturn right + 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 3913495,
                "title": "c-java-solution-with-easy-explanation-beats-90-in-runtime",
                "content": "\\n# Approach\\nApply a two-pointer technique for efficient element removal. Use `result` to track the index of non-equal elements. Iterate through the array with `item`. If `item` is not equal to `val`, update `nums[result]` and increment result.\\n\\n# Intuition\\n\\nThis technique efficiently separates non-equal from `val` elements while maintaining element order. `result` index represents the count of non-equal elements, which is returned as the final result.\\n\\n\\n\\n\\n# Complexity\\n![image.png](https://assets.leetcode.com/users/images/887039c8-4b63-4bbe-bf4f-82653b1deb65_1692103659.4461107.png)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int RemoveElement(int[] nums, int val) {\\n        int result = 0;\\n        foreach (var item in nums)\\n        {\\n            if(item != val)\\n            {\\n                nums[result] = item;\\n                result++;\\n            }\\n        }   \\n\\n        return result;\\n    }\\n}\\n```\\n\\n## If you found my solution helpful, please consider giving it an upvote. Happy coding!",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveElement(int[] nums, int val) {\\n        int result = 0;\\n        foreach (var item in nums)\\n        {\\n            if(item != val)\\n            {\\n                nums[result] = item;\\n                result++;\\n            }\\n        }   \\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873873,
                "title": "beat-100-python-one-line-most-pythonic-and-list-comprehension-no-while-loops",
                "content": "# Intuition\\nSeems like any other pythonic list comprehension problem. Only hurdle is that it has to be in place\\n# Approach\\nBy using nums[:] you can make it in place\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n\\n        nums[:] = [num for num in nums if num != val]\\n        \\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n\\n        nums[:] = [num for num in nums if num != val]\\n        \\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417841,
                "title": "python-beginner-simple-explanation",
                "content": "# Explanation\\n1. A variable i is initialized to 0. This variable will be used to keep track of the current position where elements not equal to val should be placed in the nums list.\\n2. The for loop iterates over each element x in the nums list.\\n3. For each element x, the if statement checks whether it is equal to val.\\n4. If x is not equal to val, then it is assigned to the ith position in the nums list using nums[i] = x. The variable i is then incremented by 1 using i += 1.\\n5. This process continues for all elements in the nums list, effectively removing all occurrences of val.\\n6. Finally, the method returns the new length of the nums list after removing all occurrences of val. This value is equal to the value of i.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        i = 0\\n        for x in nums:\\n            if x != val:\\n                nums[i] = x\\n                i += 1\\n        return i\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        i = 0\\n        for x in nums:\\n            if x != val:\\n                nums[i] = x\\n                i += 1\\n        return i\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224789,
                "title": "simplest-one-liner-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums: nums.remove(val)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums: nums.remove(val)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067546,
                "title": "simple-logic-code-3-lines-o-n-with-commets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        // taking a variable for count how many elements are not equal to given value\\n        int k = 0; \\n        // simple for loop for traversal in the array\\n        for (int i = 0; i< nums.length ;i++){\\n            // condition for if element of the array is not equal to the val put value in the array and k increase\\n            if (nums[i] != val){\\n                nums[k] = nums[i];\\n                k++;\\n            }\\n        }\\n        // return the final remaining value in the array\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        // taking a variable for count how many elements are not equal to given value\\n        int k = 0; \\n        // simple for loop for traversal in the array\\n        for (int i = 0; i< nums.length ;i++){\\n            // condition for if element of the array is not equal to the val put value in the array and k increase\\n            if (nums[i] != val){\\n                nums[k] = nums[i];\\n                k++;\\n            }\\n        }\\n        // return the final remaining value in the array\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780422,
                "title": "java-solution-faster-than-100-of-java-submissions",
                "content": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int prevIndex = 0;\\n        for (int index = 0; index < nums.length; index++){\\n            if (nums[index] == val)\\n                continue;\\n            nums[prevIndex++] = nums[index];\\n        }\\n        return prevIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int prevIndex = 0;\\n        for (int index = 0; index < nums.length; index++){\\n            if (nums[index] == val)\\n                continue;\\n            nums[prevIndex++] = nums[index];\\n        }\\n        return prevIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768731,
                "title": "c-simple-removal",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j = 0;\\n        for(auto& num: nums){\\n            if (num != val){\\n                nums[j++] = num;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j = 0;\\n        for(auto& num: nums){\\n            if (num != val){\\n                nums[j++] = num;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601833,
                "title": "python-easy-solution",
                "content": "```\\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2114966,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions-for-remove-element",
                "content": "```\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length ; i++)\\n        {\\n            if(nums[i] != val)\\n            {\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length ; i++)\\n        {\\n            if(nums[i] != val)\\n            {\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2036101,
                "title": "typescript-javascript-solution",
                "content": "```\\nfunction removeElement(nums: number[], val: number): number {\\n    let k = 0;\\n    for(let i = 0 ; i < nums.length; i++){\\n        if(nums[i] !== val)\\n        {\\n            nums[k] = nums[i];\\n            k++;        \\n        }\\n    }\\n    return k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\nfunction removeElement(nums: number[], val: number): number {\\n    let k = 0;\\n    for(let i = 0 ; i < nums.length; i++){\\n        if(nums[i] !== val)\\n        {\\n            nums[k] = nums[i];\\n            k++;        \\n        }\\n    }\\n    return k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1985818,
                "title": "python-solution-very-simple",
                "content": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.pop(i)\\n                i-=1\\n            i+=1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.pop(i)\\n                i-=1\\n            i+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707903,
                "title": "simple-c-solution-faster-than-100-4-lines",
                "content": "```c\\nint removeElement(int* nums, int numsSize, int val) {\\n    int count = 0;\\n    for (int i=0; i < numsSize; i++)\\n        if (nums[i] == val) count++;\\n        else nums[i-count] = nums[i];\\n    return numsSize-count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nint removeElement(int* nums, int numsSize, int val) {\\n    int count = 0;\\n    for (int i=0; i < numsSize; i++)\\n        if (nums[i] == val) count++;\\n        else nums[i-count] = nums[i];\\n    return numsSize-count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1048319,
                "title": "python-o-n-cool-easy-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef removeElement(self, nums: List[int], val: int) -> int:\\n\\t\\t\\tlength = len(nums)\\n\\t\\t\\tindex = 0\\n\\t\\t\\twhile index < length:\\n\\t\\t\\t\\tif nums[index] == val:\\n\\t\\t\\t\\t\\tnums[index] = nums[length - 1]\\n\\t\\t\\t\\t\\tlength -= 1\\n\\t\\t\\t\\telse: index += 1\\n\\t\\t\\treturn length",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef removeElement(self, nums: List[int], val: int) -> int:\\n\\t\\t\\tlength = len(nums)\\n\\t\\t\\tindex = 0\\n\\t\\t\\twhile index < length:\\n\\t\\t\\t\\tif nums[index] == val:\\n\\t\\t\\t\\t\\tnums[index] = nums[length - 1]\\n\\t\\t\\t\\t\\tlength -= 1\\n\\t\\t\\t\\telse: index += 1\\n\\t\\t\\treturn length",
                "codeTag": "Java"
            },
            {
                "id": 12297,
                "title": "javascript-very-simple-solution-beats-100",
                "content": "```\\nvar removeElement = function(nums, val) {\\n    for(var i = nums.length - 1; i >= 0; i--){\\n        if(nums[i] === val){\\n            nums.splice(i, 1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar removeElement = function(nums, val) {\\n    for(var i = nums.length - 1; i >= 0; i--){\\n        if(nums[i] === val){\\n            nums.splice(i, 1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12391,
                "title": "5-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i = 0, j = 0;\\n        while(j != nums.size())\\n            if(nums[j] == val) j++;\\n            else nums[i++] = nums[j++];\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i = 0, j = 0;\\n        while(j != nums.size())\\n            if(nums[j] == val) j++;\\n            else nums[i++] = nums[j++];\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12583,
                "title": "0ms-4-lines-c-code",
                "content": "    int removeElement(int* nums, int numsSize, int val) {\\n        int i, j;\\n        for(i = j = numsSize - 1; i >= 0; i--)\\n            if(nums[i] == val && i != j--) nums[i] = nums[j+1] ;\\n        return j+1;\\n    }",
                "solutionTags": [],
                "code": "    int removeElement(int* nums, int numsSize, int val) {\\n        int i, j;\\n        for(i = j = numsSize - 1; i >= 0; i--)\\n            if(nums[i] == val && i != j--) nums[i] = nums[j+1] ;\\n        return j+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4041857,
                "title": "video-clear-visualization-of-o-n-solution",
                "content": "https://youtu.be/pGKDzt0gk-A\\n\\nOne way to do this is to check every element of `nums`, and if an element is equal to `val`, then we use the pop method to pop it off. This works, but the problem is that the pop method is very inefficient because if we pop an element near the start of the array, all the other elements have to be shifted back one spot.  Each shift runs in O(n) time, and in the worst case, we\\'d have to do n shifts, so this algorithm ends up running in O(n<sup>2</sup>) time.\\n\\nInstead, we can use a two pointer approach that overwrites the first `k` elements of the array, where `k` is the number of elements that are not equal to `val`.  The index variable `i` keeps track of the next spot to overwrite in the array, and we use `x` to check the value of each element and compare it to `val`.\\n\\nIf an element is equal to `val`, we just move on and don\\'t do anything.  Basically, we keep searching until we find an element that is not equal to `val`.  Once we do find an element not equal to `val`, we write it to the array at index `i`, then increment `i` so that it\\'s ready to write at the next spot.\\n\\nAt the end, we can just return `i` since it has been incremented exactly once for each element found that is not equal to `val`.\\n\\n```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        i = 0\\n        for x in nums:\\n            if x != val:\\n                nums[i] = x\\n                i += 1\\n        return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        i = 0\\n        for x in nums:\\n            if x != val:\\n                nums[i] = x\\n                i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740600,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size(); // Get the size of the input vector\\n        int j = 0; // Initialize a pointer to keep track of the modified array\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == val) // If the current element is equal to the target value\\n                continue; // Skip this element and move to the next iteration\\n\\n            nums[j++] = nums[i]; // Copy the non-target element to the modified array and increment the pointer\\n        }\\n\\n        return j; // Return the length of the modified array\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size(); // Get the size of the input vector\\n        int j = 0; // Initialize a pointer to keep track of the modified array\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == val) // If the current element is equal to the target value\\n                continue; // Skip this element and move to the next iteration\\n\\n            nums[j++] = nums[i]; // Copy the non-target element to the modified array and increment the pointer\\n        }\\n\\n        return j; // Return the length of the modified array\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567590,
                "title": "remove-element-by-in-place-modification",
                "content": "# Intuition\\nThis one was very simple, my first thought was to just walk through the array and when we found the value just remove it. Not the most efficient, but I think it\\'s okay as it\\'s still stupidly quick on big arrays. This can be improved with an approach I had taken in the 26th problem.\\n\\n# Approach\\n1. Start iterating over the elements of **nums** using the index variable **i** from 0 to **nums.size()**.\\n2. Check if the current element **nums[i]** is equal to the target value **val**.\\n3. If **nums[i]** is equal to **val**, it indicates an element that needs to be removed.\\n4. Use the **erase** function to remove the element at index **i** from the **nums** vector.\\n5. Decrement **i** by 1 to account for the shifted indices after the removal.\\n6. Repeat steps 2-5 for the remaining elements in the vector.\\n7. After the loop, return the updated size of the vector **nums**.\\n\\nThis approach removes all occurrences of **val** from the vector by modifying it in-place.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$, where n is the size of the input vector **nums**\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == val) {\\n                nums.erase(nums.begin() + i);\\n                i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == val) {\\n                nums.erase(nums.begin() + i);\\n                i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470745,
                "title": "100-simple-code-for-beginner",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075910,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int index=0,i;\\n        for(i=0;i<n;i++){\\n            if(nums[i]!=val){\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int index=0,i;\\n        for(i=0;i<n;i++){\\n            if(nums[i]!=val){\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038657,
                "title": "100-faster-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count = 0, e = nums.length;\\n        for(int i = 0; i < e; i++) {\\n            if(nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count = 0, e = nums.length;\\n        for(int i = 0; i < e; i++) {\\n            if(nums[i] != val) {\\n                nums[count++] = nums[i];\\n            }\\n        }\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811097,
                "title": "c-java-python3-javascript-solutions-faster-than-90-100",
                "content": "We can solve this problem with a easy loop iteration\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-solution-and-explanation-en/)\\u2B50**\\n\\u2B06To see other languages please click the link above\\u2B06\\n\\n#### Example : JavaScript Code \\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    var j = 0;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]!=val)\\n        {\\n            nums[j++] = nums[i];\\n        }\\n    }\\n    return j;\\n};\\n```\\n\\n#### C# Code \\n```\\npublic class Solution {\\n    public int RemoveElement(int[] nums, int val) {\\n\\n        int j = 0;\\n        foreach(int i in nums)\\n        {\\n            if(i!=val)\\n            {\\n                nums[j++] = i;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```\\n\\nCongratulations! You have finished the first problem on LeetCode.\\n\\n**Now, why just try next problem immediately!**\\n**\\u2B50[Zyrastory - LeetCode#28 Find the Index of the First Occurrence in a String (Medium)](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-28-find-the-index-of-the-first-occurrence-in-a-string-solution-and-explanation-en/)\\u2B50**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n\\uD83E\\uDDE1See more problems solutions - **[Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\nThanks!\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    var j = 0;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]!=val)\\n        {\\n            nums[j++] = nums[i];\\n        }\\n    }\\n    return j;\\n};\\n```\n```\\npublic class Solution {\\n    public int RemoveElement(int[] nums, int val) {\\n\\n        int j = 0;\\n        foreach(int i in nums)\\n        {\\n            if(i!=val)\\n            {\\n                nums[j++] = i;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661084,
                "title": "python",
                "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n        return len(nums)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n        return len(nums)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2592824,
                "title": "c-easy-and-fast-solution-o-n",
                "content": "***The approach for solving this question is very simple, We are creating a vector array and then storing all non-val elements into it, then we are storing them back in main array.***\\n\\n\\t\\tvector<int>vec;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n             if(nums[i]!=val)\\n             {\\n                vec.push_back(nums[i]);\\n             }\\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            nums[i]=vec[i];\\n        }\\n        return vec.size();\\n\\t\\t\\n***If you find it helpful, please consider upvoting!!***",
                "solutionTags": [
                    "C"
                ],
                "code": "***The approach for solving this question is very simple, We are creating a vector array and then storing all non-val elements into it, then we are storing them back in main array.***\\n\\n\\t\\tvector<int>vec;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n             if(nums[i]!=val)\\n             {\\n                vec.push_back(nums[i]);\\n             }\\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            nums[i]=vec[i];\\n        }\\n        return vec.size();\\n\\t\\t\\n***If you find it helpful, please consider upvoting!!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1554453,
                "title": "0-ms-very-easy-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size()==0) return 0;\\n       int write=0;\\n        for(int read=0;read<nums.size();read++)\\n        {\\n            if(nums[read]!=val)\\n            {\\n                nums[write]=nums[read];\\n                    write++;\\n            }\\n        }\\n        return write;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429199,
                "title": "remove-element-java-0ms-runtime-100-faster-than-online-submissions",
                "content": "```\\nclass Solution {\\n    public int removeElement(int[] A, int elem) {\\n        int m = 0;\\n        for(int i = 0; i < A.length; i++){   \\n            if(A[i] != elem){\\n                A[m++] = A[i];\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] A, int elem) {\\n        int m = 0;\\n        for(int i = 0; i < A.length; i++){   \\n            if(A[i] != elem){\\n                A[m++] = A[i];\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348020,
                "title": "my-c-code",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Remove Element.\\nMemory Usage: 6.3 MB, less than 13.20% of C online submissions for Remove Element.\\nthis might not be the best one though...\\n\\n```\\nint removeElement(int* nums, int numsSize, int val){\\n    int validIndex=0,i;\\n    for(i=0;i<numsSize;i++){\\n        if(nums[i]!=val){\\n            nums[validIndex]=nums[i];\\n            validIndex++;\\n        }\\n    }\\n    return validIndex;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint removeElement(int* nums, int numsSize, int val){\\n    int validIndex=0,i;\\n    for(i=0;i<numsSize;i++){\\n        if(nums[i]!=val){\\n            nums[validIndex]=nums[i];\\n            validIndex++;\\n        }\\n    }\\n    return validIndex;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1282520,
                "title": "fast-and-o-n-solution-c",
                "content": "```\\n  int removeElement(vector<int>& nums, int val) {\\n        \\n        int i=0,n=nums.size();\\n        \\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(nums[i]==val)\\n            {\\n                nums.erase(nums.begin()+i);\\n            }\\n        }\\n        return nums.size();\\n    }\\n```\\n\\n\\nWe are just erasing the element whose value is equal to `val` . I am moving backwards because after deleting the element from behind we don\\'t need to worry about the change in index. As if we have started deleting  from the start then after each deletion the whole array indexes would decrease by -1. But in for loop we are going forward without taking this in consideration. So deleting from the end of the array is better.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n  int removeElement(vector<int>& nums, int val) {\\n        \\n        int i=0,n=nums.size();\\n        \\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(nums[i]==val)\\n            {\\n                nums.erase(nums.begin()+i);\\n            }\\n        }\\n        return nums.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 956147,
                "title": "javascript-solution-o-n-runtime-76-ms-faster-than-85-28",
                "content": "```\\n/**\\n * https://leetcode.com/problems/remove-element/\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n * Time O(n) - n is the no. of items in nums\\n * Space O(1)\\n * Optimized run time\\n */\\nvar removeElement = function(nums, val) {\\n\\tif (!nums.length) {\\n\\t\\t// when there is no nums in the array return 0\\n\\t\\treturn 0;\\n\\t}\\n\\t\\n\\tif (val === undefined) {\\n\\t\\tthrow new Error(\\'argument val cannot be undefined for removeElement function\\');\\n\\t}\\n\\t\\n\\tlet index = 0;\\n\\t\\n\\t/* for each items in the given array, check if the val is not equivalent to the val to the removed\\n\\t * if yes, then copy that value to the index which we are having as a pointer\\n\\t * and then increment the index by 1\\n\\t * finally return the index which should hold the number is items in the given array which is not === val\\n\\t*/\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] !== val) {\\n\\t\\t\\tnums[index] = nums[i];\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn index;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * https://leetcode.com/problems/remove-element/\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n * Time O(n) - n is the no. of items in nums\\n * Space O(1)\\n * Optimized run time\\n */\\nvar removeElement = function(nums, val) {\\n\\tif (!nums.length) {\\n\\t\\t// when there is no nums in the array return 0\\n\\t\\treturn 0;\\n\\t}\\n\\t\\n\\tif (val === undefined) {\\n\\t\\tthrow new Error(\\'argument val cannot be undefined for removeElement function\\');\\n\\t}\\n\\t\\n\\tlet index = 0;\\n\\t\\n\\t/* for each items in the given array, check if the val is not equivalent to the val to the removed\\n\\t * if yes, then copy that value to the index which we are having as a pointer\\n\\t * and then increment the index by 1\\n\\t * finally return the index which should hold the number is items in the given array which is not === val\\n\\t*/\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (nums[i] !== val) {\\n\\t\\t\\tnums[index] = nums[i];\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn index;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 302034,
                "title": "python-solution",
                "content": "If the element is **not equal to val**, just copy it to its corresponding index and keep incrementing the index.\\n```\\nx = 0\\nfor i in range(len(nums)):\\n\\tif(nums[i]!=val):\\n\\t\\tnums[x] = nums[i]\\n\\t\\tx+=1\\nreturn(x)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nx = 0\\nfor i in range(len(nums)):\\n\\tif(nums[i]!=val):\\n\\t\\tnums[x] = nums[i]\\n\\t\\tx+=1\\nreturn(x)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 283062,
                "title": "javascript-solution-60ms",
                "content": "```\\nvar removeElement = function(nums, val) {\\n    let newLen = 0;\\n    for (let i=0; i<nums.length; i++) {\\n        if (nums[i] == val) {\\n            continue;\\n        }\\n        nums[newLen] = nums[i]; \\n        newLen++;\\n    }\\n    return newLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElement = function(nums, val) {\\n    let newLen = 0;\\n    for (let i=0; i<nums.length; i++) {\\n        if (nums[i] == val) {\\n            continue;\\n        }\\n        nums[newLen] = nums[i]; \\n        newLen++;\\n    }\\n    return newLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12598,
                "title": "1-ms-java-solution-with-3-lines-of-code",
                "content": "        public int removeElement(int[] nums, int val) {\\n            int index = 0;\\n            for(int i : nums) if(i != val) nums[index++] = i;\\n            return index;\\n        }\\n\\nI saw a lot of really too complicated solutions.. don't complicate things.",
                "solutionTags": [],
                "code": "        public int removeElement(int[] nums, int val) {\\n            int index = 0;\\n            for(int i : nums) if(i != val) nums[index++] = i;\\n            return index;\\n        }\\n\\nI saw a lot of really too complicated solutions.. don't complicate things.",
                "codeTag": "Unknown"
            },
            {
                "id": 3732387,
                "title": "5-lines-of-code-beats-100",
                "content": "# Please Upvote if you feel it easy \\uD83D\\uDE0A   \\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int cnt=0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] != val) {\\n                nums[cnt++] = nums[i];\\n            }\\n        }return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int cnt=0;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] != val) {\\n                nums[cnt++] = nums[i];\\n            }\\n        }return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676786,
                "title": "o-n-python-solution-with-clear-logic-and-explanation-easy-understanding",
                "content": "# Key Points\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use to pointers ***i*** and ***j*** to point at the **start** and the **end** of the input list.\\n- Three cases in total:\\n    1. i points to a number==val but j is not:\\n        - **switch** the numbers stored in i and j\\n    2. j points to a number==val but i is not:\\n        - **Move j forward**, points to the prior element (j --)\\n    3. neither of them points to a number==val:\\n        - **Move i backward**, points to the next element (i ++)\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i, j = 0, len(nums)-1\\n        while i <= j:\\n            if nums[i] == val and nums[j] != val:\\n                nums[i] = nums[j]\\n                i += 1\\n                j -= 1\\n            elif nums[j] == val:\\n                j -= 1\\n            else:\\n                i += 1\\n        return i\\n```\\n\\n# Some Notes\\n- Don\\'t have to use two pointers, only one end-of-list pointer j can work as well. It\\'s just that this way makes the coding logic clearer.\\n\\n\\n***Hope that this post could help you on your leetcode journay. It\\'s not easy, as we all know it. Please leave a upvote if you find it helpful, and I hope I could see you under other questions\\' discussions.***\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i, j = 0, len(nums)-1\\n        while i <= j:\\n            if nums[i] == val and nums[j] != val:\\n                nums[i] = nums[j]\\n                i += 1\\n                j -= 1\\n            elif nums[j] == val:\\n                j -= 1\\n            else:\\n                i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637318,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomplexity is O(n). Only one loop is used.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int RemoveElement(int[] nums, int val) {\\n          int current = 0;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (nums[i]!=val)\\n                {\\n                    nums[current] = nums[i];\\n                    current++;\\n                }\\n            }\\n            return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveElement(int[] nums, int val) {\\n          int current = 0;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (nums[i]!=val)\\n                {\\n                    nums[current] = nums[i];\\n                    current++;\\n                }\\n            }\\n            return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358452,
                "title": "easy-solution-3-line-of-code-python",
                "content": "# Steps\\n<!-- Describe your approach to solving the problem. -->\\n1. makes a while loop that checks if `nums` still has `val` inside it\\n2. removes `val` from `nums` if found in the while loop\\n3. usually you would do `return nums`but in this question, it wants you to return the length of nums (idk why) but still, it works. I also got really confused here but just remember to don\\'t do this in normal python.\\n# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while nums.__contains__(val):\\n            nums.remove(val)\\n        return len(nums)\\n```\\nplease upvote!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        while nums.__contains__(val):\\n            nums.remove(val)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337824,
                "title": "91-beats-for-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    let k = 0;  // initialize the index of the next valid element\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] !== val) {  // if the current element is not equal to val\\n            nums[k] = nums[i];  // copy the current element to the next valid position\\n            k++;  // increment the index of the next valid position\\n        }\\n    }\\n    return k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    let k = 0;  // initialize the index of the next valid element\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] !== val) {  // if the current element is not equal to val\\n            nums[k] = nums[i];  // copy the current element to the next valid position\\n            k++;  // increment the index of the next valid position\\n        }\\n    }\\n    return k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2987663,
                "title": "simple-java-0ms-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use the fact that the resultant array of size k (where k is the returned value) can be of **ANY ORDER**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    We will use two pointer approach.\\n    One will point to 1st.\\n    Other will point to last.\\n    If start pointer points to target,\\n    then replace it with end pointer value.\\n\\nApart from these steps, we need to check some **BASE CONDITIONS**. (All these are mentioned in the comment part of the code.\\nEventually, you will get the answer.\\n\\n              **If this solution helped you, give it an up-vote to help others**\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n//      We will check a base condition that if the array is empty\\n\\n        if(nums.length == 0) return 0;\\n\\n\\n//      initialize i from 0 and j from last index.\\n        int i = 0;\\n        int j = nums.length-1;\\n\\n\\n        while(i < j)            // loop will break when i and j crosses each other.\\n        {\\n            if(nums[i] == val)\\n            // if ith element points to target.\\n            {\\n                // it will be replaced with jth element.\\n                nums[i] = nums[j];\\n\\n                // we will then decrement j.\\n                j--;\\n\\n                // We will NOT increment i because we never know that the\\n                // replaced element is not the target.\\n                // if jth element is also target, then we will repeat the steps.\\n            }\\n            else\\n            {\\n                // We will approach the next index.\\n                i++;\\n            }\\n        }\\n\\n        // Now we need to check one base condition.\\n\\n        // If the element at ith index is target then return i;\\n        if(nums[i] == val) return i;\\n\\n\\n        // Finally, We have to return position so will add 1 to index value i.\\n        return i+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n//      We will check a base condition that if the array is empty\\n\\n        if(nums.length == 0) return 0;\\n\\n\\n//      initialize i from 0 and j from last index.\\n        int i = 0;\\n        int j = nums.length-1;\\n\\n\\n        while(i < j)            // loop will break when i and j crosses each other.\\n        {\\n            if(nums[i] == val)\\n            // if ith element points to target.\\n            {\\n                // it will be replaced with jth element.\\n                nums[i] = nums[j];\\n\\n                // we will then decrement j.\\n                j--;\\n\\n                // We will NOT increment i because we never know that the\\n                // replaced element is not the target.\\n                // if jth element is also target, then we will repeat the steps.\\n            }\\n            else\\n            {\\n                // We will approach the next index.\\n                i++;\\n            }\\n        }\\n\\n        // Now we need to check one base condition.\\n\\n        // If the element at ith index is target then return i;\\n        if(nums[i] == val) return i;\\n\\n\\n        // Finally, We have to return position so will add 1 to index value i.\\n        return i+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891162,
                "title": "using-pivot-element",
                "content": "# Intuition\\nRemember the Quick sort Pavot Concept, Allowing all the target values to wordes left rest will stays towords right.\\n\\n# Approach\\nJust use the Concept of Pavot element concept.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1) \\n> It will take only the pivot element space.\\n\\n# Code\\n```\\n# /27. Remove Element\\n# Using Quick Sort paviot element All left side elements will be of one type\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        pi = 0\\n        for eleIdx in range(len(nums)):\\n            if nums[eleIdx] != val:\\n                nums[pi],nums[eleIdx] = nums[eleIdx],nums[pi]\\n                pi += 1\\n\\n        return pi\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# /27. Remove Element\\n# Using Quick Sort paviot element All left side elements will be of one type\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        pi = 0\\n        for eleIdx in range(len(nums)):\\n            if nums[eleIdx] != val:\\n                nums[pi],nums[eleIdx] = nums[eleIdx],nums[pi]\\n                pi += 1\\n\\n        return pi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748305,
                "title": "python-straightorward",
                "content": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k=0\\n        for i in range(len(nums)):\\n            if nums[i]==val:\\n                continue\\n            nums[k]=nums[i]\\n            k+=1\\n        return k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k=0\\n        for i in range(len(nums)):\\n            if nums[i]==val:\\n                continue\\n            nums[k]=nums[i]\\n            k+=1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597831,
                "title": "c-easy-solution-easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0; i<nums.size(); i++){\\n            auto it = nums.begin() + i ;\\n            if(nums[i]==val){\\n                nums.erase(it);\\n                i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0; i<nums.size(); i++){\\n            auto it = nums.begin() + i ;\\n            if(nums[i]==val){\\n                nums.erase(it);\\n                i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222194,
                "title": "simple-php-solution-6-ms",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $val\\n     * @return Integer\\n     */\\n    function removeElement(&$nums, $val) {\\n        $nums = array_diff($nums, [$val]);\\n        return count($nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $val\\n     * @return Integer\\n     */\\n    function removeElement(&$nums, $val) {\\n        $nums = array_diff($nums, [$val]);\\n        return count($nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979588,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```\\nclass Solution {\\npublic:\\n\\tint removeElement(vector<int>& nums, int val) {\\n\\t\\tint length = nums.size(), index = 0;\\n\\t\\twhile ( index < length )\\n\\t\\t{\\n\\t\\t\\t if ( nums[index] == val )\\n\\t\\t\\t {\\n\\t\\t\\t\\t nums[index] = nums[length - 1];\\n\\t\\t\\t\\t -- length;\\n\\t\\t\\t }\\n\\t\\t\\t\\t\\n\\t\\t\\telse ++index;\\n\\t\\t}\\n\\t\\t return length;  \\n\\t}\\n};\\n```\\n\\n***Java***\\n```\\npublic int removeElement(int[] A, int elem) {\\n    int l = A.length;\\n    for (int i=0; i<l; i++) {\\n        if (A[i] == elem) {\\n            A[i--] = A[l-- -1];\\n        }\\n    }\\n    return l;\\n}\\n```\\n\\n***Python***\\n```\\ndef removeElement(self, nums, val):\\n    i = 0\\n    for x in nums:\\n        if x != val:\\n            nums[i] = x\\n            i += 1\\n    return i\\n```\\n\\n***JavaScript***\\n```\\n var removeElement = function(nums, val) {\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == val) {\\n            nums.splice(i, 1);\\n            i -= 1\\n        }\\n    }\\n    return nums.length;\\n}\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    fun removeElement(nums: IntArray, num: Int): Int {\\n        var counter = 0\\n        nums.forEach { if (it != num) nums[counter++] = it }\\n\\n        return counter\\n    }\\n}\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint removeElement(vector<int>& nums, int val) {\\n\\t\\tint length = nums.size(), index = 0;\\n\\t\\twhile ( index < length )\\n\\t\\t{\\n\\t\\t\\t if ( nums[index] == val )\\n\\t\\t\\t {\\n\\t\\t\\t\\t nums[index] = nums[length - 1];\\n\\t\\t\\t\\t -- length;\\n\\t\\t\\t }\\n\\t\\t\\t\\t\\n\\t\\t\\telse ++index;\\n\\t\\t}\\n\\t\\t return length;  \\n\\t}\\n};\\n```\n```\\npublic int removeElement(int[] A, int elem) {\\n    int l = A.length;\\n    for (int i=0; i<l; i++) {\\n        if (A[i] == elem) {\\n            A[i--] = A[l-- -1];\\n        }\\n    }\\n    return l;\\n}\\n```\n```\\ndef removeElement(self, nums, val):\\n    i = 0\\n    for x in nums:\\n        if x != val:\\n            nums[i] = x\\n            i += 1\\n    return i\\n```\n```\\n var removeElement = function(nums, val) {\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == val) {\\n            nums.splice(i, 1);\\n            i -= 1\\n        }\\n    }\\n    return nums.length;\\n}\\n```\n```\\nclass Solution {\\n    fun removeElement(nums: IntArray, num: Int): Int {\\n        var counter = 0\\n        nums.forEach { if (it != num) nums[counter++] = it }\\n\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452426,
                "title": "c-faster-than-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0;\\n        int j=0;\\n        while(j<nums.size()){\\n            if(nums[j]!=val){\\n                nums[i]=nums[j];\\n                i++;\\n                j++;\\n\\n            }\\n            else {\\n                j++;\\n            }\\n        }return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0;\\n        int j=0;\\n        while(j<nums.size()){\\n            if(nums[j]!=val){\\n                nums[i]=nums[j];\\n                i++;\\n                j++;\\n\\n            }\\n            else {\\n                j++;\\n            }\\n        }return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389132,
                "title": "simple-two-pointers-approach-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int left=0;\\n        for(int right=0;right<nums.size();right++){\\n            if(nums[right]==val){\\n                count++;\\n            }else{\\n                nums[left]=nums[right];\\n                left++;\\n            }\\n        }\\n        return nums.size()-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int left=0;\\n        for(int right=0;right<nums.size();right++){\\n            if(nums[right]==val){\\n                count++;\\n            }else{\\n                nums[left]=nums[right];\\n                left++;\\n            }\\n        }\\n        return nums.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183128,
                "title": "rust-o-n-time-o-1-space-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\\n        let (mut len, mut i) = (nums.len(), 0);\\n        while i < len {\\n            if nums[i] == val {\\n                nums.swap(i, len - 1);\\n                len -= 1;\\n            } else {\\n                i += 1;\\n            }\\n        } \\n        len as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\\n        let (mut len, mut i) = (nums.len(), 0);\\n        while i < len {\\n            if nums[i] == val {\\n                nums.swap(i, len - 1);\\n                len -= 1;\\n            } else {\\n                i += 1;\\n            }\\n        } \\n        len as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103565,
                "title": "simple-efficient-python-solution",
                "content": "```\\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        \\n        count = 0 \\n        for i in range(len(nums)):\\n            if nums[i] != val:\\n                nums[count] = nums[i]\\n                count += 1\\n                \\n        return count \\n```",
                "solutionTags": [],
                "code": "```\\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        \\n        count = 0 \\n        for i in range(len(nums)):\\n            if nums[i] != val:\\n                nums[count] = nums[i]\\n                count += 1\\n                \\n        return count \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1078376,
                "title": "c-standard-library-one-liners",
                "content": "Not necessarily the fastest and it mixes up the order, but it is short and hard to get wrong:\\n\\n```cpp\\nstatic int removeElement(vector<int>& n, const int v) {\\n    return std::partition(begin(n), end(n), [v](auto e){ return e != v; }) - begin(n);\\n}\\n```\\n\\nThe most exact match in the standard algorithms:\\n\\n```cpp\\nstatic int removeElement(vector<int>& n, const int v) {\\n    return std::remove(begin(n), end(n), v) - begin(n);\\n}\\n```\\n\\nOf course your interviewer wants you to write out the algorithm so make sure you can produce a tight version of that and scrawl this in an afterthought as \"what I\\'d actually use in production code\". Here is one simple, non-generic, example:\\nhttps://leetcode.com/problems/remove-element/discuss/1078348\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nstatic int removeElement(vector<int>& n, const int v) {\\n    return std::partition(begin(n), end(n), [v](auto e){ return e != v; }) - begin(n);\\n}\\n```\n```cpp\\nstatic int removeElement(vector<int>& n, const int v) {\\n    return std::remove(begin(n), end(n), v) - begin(n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 873229,
                "title": "faster-than-100-easy-understanding-c",
                "content": "**1.[Runtime: 0 ms, faster than 100%]**\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j=0;\\n\\t\\t//As long as nums[i]!=val we copy nums[i] to nums[j] and increment j\\n        //nums[i] equals to the given value,skip this element\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]!=val) nums[j]=nums[i],j++;\\n        return j;\\n    }\\n};\\n```\\n**2.[Runtime: 0 ms, faster than 100%]**\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,n=nums.size();\\n\\t\\t//When nums[i]=val, we swap the current element with the last element and remove the last one so reduces the array\\'s size by 1.\\n        while (i < n) {\\n            if (nums[i] == val) nums[i] = nums[n-1],n--;\\n            else i++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j=0;\\n\\t\\t//As long as nums[i]!=val we copy nums[i] to nums[j] and increment j\\n        //nums[i] equals to the given value,skip this element\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]!=val) nums[j]=nums[i],j++;\\n        return j;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,n=nums.size();\\n\\t\\t//When nums[i]=val, we swap the current element with the last element and remove the last one so reduces the array\\'s size by 1.\\n        while (i < n) {\\n            if (nums[i] == val) nums[i] = nums[n-1],n--;\\n            else i++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599188,
                "title": "easy-go-solution",
                "content": "```go\\nfunc removeElement(nums []int, val int) int {\\n    count := 0\\n    for i, num := range nums {\\n        nums[i - count] = nums[i]\\n        if num == val {\\n            count += 1\\n        }\\n    }\\n    return len(nums) - count\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc removeElement(nums []int, val int) int {\\n    count := 0\\n    for i, num := range nums {\\n        nums[i - count] = nums[i]\\n        if num == val {\\n            count += 1\\n        }\\n    }\\n    return len(nums) - count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376418,
                "title": "python3-swap",
                "content": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        \"\"\"\\n        [3,2,2,3],val = 3\\n        \\n        [2,2,3,3]\\n        \"\"\"\\n        e = 0\\n        for i in range(len(nums)):\\n            if nums[i] != val:\\n                nums[e], nums[i] = nums[i],nums[e]\\n                e += 1\\n        return e \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        \"\"\"\\n        [3,2,2,3],val = 3\\n        \\n        [2,2,3,3]\\n        \"\"\"\\n        e = 0\\n        for i in range(len(nums)):\\n            if nums[i] != val:\\n                nums[e], nums[i] = nums[i],nums[e]\\n                e += 1\\n        return e \\n```",
                "codeTag": "Java"
            },
            {
                "id": 325013,
                "title": "scala-using-foldleft",
                "content": "```\\ndef removeElement(nums: Array[Int], v: Int): Int = {\\n\\tnums.foldLeft(0)((index, vv) => {\\n\\t\\t(vv == v) match {\\n\\t\\t\\tcase true => index\\n\\t\\t\\tcase false => {\\n\\t\\t\\t\\tnums(index) = vv\\n\\t\\t\\t\\tindex + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t})\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef removeElement(nums: Array[Int], v: Int): Int = {\\n\\tnums.foldLeft(0)((index, vv) => {\\n\\t\\t(vv == v) match {\\n\\t\\t\\tcase true => index\\n\\t\\t\\tcase false => {\\n\\t\\t\\t\\tnums(index) = vv\\n\\t\\t\\t\\tindex + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t})\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 282492,
                "title": "rust-0ms-2-lines-boilerplate",
                "content": "```\\nimpl Solution {\\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\\n        nums.retain(|&x| x != val);\\n        nums.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\\n        nums.retain(|&x| x != val);\\n        nums.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 239612,
                "title": "rust-0ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\\n        let mut current = 0;\\n        for i in 0..nums.len() {\\n            if nums[i] != val {\\n                nums[current] = nums[i];\\n                current += 1\\n            }\\n        }\\n\\n        current as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\\n        let mut current = 0;\\n        for i in 0..nums.len() {\\n            if nums[i] != val {\\n                nums[current] = nums[i];\\n                current += 1\\n            }\\n        }\\n\\n        current as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12374,
                "title": "swift-solution-two-pointers",
                "content": "```\\nclass Solution {\\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\\n        var count = 0\\n        \\n        for i in 0..<nums.count {\\n            if nums[i] != val {\\n                nums[count] = nums[i]\\n                count += 1\\n            }\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {\\n        var count = 0\\n        \\n        for i in 0..<nums.count {\\n            if nums[i] != val {\\n                nums[count] = nums[i]\\n                count += 1\\n            }\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12390,
                "title": "c-solution",
                "content": "Two pointers, O(n), No extra space\\n\\n```\\n    public int RemoveElement(int[] nums, int val) {\\n        if (nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int slowIndex = 0, fastIndex = 0;\\n        \\n        while (slowIndex <= nums.Length - 1 && fastIndex <= nums.Length - 1)\\n        {\\n            if (nums[fastIndex] != val)\\n            {\\n                nums[slowIndex] = nums[fastIndex];\\n                slowIndex++;\\n                fastIndex++;\\n            }\\n            else\\n                fastIndex++;\\n        }\\n        \\n        return slowIndex;\\n    }",
                "solutionTags": [],
                "code": "Two pointers, O(n), No extra space\\n\\n```\\n    public int RemoveElement(int[] nums, int val) {\\n        if (nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int slowIndex = 0, fastIndex = 0;\\n        \\n        while (slowIndex <= nums.Length - 1 && fastIndex <= nums.Length - 1)\\n        {\\n            if (nums[fastIndex] != val)\\n            {\\n                nums[slowIndex] = nums[fastIndex];\\n                slowIndex++;\\n                fastIndex++;\\n            }\\n            else\\n                fastIndex++;\\n        }\\n        \\n        return slowIndex;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 12475,
                "title": "7-lines-java-solution",
                "content": "```\\npublic class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int index = 0;\\n        for (int i = 0; i < nums.length; i++) if (nums[i] != val) nums[index++] = nums[i];  \\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int index = 0;\\n        for (int i = 0; i < nums.length; i++) if (nums[i] != val) nums[index++] = nums[i];  \\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12610,
                "title": "4ms-of-c-solution",
                "content": "    class Solution {\\n    public:\\n        int removeElement(vector<int>& nums, int val) {\\n            int l=nums.size();\\n            int k=0;\\n            for(int i=0;i<l;i++)\\n            {\\n                if(nums[i]!=val)\\n                {\\n                    nums[k]=nums[i];\\n                    k++;\\n                }\\n            }\\n            return k;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int removeElement(vector<int>& nums, int val) {\\n            int l=nums.size();\\n            int k=0;\\n            for(int i=0;i<l;i++)\\n            {\\n                if(nums[i]!=val)\\n                {\\n                    nums[k]=nums[i];\\n                    k++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 12470,
                "title": "my-python-solution",
                "content": "    class Solution(object):\\n        def removeElement(self, nums, val):\\n            for x in nums[:]:\\n                if x == val:\\n                    nums.remove(val)\\n            return len(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def removeElement(self, nums, val):\\n            for x in nums[:]:\\n                if x == val:\\n                    nums.remove(val)\\n            return len(nums)",
                "codeTag": "Java"
            },
            {
                "id": 12664,
                "title": "my-accepted-java-solution",
                "content": "    public int removeElement(int[] nums, int val) {\\n        int i=0, j=0;\\n        \\n        for (i=0;i<nums.length; i++) {\\n            if(nums[i]!=val)\\n                nums[j++] = nums[i];\\n        }\\n        \\n        return j;\\n    }",
                "solutionTags": [],
                "code": "    public int removeElement(int[] nums, int val) {\\n        int i=0, j=0;\\n        \\n        for (i=0;i<nums.length; i++) {\\n            if(nums[i]!=val)\\n                nums[j++] = nums[i];\\n        }\\n        \\n        return j;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 12678,
                "title": "2-lines-this-is-why-i-love-python",
                "content": "    def removeElement(self, nums, val):\\n            nums[:] = [x for x in nums if x!=val]\\n            return len(nums)",
                "solutionTags": [],
                "code": "    def removeElement(self, nums, val):\\n            nums[:] = [x for x in nums if x!=val]\\n            return len(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 12747,
                "title": "5ms-6-lines-c-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n        int removeElement(int A[], int n, int e) {\\n            for(int i=0; i<n; i++){\\n                if(A[i] == e){\\n                    A[i] = A[n-1];\\n                    n--;\\n                    i--;\\n                }\\n            }\\n            \\n            return n;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeElement(int A[], int n, int e) {\\n            for(int i=0; i<n; i++){\\n                if(A[i] == e){\\n                    A[i] = A[n-1];\\n                    n--;\\n                    i--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3917831,
                "title": "replacing-the-position-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you understand the question properly:\\n![image.png](https://assets.leetcode.com/users/images/34ab0276-90d4-4e2c-a1dc-d650dc5a1592_1692187618.331171.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=val){\\n                nums[count]=nums[i];\\n        \\n                count++;\\n            }\\n        \\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=val){\\n                nums[count]=nums[i];\\n        \\n                count++;\\n            }\\n        \\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680270,
                "title": "java-solution-simple-to-understand",
                "content": "\\nTime complexity: \\nO(n)\\nSpace complexity:\\nO(1)\\n\\n\\n\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int index = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != val) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int index = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != val) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615938,
                "title": "c-java-javascript-solutions-faster-than-90-100",
                "content": "We can solve this problem with a easy loop iteration\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-27-remove-element-solution-and-explanation-en/)\\u2B50**\\n\\u2B06To see other languages please click the link above\\u2B06\\n\\n#### Example : JavaScript Code \\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    var j = 0;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]!=val)\\n        {\\n            nums[j++] = nums[i];\\n        }\\n    }\\n    return j;\\n};\\n```\\n\\n---\\n\\n\\n#### C# Code \\n```\\npublic class Solution {\\n    public int RemoveElement(int[] nums, int val) {\\n\\n        int j = 0;\\n        foreach(int i in nums)\\n        {\\n            if(i!=val)\\n            {\\n                nums[j++] = i;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```\\n\\n---\\n\\n### Java\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        \\n        int j = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[j++] = nums[i];\\n            }\\n        }\\n        return j;\\n    }\\n}\\n```\\n---\\n\\n\\n**Now, try next problem immediately!**\\n**\\u2B50[Zyrastory - LeetCode#28 Find the Index of the First Occurrence in a String (Medium)](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-28-find-the-index-of-the-first-occurrence-in-a-string-solution-and-explanation-en/)**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n\\uD83E\\uDDE1See more problems solutions - **[Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n## Thanks!\\n\\n",
                "solutionTags": [
                    "Java",
                    "C#",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    var j = 0;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]!=val)\\n        {\\n            nums[j++] = nums[i];\\n        }\\n    }\\n    return j;\\n};\\n```\n```\\npublic class Solution {\\n    public int RemoveElement(int[] nums, int val) {\\n\\n        int j = 0;\\n        foreach(int i in nums)\\n        {\\n            if(i!=val)\\n            {\\n                nums[j++] = i;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        \\n        int j = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[j++] = nums[i];\\n            }\\n        }\\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525894,
                "title": "q-27-c-solution-super-easy-study-from-this",
                "content": "\\n# Complexity\\nTime: O(n)\\nSpace: O(1)\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                i++;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                i++;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428240,
                "title": "two-step-using-list-comprehension-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nUsing list comprehension (Default method)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        nums [:]= [i for i in nums if i != val]\\n        return len(nums)\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElement(self, nums, val):\\n        nums [:]= [i for i in nums if i != val]\\n        return len(nums)\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172103,
                "title": "efficient-in-place-element-removal-from-a-list-using-two-pointers-python",
                "content": "\\n\\n# Intuition:\\nThe idea behind this approach is to use two pointers, k and single. The variable k keeps track of the position of the current non-target element, while single iterates through the entire list.\\n\\n# Approach:\\nThe code iterates through the list, and for each element, if it\\'s not equal to the target value, the current element is copied to the k-th position. k is then incremented, and the next iteration proceeds.\\n\\n# Complexity:\\n\\n- Time complexity: O(n)\\n\\n  The solution iterates through the entire list once, so its time complexity is linear with respect to the size of the list.\\n\\n-  Space complexity: O(1)\\n   This solution does not require any additional memory allocation, since it only uses a constant amount of extra memory for the two pointers.\\n\\nOverall, this is an efficient solution to the problem of removing elements from a list in-place.\\n# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        \\n        k = 0  \\n        \\n        for single in range(len(nums)):\\n\\n            if nums[single] != val:\\n                nums[ k ] = nums[ single ]\\n                k += 1\\n        return k   \\n        \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        \\n        k = 0  \\n        \\n        for single in range(len(nums)):\\n\\n            if nums[single] != val:\\n                nums[ k ] = nums[ single ]\\n                k += 1\\n        return k   \\n        \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151247,
                "title": "java-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int n=nums.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=val) ans++;\\n            else{\\n            for(int j=i;j<n;j++){\\n                if(j!=n-1)\\n                nums[j]=nums[j+1];\\n            }\\n            n--;\\n            i--;\\n        }\\n        }\\n        \\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int n=nums.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=val) ans++;\\n            else{\\n            for(int j=i;j<n;j++){\\n                if(j!=n-1)\\n                nums[j]=nums[j+1];\\n            }\\n            n--;\\n            i--;\\n        }\\n        }\\n        \\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070256,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "# Approach\\nThe loop goes through the vector checking each value against the restricted value `val`, for each value that is not `val` it will be set to the seperate index k which starts at the beginning of the vector overwriting the already checked values.\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(1)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int k {};\\n        for(int i {}; i<nums.size();i++){\\n                (nums[i]!=val) ? nums[k++]=nums[i]:NULL;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int k {};\\n        for(int i {}; i<nums.size();i++){\\n                (nums[i]!=val) ? nums[k++]=nums[i]:NULL;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945604,
                "title": "very-easy-solution-to-understand-with-comments",
                "content": "Used .filter method, rest in comments\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    // create array with content of nums but without val items\\n    let arr = nums.filter(num => num !== val);\\n    // set nums length to zero\\n    nums.length = 0;\\n    // push content of arr to num\\n    nums.push(...arr);\\n    //return length of nums\\n    return nums.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    // create array with content of nums but without val items\\n    let arr = nums.filter(num => num !== val);\\n    // set nums length to zero\\n    nums.length = 0;\\n    // push content of arr to num\\n    nums.push(...arr);\\n    //return length of nums\\n    return nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2863900,
                "title": "cpp-solution-using-swap-function-only",
                "content": "# Complexity\\n- Time complexity: O(n), 3ms 70.15% better than Online Cpp Submissions\\n\\n- Space complexity: O(1), 8.6 mb 92.8% better than Online Cpp Submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& n, int val) {\\n        int i=0,j=n.size()-1,k=0;\\n        while(i<=j)\\n        {\\n            if(n[i]==val && n[j]!=val)\\n            {\\n                swap(n[i],n[j]);\\n                k++;\\n                i++;\\n                continue;\\n            }\\n            if(n[i]!=val)\\n             {\\n                k++;\\n                i++;\\n             }\\n            if(n[j]==val)\\n             j--;\\n        }\\n  return k;  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& n, int val) {\\n        int i=0,j=n.size()-1,k=0;\\n        while(i<=j)\\n        {\\n            if(n[i]==val && n[j]!=val)\\n            {\\n                swap(n[i],n[j]);\\n                k++;\\n                i++;\\n                continue;\\n            }\\n            if(n[i]!=val)\\n             {\\n                k++;\\n                i++;\\n             }\\n            if(n[j]==val)\\n             j--;\\n        }\\n  return k;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765130,
                "title": "as-simple-as-that-python",
                "content": "```\\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n```",
                "solutionTags": [],
                "code": "```\\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        while val in nums:\\n            nums.remove(val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2745845,
                "title": "c-multiple-approaches-two-pointer-linear-search-faster-than-100",
                "content": "Pls upvote if you like the solution\\n\\nApproach 1:\\n***Check for the elements which are not \\'val\\' in the vector nums and push them to another vector \\' vec \\'\\nreturn the size of new vector \\'vec\\', as it has only elements which are not \\'val**\\' *\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n    vector<int>vec;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n         if(nums[i]!=val)\\n         {\\n            vec.push_back(nums[i]);\\n         }\\n    }\\n    for(int i=0;i<vec.size();i++)\\n    {\\n        nums[i]=vec[i];\\n    }\\n    return vec.size();\\n    }\\n};\\n```\\n\\n**Approach 2: Two pointer **\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int j = 0;\\n            for(int i = 0; i<nums.size(); i++){\\n                    if(nums[i]!= val){\\n                        nums[j] = nums[i];\\n                        j++;\\n                }   \\n            }\\n            return j;\\n    }\\n };\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n    vector<int>vec;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n         if(nums[i]!=val)\\n         {\\n            vec.push_back(nums[i]);\\n         }\\n    }\\n    for(int i=0;i<vec.size();i++)\\n    {\\n        nums[i]=vec[i];\\n    }\\n    return vec.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562453,
                "title": "java-simple-solution-0ms-100-faster",
                "content": "class Solution {\\n\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        for(int j=0; j<nums.length; j++){\\n            if(nums[j] != val){\\n                nums[i] = nums[j];\\n                i++;\\n            }\\n        }\\n        return i;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        for(int j=0; j<nums.length; j++){\\n            if(nums[j] != val){\\n                nums[i] = nums[j];\\n                i++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567813,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1761692,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1697251,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1576937,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1898202,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1746065,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1571069,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1567347,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1796007,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1566738,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1567813,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1761692,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1697251,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1576937,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1898202,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1746065,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1571069,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1567347,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1796007,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1566738,
                "content": [
                    {
                        "username": "HiCode",
                        "content": "For this input it is giving output as wrong answer.\\n[3,2,2,3] and val=3\\nMy answer is 2\\nIt is saying expected answer is [2,2].\\nNow I am confused that I have to return and array or the count of elements (i. e. and integer)."
                    },
                    {
                        "username": "GauravPandey999",
                        "content": "you have to return the no of elements not equal to given key, but you are returning no of elements equal to key\\n"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "You Just need to Count the elements "
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Try Running this one!\\nint removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "vishuraj2427",
                        "content": "You have to return the total number of elements present in the final array but keep one thing in mind array should be in-place"
                    },
                    {
                        "username": "awoldt",
                        "content": "exactly what i was thinking"
                    },
                    {
                        "username": "jeffala",
                        "content": "[@SanskarBabel](/SanskarBabel) this makes sense, the output has to match the exact numbers not just be the correct count. They should do a better job explaining that the actual return val is just the count though. Then again I am not paying for this service so.... "
                    },
                    {
                        "username": "Sanyum_Manhas",
                        "content": "You have to return the count of elements without the val in array"
                    },
                    {
                        "username": "bdedic",
                        "content": "You are returning count but you have to modify an array provided to you so it contains expected result. "
                    },
                    {
                        "username": "Spydermanno",
                        "content": "make an array but return an integer "
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "You have to count the elements but there is a checker in the code that is checking for the array also so you have to modify the array also "
                    },
                    {
                        "username": "Code_Surgeon",
                        "content": "LeetCode: It does not matter what you leave beyond the returned K\\nAlso LeetCode :\\noutput [2, 2, 3]\\nexpected [2, 2]"
                    },
                    {
                        "username": "faye231019",
                        "content": "Because nums its already a list so you have to specify to insert the values "
                    },
                    {
                        "username": "Tejbad",
                        "content": "please check what you are returning, you should return the size of output array, this issue might be because you returned 3, which should be 2 in this case."
                    },
                    {
                        "username": "aosswal2",
                        "content": "i have the same problem."
                    },
                    {
                        "username": "SleakEffect",
                        "content": "if the val = 3, then it shouldn\\'t be part of the output if you return k "
                    },
                    {
                        "username": "Rishi-jain",
                        "content": "i think it because you returned 3 from the function hence it is printing 3 elements instead of 2\\n"
                    },
                    {
                        "username": "steve1031",
                        "content": "Answer does not seem to be correct for this case.\\n\\nInput\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "you need to return the number of elements which are not equal to val (i.e., you need to return 8-3 = 5)"
                    },
                    {
                        "username": "DraconisRaveusRex",
                        "content": "The complier will say that the expected answer is an array, (due  to the weird way leetcode\\'s compiler works). The description is incorrectly and it means to say: consider the number of elements in nums which are not equal to val \"as\" k, to get accepted, you need to do the following things. So the return value is supposed to be the number of items in the array that aren\\'t val. Unfortunately LeetCode and HackerRank sometimes forget to spellcheck these questions..."
                    },
                    {
                        "username": "ahmadfaiz8720",
                        "content": "just return the index value "
                    },
                    {
                        "username": "narekpetrosyan",
                        "content": "Its definitely not correct, faced the same issue. "
                    },
                    {
                        "username": "datsenkoboos",
                        "content": "[@bdedic](/bdedic) thank you!"
                    },
                    {
                        "username": "bdedic",
                        "content": "If the 3 is your return int as result that is why your answer is not correct. Check description of problem. K or returned int is the numer of elements in an array after the specific value is removed. In your case it should be 5."
                    },
                    {
                        "username": "MichaelMcG5100",
                        "content": "Order of output doesn\\u2019t matter"
                    },
                    {
                        "username": "ishbar",
                        "content": "I really dislike whoever made this, and the other similar problems.\\n\\n`nums[:] = [x for x in nums if x != val]` works, but (for whatever reason) `nums = [x for x in nums if x != val]` does not. \\n\\nThis is really confusing to me when the problem description states \\n\"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n\\n"
                    },
                    {
                        "username": "NoobCoder1231231231",
                        "content": "[@dkochetov](/dkochetov) I still dont get it "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@kbventures](/kbventures) These String manipulations are not easy."
                    },
                    {
                        "username": "ricflairdrip",
                        "content": "This is because when you slice a list it creates a new list object that references the original list\\'s elements. The second method creates an entirely new list object with new elements. Shallow vs deep. The question specifies that it must be in-place (return the same list)."
                    },
                    {
                        "username": "dkochetov",
                        "content": "This is really important for beginner to understand the difference between passing by value and passing by reference. Which types can be modified in-place, which can not. Pure functions and other theoretical knowledge that will greatly benefit you in your work.\\n\\nEspecially in python, that implicitly works with pointers. If you don\\'t have any experience with C, it can be hard to comprehend."
                    },
                    {
                        "username": "vetor",
                        "content": "[@Lexi36871](/Lexi36871) brecause strings are immutable in python without [:] this u are just creating a new string with different location thats the reason why its not working :)"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "This problem is related with the way the question is judged rather than the way it\\'s phrased. The idea of doing something in-place implies moving the elements around in the original array, not allocating a new array and then assigning it to the old one.  The for-comprehensions are not in-place solutions and are not O(1) in memory, even though the nums[:] syntax replaces the elements of the old array with the elements of the new array, therefore passing the tests."
                    },
                    {
                        "username": "kbventures",
                        "content": "[@jimmyhodl](/jimmyhodl) This problem is very very very poorly explained. "
                    },
                    {
                        "username": "seal_here",
                        "content": "only way to check if array is modified inplace in python is to check the variable\\'s storage location (which stores reference to the memory address of variable) which is not modified in the first case while second one modifies it."
                    },
                    {
                        "username": "LCPaily",
                        "content": "Yeah the output is just straight up wrong for the latter. This is a bad problem for anyone using Python"
                    },
                    {
                        "username": "Lexi36871",
                        "content": "[@jimmyhodl](/jimmyhodl) I have the same problem... Any idea why without [:] won\\'t work?"
                    },
                    {
                        "username": "manicko",
                        "content": "Thank you!!! I\\'ve spent a whole day to find why this approach does not accepted"
                    },
                    {
                        "username": "jimmyhodl",
                        "content": "Exactly. My first thought. Spent almost an hour figuring why this comprehension isn\\'t accepted here while it prints correct values on my IDE. Filling list with numbers to preserve the lenght doesn\\'t help either. It appears you don\\'t have to keep all the initial elements in list. This code with [:] works great"
                    },
                    {
                        "username": "niamlaylor",
                        "content": "This is a vert poorly written question. Clarity is key in coding. Bad requests get bad code!"
                    },
                    {
                        "username": "rwatso",
                        "content": "It\\'s because English is not the first language of the site itself and I think most of the people here. And programmers like to over-complicate things in general. Not a good combination when you\\'re trying to learn a complex discipline. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "I want to comment this on half of Leetcode\\'s challenges - Clarity is severely lacking on this site"
                    },
                    {
                        "username": "centroid",
                        "content": "[python]\\n\"Case2\" IS WRONG!\\n========\\nnums = [0,1,2,2,3,0,4,2]\\nval = 2\\nOutput = [0,1,3]      # stop checking elements after getting 3 instead of 4\\nExpected = [0,1,4,0,3]\\n=========\\nCorrect expected nums is [0,1,3,0,4]! so testcase2 is incorrect! "
                    },
                    {
                        "username": "mochiball",
                        "content": "[@Maheshwar_Bhat](/Maheshwar_Bhat) You can return in any order. Its not wrong "
                    },
                    {
                        "username": "here_we_stand",
                        "content": "bruh, check the description. It\\'s said that you can change the order of elements, so both [0,1,4,0,3] and [0,1,3,0,4] are correct. Also it seems that you equated k to the number of values equal to val, instead of number of values NOT equal to val"
                    },
                    {
                        "username": "Mahzarasua",
                        "content": "I thought the testcase was incorrect and for some reason it didn\\'t make any sense. However if you iterate through the array and the first val you find you replace it with the number iterating through the array in reverse order you will get the testcase2 output. Think about it, you find the first 2 and then you go in reverse order through the array, the last number is another 2 so you skip it and then you got it."
                    },
                    {
                        "username": "Maheshwar_Bhat",
                        "content": "Absolutely true. This test case is incorrect."
                    },
                    {
                        "username": "samsonzijian",
                        "content": "Input:\\t[3,3], 5\\n\\nOutput:\\t[3,3,0]\\n\\nExpected:\\t[3,3]\\n\\nSo I don't understand, what does this mean..."
                    },
                    {
                        "username": "mskamel",
                        "content": "It mean that the number of elements not equal to val that you return from your removeElement() function is incorrect. This is means that the value you return from your function might be greater or less than the value that you returned from your function."
                    },
                    {
                        "username": "StefanelStan",
                        "content": "It expects to return 2: an array of size 2, not size 3. \\nIf your input is [3,3,3], val = 3, it expects 0."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think you need to decrease the size of the array when you removing a number."
                    },
                    {
                        "username": "jas688",
                        "content": "There seems to be significant variance in excution time for the same submitted code. I wonder if this is correlated with server load?"
                    },
                    {
                        "username": "Benties",
                        "content": "delete this one"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its not that bad lol "
                    },
                    {
                        "username": "oscarbatori",
                        "content": "Was just working through some basic algorithms in JavaScript to get to know the language, and began working on [Remove Element][1], which seems to be a very popular one.\\n\\nThe question doessn't seem to make sense: \"Given an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn't matter what you leave beyond the new length.\"\\n\\nThis seems to imply the question merely requires counting the remaining elements, which is trivial. Yet the submission seems to want the array with the remaining elements. The parameters seem to agree with the way the question was posed:\\n\\n    /**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\n\\n\\n  [1]: https://leetcode.com/problemset/algorithms/?cong=true"
                    }
                ]
            },
            {
                "id": 1967481,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1568088,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1920625,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1808506,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1957683,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1883960,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1844325,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1763219,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1576385,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 2031025,
                "content": [
                    {
                        "username": "tristancrudge",
                        "content": "One of the worst questions on the platform hands down. \\n\\nSays: Return k\\nI: Return k\\n\\nResult: Error expected an array\\nI: Change to an array\\n\\nResult: VALUE NOT EXPECTED\\n\\n\\nGet out"
                    },
                    {
                        "username": "phigh",
                        "content": "I am curious, right now there are 3 times more likes than likes. Strange"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is really strange."
                    },
                    {
                        "username": "YadavVicky",
                        "content": "For all those who are confused. Question is just asking one thing.\\nYou have return the index not count (as I am seeing here in discussion) but the index.\\nFor Eg:- nums = [13,11,11,13], val = 13, by removing the value they mean it to be still in the array but at the end so in case it will be [11,11,13,13], now you have return the index after which the val in this case it is 13 will start to occur in the array. So in this case it is index 2. Because after index 2 which is index 3 and 4, we have 13.\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "I think the indices you reference are off by 1. Index 3 is the last element in the array and index 4 is out of bounds past the end of the array; the array has only 4 elements total (indices 0 - 3)."
                    },
                    {
                        "username": "almostcolin",
                        "content": "Okay... But in the first test case nums=[3,2,2,3] and val=3. I can hard code it to return 2 and I get the output [3,2]..."
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "has anyone felt that this problem is bit annoying for a Easy? I feel this is slightly above easy, could have been a medium."
                    },
                    {
                        "username": "bubbakill7",
                        "content": "The wording is confusing, but mediums are much harder. "
                    },
                    {
                        "username": "charlescolfer",
                        "content": "Incredibly confusing and unhelpful description, like most of Leetcode unfortunately... no quality control... \\n\\nAll you need to do is return the number of \"Nums\" (Count, Answer, whatever Int variable you want to name it as) that aren\\'t included in your import. A one line loop can do it. \\n\\nExample 1:\\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nLOOP THROUGH NUMS, check for 3\\n\\nLogic: is val nums[i]? If NOT, increase Count by 1. Return Count. \\n\\nIs Val (3) === nums[i](3)? yes? next\\nIs Val (3) === nums[i](2)? no? Count += 1\\netc. \\n\\nExtremely easy problem that is complicated infinitely by the terrible description."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the two pointer approach running in O(n) time:\nhttps://www.youtube.com/watch?v=pGKDzt0gk-A\n"
                    },
                    {
                        "username": "user7903L",
                        "content": "Seems like this problem is not property set up and also is completely broken. At least for typescript. \\n\\nFirst of all by default the function is defined to return a `number.` But when you run the test the output expected is an array of numbers `number[]`.\\n\\nSecond something is completely broken making this unsolvable (for typescript at least that is). When running test case one the expected output is `[2,2]`. Even if I hardcode the function to return `[2,2]` the output of my function ends up being an empty array. I tried multiple time."
                    },
                    {
                        "username": "iota_by_0",
                        "content": "My code is running perfecty in vsCode but in leetcode it is showing me runtime error....\\nwhy ?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for (int i = 0; i < nums.size(); i++)\\n    {\\n        int ele = nums[i];\\n        if (val == ele)\\n        {\\n            for (int j = i+1; j < nums.size(); j++)\\n            {\\n                if (nums[j] != val)\\n                {\\n                    swap(nums[j], nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    for (int i = nums.size(); i >= 0; i--)\\n    {\\n        if (nums[i] == val)\\n        {\\n            nums[i] = -1;\\n        }\\n    }\\n    int count = 0;\\n    for (int i = 0; nums[i] != -1; i++)\\n    {\\n        count++;\\n    }\\n    return count;\\n    }\\n};"
                    },
                    {
                        "username": "Rajneeshyadavg",
                        "content": "it\\'s taking too much time. "
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/af85056a-5109-4f6b-84df-f45b39145912_1644805304.85511.jpeg)\\n"
                    },
                    {
                        "username": "2020B0101194",
                        "content": "nums.erase(remove(nums.begin(),nums.end(),val),nums.end());\\njust one line code......."
                    },
                    {
                        "username": "DyuldinKS",
                        "content": "The most unclear description I\\'ve ever seen on leetcode. Especially for an easy task. Wasted time."
                    }
                ]
            },
            {
                "id": 1858171,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 1697305,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 1898633,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 1997392,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 1791526,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 1737034,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 1574657,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 1569471,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 2045634,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 2044368,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\nHere is two ways to solve this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "kswa",
                        "content": "\\nwhy my cod does not work ?\\nvar removeElement = function(nums, val) {\\n    let newnums =[]\\n    nums.forEach(item =>{if(item !==val){\\n        newnums.push(item)\\n    }})\\n    return newnums.length;\\n};"
                    },
                    {
                        "username": "nafajardo637",
                        "content": "Have you tried putting it in a fish tank."
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory."
                    },
                    {
                        "username": "mr_president",
                        "content": "dunno why this is downvoted so much, just read the question properly. "
                    },
                    {
                        "username": "dimfu",
                        "content": "This problem sucks ass"
                    },
                    {
                        "username": "icy93770",
                        "content": "\\uC544\\uB2C8 \\uC774\\uAC70\\uB97C \\uC815\\uB2F5\\uC744 \\uBC30\\uC5F4\\uB85C \\uD558\\uBA74\\uC740 \\uD1A0\\uC885 \\uD55C\\uAD6D\\uC740 \\uC54C\\uACA0\\uB0D0\\uACE0\\uC694!!!! "
                    },
                    {
                        "username": "sanjay_bhat",
                        "content": "After submitting the code, I was looking in the chart for the code with least runtime...\\nHow is a code that has nested for loops be the best performing code? When my solution and different variants which do the same with just a single iteration be slower than nested for loops?\\n\\nI am really confused, Is the time distribution chart on Leetcode flawed or am I missing something fundamental?\\n"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "[@KovDimaY](/KovDimaY)  It isn\\'t completely random though"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Do not mind that chart, it makes no sense. I also had the same concern after 1 or 2 first submissions and then I realised that the statistics that they provide is just a random numbers generator. You can check it submitting the same code several times in a row. Sometimes when I did it 5 times, the results told me that my code is better than 99% of the submissions and then the same code was better than 5% in another try. Is just super misleading and stupid. So just focus on solving problems and check other solutions just for getting some new ideas of how to solve them. Do not compare metrics, they just make no sense."
                    },
                    {
                        "username": "perekhodovalexey",
                        "content": "Obvoiusly there is a typo in the description:\\n\\nif you return 2 with nums = [2,2,3,3] or nums = [2,3,0,0], your answer will be accepted.\\n\\nSince 3 is the number to remove [2, 2, 0, 0] can be accepted, not [2, 3, 0, 0]"
                    },
                    {
                        "username": "big_big_orange",
                        "content": "![image](https://assets.leetcode.com/users/big_big_orange/image_1554384065.png)\\n"
                    },
                    {
                        "username": "ccristiany339",
                        "content": "i think people forget THIS GOES INTO THE SOLUTIONS TAB"
                    },
                    {
                        "username": "nagyabonyigergo",
                        "content": "Hello!\\n\\nUnfortunately, I don\\'t see the error, what am I doing wrong? I also printed the array because I couldn\\'t see where the error was! Thank you for your help!\\n\\n`func removeElement(numbers []int, flag int) int {\\ncount := 0\\nresultArray := []int{}\\n\\nfor index := 0; index < len(numbers); index++ {\\n\\tif numbers[index] != flag {\\n\\t\\tresultArray = append(resultArray, numbers[index])\\n\\t\\tcount++\\n\\t}\\n}\\n\\nfmt.Println(resultArray)\\nreturn count\\n}`\\n\\nStdout: [2 2] <-- This is what I got in PrintlN\\nOutput: [3,2] <-- LeetCode result\\nExpected: [2,2]"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You have to modify the original arrray in place. Not creating a new one."
                    },
                    {
                        "username": "LeetCoder-1711",
                        "content": "I wrote the code and ran the same in VS Code using nodejs, gets expected answer; while leetcode says Wrong answer."
                    }
                ]
            },
            {
                "id": 2029085,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 2026183,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 2013012,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 1965900,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 1956657,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 1949255,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 1802824,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 1710050,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 1700128,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 1576295,
                "content": [
                    {
                        "username": "cblakely",
                        "content": "This question is retarded and I\\'m skipping it."
                    },
                    {
                        "username": "mutongzi",
                        "content": "the description is terrible. it should just say\nmove all  values  not equal to val to the front of the array\ndone!"
                    },
                    {
                        "username": "GMatorin",
                        "content": "Whoever wrote the description can\\'t write in a clear way. The description doesn\\'t make sense."
                    },
                    {
                        "username": "mochiball",
                        "content": "I agree it is a bit vague. However, take your time reading it and you\\'ll understand the problem "
                    },
                    {
                        "username": "hurrycaner",
                        "content": "This question is totally broken for go"
                    },
                    {
                        "username": "mochiball",
                        "content": "Amazingly annoying question "
                    },
                    {
                        "username": "TrangBui-1999",
                        "content": "Be ware to use Javascript any array.prototype because it may not worked. I need to bulid from scratch with loop for()"
                    },
                    {
                        "username": "nroscillada",
                        "content": "[@thos25](/thos25) this does not work as well:\\n\\nnums = nums.filter((n) => {\\n    return n !== val;\\n  });\\n  return nums.length;"
                    },
                    {
                        "username": "thos25",
                        "content": "I think this might be an issue. I solved it using .map and it rejected it. \\n\\nconst removeElement = (nums, val) => {\\nlet k = nums.length\\nnum = nums.map(x => x === val ? k-- : null)\\nreturn k\\n}\\n\\nso then I was wondering if maybe the array has to be modified to remove/alter the elements that match val. So I did this and even tried a forEach to mix it up...but it also fails. \\n\\nconst removeElement = (nums, val) => {\\n    let k = nums.length\\n    nums = nums.map(x => x === val ? x = \"_\" : x = x).sort()\\n    nums.forEach(num => num == \"_\" ? k-- : null)\\n    console.log(k, `nums = ${nums}`)\\n    return k\\n}\\n\\nmeanwhile I did it in a for loop that does the exact same thing and it passed. So I think you might be right about it failing array prototype methods. "
                    },
                    {
                        "username": "user0291CQ",
                        "content": "This is the 3rd problem in a row with confusing directions. Someone mentioned Hackerrank. I think I\\'ll give that a try as well. I want to solve problems, not battle the directions. At the very least, I\\'ll be skipping all problems with significant dislikes."
                    },
                    {
                        "username": "JamesMEvansMBA",
                        "content": "This should work, but it doesn\\'t.  Why?\\nnums =Arrays.stream(nums)\\n            .filter(i -> i != val)\\n            .toArray();"
                    },
                    {
                        "username": "taikhoanhocchung2",
                        "content": "you must make update on the nums itselft"
                    },
                    {
                        "username": "barrettev",
                        "content": "\"nums\" is a reference to a mutable array allocated elsewhere in the program.  You can modify its content (nums[a] = b) and that will be reflected  by all references to the array.\n\nArrays.stream is creating a new array, and you're nums = Arrays.stream(...).toArray() is updating the local reference called nums to a new array rather than modifying the original array.\n\nYou can accomplish what you're trying to do by updating the content of the original nums reference with a forEach like this:\n\nArrays.stream(nums).filter(n->n!=val).forEach(n->{nums[k++]=n;});\n"
                    },
                    {
                        "username": "msss",
                        "content": "Your are creating a new array, that was not allowed.\\n"
                    },
                    {
                        "username": "apiwut_t",
                        "content": "why output different from my local machine\\ngolang\\n\\n `func removeElement(nums []int, val int) int {\\n    var ans [] int\\n    for i:=0;i<len(nums);i++{\\n        if nums[i] != val{\\n            ans = append(ans, nums[i])\\n        }\\n    }\\n    return len(ans)\\n}`\\n\\nresult on test case 1 \\ninput\\n`nums = [3,2,2,3]` `val=3`\\noutput `[3,2]`\\nit should be `[2,2]` like i run this code on my computer"
                    },
                    {
                        "username": "pranaseptia21",
                        "content": "![image](https://assets.leetcode.com/users/images/f7db61c6-5a6f-4924-80aa-3cd3647f0564_1643191666.3219159.png)\\n"
                    }
                ]
            },
            {
                "id": 1575931,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 1573810,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 1572969,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 1576433,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 2076013,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 2074561,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 2069922,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 2068456,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 2068008,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 2067563,
                "content": [
                    {
                        "username": "Dark007",
                        "content": "I solved the move zeros question and this popped up as the follow up question. It has an ashtonishing like:dislike ratio. Is it because of the custom testcase? or does the problem seem repetitive."
                    },
                    {
                        "username": "RAMSWARUP-KULHARY",
                        "content": "\\treturn distance(nums.begin(), std::remove(nums.begin(), nums.end(), val));"
                    },
                    {
                        "username": "linziin7748",
                        "content": "Testcase:\\n[3,3,2,2,3,2,1]\\n3\\n\\nThe expected shows [1,2,2,2].\\n\\n"
                    },
                    {
                        "username": "Lunazhang",
                        "content": "If  we only need count the number of unpicked value, why cannot use this solution:\\n\\nreturn len([x for x in nums if x != val])"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "[@cswartzell](/cswartzell) sometimes it\\u2019s better to make operations in place, so you don\\u2019t need to use additional memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You are only RETURNING the value, it still asked you to modify the array in place. Not a great practice, asking for a side effect to be the intended goal of a function, but thats what the problem wants., "
                    },
                    {
                        "username": "Patricklmm7",
                        "content": "For the input is [3,2,2,3] val = 3, the output should be [2,2] and nums.length = 2, but the system said it is wrong answer..."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "nums.length is 4\\nreturn k = 2"
                    },
                    {
                        "username": "Hamii",
                        "content": "Yet another broken problem. I just came back from a similar one. You can\\'t be asking for us to return K, yet not check for K at all. Also, the second testcase is wrong. I really expected more from leetcode, given how big of a name they are. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is not broken. 2.2 milion answers have been submitted successfully. The order of the elements in the array does not matter."
                    },
                    {
                        "username": "Halvess",
                        "content": "This question is not right (at least the judging part). \nFor testing purposes I did the following code:\n```\nnums=[2], val = 3\nvar removeElement = function(nums, val){\n if (nums.length == 0 && nums[0] !== val) return 0\n}\n```\nI got this:\n```\nOutput: []\nExpected: [2]\n```\n\nI didn't even touch the array, wtf"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "You are supposed to return the length of the array, if you return 1, you will get the expected output."
                    },
                    {
                        "username": "user1815P",
                        "content": "it was really easy!\\n:)"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I think it is medium."
                    },
                    {
                        "username": "maxvdsluis",
                        "content": "Outlined description exclaims you have to return k.\\nI\\'ve found I could simply skip this and still get 100% test passing."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No that gives an error. \\nWhich programming language would that be?"
                    },
                    {
                        "username": "_thomash_",
                        "content": "The question needs reworking as it doesn\\'t take into consideration the answers that have the first k elements in a different order (which should be admissable looking at the description of the question)."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is not sorted."
                    }
                ]
            },
            {
                "id": 2057405,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2057396,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2052347,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2050695,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2050478,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2050406,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2049267,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2048241,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2048140,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2047705,
                "content": [
                    {
                        "username": "vtu13227",
                        "content": "Why below code is not working if iam getting the output as expected\\n\\nvar removeElement = function(nums, val) {\\n  for(let i=0;i<nums.length;i++){\\n      if(nums[i]===val){\\n          nums.splice(i,1)\\n      }\\n  }\\n  return nums\\n};"
                    },
                    {
                        "username": "isydor",
                        "content": "you need to return k - number of elements that are not equal to val, not nums itself."
                    },
                    {
                        "username": "vtu13227",
                        "content": "Why the below code is giving me the wrong output. When i debugged through VS code it is working as expected\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n    const filteredArray = nums.filter(num=>num!==val)\\n    return filteredArray\\n};"
                    },
                    {
                        "username": "Krishna-anil",
                        "content": "can anyone tell me why it is showing runtime error\\n\\n\\nint removeElement(int* nums, int numsSize, int val)\\n{\\n    int i,k=0;\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==val)\\n        {\\n            for(int j=i;j<numsSize;j++)\\n            {\\n                int temp=nums[j];\\n                nums[j]=nums[j+1];\\n                nums[j+1]=temp;\\n            }\\n            numsSize--;\\n            i--;\\n        }\\n        else\\n        {\\n            k++;\\n        }\\n    }\\n    return k;\\n}\\n\\n"
                    },
                    {
                        "username": "isydor",
                        "content": "maybe because you have three inputs (int* nums, int numsSize, int val) not two (int[] nums, int val)?"
                    },
                    {
                        "username": "myCatsName",
                        "content": "The description is problematic and unclear. And the expected return WRT the nums array is really too hard to understand from what is written. Further, the \"Output\" when running tests is clear as mud. Return an int length and Output sees an array, nothing matches what we do in IDE. Ultimately needed to \"cheat\" just to understand what is required."
                    },
                    {
                        "username": "ersurajaky",
                        "content": "My code is given expected output. But here it is showing wrong code."
                    },
                    {
                        "username": "DiPipero",
                        "content": "wtf is:\n `assert k == expectedNums.length;`\n\nit shouldn't be here. it isn't common of all languages. \nThis is the worst written problem in all leetcode"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "That is Java code. It checks your solution, if k has the correct value."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "assert is checking the boolean condition and is throwing an exception if it is false."
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "nums =\\n[2]\\nval =\\n3\\n\\nUse Testcase\\nOutput\\n[]\\nExpected\\n[2] can anyone tell me where is problem\\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You shall remove 3 from the array, there is none, so you return the array with the 2."
                    },
                    {
                        "username": "kothariayush025",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int[] ans = new int[nums.length];\\n        int count =0;\\n        int k =0;\\n        for(int i =0; i<nums.length;i++){\\n            if(nums[i]==val){\\n                count = count+1;\\n                continue;\\n            }\\n            else{\\n            ans[k] = nums[i];\\n            k++;\\n            }\\n        \\n        }\\n         System.out.println(nums.length-count);\\n        System.out.println(Arrays.toString(ans));\\n        return nums.length-count;\\n    }\\n}\\n\\nI am getting the output as [2,2,0,0] and count matches 2, Why does it show the output as [3,2]? Can anyone explain\\n"
                    },
                    {
                        "username": "Saalim_k",
                        "content": "can someone help me understand what im doing wrong here?\\n\\nit says my output is [] but when i run the script on chrome console i get the correct output.\\n\\nvar removeElement = function(nums, val) {\\n\\n    var i = 0;\\n    var j = nums.length-1;\\n    var k = 0;\\n    while(i <= j)\\n        if(nums[i] == val){\\n            while(nums[j] == val){\\n                j--;\\n            }\\n            var temp = nums[j];\\n            nums[j] = nums[i];\\n            nums[i] = temp;\\n            j--;\\n            i++;\\n            k++;\\n        }\\n        else{\\n            i++;\\n        }\\n    return nums\\n};"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You should return k instead of nums. There are other errors too, for example what happens if the array is all val?"
                    },
                    {
                        "username": "ZubriQ",
                        "content": "OMG. this \\'problem\\' is so bad. Don\\'t waste your time here."
                    }
                ]
            },
            {
                "id": 2043174,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2039902,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2037585,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2036912,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2035772,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2030691,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2027004,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2026058,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2021521,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2017533,
                "content": [
                    {
                        "username": "adamstrejcovsky",
                        "content": "It does not matter what you leave beyond the returned k (hence they are underscores). - this is not true."
                    },
                    {
                        "username": "SomtoJF",
                        "content": "Do they expect to mutate the original array? My value for k seems to be correct but it is checking against the input array even after I reassign nums to the array I created to solve the problem."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, modify the input array in place, without using a second array."
                    },
                    {
                        "username": "Naad420",
                        "content": "## Leetcode Python3 Compiler is bugged, I tried running the same code in Pycharm and it works like a charm(pun intended)."
                    },
                    {
                        "username": "overflow0x",
                        "content": "Poorly written, wrong return type, incorrect test case."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What?"
                    },
                    {
                        "username": "ebarcly",
                        "content": "All they are really asking is to return the size of the modified array, not the modified array itself. Using a pointer to keep track of the `val` at index in `nums` should be enough to count up to the size of the mod array. "
                    },
                    {
                        "username": "ebarcly",
                        "content": "[@Tom_Dev](/Tom_Dev) correct, where that reference counts up to k."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "The array is modified in place through the reference parameter."
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != val){\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MOVAPS",
                        "content": "This problem marked my 200th leetcode solution."
                    },
                    {
                        "username": "bobspace",
                        "content": "The description is misleading. The solution tester looks for the elements in a specific order so the passage that says: \"The order of the elements may be changed.\" is inaccurate.\\n\\nI can log out my `nums` array and it has the correct elements, but in a different order, but the \"output\" of my testcase is just an array that contains the correct elements until the checker found a value not in its prescribed results array."
                    },
                    {
                        "username": "Bl4kcrow",
                        "content": "Using Dart language, I have tested a couple of solutions in the DartPad and they work well, but the same code doesn\\'t work here "
                    },
                    {
                        "username": "Francof",
                        "content": "var removeElement = function(nums,val) {\\n     for(let i = 0; i < nums.length; i++ ){\\n       if(nums[i] == val){\\n         nums[i] = null\\n       }\\n       \\n    }\\n  nums = nums.join(\\'\\').split(\"\")\\n  return nums\\n};\\n\\n\\nCan someone tell me why this isn\\'t working? "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "null is the end of the string. You have to copy the next element in place."
                    }
                ]
            },
            {
                "id": 2011244,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 2009276,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 2007542,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 2001885,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 2001838,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 2000701,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 1997374,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 1996039,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 1994561,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 1993254,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "\\n1. Initialize two pointers, `i` and `j`, both set to 0.\\n2. Iterate through the array using pointer `i`:\\n   - If `nums[i]` is not equal to `val`, assign `nums[j] = nums[i]` and increment both `i` and `j`.\\n3. After the loop, return the value of pointer `j`, which represents the length of the modified array.\\n\\nThis algorithm efficiently removes all occurrences of the specified value `val` from the array while maintaining the relative order of other elements."
                    },
                    {
                        "username": "hoodiCS",
                        "content": "Input\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\n\\nMy output: \\n[0,1,4,0,3,2]\\n\\nim using print(nums[:x])   here x is len(nums)-k\\nbut when is used  nums[:] = [x for x in nums if x != val] and printed nums it worked why is that"
                    },
                    {
                        "username": "priyakhandelwal65",
                        "content": "It seems mentioned case is wrong. \"sort(nums, 0, k); // Sort the first k elements of nums \" It is sorting the given array not the  expected array and then comparing it which is incorrect way to compare. "
                    },
                    {
                        "username": "cabouey",
                        "content": "Can anyone help me identify why this is failing tests? The output is not correct:\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        count = 0\\n        while i < len(nums):\\n            if nums[i] == val:\\n                count += 1\\n                if i == len(nums)-1:\\n                    nums = nums[:i]\\n                else:\\n                    nums = nums[:i] + nums[i+1:]\\n            else:\\n                i += 1\\n            \\n        print(f\\'final: {nums}\\')\\n        return len(nums)"
                    },
                    {
                        "username": "Nitaydas",
                        "content": "simple rules to understand:\\n\\n1. iterate a loop for the size of nums.\\n2. remove all elements from the nums that are equal to the val or store all elements in another vector that are      not equal to val.\\n3. assign nums=vector(v) that was created for storing elements not equal to the val.\\n4. return the number of element that are not equal to the val or simply return the v.size(). \\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "That\\'s not in place as the question requests, and in many languages (and in c depending of the actual function signature), reassigning nums won\\'t actually modify the original nums "
                    },
                    {
                        "username": "AnkitModak",
                        "content": "I am a beginner and I was curious to know the same, why [:] this works and another doesn't. After doing some search on google and gpt, what I learnt was when you go through the second approach, the code is going through the same elements twice, also making a copy of nums which causes extra memory consumption (I believe the main reason for second approach not satisfying leetcode testcases). Also, when we use [:], the original memory location of the elements of nums is changing which in result of [3, 2, 2, 3] we get nums in the memory as [2, 2] which satisfies the leetcode testcase. \n\nYet to understand the time complexity of this solution!\n\nIt will be great if someone can give me a glimpse of it. Thank you in advance!\n"
                    },
                    {
                        "username": "PelegBN",
                        "content": "Does using built-in JS functions (like \\'splice\\' and \\'indexOf\\') allowed?\\nThe platform accepts the answer but will the interviewers?"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "It would depend on how you are using it. I think most of the algorithms for this problem that use indexOf do NOT have linear time complexity, which is a requirement in the question"
                    },
                    {
                        "username": "Parth7199",
                        "content": "Can someone spot what mistake I am making here? \\n  \\nint removeElement(vector<int>& nums, int val) {\\n        int k = 0; \\n        for (int i = 0; i < nums.size(); i++)  {\\n            if (nums[i] == val) \\n                nums.erase(nums.begin() + i);            \\n            else \\n                k++;\\n        }\\n        return k;\\n}\\n\\nThanks in advance."
                    },
                    {
                        "username": "Parth7199",
                        "content": "[@aryan_mittal](/aryan_mittal) Hi thanks for the reply and for sharing the code. Your code is very understandable and I see this was much simpler than what I made to be.\n\nSo, what I was trying to do was that I was removing the elements equal to val using the erase function, and keeping count of elements not equal to val in k. Then, after the for loop is terminated, I would have the count of elements not equal to val in k and I would have removed all elements equal to val. I am not 100% sure why it didn't work, but my guess is it has something to do with erase function's implementation. Regardless, I'll look into this and thank you!"
                    },
                    {
                        "username": "aryan_mittal",
                        "content": "actually I  didn't get what r u trying to do on ur program but according to the question u have put the element in the array removing the given val element \nhere is my code hope u find it understandable\n\nint size = nums.size();\n        int k = 0;\n        for(int i =0 ; i < size ; i++){\n            if(nums[i] != val){\n                nums[k++] = nums[i]; \n            }\n        }\nreturn k;"
                    },
                    {
                        "username": "madhura--03",
                        "content": "the question is too confusing."
                    },
                    {
                        "username": "dipesh1203",
                        "content": "This code running very well in my vs code but not passing test cases in  leet code and my all test cases are passing in vscode with same code what can i do?? please help.\\n"
                    }
                ]
            },
            {
                "id": 1987405,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1979805,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1979221,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1978573,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1977924,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1974642,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1974191,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1968896,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1962176,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1961921,
                "content": [
                    {
                        "username": "emilija-99",
                        "content": "For the same code, my machine is displaying me a correct value, but when i paste that code in this editor, doesn\\'t return same result . Can someone help me? "
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me why me code doesn\\'t work well ? \\nvar removeElement = function(nums, val) {\\n\\tnums = nums.filter((e) => e!== val).concat(nums.filter((e) => e=== val));\\n\\treturn nums.filter((e) => e!== val).length;\\n};"
                    },
                    {
                        "username": "ybbyun93",
                        "content": "I tried a following code below.\n\n        index = 0\n        for i in range(len(nums)):\n            if nums[i] == val: \n                nums[i] = nums[i+1]\n                index += 1 \n        return index\n\nand I got an IndexError in this line: nums[i] = nums[i+1]\n\nDoes anyone know why? Is because 'i' in for statement just gets itself in every loops by any chance?"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "in your code once you reach to the end its looking to add num[i+1] which doesn\\'t exists. try this code -     int ctr = 0;\\n        for (int i=0;i<nums.length;i++){\\n                if(nums[i]!=val){\\n                    nums[ctr] = nums[i]; \\n                    ctr++;\\n                }\\n\\n        }\\n        return ctr;"
                    },
                    {
                        "username": "mohitbharti",
                        "content": "Why this solution is not working on your portal -  \\n    List<Integer> list =  Arrays.stream(nums).boxed().collect(Collectors.toList());\\n         list.removeAll(Arrays.asList(val));\\n      return list.size();"
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "The description of this problem is very poor. In really don\\'t get what shall be done here"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Check hints to the problem.\nThey could help you."
                    },
                    {
                        "username": "kallask",
                        "content": "Testcase2 has an error. It returns output: [0,1,4] expected: [0,1,4,0,3]. I put my solution into both PyCharm debugger and Python Tutor Visualizer (just to make sure) - the output for nums should not be throwing an error. \\n\\nI am wondering if your testcase2 is accidentally reading to length of k? It seems to stop reading nums at index 2 which would correspond to this error. "
                    },
                    {
                        "username": "anarbaev_u",
                        "content": "Expected output in testcase 1: [2,2]\\nMy output: [2,2] and k = 2\\n\\nHowever,\\nTypeError: [2, 2] is not valid value for the expected return type integer[]\\n\\nI dont understand. I am returning answer as list with int values but it says invalid type???"
                    },
                    {
                        "username": "katariachirag14",
                        "content": "Can somebody please tell me, what is wrong with this code:-\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        l=0\\n        n=len(nums)\\n        for i in range(0,n):\\n            if nums[i]==val:\\n                nums.pop(i)\\n            else:\\n                l+=1\\n        return l\\n\\nNote:- For me it is giving the following error:\\nIndexError: list index out of range\\n    if nums[i]==val:\\nLine 6 in removeElement (Solution.py)\\n    ret = Solution().removeElement(param_1, param_2)\\nLine 35 in _driver (Solution.py)\\n    _driver()\\nLine 47 in <module> (Solution.py)\\n\\nAccording to my understanding, this should be within range of index."
                    },
                    {
                        "username": "alejandrorm",
                        "content": "You are iterating between [0,n) but also removing elements from the list, so the list won\\'t actually have length n while you go through it"
                    },
                    {
                        "username": "utkarshsingh2012",
                        "content": "Do use the condition that the numbers beyond k (number of elements which are not equal to val) can be have any value and the proceed."
                    },
                    {
                        "username": "giannismel",
                        "content": "Confusing. Not clear description or test cases"
                    }
                ]
            },
            {
                "id": 1956128,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1955578,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1954230,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1951370,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1950656,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1950241,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1948121,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1946997,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1945944,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1941489,
                "content": [
                    {
                        "username": "CORVUS047",
                        "content": "case 1 and case 2 are wrong for js"
                    },
                    {
                        "username": "KevJ123",
                        "content": "Wait, so when they ask us to \"remove all occurrences of val\" they don\\'t really mean to \"remove\" them? Who even made this problem? This is very, VERY poorly worded. \\n\\nFrom the hint given: \"We don\\'t technically need to REMOVE that element per-say, right?\"\\n\\nFirst of all, it\\'s per-se, not \"per-say\". Secondly, the problem does NOT \"clearly ask us\" to modify the array in-place. \"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.\"\\n\\nDictionary definition of \"remove\":\\nverb.\\n1. take (something) away or off from the position occupied.\\n2. eliminate or get rid of.\\n\\nDictionary definition of \"modify\":\\nverb.\\n1. make partial or minor changes to (something), typically so as to improve it or to make it less extreme."
                    },
                    {
                        "username": "abhijeetkarmakar150",
                        "content": "If run my run code in Replit. I am getting the correct output but here is showing wrong output. I am not sure what\\'s wrong."
                    },
                    {
                        "username": "poorvi-vaish",
                        "content": " `[0,1,3,0,4,2]` is my output and the expected output is `[0,1,4,0,3]` and this is giving me wrong answer? Can anyone explain why?"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "AASAN Solution in PYTHON..!!!! \\nl = 0\\n        r = len(nums)-1\\n\\n        while l <= r:\\n            if nums[l] == val:\\n                del nums[l]\\n                l-=1\\n                r-=1\\n            l+=1\\n        return len(nums)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhowmicktanmoy999",
                        "content": "in the problem statement it is given that we can \" return the number of elements in nums which are not equal to val.\"\\nin my solution i have just counted no of non - target elements , so my solution is wrong . Can someone explain"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The problem asks to modify the input array in place to actually remove the target element, not just return the number of non target elements"
                    },
                    {
                        "username": "khalilkhedhri39",
                        "content": "i didnt understand it :/ \n// my try\n var removeElement = function(nums, val) {\n   while(nums.includes(val)){\n       nums.splice(nums.indexOf(val),1);\n   }\n   return nums.length;\n}; \ni didnt find other answer with less time complexity :/ i saw someone's solution but whene i turned it in my head it doesnt remove all the occurance of the val  , maybe iam idiot :/"
                    },
                    {
                        "username": "angelicawu",
                        "content": "For testcase nums=[2], val = 2, why [3] is not accepted as an answer?\\nIt seems that only empty list [] is accepted. \\nBut in this case, it should not care what the list is, but only check the first k=0 element in the list...\\nAm I understanding the question wrong...?"
                    },
                    {
                        "username": "vrishab",
                        "content": "Case 2 seems to be wierd: \\nmy code output: [\\n  0, 1,   4,   0,\\n  3, \\'_\\', \\'_\\', \\'_\\'\\n]\\n\\nexpected output: [0,1,4,0,3].\\nWhy did the test fail ?"
                    },
                    {
                        "username": "Jeffery_SLC",
                        "content": "The acceptance rate is around 50%. So, is that really easy level?\\n"
                    }
                ]
            },
            {
                "id": 1940891,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1940884,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1940830,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1937284,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1936399,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1935745,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1933546,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1932801,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1931734,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1927137,
                "content": [
                    {
                        "username": "a_sJoshi",
                        "content": "Dont worry about returning the array elements, just return the array size or no of elements in array.. the output expexted is tricky"
                    },
                    {
                        "username": "indraw705",
                        "content": "My output\\n3, [0, 1, 3, 0, 4] but expected answer is [0, 1, 4, 0, 3]\\n\\nwhy the order is changed ??"
                    },
                    {
                        "username": "javen09",
                        "content": "i test this in vsc and it gives the expected results but why does this not work in leetcode \\n\\n\\n\\nclass Solution:\\n    def removeElement(self, nums, val):\\n        integer_list = []\\n        underscore_list = []\\n        ans = []\\n        for i in nums:\\n            if i == val:\\n                underscore_list.append(\"_\")\\n            else:\\n                integer_list.append(i)\\n        \\n        my_list = integer_list + underscore_list\\n        print(my_list)\\n        \\n\\n        for j in my_list:\\n            if isinstance(j, (int,str)):\\n                if type(j) is int:\\n                    ans.append(j)\\n                else:\\n                    continue\\n\\n        k = len(ans)\\n        print(k)\\n        return k\\n\\n\\nsoln = Solution()\\nsoln.removeElement([1,7,3,4,5,3,3,2,2], 3)\\n\\n\\n"
                    },
                    {
                        "username": "SYED_HAMMAD",
                        "content": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int count=0,a=0;\n        a=nums.size();\n        for (int j =0;j<a;)\n        { \n            if(nums[j]== val)\n            {\n              nums.erase(nums.begin() + j);    \n             count++;\n              a--;\n            }\n          else{\n              j++;\n          }\n        }\n       return count;       \n    }\n};                                                                                                                                                                                                                                                                                                                                                            this code is showing error for [0,1,2,2,3,0,4,2] case my output is [0,1,3] but it should be [0,1,4,0,3]  can anyone explain what is wrong with this code ?"
                    },
                    {
                        "username": "Priyansh1909",
                        "content": "Question is Correct here! is the right Code\\n int removeElement(vector<int>& nums, int val) {\\n       int i=0;\\n       int j=0; \\n       while(j<nums.size())\\n        {  if(nums[j]!=val){\\n            swap(nums[i],nums[j]);\\n            i++;\\n           }\\n           j++;\\n        }    \\nint k=i-1;\\nint counter=0;\\nfor(int i=0;i<=k;i++){\\n  counter=counter+1;\\n}\\n   return counter;\\n"
                    },
                    {
                        "username": "voskrebentsev",
                        "content": "It\\'s really strange. \\nIn my local vscode I got this: \\n[0, 1, 4, 0, 3, \\'_\\', \\'_\\', \\'_\\']  \\nand leetcode test shows me this:\\n[0,1,4] as my output \\nI pretty sure test is incorrect. Is it problem with python only?"
                    },
                    {
                        "username": "Richa_Chanpuriya",
                        "content": "testcase output does not seems correct as the it does not count left values but expecting it into output?\\ncorrect output=[2]\\nexpected output leetcode=[2,2]"
                    },
                    {
                        "username": "darsh297",
                        "content": "class Solution {\\n    public int removeElement(int[] nums, int val) {\\n    int i=0;\\n    for(int j=0;j<nums.length;j++)\\n    {\\n        if(nums[j] != val)\\n        {\\n         nums[i]=nums[j];\\n        i++;\\n        }\\n       \\n    }    \\n    return i;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "maanyagarg",
                        "content": "I think there is some problem with this question, I tried to submit it for first time it didn\\'t work and showed Runtime Error, but then for the same solution it did."
                    },
                    {
                        "username": "Shi-Yueyang",
                        "content": "this problem sucks"
                    }
                ]
            },
            {
                "id": 1925160,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1920219,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1919178,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1914416,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1914321,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1911214,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1909197,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1908070,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1906530,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1903897,
                "content": [
                    {
                        "username": "yamunaanand2210",
                        "content": "According to the question , they said after the k elements whatever be the order of the elements, it doesn\\'t matter whatever is left behind. My answer is [0 , 1, 4, 0,3 ,0,4, 3]  and k=5 and it judges my answer to be wrong."
                    },
                    {
                        "username": "JuanSobalvarro",
                        "content": "This problem is just a lot of text to confuse you, remember, you only need to keep all numbers that are different of val at first and the array does not have to have in any place the val number, thats all you need to know.\\n"
                    },
                    {
                        "username": "moshrraf",
                        "content": "Gy\\'s How can I understand the Problem and solve the questions"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "const removeElement = (nums, val) => {\\n   let array = []\\n   for(i = 0; i < nums.length; i++){\\n       if(nums[i] != val){\\n           array.push(nums[i])\\n           array.sort()\\n       }\\n   }\\n   return array \\n\\n};\\n\\ncan somebody tell me why my output keeps returning empty but when I run it in VS Code it return the correct value"
                    },
                    {
                        "username": "EdwinCodes9",
                        "content": "Never mind I now understand that we weren\\'t suppose to create a new array "
                    },
                    {
                        "username": "91nunocosta",
                        "content": "The code presented in _Custom Judge_ section has an imprecision:\\n `for (int i = 0; i < actualLength; i++) {`\\n\\n`actualLength` isn\\'t defined. Also, the actual length of `nums` is greater than the number of elements to consider, _k_.\\n\\nShould the line be replaced by following?\\n `for (int i = 0; i < k; i++) {`"
                    },
                    {
                        "username": "245321733303",
                        "content": "can i get a brief explanation on this"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "So you should remove all elements in the list, wich euqals val and replace these with \"_\". In the end, you have to return the len of the list without \"_\" (For example: [8,9,1,\"_\",\"_\") len = 3) and the entire list. For example: \\nInput:\\nnums = [1,2,2,5,7,1,2]  val = 2 \\nOutput: \\n4, nums = [1,5,7,1,\"_\",\"_\",\"_\"]\\n"
                    },
                    {
                        "username": "shawnby222",
                        "content": "Don\\'t understand why this does not work. In javascript I just grab nums.length before modifying it with filter() to remove the val. After the filter I grab nums.length again and just subtract the before length with the after length to get k. It modifies the nums array correctly and returns k correctly why is it the \"wrong answer\"????\\n"
                    },
                    {
                        "username": "lightNight88",
                        "content": "I was having issues with it saying something like \"output: [2, 2, 3]    expected: [2, 2]\" but I realized that my return value was too large. Even though it doesn\\'t say it clearly, the return value must be correct for it to count your code as correct"
                    },
                    {
                        "username": "erikjm",
                        "content": "Why doesn\\'t this work? I\\'m totally stumped.\\n\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums = hi + bye\\n        return len(hi)"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code would work, but there is one  problem- it has to be \"nums[:]\". \\nThe corrected code is: \\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        hi = []\\n        bye = []\\n        for num in nums:\\n            if num != val:\\n                hi.append(num)\\n            else:\\n                bye.append(\"_\")\\n        nums[:] = hi + bye\\n        return len(hi)\\n"
                    },
                    {
                        "username": "Vikas_Chaudhary9966",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left=0;\\n        for(int right = 0;right<nums.size();right++)\\n        {\\n            if(nums[right]==val)\\n            continue;\\n            else\\n            nums[left++] = nums[right];\\n        }\\n        return left;\\n        \\n    }\\n};   Beats 100%"
                    }
                ]
            },
            {
                "id": 1899863,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1897091,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1896562,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1896021,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1895486,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1895433,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1891081,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1889949,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1889550,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1883690,
                "content": [
                    {
                        "username": "rayhanul17",
                        "content": "C#\n`nums = nums.Where( x => x != val).ToArray();\nreturn nums.Length;`\nThis code runs well in my PC & gives right answer. But wrong in leetcode. what is the issue?\nI had tried it instead of it\n`int c = 0;\n        for (int i = 0; i < nums.Length; i++)\n            if (nums[i] != val)\n                nums[c++] = nums[i];\nreturn c;`\n"
                    },
                    {
                        "username": "heyyyankit",
                        "content": "*don\\'t solve this*\\neven if code is correct, it gives wrong answer in some cases..\\nit also got more dislikes than likes"
                    },
                    {
                        "username": "NikGringo",
                        "content": "People! What\\'s wrong with this problem? \\nWhy this cod is not valid:\\nvar removeElement = function (nums, val) {\\n  return nums.filter(x => x !== val).length\\n};\\n\\nWHAAAAAAYYYYY !?!?!?!?!"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "I passed case 1, having trouble with 2nd and beyond. Please help.\\n\\n\\n int i=0,j=nums.length-1,k=0;\\n        while(i<=j){\\n            while(nums[i] !=val){\\n                i++;\\n                k++;\\n            }\\n            while(nums[j]==val){\\n                j--;\\n            }\\n            if(i<j){\\n                nums[i++] = nums[j--];\\n                k++;\\n            }else{\\n                return i-1;\\n            }\\n                \\n        }\\n        return i-1;\\n        //return k;\\n"
                    },
                    {
                        "username": "flarpon",
                        "content": "I tested my answer with an IDE and its output is exactly the same as the test cases\\' expected outputs, yet when I run my solution here it\\'s saying my output is wrong. Are some of the test cases wrong for this one?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could you please provide your complete code? "
                    },
                    {
                        "username": "rora24",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> List[int]:\\n        nums = list(filter(lambda x: x!= val, nums))\\n        k = len(nums)\\n        return k\\n\\nWhy is my solution not working?"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, there are some issues with your code. In the core, you understood the problem and you approach seems correct. However, make sure that your code is equivalent to this scheme: \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2, _ , _ ]\n\n--> you have to return the entire list, where every \"target value\" is replaced with \"_\" and \"_\" is at the end of the list and the len of the list without \"_\". Hope this helped. If there are any questions, feel free to ask me :)"
                    },
                    {
                        "username": "Danmw1211",
                        "content": "## The following code fails (Javascript) ?? \n\n `var removeElement = function(nums, val) {\n    while (nums.indexOf(val) !== -1) nums.splice(nums.indexOf(val), 1);\n    return nums\n};`\n\n## With input: [3,2,2,3] it returns output '[]' apparently, but when testing in VSCode the exact same function returns [2,2] (expected answer). Please could someone explain!?"
                    },
                    {
                        "username": "Virali_Thaker",
                        "content": "I tried this way but Leetcode is not accepting my answer\\nvar removeElement = function(nums, vl) {\\n    var test = nums.filter((num)=> num !== vl)\\n    return test\\n};\\nremoveElement([3,2,2,3],3);"
                    },
                    {
                        "username": "Laofeng",
                        "content": "Testcase 2 is evaluated wrong in c#\\n\\nmy array is filled as discribed in description.\\n\\nOutput\\n[0,1,3]\\nExpected\\n[0,1,4,0,3]\\n\\nIn reality its: \\n[0,1,3,0,4,0,4,2] (last 3 are irrelevant)"
                    },
                    {
                        "username": "Rangaraaja",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int start=0,end=nums.size()-1;\\n        int count=0;\\n        while(nums[end]==val){\\n            end--;\\n            count++;\\n        }\\n\\n        while(start<=end){\\n            if(nums[start]==val){\\n                count++;\\n                nums[start]=nums[end];\\n                nums[end]=val;\\n                end--;\\n            }\\n            start++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWhat is wrong with this code why iam getting wrong"
                    }
                ]
            },
            {
                "id": 1879738,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878307,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1869906,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1867507,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1858293,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1858253,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1857637,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1854656,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1851872,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1844666,
                "content": [
                    {
                        "username": "Asifa7",
                        "content": " for i in nums:\\n            if i==val:\\n                nums.remove(i)\\n\\nthis code is not running in case 2 can some one plz explain"
                    },
                    {
                        "username": "Ssekajja_Wavamuno_Isaac",
                        "content": "I just don\\'t know if its server issue but the logic is simply iterating through the array and check if the current position if NOT equal to val and then write that element to the current position. But i just don\\'t know why the test case of [3, 2, 2, 3] is a menace."
                    },
                    {
                        "username": "Irfan_7",
                        "content": "its a real tricky question but you should have a simple intution of  moving the elements ( which r equal to val ) , to the last of the array and simply get the track of yr 1st pointer & returns the number of times yr 1st pointer moved.\\nupvote me if it helped :>  "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i\\'m a dummo took 3hr\\'s to solve this one "
                    },
                    {
                        "username": "paulon_z",
                        "content": "Im not sure why is this wrong, please clarify your description as it is soo confusing. please make clear the requirements and output, and if you need some output arrangement to be follow please indicated thoroughly. \n ` \nclass Solution(object): \n\n    def moveNumber(self, nums, index):\n        if index <= len(nums)-1:\n            if nums[index] == None:                \n                return self.moveNumber(nums, (index+1))\n            dummy = nums[index]\n            nums[index] = None\n            return dummy \n        else:\n            return None        \n\n    def removeElement(self, nums, val):\n        deletedNums = 0\n        size = len(nums)\n        for i,v in enumerate(nums):            \n            if nums[i] == val:                \n                nums[i] = None\n                deletedNums += 1        \n        for i,v in enumerate(nums):             \n            if nums[i] == None:\n                nums[i] = self.moveNumber(nums, (i+1))        \n        return (deletedNums - size)\n\n`\n"
                    },
                    {
                        "username": "shersingchouhan44",
                        "content": "Input\\nnums =\\n[3,2]\\nval =\\n3\\nOutput\\n[3]\\nExpected\\n[2]\\nSo, I don.t understand this types of output \\n... why?"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\n# class Solution(object):\\n#     def removeElement(self, list, val):\\n#         count = 0\\n#         for i in list:\\n#             if i == val:\\n#                 count += 1\\n#         for j in range(count):\\n#             list.remove(val)\\n```\\n```\\nclass Solution(object):\\n    def removeElement(self, list, val):\\n        while val in list:\\n            list.remove(val)\\n```\\nHere is two solutions of this problem\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "vaviditdoshi",
                        "content": "My answer in JavaScript. Why is this not working?\\n\\nvar removeElement = function(nums, val) {\\n    var newNums = [];\\n    //Solution loop\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            continue;;\\n        }\\n        else {\\n            newNums.push(nums[i]);\\n        }\\n    }\\n    return newNums;\\n};"
                    },
                    {
                        "username": "NANDINI-SINGHAL",
                        "content": "i\\'m not getting the mistake in my code\\n#include<stdio.h>\\nint removeElement();\\n int main(){\\n     int nums[]={2,4,5,2},val=2;\\n      removeElement(nums,val);\\n      return 0;\\n }\\n\\n\\n\\n\\nint removeElement(int* nums, int numsSize, int val){\\n    int i,count=0;\\n    for(i=0;i<=numsSize-1;i++){\\n        if(nums[i]!=val){\\n         nums[count]=nums[i];\\n         count=count++;\\n\\n        }\\n        else{\\n            count=count++;\\n        }\\n    }\\n \\n}"
                    },
                    {
                        "username": "ankush920",
                        "content": "Intuition\\npick and replace\\n\\nApproach\\ntraverse every element and do action on target element\\n\\nComplexity\\nTime complexity:\\nO(N)\\n\\nSpace complexity:\\no(1)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i =0 ;\\n        int n = nums.size();\\n        int j= n-1;\\n       int count =0;\\n\\n\\nfor( int i = 0 ; i<n ;i++)\\n{ \\n  if(nums[i]==INT_MAX)\\n  {\\n     continue;\\n  }\\n  if( nums[i]==val)\\n  {\\n   \\n     count++;\\n     nums[i] =nums[j];\\n     nums[j]=INT_MAX;\\n     j--;\\n     i--;\\n  }\\n}\\n\\n     \\nreturn (n-count);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1841630,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1841546,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1841160,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1840560,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1840536,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1839864,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1839620,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1837864,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1835130,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1834836,
                "content": [
                    {
                        "username": "Yung_Shadi",
                        "content": "change your description, there is wrong information about what you need to return. To submit a decision you need to return length. WTF"
                    },
                    {
                        "username": "dnecklesportfolio",
                        "content": "This problem is verbose and there is so much upfront information. Maybe its my issue with reading word problems..The problem could be be even more direct, that even though you are removing the target number it\\'s okay if the final array still has the target number in it. Say that instead of \" It does not matter what you leave beyond the first k elements.\" It may be similar but one is tells the user what they could actually expect.\\n \\nAlso when I console log the final array it has more than what is in the output. Even though the test function is given, its so much details to keep track of in a rather simple question. It may be easier to display the entire result array in expected. I don\\'t know. This is just my opinion but they were so many times were I thought I had the wrong answer but no, I had to remember the 2 points made above."
                    },
                    {
                        "username": "rohantyagi6898",
                        "content": "not all the test cases are passing\\n/**\\n * @param {number[]} nums\\n * @param {number} val\\n * @return {number}\\n */\\nvar removeElement = function(nums, val) {\\n\\n    var cnt=0;\\n    var temp=0;\\n\\n    for (let i=0;i<nums.length-1;i++){\\n\\n        if(nums[i]!==val){\\n        \\n            nums[temp]=nums[i];\\n            temp++;\\n            cnt++\\n            \\n            \\n\\n        }\\n\\n    }\\n    return cnt;\\n}"
                    },
                    {
                        "username": "Almazino",
                        "content": "how to return 2 elements(;-;)?"
                    },
                    {
                        "username": "2003a54015",
                        "content": "int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                nums[i] = nums[j];\\n                i++;"
                    },
                    {
                        "username": "manohardaram2128",
                        "content": "isnt this correct ?\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        #include<iostream>\\nusing namespace std;\\n\\nint arr[4],k,arr1[4],sum=0;\\ncout<<\"enter the value of k\";\\ncin>>k;\\ncout<<\"enter the elements\";\\nfor(int i=0;i<4;i++){\\ncin>>arr[i];\\n}\\nfor(int i=0;i<4;i++){\\n    if(arr[i]!=k){\\narr1[sum]=arr[i];\\nsum++;\\n}\\n}\\ncout<<\"the value is \"<<sum<<endl;\\nfor(int i=0;i<sum;i++){\\n    cout<<arr1[i];\\n}\\n\\nreturn 0;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "By using this code, I can not pass the case 2.\nCan anyone help me plz?\nI have no idea. \nAll I want to know is just why it doesn't work.\n\n```python\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        [nums.remove(elem) if elem == val else None for elem in nums]\n        return len(nums)\n```"
                    },
                    {
                        "username": "wjleekr927",
                        "content": "I got it. Continuous elements are problem."
                    },
                    {
                        "username": "proalexv",
                        "content": "The question is here written wrong, what they want is an array without the said value while instead the question is asking for a single int with the number of values that remain... "
                    },
                    {
                        "username": "Ackbar90",
                        "content": "The question is not even clear"
                    },
                    {
                        "username": "user3515zv",
                        "content": "Output: 2, nums = [2,2,_,_]\\nWhy you guide us to output like this?\\nInnitially i code (in python3): return \\'{}, nums = {}\\'.format(len(nums), nums).\\nFor the one did not know: output only the number of elements left after remove \"val\"; which is len(nums)"
                    }
                ]
            },
            {
                "id": 1830715,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1826938,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1823804,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1820429,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810396,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809697,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806990,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806774,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1804414,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1799848,
                "content": [
                    {
                        "username": "ufve0704terry",
                        "content": "int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        for(int a=0;a<nums.size();a++){\\n            while(nums[a]==val&&a<nums.size()){\\n                count++;\\n                nums.erase(nums.begin()+a);\\n            }\\n        }\\n        return count;\\n    }\\n\\nCan someone tell me why the answer I have on the laptop and on the Leetcode are different?\\nMy program always get right on my laptop.\\n\\nnums =[0,1,2,2,3,0,4,2]\\nval =2\\nOutput:[0,1,3]\\nExpected:[0,1,4,0,3]\\n"
                    },
                    {
                        "username": "alejandrorm",
                        "content": "The reason is that you are returning \"count\", the number of elements removed, rather than the number of elements remaining after the removal of duplicates. Also note that this solution doesn\\'t satisfy the requirement of linear time complexity."
                    },
                    {
                        "username": "yewin",
                        "content": "does someone show correct return value? there are many problems like, \\nInput: nums = [3,2,2,3], val = 3\\nOutput: 2, nums = [2,2,_,_]\\n\\nExpected  [2,2]\\n\\nI try to return length of array or array like they said [2,2]. my answer is still wrong.\\n\\npls someone can advice if you get correct answer"
                    },
                    {
                        "username": "Alterra",
                        "content": "What the shit is this\\nWhen I run my code on VsCode it gives me the correct answer: [0, 1, 3, 0, 4]\\nBut on this page console: [0,1,3]"
                    },
                    {
                        "username": "Pallavite",
                        "content": "\\n        for(int i=0;i<nums.length-1;i++) {\\n            if(nums[i] == val) {\\n                for(int j=i;j<nums.length;j++)\\n                 {\\n                   nums[j] = nums[j+1];\\n\\n                 }\\n                 break;\\n            }\\n           }   for(int i =0;i<nums.length-1;i++)\\n        {\\n            System.out.println(nums[i]);\\n        }\\n    }\\nFrom this logic, I\\'m able to remove only 1 element. Pls someone help.\\n"
                    },
                    {
                        "username": "PERCY001",
                        "content": "class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        for(int i=0;i<=nums.size();i++)\\n        {\\n\\n            if(nums[i]==val)\\n            {  \\n               \\n                \\n                auto itr=nums.begin()+i;\\n                nums.erase(itr);\\n                 if(i>1)\\n                i=i-1;\\n          \\n\\n            }\\n           \\n        }\\n        return nums.size();\\n    }\\n};\\n\\n\\nits showing adress sanitizer as error why?"
                    },
                    {
                        "username": "Ashu07",
                        "content": "https://leetcode.com/problems/remove-element/submissions/902339232/"
                    },
                    {
                        "username": "ayush_mech",
                        "content": "I tried using arrayList but not working if value to be removed occurs simultaneously (like in second test case, 2 to be removed is coming twice). It removes only first occurence.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int k=0,j=0;\\n        ArrayList<Integer> a = new ArrayList<Integer>(); \\n        for(int i=0;i<nums.length;i++){\\n                 a.add(nums[i]);                       \\n            }\\n        \\n        for(int i=0;i<a.size();i++){\\n        if(a.get(i) == val){\\n                j+=1;\\n                a.remove(i);              \\n        }}\\n\\n        for(int i=0;i<a.size();i++){\\n                 nums[i] = a.get(i);                          \\n            }      \\n\\n        k = nums.length - j;\\n        return k;\\n    }\\n}"
                    },
                    {
                        "username": "Airatff102",
                        "content": "Why does not the code below  work? \\n\\n`nums = ([n for n in nums if n!=val])` "
                    },
                    {
                        "username": "thishi2003",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int: \\n        i = 0\\n        j = len(nums)-1\\n        while(i<len(nums)):\\n            if(nums[i] == val):\\n                for k in range(i, len(nums)-1):\\n                    nums[k] = nums[k+1]\\n                nums[j] = \"_\"\\n                j -= 1\\n            else:\\n                i += 1\\n        return nums[0:j+1]\\n\\nCan someone pls help me out finding wats wrong with this solution?"
                    },
                    {
                        "username": "alishachhabra1111",
                        "content": "Can anyone please tell me ,what\\'s the problem with this solution?\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        vector<int>ans;\\n        int j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=val){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        j=ans.size();\\n        return j;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793927,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1793317,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1793172,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1786696,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1783305,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1783163,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1782289,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1782107,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1782100,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1774048,
                "content": [
                    {
                        "username": "user3662q",
                        "content": "#Python3 Solution  @user3662q\\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        while(i<len(nums)):\\n            if(nums[i]==val):\\n                nums.remove(val)\\n            else:\\n                i+=1\\n        print(*nums)"
                    },
                    {
                        "username": "86joeyes",
                        "content": "    int removeElement(vector<int>& nums, int val) {\\n        int cnt = 0;\\n        sort(nums.begin(), nums.end());\\n        while (binary_search(nums.begin(), nums.end(), val)) {\\n            cnt++;\\n            auto it = lower_bound(nums.begin(), nums.end(), val); \\n            nums.erase(it);\\n        }\\n        return cnt;\\n    }\\n\\n100% correct function, but\\nnums =\\n[0,1,2,2,3,0,4,2]\\nval =\\n2\\nOutput\\n[0,0,1]\\nExpected\\n[0,1,4,0,3]"
                    },
                    {
                        "username": "pjr_2001",
                        "content": "very inaccurate info provided\\n"
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int p=nums.length;\n\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]='_';\n                p--;\n            }\n        }\n        Arrays.sort(nums);\n        return p;\n        \n    }\n}`"
                    },
                    {
                        "username": "sigurdblueface",
                        "content": "my code works perfectly fine in my local IDE, but fails completely here in leetcode, lol\\n"
                    },
                    {
                        "username": "Evil_123",
                        "content": "//100% beatable answer please like if you appriciated it\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size(),k,countr=0;\\n      for(int i=0;i<n;i++){\\n          if(nums[i]==val){\\n             countr++;\\n             nums[i]=52;\\n          }\\n      }\\n      sort(nums.begin(),nums.end());\\n      k=n-countr;\\n       return k;\\n    }\\n};"
                    },
                    {
                        "username": "aditya3492gupta",
                        "content": "declare a variable and initialize it with 0 example` count=0.`\niterate a loop from 0 till n-1.\nif the ith element is equal to val then skip the loop\nelse using `count` as index in-place the element in the array and increment `count` by one. \nat the end return` count`"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "First time i beated 100% runtime\\n```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            if(nums[i]==val){count++;nums[i] = 100;}\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums.size() - count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "first time ever \\ni beats 100% of solution in runtime  \\n=   =   =   =   = \\nclass Solution {    \\npublic:      \\n    int removeElement(vector<int>& nums, int val) {    \\n        int count = 0;     \\n        for (int i=0; i<nums.size() ; i++){    \\n            if(nums[i]==val){count++;nums[i] = 100;}    \\n        }    \\n        sort(nums.begin(),nums.end());    \\n        return nums.size() - count;    \\n    }    \\n};    \\n=    =    =    ="
                    },
                    {
                        "username": "abdumajidabdullatipov1",
                        "content": "    public int removeElement(int[] nums, int val) {\n        int countVal = 0;\n\n        for (int i = 0, count = 0; count < nums.length; i++, count++) {\n            if (nums[i] == val) {\n                move(i, nums, countVal);\n                countVal++;\n                i--;\n            }\n        }\n\n        return nums.length - countVal;\n    }\n\n    private void move(int index, int[] nums, int countVal) {\n        for (int i = index; i < nums.length - 1 - countVal; i++) {\n            nums[i] = nums[i + 1];\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1773640,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1773602,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1773063,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1770145,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1767458,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1766707,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1766515,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1764666,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1763472,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1761898,
                "content": [
                    {
                        "username": "dienazty",
                        "content": "A bit confused as the code that I wrote works in vscode with the same variables that the test cases supposedly use.  Can someone help me understand why this code isn't being accepted?\n\nIn JavaScript\n\n```\nvar removeElement = function(nums, val) {\n    console.log(nums.filter(x => x != val))\n}\n```\n\nIf I set `nums = [3,2,2,3]` and `val = 3` and run removeElement(nums, val), the output in vscode is [2,2] but result in leetcode shows [3,2,2,3]."
                    },
                    {
                        "username": "Front5105",
                        "content": "Your filter function creates a (shallow) copy of the nums array. You are supposed to use the same array and do your operations in-place.\\nnums.filter() returns a different/second array"
                    },
                    {
                        "username": "shamilrasheed131",
                        "content": "Simple Typescript Solution\\n\\n`const removeElement = (nums: number[], val: number): void => {\\n    const end = nums.length - 1;\\n\\n    for(let i = 0; i<=end; i++){\\n        let end = nums.length - 1;\\n        if(nums[i] === val){\\n            const temp = nums[i];\\n            nums[i] = nums[end];\\n            nums.pop()\\n            --end;\\n            --i;\\n        }\\n    }\\n};\\n`"
                    },
                    {
                        "username": "mask73",
                        "content": "is anyone stuck at testcase nums = [4,5] val = 5\\nthe expected output is [4]\\nbut my output is [ ].\\nmy code is running fine for most case, but why is it wrong for this case? i don\\'t know\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int j = n-1,i=0;\\n        while(i<=j ){\\n            while(  j>=0  && nums[i]==val ){\\n                swap(nums[i],nums[j--]);\\n            }\\n                i++;\\n        }\\n        return ++j;\\n    }\\n};\\n"
                    },
                    {
                        "username": "HimanshuRathore_7784",
                        "content": "Just try to do it from the end of the array it will work better"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "Very Easy || O(n) time complexity || Java \\n\\n==========code============\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n     int count =0; // intialise count =0;\\n     for(int i=0;i<nums.length;i++){   //moving to length of the nums\\n         if(nums[i] != val){    //checking if val is  not matching then will store value in count \\n             nums[count]=nums[i];  //value storing in count\\n             count++;   // \\n         }\\n     }\\n    return count;\\n\\n\\n    }\\n}\\n==========end============"
                    },
                    {
                        "username": "aar66",
                        "content": "I changed nums inplace and still got wrong solution...\\nprinting nums right before returning gives me the same answer as the expected one."
                    },
                    {
                        "username": "darpandaswani04",
                        "content": "here the code:  \\n`your inline code...\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n = nums.size();\\n        int i =0  , j = n-1;\\n        int count = 0 ;\\n        while(i<n && j>=i){\\n            if(nums[i] == val){\\n                nums[i] = nums[j];\\n                j--;\\n            }\\n            else{\\n                i++;\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};your inline code...`\\n\\nI am new here , so please help if you find anything to improve\\nopen to all suggestions."
                    },
                    {
                        "username": "dhanjitthakur0",
                        "content": "I have solved this question using Two Pointers Technique. \\n\\n1st Pointer  will point at starting index of array  and 2nd Pointer will be pointing to end/last index of array. \\n\\nLet say 1st pointer as  \"start\" and 2nd pointer as \"end\".\\na) If start is pointing the element is equal to the Val, then swap the start and end elements and then decrement the end.\\nb) If start is pointing the element is not equal to the Val, then just increment the start.\\nc) while condition for this iteration would be       while(start < end)\\n\\nAfter this iteration all the Val elements will be placed at the last and another elements are place in starting of the array.\\n\\nNow just iterate through the array element and count till you find the Val. If you find the Val then return count else keep incrementing the count.\\n\\nYou can refer my code from the below link\\n\\n[leetcode]\\n(https://leetcode.com/problems/remove-element/submissions/881048437/)\\n   "
                    },
                    {
                        "username": "akashmaurya78",
                        "content": "Python Solution \\n\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i=0\\n        j=len(nums)\\n        while(i<j) :\\n            if nums[i] == val :\\n                nums.pop(i)\\n                j=j-1\\n            else :\\n                i=i+1\\n        \\n        return j\\n"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "The second question I found with more number of dislikes as compared to likes."
                    }
                ]
            },
            {
                "id": 1761608,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1761101,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1760918,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1759281,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1758897,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1757707,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1755313,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1755106,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1754540,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1753514,
                "content": [
                    {
                        "username": "Sang-96",
                        "content": "I am confused with return type. plzz help me configure out what i have to return as output"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We have to return a number, which is the length of the array after removing all the values that were asked to remove. The trick is that while removing the values, we have to modify the original array that was provided as input, solution consists in both these things: returning a correct number and correctly modifying the input array so the corresponding values are correctly removed. I hope this helps, good luck!"
                    },
                    {
                        "username": "sany2k8dev",
                        "content": "Any reason it should not work in python?\n\n```\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        return [num for num in nums if num!=val ]\n```"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the input, not to create a new array. Also the return has to be a number, not array."
                    },
                    {
                        "username": "gersteni",
                        "content": "Is this problem broken for Racket? I wrote ...\\n\\n(define (remove-element nums val)\\n    (cond\\n      ((null? nums) \\'())\\n      ((eq? val (car nums)) (remove-element (cdr nums) val))\\n      (else (cons (car nums) (remove-element (cdr nums) val)))))\\n\\n... and this worked fine on my terminal, but gave a weird error when I ran it. "
                    },
                    {
                        "username": "FunctionallySane",
                        "content": "These kinds of problems forces you to mutate the passed value and I don\\'t even know if this should really go down on my portfolio, this is not a good practice, and I for one certainly don\\'t want that to be on display."
                    },
                    {
                        "username": "stepaniukoleksii",
                        "content": "In my solution the test case:\\nnums =[2]  val = 3 \\nfails like this:\\nOutput []\\nExpected [2]\\n\\nBut I do not modify array at all! Double checked it in my IDE with debugger and it shows that at the end of the function array has one element [2];\\n\\nIs anyone else have same issue? As I understand I cannot paste my solution here..."
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "..Kind of.\nIn Eclipse I get [2,2,3,3] -which is correct, but on LeetCode I get [2] which isn't.\nNo idea why.\nEdit: \nOK. It clearly only checks your modified array up to the index of of your return. That's why. t_t;:\nSo it will cut off your array at nums[output-1];"
                    },
                    {
                        "username": "hazemyaheadev",
                        "content": " I Get Confused because we only return the length of array , not the new array .. so how the leetcode compiler know the new array ? "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "We need to modify the original array that is provided as input. Compiler will use that array to run the tests. The number that we return as the result of the function is used to know for the compiler when to stop comparing expected array with the one that we modified in our solution."
                    },
                    {
                        "username": "_ayush_kushwaha_0512",
                        "content": "In this problem we have not think about to delete or about to swap element.\\nwe have to just put not target element on target element position without putting target any other place  and return the value or limit of the array.\\n\\n\\nint count=0;\\nfor(int i = 0 ; i < nums.length ; i++){\\n      if(nums[i]!=val){\\n            nums[count]=nums[i];\\n            count++;\\n      }\\n}\\n        return count;"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "can anyone explain this? what's wrong in my code?\n \n112/113 test cases passed.\n\nfailed test case:  \nnums =   [3,1,3,3,3], val= 3,  I got output as [1, 3]\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if len(set(nums))== 1 and val in nums:\n            return 0\n        for num in nums:    \n            if val in nums:\n                nums.remove(val)\n        return len(nums)"
                    },
                    {
                        "username": "tushargupta29430",
                        "content": "lass Solution(object):\\n    def removeElement(self, nums, val):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type val: int\\n        :rtype: int\\n        \"\"\"\\n        while(nums.count(val)>=1):\\n            nums.remove(val)\\n        print(len(nums))"
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 112/ 113 test cases passed.\\n \\nbut this test case is failed:  \\nnums =  [3,1,3,3,3]    val= 3 \\n\\nif len(set(nums))== 1 and val in nums:\\n            return 0\\n       \\nfor num in nums:\\n            \\n      if val in nums:\\n            nums.remove(val)\\nreturn len(nums)\\n\\n"
                    }
                ]
            },
            {
                "id": 1753382,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1752595,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1748701,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1745947,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1743699,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1742546,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1741533,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1739427,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1738491,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1738416,
                "content": [
                    {
                        "username": "AbishekNanjappa",
                        "content": "How do i improve it from O(n^2) to a better efficiency class?\nI used bubble sort logic and moved the value to be removed to the end of the array."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "deleted_user",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        k = 0\\n        for i in nums:\\n            if i != val:\\n                nums[k] = i\\n                k += 1\\n        return k"
                    },
                    {
                        "username": "kvkalyan1998",
                        "content": "[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "MMvKA",
                        "content": " `int cont = 0;\\n  for(int i = 0; i < nums.length; i++){\\n  if(nums[i] != val){\\n  nums[cont++] = nums[i];\\n  }\\n}\\n  I don\\'t understand why is cont++ and can\\'t be cont + 1. Someone can explain me that?"
                    },
                    {
                        "username": "CodeCanyon",
                        "content": "cont++ is the shorten form of count = count+1. You need to initialise new incremented value to count variable. "
                    },
                    {
                        "username": "belalmostafa1993",
                        "content": "nums.filter(item => item !== val)\\n this return empty array\\nbut in console in chrome return correct answer"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Because you need to mutate the original array that is provided as an input, not return a new one. And the return from the function should be a number (length of the \\'new\\' array without the requested value), is used as well in the tests. "
                    },
                    {
                        "username": "ranger45",
                        "content": "I returned the expected output which they asked it in the question and i wrote a two method which one of the method will return the expected output but  getting wrong case\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n         \\n\\t        int  k=nums.length-1,j=0;\\n\\t        int[] duplicate=new int[nums.length];\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t         if(val==nums[i]){\\n\\t               duplicate[k--]=nums[i];}\\n\\t         else{\\n\\t               duplicate[j++]=nums[i];}\\n\\t        }\\n\\t       return count(duplicate,val); \\n\\t    }\\n\\t  public  int count(int duplicate[],int val) {\\n\\t\\t  int count=0;\\n\\t    \\tfor(int i=0;i<duplicate.length;i++) {\\n\\t    \\t\\tif(val==duplicate[i])\\n\\t    \\t\\t\\tcontinue;\\n\\t    \\t\\tcount++;\\n\\t    \\t}\\n\\t    \\treturn count;\\n\\t    }\\n\\n\\n\\n    }\\n"
                    },
                    {
                        "username": "nooruzbay",
                        "content": "Hi Guys, I have got a problem, whenever I am trying to run the same code and solution for this task my local python3 shows different result than Leetcode python3 or 2? Why is it so?"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0ms || beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/remove-element/solutions/2987663/simple-java-0ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": " We will use two pointer approach.\n         One will point to 1st index.\n         Other will point to last index.\n         If start pointer points to target, then replace it with end pointer value.\nThen according update the pointers.\n\nFinally, return start+1."
                    }
                ]
            },
            {
                "id": 1736499,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1735378,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1734926,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1734200,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1732923,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1731579,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1729149,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1728785,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1726109,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1725037,
                "content": [
                    {
                        "username": "juiprht",
                        "content": "JAVA SOlution with O(N) time and O(1) space complexity.\n\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        int j=0;\n        while(i<nums.length){\n            if(nums[i]!=val){\n                nums[j]=nums[i];\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ EASY Solution \\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int count=0;\\n        int k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]!=val)\\n          {\\n              nums[k]=nums[i];\\n              k++;\\n          }\\n          else\\n          count++;\\n\\n        }\\n        return nums.size()-count;\\n    }\\n};"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "Are you supposed to modify the array you are given or can you return another array? Because whenever I try to return another array with the right elements in it, it gives the same output every single time."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@Ismmoh101](/Ismmoh101) you shouldn't create any new arrays, you are expected to iterate through and modify the array that was received as a parameter"
                    },
                    {
                        "username": "Ismmoh101",
                        "content": "This is my code:\\npublic int removeElement(int[] nums, int val) \\n    {\\n        int[] numbers = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int currNum = nums[i];\\n            if (currNum!=val)\\n            {\\n                numbers[count] = currNum;\\n                count++;\\n            }\\n        }\\n        return numbers.length;\\n    }"
                    },
                    {
                        "username": "ottomen",
                        "content": "Pretty obscure description without that doesn\\'t mention what should I return when no match happened at all. "
                    },
                    {
                        "username": "dev-ravikiran-rk",
                        "content": "Whats wrong with this code?\\n```class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        if(nums.size() == 0) return 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            while(nums[nums.size() - 1]== val)\\n                nums.erase((nums.end()-1));\\n            if(nums.size() == 0) return 0;\\n            if(nums[i] == val)\\n            swap(nums[i], nums[nums.size() - 1]); \\n        }\\n        return nums.size();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "matekopa",
                        "content": "public static int removeElement(int[] nums, int val) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        list = list.stream().filter(i->!i.equals(val)).collect(Collectors.toList());\\n        return list.size();\\n    }\\nthis code works perfectly on my computer but it doesn\\'t work on Leet code does anyone know why?"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "You have to modify the original array, the actual tests are using it to check if the elements were removed."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "can anybody throw light on what's wrong with my code?\n\n `       int count = 0;\n        for(auto it = nums.begin() ; it != nums.end(); it++){\n            if(*it == val)   nums.erase(it);\n            else count++;\n        }\n        return count;\n`"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/27_REMOVE_elements.cpp"
                    },
                    {
                        "username": "kevinttc93",
                        "content": "Hi there, can anyone help me take a look at why is my code returning illegalArgumentException? Thanks in advance!\n\n `class Solution {\n    public int removeElement(int[] nums, int val) {\n        int counter = 0;\n        int p = nums.length-1;\n        \n        for(int i =0; i < nums.length; i++){\n            if(nums[i] == val){\n                if(nums[p] == val){\n                    nums[i] = nums[p-1];\n                    nums[p-1] = val;\n                    counter++;\n                    p--;\n                }else{\n                    nums[i] = nums[p];\n                    nums[p] = val;\n                    p--;\n                    counter++;\n                }\n            }\n        }\n        return p - counter;\n    }\n}`"
                    },
                    {
                        "username": "bshowell",
                        "content": "Having trouble understanding why my C code doesn't work.\n\n`int removeElement(int* nums, int numsSize, int val)\n{`\n`    int i = 0;`\n`    while(i < numsSize)  // using while loop since numsSize is changing`\n`    {`\n`        if (nums[i] == val)  // if current number is equal to the value we're looking for`\n`        {`\n`            nums[i] = nums[numsSize - 1];  // set the current value at nums (the one we want to replace) equal to the last value in the array`\n`            numsSize--;  // decrement the size of the array, effectively deleting the last element we just moved`\n`        } else i++;  // if we don't have to get rid of a number, increment the counter as normal`\n`    }`\n`    return *nums;`\n`}`\n\nI am newish to using C in these types of scenarios, but for almost every test case, I'm getting an empty list returned. The things I'm not sure about is returning *nums, originally I was just returning nums but that was giving me weird errors. Would really appreciate some enlightenment on what I don't understand about C here. And sorry for the bad formatting. Thanks!"
                    }
                ]
            },
            {
                "id": 1723896,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722967,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1721766,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1720947,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1719131,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1718329,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709974,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709753,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1708413,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1704543,
                "content": [
                    {
                        "username": "xherdon",
                        "content": "What the heck is the problem with my code. It has to be correct this way:\n\n class Solution {\n    public int removeElement(int[] nums, int val) {\n        List<Integer> sortedList =  Arrays.stream(nums).boxed().collect(Collectors.toList());\n    \tsortedList.removeIf(Predicate.isEqual(val));\n    \tnums = sortedList.stream().mapToInt(Integer::intValue).toArray();\n\t\treturn sortedList.size();\n    }\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "Pinho1",
                        "content": "Could anybody help me? \n\nI can't understand why my code isn't working, when given the array [3,2,2,3] with val=3, it is returning the array [3,2], not [2,2], but testing in others compilers, it returns [2,2]\n\nPython:\nclass Solution(object):\n    def removeElement(self, nums, val):\n        nums = list(filter(lambda x : x != val,nums))\n        return len(nums)"
                    },
                    {
                        "username": "alekhyaakella",
                        "content": "Can someone please tell me whats wrong with my code?\\n\\nMy approach:\\n\\nIf we take array as [0,1,2,2,3,0,4,2], after iteratiion is completed the list I will get is [0, 1, 3, 0, 4]\\n\\nimport java.util.*;\\nclass Solution {\\npublic int removeElement(int[] nums, int val) {\\nList li = new ArrayList();\\nfor (int i = 0; i < nums.length; i++){\\nli.add(nums[i]);\\n}\\nIterator itr = li.iterator();\\nwhile(itr.hasNext()){\\nif(itr.next()==val){\\nitr.remove();\\n}\\n}\\nreturn li.size();\\n}\\n}"
                    },
                    {
                        "username": "msss",
                        "content": "You are creating a new array. That was not allowed. \"Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\"\\n"
                    },
                    {
                        "username": "arbaja",
                        "content": "My code produces the expected results in command prompt but will not accept here for some reason."
                    },
                    {
                        "username": "Rakesh2004",
                        "content": "i understand the whole concept and implementation but dont know in which step element deleted,someone please explain.\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int start=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[start]=nums[i];\\n                start++;   \\n            } \\n        }\\n        return start;\\n\\n    }\\n}"
                    },
                    {
                        "username": "amandafribo",
                        "content": "Does anyone know why i can make the output correct in my consol in VS, but it gives me an empty output in the console in here?\\nvar removeElement = function(nums, val) {\\n    const duplicant = [];\\n    \\n    //Looks for the duplicants\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === val) {\\n            duplicant.push(nums[i]);\\n            //If found rename to NaN\\n            nums[i] = NaN;\\n        } \\n    }\\n\\n    //Calculates the amount of dupes\\n    k = duplicant.length\\n    return nums\\n};"
                    },
                    {
                        "username": "Virus_23",
                        "content": "We will follow below steps \\u2014\\n\\nTake a variable count. This will count the number of elements except val.\\nScan the array left to right.\\nIf the current element is not equal to val, we will add that element to the place of count.\\nTime Complexity\\nSince there is a single scan of the array, the time complexity will be O(n).\\n\\nSpace Complexity\\nWe are not using any data structure for internal computations, hence the space complexity will be O(1)."
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Should not be categorized as easy question for sure.\\nBut once you get the concept right you can do that easily.\\nI have solved medium questions that were easier than this. \\n"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "I find that, depending on the weak spots of the engineer, easy problems may seem hard and some mediums may seem easy. It\\'s all relative and every problem that gets you stuck is revealing a weak spot in your game"
                    },
                    {
                        "username": "satyam_botadara",
                        "content": "simple java solution\\n\\n\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n\\n        int index=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=val)\\n            {\\n                nums[index]=nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "Sibajyoti2001",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int n=nums.size();\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(val==nums[i])\\n            {\\n                for(int k=i;k<n-1;k++)\\n                {\\n                    nums[k]=nums[k+1];\\n                }\\n                n=n-1;\\n               i=i-1;\\n            }\\n        }\\n        return n;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1703539,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1703457,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1703240,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1702610,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1700850,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1697611,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1695075,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1694608,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1686215,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1686157,
                "content": [
                    {
                        "username": "aarushiksk",
                        "content": "It\\'s weird, it says the return type of the answer should be integer but it\\'s giving me the expected output as an array. For the first test case it says the expected output is [2,2] but the return should be an integer."
                    },
                    {
                        "username": "msauer22",
                        "content": "Thats because you have to modify the array so that the first k values hold the solution.\\nHowever you return k."
                    },
                    {
                        "username": "spaceMatcha",
                        "content": "Is this problem asking for an array to be returned that does not contain `val` but also does not modify the array in place.  For instance, it does not allow you to use Javascript array methods like `splice`.  I use a separate IDE and can get the correct answer there, but here on LC I\\'ve tried several solutions and it does not recognize my result.\\n\\nThis seems to be an issue with this and several other problems on LC.  Is there something that I\\'m missing?"
                    },
                    {
                        "username": "msauer22",
                        "content": "You have to return an int k where k are the first k elements in the array that is provided.\nThis array has to be modified in place so that the first k elements do not contain the given val."
                    },
                    {
                        "username": "sheenlenny123",
                        "content": "C `your inline code...your inline code...`"
                    },
                    {
                        "username": "LucasKoc",
                        "content": "The wording is not very clear. I thought I had to return the count and a string of the form \\'nums=\\'+string(nums+[,_]*(n-count))."
                    },
                    {
                        "username": "Akash_Aryan",
                        "content": "easy peasy c++ solution `class Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int i=0,j=nums.size()-1,temp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==val)\\n            {\\n            temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            nums.pop_back();\\n            j=nums.size()-1;\\n            i--;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};`"
                    },
                    {
                        "username": "skaran007",
                        "content": "Solved in 2 pointer Approach:-\\n\\n`class Solution {\\n    public int removeElement(int[] arr, int val) {\\n     int size = arr.length;\\n     int start = 0, end = size -1;\\n\\n     while(start <= end) {\\n         if(arr[start] == val && arr[end] != val) {\\n             int temp = arr[start];\\n             arr[start] = arr[end];\\n             arr[end] = temp;\\n         }\\n\\n         if(arr[start] != val) {\\n             start++;\\n         }\\n         if(arr[end] == val) {\\n             end--;\\n         }\\n     }\\n     return start;\\n    }\\n}`"
                    },
                    {
                        "username": "Niteesh_Sai",
                        "content": "can any one tell why my code is not working for the second test case\\nfor i in range(len(nums)-1):\\n    if nums[i] == val:\\n        nums.pop(i)\\nreturn len(nums)"
                    },
                    {
                        "username": "bdedic",
                        "content": "range(x)\\xA0will generate numbers from 0 to x-1. range(10)\\xA0will generate numbers from 0 to 9 (10 numbers).\\nI guess your loop is not defined correctly. "
                    },
                    {
                        "username": "surajtiwari4970",
                        "content": "one thing I m not understanding ..Can anyone tell me whats the difference between them [2,2] and [2, 2]\\n"
                    },
                    {
                        "username": "Kcoder_01",
                        "content": " `your inline code...your inline code...`\\nMy Java Solution \\n`class Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i=0;\\n        int j=nums.length-1;\\n\\n        while(i<=j){\\n            while(nums[i]==val && i<=j){\\n                int temp=nums[i];\\n                nums[i]=nums[j];\\n                nums[j]=temp;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return j+1;\\n    }\\n}`"
                    },
                    {
                        "username": "naiveperson",
                        "content": "```\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int count = 0;\\n        while (left <= right) {\\n            if (nums[left] == val) {\\n                while (nums[right] == val && left <= right) {\\n                    right--;\\n                    count++;\\n                }\\n\\n                if (left <= right) {\\n                    //swap(nums[left], nums[right]);\\n                    int t = nums[left];\\n                    nums[left] = nums[right];\\n                    nums[right] = t; \\n                    right--;\\n                    count++;\\n                }\\n            }\\n\\n            left++;\\n        }\\n\\n        return nums.size() - count;\\n    }\\n};\\n```\\nCan anyone tell me what the problem is in this code?   "
                    }
                ]
            },
            {
                "id": 1685437,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1679980,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1679818,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1679326,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1671287,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1669672,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1650002,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1648669,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1646377,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            },
            {
                "id": 1640580,
                "content": [
                    {
                        "username": "Kamikotosss",
                        "content": "JS one:\\nlet removeElement = function(nums, val) {\\n    let slice = 0 ;\\n    let index = 0; \\n    for(let i =0 ; i < nums.length ; i++){\\n        if(nums[i] === val ){\\n            if(!!nums[i+1]) nums[i] = nums[i+1]\\n            index = i;\\n            slice++;\\n        }\\n    }\\n    nums.length = nums.length - slice;\\n    return nums\\n};\\nIt is strange because I got correct answer with the same code in VScode\\nInput\\nnums =\\n[3,2,2,3]\\nval =\\n3\\nOutput\\n[]\\nExpected\\n[2,2]"
                    },
                    {
                        "username": "arurahul16",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        count=0\\n        nums=[101 if num==val else num for num in nums]\\n        nums.sort()\\n        count=nums.count(101)\\n        count=len(nums)-count\\n        return count\\n\\nThis is not working i don\\'t know where I am going wrong .Please help me"
                    },
                    {
                        "username": "adaptive-alexander",
                        "content": "I\\'m new here, maybe I\\'m missing something.\\n\\nMy code is the exact same as the fastest solution, but I\\'m bechmarked quite a bit slower (0 vs 2 ms). Is there anything I can do to improve the benchmarking time, or is it kinda just how busy the server was at the minute?"
                    },
                    {
                        "username": "GouravKamboj",
                        "content": "Simple || C++ || Normal Approach || O(n)\\n\\n\\nclass Solution {\\npublic:\\n    int removeElement(vector<int>& nums, int val) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0; i<n; i++)\\n            {\\n                if(nums[i] != val)\\n                {\\n                    nums[c] = nums[i];\\n                    c++;\\n                }\\n            }\\n            return c;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-remove-element-problem-solution.html)"
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        for i in range(len(nums)):\\n            if val in nums:\\n                nums.remove(val)\\n        return len(nums)"
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "I am confused with return type. plzz  help me configure out what i have to return as output"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-element-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "hebeying0711",
                        "content": "Inspired by Partition from Quicksort, we could revise Partition to start from right side to solve this problem.    \\ndef removeElement(self, nums: List[int], val: int) -> int:\\n        j=len(nums)-1\\n        i=j+1\\n        while j>=0:\\n            if nums[j]==val:\\n                i -= 1\\n                nums[i],nums[j]=nums[j],nums[i]\\n            j-=1\\n            print(nums,i,j)\\n        return i"
                    },
                    {
                        "username": "Omar211",
                        "content": "what is wrong here??\n\n class Solution {\n    public int removeElement(int[] nums, int val) { \n        int result =0;\n        int j=0;\n      for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != val) {\n            nums[j] = nums[i];\n            j++;\n        }\n        else\n        result++;\n      }\n      return result;\n    }\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Ladder",
        "question_content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1764371,
                "title": "a-very-highly-detailed-explanation",
                "content": "\\n**So, all this problem is asking us to do, is find a shortest path from our start word to end word using only word inside our list.** Now any time you think, find the shortest sequence you should immediately think, alright i need to use some shortest path algorithm like `Breadth-First-Search`.\\n\\nLet\\'s take an example:-\\n```\\nstart = be\\nend = ko\\nwords = [\"ce\", \"mo\", \"ko\", \"me\", \"co\"]\\n```\\nSo, using this word list we have 4 different path\\'s that we can take to get from our start to end word.\\n* So, we can go from `\"be\" -- \"ce\" -- \"co\" -- \"ko\"`\\n\\nThere are other\\'s path as well to go from start word to end word, however we only consider the shortest path, the one that has least amount of word in the sequence and in that case that would be:\\n\\n![image](https://assets.leetcode.com/users/images/7d41268c-da5f-40ce-a11b-e16b7e27e875_1644630682.2860324.png)\\n\\nSo, in a typicall `Breadth-First-Search we utilize the queue` and it\\'s going to store each string that in our sequence & then we also going to have integer value called changes which will be eventually return from our function, which will keep track how many changes do we have in the sequence.\\n\\nSo, we intialize our **queue** that have starting word inside of it i.e. **\"be\",** then our **changes** variable is going to **start at 1**, this is because at minimum we going to have starting word in our minimum. And finally we have a **set** which will **keep track\\'s of node** that have been **visited**, in this case we just **keeping track of string** that we have already **added inside our queue**. \\n```\\nqueue = [\"be\"  ]\\nchanges = 1\\nset = [\"be\"  ]\\n```\\n\\nSo, to start of our bfs, we take \"be\" off from our queue & we can only change one character at a time. So, first we gonna check by changing the character **b**, if we can form another word inside our word list. \\n* So, we try **ae**, which is not in our word list. Then, **be** is already in our set, so we can\\'t use that. Now we try **ce** and we have that word inside our word list. With that means add **ce** in our queue.\\n\\n\\n* Then we check **de, fe** and so on............ until we get to **me** which is inside our word list, so we add **me** inside our word list as well.\\n* So, all that way we check all the way down to **ze** and there is no other words that we add by changing **b** to another character.\\n\\n![image](https://assets.leetcode.com/users/images/6d8dd6e4-aaee-4d89-a97c-2b90cba4ce9d_1644631773.493334.png)\\n\\nSo, now we need to check first index. So, by changing the character **e** from **be** to something else if we form an another word.\\n* So, we gonna check **ba, bb** all the way down to **bz**. However none of the word inside our word list.\\n* Adittionaly, thw word **ce & me** are going to get added inside our set. To show, that we have already visited those words.\\n\\n![image](https://assets.leetcode.com/users/images/0b6666c7-1a53-43de-aecb-9dc831096fd8_1644633217.5717092.png)\\n\\n\\nAnd then we gonna perform same logic as before. We **poll from our queue** we take **ce** off from our queue. And we check if by changing any character we can form another word.\\n* So, we gonna see if we change first character **c** to another character to form a word. So, we gonna try **ae** **, be, ce** which is already in our set doesn\\'t count **de, ee** all the ay down to **ze** and none of the word included inside our word list.\\n\\n![image](https://assets.leetcode.com/users/images/e580b3e4-5ebd-46e7-b546-f63e46749ed1_1644633248.873971.png)\\n\\n\\nNow we gonna see if we change **e** from **ce** to another character. \\n* So, we gonna try **ca, cb** and so on..... eventually we get to the word **co** which is in our word list. So what that means we gonna add **co** to our queue & our set. \\n\\n![image](https://assets.leetcode.com/users/images/10697e6c-f2a9-4631-bb8f-271a0d4ca139_1644633282.432196.png)\\n\\n\\nThen we gonna **pull from our queue** again, in this case it would be **me**\\n* Now from **me** we can go to **mo** by changing **e** from **me** to **o** from **mo**. So, we gonna add **mo** to our queue and our set.\\n\\n![image](https://assets.leetcode.com/users/images/ad0a8570-27f4-4e75-8ac9-dd6d5f16c8ba_1644633419.043082.png)\\n\\n```\\nAnother, thing i forgot to mention is our changes variable is being updated on every iteration.\\nSo, we have gone from be -> ce -> co which is a total of 3 changes.\\n```\\n\\nSo, we gonna pull from our queue again **co**, now we can go from **co** to **ko** by changing **c** to **k**. So, what that mean\\'s we need to add **ko** inside our queue and our set. And we increase our **changes** variable by **1**\\n\\n![image](https://assets.leetcode.com/users/images/930fbdd7-774e-4384-93da-be75ee4b31be_1644633808.140633.png)\\n\\nNow we pull from our queue again, which would be **mo**. We can get from **mo -> ko** by changing **m** to **k**. However, **ko** is already in our set. So, that mean\\'s we gonna pull from our queue again which in this case would be **ko**.\\n\\n```\\nqueue = [  ]\\nchanges = 4\\nset = [\"be\", \"ce\", \"me\", \"co\", \"mo\", \"ko\"  ]\\n```\\n\\nAnd that is our **end word.** Once, we find our **end word** we poll from our queue and that is equal end word then we know we have found our shortest path sequence, so we just **return 4** from this function.\\n\\n*I hope now you have crystal clear, understand the approach.* **Let\\'s code it :**\\n\\n```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> set = new HashSet<>(wordList);\\n        if(!set.contains(endWord)) return 0;\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(beginWord);\\n        \\n        Set<String> visited = new HashSet<>();\\n        queue.add(beginWord);\\n        \\n        int changes = 1;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                String word = queue.poll();\\n                if(word.equals(endWord)) return changes;\\n                \\n                for(int j = 0; j < word.length(); j++){\\n                    for(int k = \\'a\\'; k <= \\'z\\'; k++){\\n                        char arr[] = word.toCharArray();\\n                        arr[j] = (char) k;\\n                        \\n                        String str = new String(arr);\\n                        if(set.contains(str) && !visited.contains(str)){\\n                            queue.add(str);\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n            }\\n            ++changes;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(M^2 * N), where M is size of dequeued word & N is size of our word list\\n\\n* **Space Complexity :-** BigO(M * N) where M is no. of character that we had in our string & N is the size of our wordList.",
                "solutionTags": [],
                "code": "```\\nstart = be\\nend = ko\\nwords = [\"ce\", \"mo\", \"ko\", \"me\", \"co\"]\\n```\n```\\nqueue = [\"be\"  ]\\nchanges = 1\\nset = [\"be\"  ]\\n```\n```\\nAnother, thing i forgot to mention is our changes variable is being updated on every iteration.\\nSo, we have gone from be -> ce -> co which is a total of 3 changes.\\n```\n```\\nqueue = [  ]\\nchanges = 4\\nset = [\"be\", \"ce\", \"me\", \"co\", \"mo\", \"ko\"  ]\\n```\n```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> set = new HashSet<>(wordList);\\n        if(!set.contains(endWord)) return 0;\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(beginWord);\\n        \\n        Set<String> visited = new HashSet<>();\\n        queue.add(beginWord);\\n        \\n        int changes = 1;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                String word = queue.poll();\\n                if(word.equals(endWord)) return changes;\\n                \\n                for(int j = 0; j < word.length(); j++){\\n                    for(int k = \\'a\\'; k <= \\'z\\'; k++){\\n                        char arr[] = word.toCharArray();\\n                        arr[j] = (char) k;\\n                        \\n                        String str = new String(arr);\\n                        if(set.contains(str) && !visited.contains(str)){\\n                            queue.add(str);\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n            }\\n            ++changes;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40707,
                "title": "c-bfs",
                "content": "This problem has a nice BFS structure. Let\\'s illustrate this using the example in the problem statement.\\n\\n```\\nbeginWord = \"hit\",\\nendWord = \"cog\",\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n```\\n\\nSince only one letter can be changed at a time, if we start from `\"hit\"`, we can only change to those words which have exactly one letter different from it (in this case, `\"hot\"`). Putting in graph-theoretic terms, `\"hot\"` is a neighbor of `\"hit\"`. The idea is simpy to start from the `beginWord`, then visit its neighbors, then the non-visited neighbors of its neighbors until we arrive at the `endWord`. This is a typical BFS structure.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> dict(wordList.begin(), wordList.end());\\n        queue<string> todo;\\n        todo.push(beginWord);\\n        int ladder = 1;\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                string word = todo.front();\\n                todo.pop();\\n                if (word == endWord) {\\n                    return ladder;\\n                }\\n                dict.erase(word);\\n                for (int j = 0; j < word.size(); j++) {\\n                    char c = word[j];\\n                    for (int k = 0; k < 26; k++) {\\n                        word[j] = \\'a\\' + k;\\n                        if (dict.find(word) != dict.end()) {\\n                            todo.push(word);\\n                        }\\n                     }\\n                    word[j] = c;\\n                }\\n            }\\n            ladder++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nThe above code starts from a single end `beginWord`. We may also start from the `endWord` simultaneously. Once we meet the same word, we are done. [This link](https://leetcode.com/problems/word-ladder/discuss/40708/Share-my-two-end-BFS-in-C%2B%2B-80ms.) provides such a two-end search solution. I rewrite the code below for better readability. This solution uses two pointers `phead` and `ptail` to switch to the smaller set at each step to save time.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> dict(wordList.begin(), wordList.end()), head, tail, *phead, *ptail;\\n        if (dict.find(endWord) == dict.end()) {\\n            return 0;\\n        }\\n        head.insert(beginWord);\\n        tail.insert(endWord);\\n        int ladder = 2;\\n        while (!head.empty() && !tail.empty()) {\\n            if (head.size() < tail.size()) {\\n                phead = &head;\\n                ptail = &tail;\\n            } else {\\n                phead = &tail;\\n                ptail = &head;\\n            }\\n            unordered_set<string> temp;\\n            for (auto it = phead -> begin(); it != phead -> end(); it++) {    \\n                string word = *it;\\n                for (int i = 0; i < word.size(); i++) {\\n                    char t = word[i];\\n                    for (int j = 0; j < 26; j++) {\\n                        word[i] = \\'a\\' + j;\\n                        if (ptail -> find(word) != ptail -> end()) {\\n                            return ladder;\\n                        }\\n                        if (dict.find(word) != dict.end()) {\\n                            temp.insert(word);\\n                            dict.erase(word);\\n                        }\\n                    }\\n                    word[i] = t;\\n                }\\n            }\\n            ladder++;\\n            phead -> swap(temp);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nbeginWord = \"hit\",\\nendWord = \"cog\",\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> dict(wordList.begin(), wordList.end());\\n        queue<string> todo;\\n        todo.push(beginWord);\\n        int ladder = 1;\\n        while (!todo.empty()) {\\n            int n = todo.size();\\n            for (int i = 0; i < n; i++) {\\n                string word = todo.front();\\n                todo.pop();\\n                if (word == endWord) {\\n                    return ladder;\\n                }\\n                dict.erase(word);\\n                for (int j = 0; j < word.size(); j++) {\\n                    char c = word[j];\\n                    for (int k = 0; k < 26; k++) {\\n                        word[j] = \\'a\\' + k;\\n                        if (dict.find(word) != dict.end()) {\\n                            todo.push(word);\\n                        }\\n                     }\\n                    word[j] = c;\\n                }\\n            }\\n            ladder++;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> dict(wordList.begin(), wordList.end()), head, tail, *phead, *ptail;\\n        if (dict.find(endWord) == dict.end()) {\\n            return 0;\\n        }\\n        head.insert(beginWord);\\n        tail.insert(endWord);\\n        int ladder = 2;\\n        while (!head.empty() && !tail.empty()) {\\n            if (head.size() < tail.size()) {\\n                phead = &head;\\n                ptail = &tail;\\n            } else {\\n                phead = &tail;\\n                ptail = &head;\\n            }\\n            unordered_set<string> temp;\\n            for (auto it = phead -> begin(); it != phead -> end(); it++) {    \\n                string word = *it;\\n                for (int i = 0; i < word.size(); i++) {\\n                    char t = word[i];\\n                    for (int j = 0; j < 26; j++) {\\n                        word[i] = \\'a\\' + j;\\n                        if (ptail -> find(word) != ptail -> end()) {\\n                            return ladder;\\n                        }\\n                        if (dict.find(word) != dict.end()) {\\n                            temp.insert(word);\\n                            dict.erase(word);\\n                        }\\n                    }\\n                    word[i] = t;\\n                }\\n            }\\n            ladder++;\\n            phead -> swap(temp);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40729,
                "title": "compact-python-solution",
                "content": "    class Solution(object):\\n        def ladderLength(self, beginWord, endWord, wordList):\\n            wordList.add(endWord)\\n            queue = collections.deque([[beginWord, 1]])\\n            while queue:\\n                word, length = queue.popleft()\\n                if word == endWord:\\n                    return length\\n                for i in range(len(word)):\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        next_word = word[:i] + c + word[i+1:]\\n                        if next_word in wordList:\\n                            wordList.remove(next_word)\\n                            queue.append([next_word, length + 1])\\n            return 0\\n\\n(2018/04/29) Since the problem description and argument is changed, I update the solution:\\n```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)\\n        queue = collections.deque([[beginWord, 1]])\\n        while queue:\\n            word, length = queue.popleft()\\n            if word == endWord:\\n                return length\\n            for i in range(len(word)):\\n                for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                    next_word = word[:i] + c + word[i+1:]\\n                    if next_word in wordList:\\n                        wordList.remove(next_word)\\n                        queue.append([next_word, length + 1])\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)\\n        queue = collections.deque([[beginWord, 1]])\\n        while queue:\\n            word, length = queue.popleft()\\n            if word == endWord:\\n                return length\\n            for i in range(len(word)):\\n                for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                    next_word = word[:i] + c + word[i+1:]\\n                    if next_word in wordList:\\n                        wordList.remove(next_word)\\n                        queue.append([next_word, length + 1])\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40711,
                "title": "two-end-bfs-in-java-31ms",
                "content": "Modified from **[Share my two-end BFS in C++ 80ms.][1]** \\n\\n    public class Solution {\\n\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n\\t\\tSet<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();\\n\\n\\t\\tint len = 1;\\n\\t\\tint strLen = beginWord.length();\\n\\t\\tHashSet<String> visited = new HashSet<String>();\\n\\t\\t\\n\\t\\tbeginSet.add(beginWord);\\n\\t\\tendSet.add(endWord);\\n\\t\\twhile (!beginSet.isEmpty() && !endSet.isEmpty()) {\\n\\t\\t\\tif (beginSet.size() > endSet.size()) {\\n\\t\\t\\t\\tSet<String> set = beginSet;\\n\\t\\t\\t\\tbeginSet = endSet;\\n\\t\\t\\t\\tendSet = set;\\n\\t\\t\\t}\\n\\n\\t\\t\\tSet<String> temp = new HashSet<String>();\\n\\t\\t\\tfor (String word : beginSet) {\\n\\t\\t\\t\\tchar[] chs = word.toCharArray();\\n\\n\\t\\t\\t\\tfor (int i = 0; i < chs.length; i++) {\\n\\t\\t\\t\\t\\tfor (char c = 'a'; c <= 'z'; c++) {\\n\\t\\t\\t\\t\\t\\tchar old = chs[i];\\n\\t\\t\\t\\t\\t\\tchs[i] = c;\\n\\t\\t\\t\\t\\t\\tString target = String.valueOf(chs);\\n\\n\\t\\t\\t\\t\\t\\tif (endSet.contains(target)) {\\n\\t\\t\\t\\t\\t\\t\\treturn len + 1;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif (!visited.contains(target) && wordList.contains(target)) {\\n\\t\\t\\t\\t\\t\\t\\ttemp.add(target);\\n\\t\\t\\t\\t\\t\\t\\tvisited.add(target);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tchs[i] = old;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tbeginSet = temp;\\n\\t\\t\\tlen++;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn 0;\\n\\t}\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/28573/share-my-two-end-bfs-in-c-80ms",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n\\t\\tSet<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();\\n\\n\\t\\tint len = 1;\\n\\t\\tint strLen = beginWord.length();\\n\\t\\tHashSet<String> visited = new HashSet<String>();\\n\\t\\t\\n\\t\\tbeginSet.add(beginWord);\\n\\t\\tendSet.add(endWord);\\n\\t\\twhile (!beginSet.isEmpty() && !endSet.isEmpty()) {\\n\\t\\t\\tif (beginSet.size() > endSet.size()) {\\n\\t\\t\\t\\tSet<String> set = beginSet;\\n\\t\\t\\t\\tbeginSet = endSet;\\n\\t\\t\\t\\tendSet = set;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 40723,
                "title": "simple-to-understand-python-solution-using-list-preprocessing-and-bfs-beats-95",
                "content": "    from collections import deque\\n    \\n    \\n    class Solution(object):\\n        def ladderLength(self, beginWord, endWord, wordList):\\n            \\n            def construct_dict(word_list):\\n                d = {}\\n                for word in word_list:\\n                    for i in range(len(word)):\\n                        s = word[:i] + \"_\" + word[i+1:]\\n                        d[s] = d.get(s, []) + [word]\\n                return d\\n                \\n            def bfs_words(begin, end, dict_words):\\n                queue, visited = deque([(begin, 1)]), set()\\n                while queue:\\n                    word, steps = queue.popleft()\\n                    if word not in visited:\\n                        visited.add(word)\\n                        if word == end:\\n                            return steps\\n                        for i in range(len(word)):\\n                            s = word[:i] + \"_\" + word[i+1:]\\n                            neigh_words = dict_words.get(s, [])\\n                            for neigh in neigh_words:\\n                                if neigh not in visited:\\n                                    queue.append((neigh, steps + 1))\\n                return 0\\n            \\n            d = construct_dict(wordList | set([beginWord, endWord]))\\n            return bfs_words(beginWord, endWord, d)",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution(object):\\n        def ladderLength(self, beginWord, endWord, wordList):\\n            \\n            def construct_dict(word_list):\\n                d = {}",
                "codeTag": "Java"
            },
            {
                "id": 40704,
                "title": "java-solution-using-bfs-with-explanation",
                "content": "```\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordDict) {\\n        Set<String> reached = new HashSet<String>();\\n        reached.add(beginWord);\\n        wordDict.add(endWord);\\n        int distance = 1;\\n        while (!reached.contains(endWord)) {\\n            Set<String> toAdd = new HashSet<String>();\\n            for (String each : reached) {\\n                for (int i = 0; i < each.length(); i++) {\\n                    char[] chars = each.toCharArray();\\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\\n                        chars[i] = ch;\\n                        String word = new String(chars);\\n                        if (wordDict.contains(word)) {\\n                            toAdd.add(word);\\n                            wordDict.remove(word);\\n                        }\\n                    }\\n                }\\n            }\\n            distance++;\\n            if (toAdd.size() == 0) return 0;\\n            reached = toAdd;\\n        }\\n        return distance;\\n    }\\n```\\n\\n**Basically I keep two sets of words, one set reached that represents the borders that have been reached with \"distance\" steps; another set wordDict that has not been reached. In the while loop, for each word in the reached set, I give all variations and check if it matches anything from wordDict, if it has a match, I add that word into toAdd set, which will be my \"reached\" set in the next loop, and remove the word from wordDict because I already reached it in this step. And at the end of while loop, I check the size of toAdd, which means that if I can't reach any new String from wordDict, I won't be able to reach the endWord, then just return 0. Finally if the endWord is in reached set, I return the current steps \"distance\".**\\n\\n**The idea is that reached always contain only the ones we just reached in the last step, and wordDict always contain the ones that haven't been reached. This is pretty much what Dijkstra's algorithm does, or you can see this as some variation of BFS.**\\n\\n\\nps: I get TLE at the first two submissions, because when I check if wordDict has any matches with reached set, I use two for loops and determine if any pair of words differ by one. That's a huge slow-down because it'll takes m (size of reached) * n (size of wordDict) * l (length of words) time, while in this solution, it takes 26 * l * m time. So when n is huge, this solution will be (n/26) times faster.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordDict) {\\n        Set<String> reached = new HashSet<String>();\\n        reached.add(beginWord);\\n        wordDict.add(endWord);\\n        int distance = 1;\\n        while (!reached.contains(endWord)) {\\n            Set<String> toAdd = new HashSet<String>();\\n            for (String each : reached) {\\n                for (int i = 0; i < each.length(); i++) {\\n                    char[] chars = each.toCharArray();\\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\\n                        chars[i] = ch;\\n                        String word = new String(chars);\\n                        if (wordDict.contains(word)) {\\n                            toAdd.add(word);\\n                            wordDict.remove(word);\\n                        }\\n                    }\\n                }\\n            }\\n            distance++;\\n            if (toAdd.size() == 0) return 0;\\n            reached = toAdd;\\n        }\\n        return distance;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346920,
                "title": "python3-breadth-first-search",
                "content": "```\\nInput:\\nbeginWord = \"hit\",\\nendWord = \"cog\",\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\nOutput: 5\\n```\\n1. Only one letter can be changed at a time.\\nIn the example, from begin word, you can change one letter in 3 ways. 3 is the length of the word.\\n```\\n\\t\\t\\t\\t hit\\n\\t\\t   /      |      \\\\\\n\\t\\t   *it   h*t   hi*\\n\\t\\t /|\\\\     /|\\\\     /|\\\\ \\n# In order to continue the  Breath First Search(BFS) process,\\n# we need to know the children of *it, h*t, and hi*.\\n# so we need the information from word list.\\n```\\n2. Each transformed word must exist in the word list.\\n\\tIn the example, we need to record all the possible changes that could be made from the word list so that we can have the information to do BFS in the graph above. We use a map to store the data. The key is one-letter-change-word, for example,\" *it,\" the value is the word meet the key\\'s condition in the word list.\\n```\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\nchange_map ={ *ot : hot, dot, lot\\n\\t\\t\\th*t : hot\\n\\t\\t\\tho* :hot\\n\\t\\t\\td*t : dot\\n\\t\\t\\tdo* : dot, dog\\n\\t\\t\\t*og : dog, log, cog\\n\\t\\t\\td*g : dog\\n\\t\\t\\tl*t : lot\\n\\t\\t\\tlo* : lot, log\\n\\t\\t\\tl*g : log\\n\\t\\t\\tc*g: cog\\n\\t\\t\\tco* : cog \\n\\t\\t\\t}\\n```\\n\\nWith the information in change_map, we got the information to expand the breadth first search tree.\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t hit, level = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t /            |              \\\\\\n\\t\\t\\t\\t\\t     *it                h*t                  hi*\\n\\t\\t\\t\\t\\t\\t   |                 |                     |     \\n\\t\\t\\t             null  \\t       hot ,level = 2      null\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t /   |   \\\\    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/    |     \\\\\\n\\t\\t\\t\\t               *ot           h*t      ho*\\n\\t\\t\\t\\t           /    |   \\\\         |        |\\n                     hot,2   dot,3  lot,3   hot,2    hot,2\\t\\t\\t\\t\\t\\n\\n\\n# as we can see,  \"hot\" has been visited in level 2, but \"hot\" will still appear at the next level. \\n# To avoid duplicate calculation, \\n# we keep a visited map,  \\n# if the word in the visited map, we skip the word, i.e. don\\'t append the word into the queue.\\n# if the word not in the visited map, we put the word into the map, and append the word into the queue.\\n```\\n```\\nfrom collections import defaultdict\\nfrom collections import deque\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: int\\n        \"\"\"\\n        if endWord not in wordList or not endWord or not beginWord or not wordList:\\n            return 0\\n        L = len(beginWord)\\n        all_combo_dict = defaultdict(list)\\n        for word in wordList:\\n            for i in range(L):\\n                all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word) \\n        queue = deque([(beginWord, 1)])\\n        visited = set()\\n        visited.add(beginWord)\\n        while queue:\\n            current_word, level = queue.popleft()\\n            for i in range(L):\\n                intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\\n                for word in all_combo_dict[intermediate_word]:\\n                    if word == endWord:\\n                        return level + 1\\n                    if word not in visited:\\n                        visited.add(word)\\n                        queue.append((word, level + 1))\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nInput:\\nbeginWord = \"hit\",\\nendWord = \"cog\",\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\nOutput: 5\\n```\n```\\n\\t\\t\\t\\t hit\\n\\t\\t   /      |      \\\\\\n\\t\\t   *it   h*t   hi*\\n\\t\\t /|\\\\     /|\\\\     /|\\\\ \\n# In order to continue the  Breath First Search(BFS) process,\\n# we need to know the children of *it, h*t, and hi*.\\n# so we need the information from word list.\\n```\n```\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\nchange_map ={ *ot : hot, dot, lot\\n\\t\\t\\th*t : hot\\n\\t\\t\\tho* :hot\\n\\t\\t\\td*t : dot\\n\\t\\t\\tdo* : dot, dog\\n\\t\\t\\t*og : dog, log, cog\\n\\t\\t\\td*g : dog\\n\\t\\t\\tl*t : lot\\n\\t\\t\\tlo* : lot, log\\n\\t\\t\\tl*g : log\\n\\t\\t\\tc*g: cog\\n\\t\\t\\tco* : cog \\n\\t\\t\\t}\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t hit, level = 1\\n\\t\\t\\t\\t\\t\\t\\t\\t /            |              \\\\\\n\\t\\t\\t\\t\\t     *it                h*t                  hi*\\n\\t\\t\\t\\t\\t\\t   |                 |                     |     \\n\\t\\t\\t             null  \\t       hot ,level = 2      null\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t /   |   \\\\    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/    |     \\\\\\n\\t\\t\\t\\t               *ot           h*t      ho*\\n\\t\\t\\t\\t           /    |   \\\\         |        |\\n                     hot,2   dot,3  lot,3   hot,2    hot,2\\t\\t\\t\\t\\t\\n\\n\\n# as we can see,  \"hot\" has been visited in level 2, but \"hot\" will still appear at the next level. \\n# To avoid duplicate calculation, \\n# we keep a visited map,  \\n# if the word in the visited map, we skip the word, i.e. don\\'t append the word into the queue.\\n# if the word not in the visited map, we put the word into the map, and append the word into the queue.\\n```\n```\\nfrom collections import defaultdict\\nfrom collections import deque\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: int\\n        \"\"\"\\n        if endWord not in wordList or not endWord or not beginWord or not wordList:\\n            return 0\\n        L = len(beginWord)\\n        all_combo_dict = defaultdict(list)\\n        for word in wordList:\\n            for i in range(L):\\n                all_combo_dict[word[:i] + \"*\" + word[i+1:]].append(word) \\n        queue = deque([(beginWord, 1)])\\n        visited = set()\\n        visited.add(beginWord)\\n        while queue:\\n            current_word, level = queue.popleft()\\n            for i in range(L):\\n                intermediate_word = current_word[:i] + \"*\" + current_word[i+1:]\\n                for word in all_combo_dict[intermediate_word]:\\n                    if word == endWord:\\n                        return level + 1\\n                    if word not in visited:\\n                        visited.add(word)\\n                        queue.append((word, level + 1))\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40717,
                "title": "another-accepted-java-solution-bfs",
                "content": "    public int ladderLength(String start, String end, Set<String> dict) {\\n      // Use queue to help BFS\\n      Queue<String> queue = new LinkedList<String>();\\n      queue.add(start);\\n      queue.add(null);\\n      \\n      // Mark visited word\\n      Set<String> visited = new HashSet<String>();\\n      visited.add(start);\\n      \\n      int level = 1;\\n      \\n      while (!queue.isEmpty()) {\\n        String str = queue.poll();\\n        \\n        if (str != null) {\\n          // Modify str's each character (so word distance is 1)\\n          for (int i = 0; i < str.length(); i++) {\\n            char[] chars = str.toCharArray();\\n            \\n            for (char c = 'a'; c <= 'z'; c++) {\\n              chars[i] = c;\\n              \\n              String word = new String(chars);\\n              \\n              // Found the end word\\n              if (word.equals(end)) return level + 1;\\n              \\n              // Put it to the queue\\n              if (dict.contains(word) && !visited.contains(word)) {\\n                queue.add(word);\\n                visited.add(word);\\n              }\\n            }\\n          }\\n        } else {\\n          level++;\\n          \\n          if (!queue.isEmpty()) { \\n            queue.add(null);\\n          }\\n        }\\n      }\\n      \\n      return 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int ladderLength(String start, String end, Set<String> dict) {\\n      // Use queue to help BFS\\n      Queue<String> queue = new LinkedList<String>();\\n      queue.add(start);\\n      queue.add(null);\\n      \\n      // Mark visited word\\n      Set<String> visited = new HashSet<String>();\\n      visited.add(start);\\n      \\n      int level = 1;\\n      \\n      while (!queue.isEmpty()) {\\n        String str = queue.poll();\\n        \\n        if (str != null) {\\n          // Modify str's each character (so word distance is 1)\\n          for (int i = 0; i < str.length(); i++) {\\n            char[] chars = str.toCharArray();\\n            \\n            for (char c = 'a'; c <= 'z'; c++) {\\n              chars[i] = c;\\n              \\n              String word = new String(chars);\\n              \\n              // Found the end word\\n              if (word.equals(end)) return level + 1;\\n              \\n              // Put it to the queue\\n              if (dict.contains(word) && !visited.contains(word)) {\\n                queue.add(word);\\n                visited.add(word);\\n              }\\n            }\\n          }\\n        } else {\\n          level++;\\n          \\n          if (!queue.isEmpty()) { \\n            queue.add(null);\\n          }\\n        }\\n      }\\n      \\n      return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 40728,
                "title": "simple-java-bfs-solution-with-explanation",
                "content": "The first intuition for this problem is to build a graph whose nodes represent strings and edges connect strings that are only 1 character apart, and then we apply BFS from the startWord node. If we find the endWord, we return the level count of the bfs. This intuition is correct, but there are some places that we can save time.\\n\\n1. When we build adjacency list graph, we don't use two loops to check every pair of string to see if they are 1 character apart. Instead, we make changes to current string to obtain all the strings we can reach from current node, and see if it is in the wordList. Thus, there are currentString.length() * 25 case we need to check for every node. This is faster when the wordList set is large, since the check-every-pair method need wordList.size() * currentString.length() for each node. Otherwise, your may exceed the running time limit.\\n\\n2. For the strings we visited, we remove it from the wordList. This way we don't need to mark visited using another HashSet or something. \\n\\n\\n3. Actually, we don't even need to build the adjacency list graph explicitly using a HashMap<String, ArrayList<String>>, since we keep all the nodes we can reach in the queue of each level of BFS. This can be seen as the keys of the HashMap are the strings that in the queue, and values are the strings that satisfy the 1 character apart in the wordList. Thus, we avoid the time cost of build map for those nodes we don't need to visit. \\n\\n\\npublic class Solution {\\n\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n        wordList.add(endWord);\\n        Queue<String> queue = new LinkedList<String>();\\n        queue.add(beginWord);\\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                String cur = queue.remove();\\n                if(cur.equals(endWord)){ return level + 1;}\\n                for(int j = 0; j < cur.length(); j++){\\n                    char[] word = cur.toCharArray();\\n                    for(char ch = 'a'; ch < 'z'; ch++){\\n                        word[j] = ch;\\n                        String check = new String(word);\\n                        if(!check.equals(cur) && wordList.contains(check)){\\n                            queue.add(check);\\n                            wordList.remove(check);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n        wordList.add(endWord);\\n        Queue<String> queue = new LinkedList<String>();\\n        queue.add(beginWord);\\n        int level = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                String cur = queue.remove();\\n                if(cur.equals(endWord)){ return level + 1;}",
                "codeTag": "Java"
            },
            {
                "id": 898086,
                "title": "easy-bfs-in-c-with-explanation",
                "content": "We can easily solve this problem using BFS with the following steps :-\\n* At the very first we check weather our endWord is present in the word list or not. If not then we return 0.\\n* First of all we have to see that how we can form a graph for the given question -> The first node in the graph will be our begin word and the last node as the endWord.\\n* For each node\\'s neighbour we transform at most one character in the node\\'s string and check weather it is present in our wordList or not. Then, the transformed word forms the neighbour of the given node.\\n![image](https://assets.leetcode.com/users/images/13453c69-32d4-49ed-8d1c-fda814a0188c_1602912215.1767445.png)\\nThe above is the graph we have constructed...\\n\\n**Now we will see how can we apply BFS to the above constructed graph -**\\n* First of all insert the beginWord to the queue.\\n* Then for each level in the queue we increase the depth variable as indicated in the code as \\'d\\' by one.\\n* Then we replace each character of the top of the queue and check it with the endWord.\\n* If present we return \\'d\\'+1, else we  insert the transformed word in the queue and remove the transformed word from the wordList....\\n**And that\\'s it.....U are done...**\\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList)\\n    {\\n        if(find(wordList.begin(),wordList.end(),endWord)==wordList.end())\\n            return 0;\\n        set<string> s;\\n        for(auto i:wordList)\\n            s.insert(i);\\n        queue<string> q;\\n        q.push(beginWord);\\n        int d=0;\\n        while(!q.empty())\\n        {\\n            d++;\\n            int n=q.size();\\n            while(n--)\\n            {\\n                string curr=q.front();\\n                q.pop();\\n                for(int i=0;i<curr.length();i++)\\n                {\\n                    string tmp=curr;\\n                    for(char c=\\'a\\';c<=\\'z\\';c++)\\n                    {\\n                        tmp[i]=c;\\n                        if(tmp==curr)\\n                            continue;\\n                        if(tmp==endWord)\\n                            return d+1;\\n                        if(s.find(tmp)!=s.end())\\n                        {\\n                            q.push(tmp);\\n                            s.erase(tmp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**Please upvote if U got my explanation....Happy Coding...**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList)\\n    {\\n        if(find(wordList.begin(),wordList.end(),endWord)==wordList.end())\\n            return 0;\\n        set<string> s;\\n        for(auto i:wordList)\\n            s.insert(i);\\n        queue<string> q;\\n        q.push(beginWord);\\n        int d=0;\\n        while(!q.empty())\\n        {\\n            d++;\\n            int n=q.size();\\n            while(n--)\\n            {\\n                string curr=q.front();\\n                q.pop();\\n                for(int i=0;i<curr.length();i++)\\n                {\\n                    string tmp=curr;\\n                    for(char c=\\'a\\';c<=\\'z\\';c++)\\n                    {\\n                        tmp[i]=c;\\n                        if(tmp==curr)\\n                            continue;\\n                        if(tmp==endWord)\\n                            return d+1;\\n                        if(s.find(tmp)!=s.end())\\n                        {\\n                            q.push(tmp);\\n                            s.erase(tmp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40710,
                "title": "share-my-two-python-solutions-a-very-concise-one-12-lines-160ms-and-an-optimized-solution-100ms",
                "content": "The idea behind the first solution is to use character flopping plus bidirectional BFS. Use set operations as much as possible.\\n\\n    class Solution:\\n        # @param {string} beginWord\\n        # @param {string} endWord\\n        # @param {set<string>} wordDict\\n        # @return {integer}\\n        def ladderLength(self, beginWord, endWord, wordDict):\\n            length = 2\\n            front, back = set([beginWord]), set([endWord])\\n            wordDict.discard(beginWord)\\n            while front:\\n                # generate all valid transformations\\n                front = wordDict & (set(word[:index] + ch + word[index+1:] for word in front \\n                                    for index in range(len(beginWord)) for ch in 'abcdefghijklmnopqrstuvwxyz'))\\n                if front & back:\\n                    # there are common elements in front and back, done\\n                    return length\\n                length += 1\\n                if len(front) > len(back):\\n                    # swap front and back for better performance (fewer choices in generating nextSet)\\n                    front, back = back, front\\n                # remove transformations from wordDict to avoid cycle\\n                wordDict -= front\\n            return 0\\n\\nThe optimizations:\\n\\n-- Generating next set\\n\\n  An alternative is to immediately add a candidate to next set if it is in the dictionary.\\n\\n   Another way to generate next set: for each word in the current set, check if a word in the dictionary can be transformed to it. If it can, add it to the next set. The time complexity of the two methods is analyzed below, assuming word length is L, size of current set and dictionary are M and N, respectively.\\n\\na. character flopping:\\n\\nLoop over current set, character of word, alphabet, the flopping itself is O(L). Time complexity is O(26ML^2)\\n\\nb. verify transformation:\\n\\nLoop over current set, dictionary, character of word. Time complexity is O(MNL)\\n\\nFor b) to be faster, the switching point is N = 26L. This scale can be adjusted.\\n\\nSince the size of dictionary shrinks during the process, it is beneficial to switch to b) in the late stage, or use it for a small dictionary.\\n\\n-- Removing current word set from dictionary\\n\\nIt seems natural to use difference_update for this job since size of dictionary is bigger than that of current word set. But is it so? Note that here we are sure that every word in current set does exist in the dictionary.\\n\\na. S.difference_update(T) or S -= T\\n\\nFor every key (entry) in T, if it is in S, remove it from T. There are len(T) removes and len(T) peeks.\\n\\nb. S.difference(T) or S - T\\n\\nCreate a new empty set. For every key (entry) in S, if it is not in T, add it to new set. There are len(S)-len(T) adds and len(S) peeks.\\n\\nIf the sizes of current word set and dictionary are close, using difference_update means we will remove almost everything from dictionary. If we use difference, only a handful of adds. I use size of dictionary is twice that of current word set as the switching point. This threshold can be adjusted too.\\nThe following optimized code takes ~100ms.\\n\\n    class Solution:\\n        # @param {string} beginWord\\n        # @param {string} endWord\\n        # @param {set<string>} wordDict\\n        # @return {integer}\\n        def ladderLength(self, beginWord, endWord, wordDict):\\n            def generateNextSet1(current, wordDict, wordLen):\\n                nextSet = set()\\n                for word in current:\\n                    for index in range(wordLen):\\n                        for ch in 'abcdefghijklmnopqrstuvwxyz':\\n                            nextWord = word[:index] + ch + word[index+1:]\\n                            if nextWord in wordDict:\\n                                nextSet.add(nextWord)\\n                return nextSet\\n    \\n            def generateNextSet2(current, wordDict):\\n                nextSet = set()\\n                for word in current:\\n                    for nextWord in wordDict:\\n                        index = 0\\n                        try:\\n                            while word[index] == nextWord[index]:\\n                                index += 1\\n                            if word[index+1:] == nextWord[index+1:]:\\n                                nextSet.add(nextWord)\\n                        except:\\n                            continue\\n                return nextSet\\n    \\n            steps, wordLen = 2, len(beginWord)\\n            front, back = set([beginWord]), set([endWord])\\n            wordDict.discard(beginWord)\\n            switchThreshold = 26*wordLen\\n            while front:\\n                # get all valid transformations\\n                if len(wordDict) >= switchThreshold:\\n                    front = generateNextSet1(front, wordDict, wordLen)\\n                else:\\n                    front = generateNextSet2(front, wordDict)\\n                if front & back:\\n                    # there are common elements in front and back, done\\n                    return steps\\n                steps += 1\\n                if len(front) >= len(back):\\n                    # swap front and back for better performance (smaller nextSet)\\n                    front, back = back, front\\n                # remove transformations from wordDict to avoid cycles\\n                if (len(wordDict)>>1) >= len(front):\\n                    # s.difference_update(t): O(len(t))\\n                    wordDict -= front\\n                else:\\n                    # s.difference(t): O(len(s))\\n                    wordDict = wordDict - front\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 40708,
                "title": "share-my-two-end-bfs-in-c-80ms",
                "content": "\\n\\n\\n    //BFS\\uff0c two-end method\\n    //traverse the path simultaneously from start node and end node, and merge in the middle\\n    //the speed will increase (logN/2)^2 times compared with one-end method\\n    int ladderLength(string start, string end, unordered_set<string> &dict) {\\n        unordered_set<string> begSet, endSet, *set1, *set2;\\n        begSet.insert(start);\\n        endSet.insert(end);\\n        int h=1, K=start.size();\\n        while(!begSet.empty()&&!endSet.empty()){\\n            if(begSet.size()<=endSet.size()){   //Make the size of two sets close for optimization\\n                set1=&begSet;\\t//set1 is the forward set\\n                set2=&endSet;\\t//set2 provides the target node for set1 to search\\n            }\\n            else{\\n                set1=&endSet;\\n                set2=&begSet;\\n            }\\n            unordered_set<string> itmSet;\\t//intermediate Set\\n            h++;\\n            for(auto i=set1->begin();i!=set1->end();i++){\\n            \\tstring cur=*i;\\n            \\tfor(int k=0;k<K;k++){\\t//iterate the characters in string cur\\n            \\t\\tchar temp=cur[k];\\n            \\t\\tfor(int l=0;l<26;l++){\\t//try all 26 alphabets\\n            \\t\\t\\tcur[k]='a'+l;\\n            \\t\\t\\tauto f=set2->find(cur);\\n            \\t\\t\\tif(f!=set2->end())return h;\\n            \\t\\t\\tf=dict.find(cur);\\n            \\t\\t\\tif(f!=dict.end()){\\n            \\t\\t\\t\\titmSet.insert(cur);\\n            \\t\\t\\t\\tdict.erase(f);\\n            \\t\\t\\t}\\n            \\t\\t}\\n            \\t\\tcur[k]=temp;\\n            \\t}\\n            }\\n            swap(*set1, itmSet);\\n        }\\n        return 0;\\n    }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "\\n\\n\\n    //BFS\\uff0c two-end method\\n    //traverse the path simultaneously from start node and end node, and merge in the middle\\n    //the speed will increase (logN/2)^2 times compared with one-end method\\n    int ladderLength(string start, string end, unordered_set<string> &dict) {\\n        unordered_set<string> begSet, endSet, *set1, *set2;\\n        begSet.insert(start);\\n        endSet.insert(end);\\n        int h=1, K=start.size();\\n        while(!begSet.empty()&&!endSet.empty()){\\n            if(begSet.size()<=endSet.size()){   //Make the size of two sets close for optimization\\n                set1=&begSet;\\t//set1 is the forward set\\n                set2=&endSet;\\t//set2 provides the target node for set1 to search\\n            }\\n            else{\\n                set1=&endSet;\\n                set2=&begSet;\\n            }\\n            unordered_set<string> itmSet;\\t//intermediate Set\\n            h++;\\n            for(auto i=set1->begin();i!=set1->end();i++){\\n            \\tstring cur=*i;\\n            \\tfor(int k=0;k<K;k++){\\t//iterate the characters in string cur\\n            \\t\\tchar temp=cur[k];\\n            \\t\\tfor(int l=0;l<26;l++){\\t//try all 26 alphabets\\n            \\t\\t\\tcur[k]='a'+l;\\n            \\t\\t\\tauto f=set2->find(cur);\\n            \\t\\t\\tif(f!=set2->end())return h;\\n            \\t\\t\\tf=dict.find(cur);\\n            \\t\\t\\tif(f!=dict.end()){\\n            \\t\\t\\t\\titmSet.insert(cur);\\n            \\t\\t\\t\\tdict.erase(f);\\n            \\t\\t\\t}\\n            \\t\\t}\\n            \\t\\tcur[k]=temp;\\n            \\t}\\n            }\\n            swap(*set1, itmSet);\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 40810,
                "title": "python-bfs-solution",
                "content": "    def ladderLength(beginWord, endWord, wordList):\\n        queue = [(beginWord, 1)]\\n        visited = set()\\n        \\n        while queue:\\n            word, dist = queue.pop(0)\\n            if word == endWord:\\n                return dist\\n            for i in range(len(word)):\\n                for j in 'abcdefghijklmnopqrstuvwxyz':\\n                    tmp = word[:i] + j + word[i+1:]\\n                    if tmp not in visited and tmp in wordList:\\n                        queue.append((tmp, dist+1))\\n                        visited.add(tmp)\\n        return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def ladderLength(beginWord, endWord, wordList):\\n        queue = [(beginWord, 1)]\\n        visited = set()\\n        \\n        while queue:\\n            word, dist = queue.pop(0)\\n            if word == endWord:\\n                return dist\\n            for i in range(len(word)):\\n                for j in 'abcdefghijklmnopqrstuvwxyz':\\n                    tmp = word[:i] + j + word[i+1:]\\n                    if tmp not in visited and tmp in wordList:\\n                        queue.append((tmp, dist+1))\\n                        visited.add(tmp)\\n        return 0",
                "codeTag": "Python3"
            },
            {
                "id": 538519,
                "title": "c-bidirectional-bfs-beats-97",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\t\\tunordered_set<string> s1;\\n\\t\\t\\tunordered_set<string> s2;\\n\\t\\t\\tunordered_set<string> dict(wordList.begin(),wordList.end());\\n\\t\\t\\tif(!dict.count(endWord)) return 0;\\n\\t\\t\\tint len=beginWord.size();\\n\\t\\t\\tint ans=0;\\n\\t\\t\\ts1.insert(beginWord);\\n\\t\\t\\ts2.insert(endWord);\\n\\t\\t\\twhile(!s1.empty() && !s2.empty()){\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tif(s1.size()>s2.size()){\\n\\t\\t\\t\\t\\tswap(s1,s2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tunordered_set<string> cur;\\n\\t\\t\\t\\tfor(string w:s1){\\n\\t\\t\\t\\t\\tfor(int i=0;i<len;i++){\\n\\t\\t\\t\\t\\t\\tchar temp=w[i];\\n\\t\\t\\t\\t\\t\\tfor(char x=\\'a\\';x<=\\'z\\';x++){\\n\\t\\t\\t\\t\\t\\t\\tw[i]=x;\\n\\t\\t\\t\\t\\t\\t\\tif(s2.count(w)){\\n\\t\\t\\t\\t\\t\\t\\t\\treturn ans+1;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(!dict.count(w))continue;\\n\\t\\t\\t\\t\\t\\t\\tdict.erase(w);\\n\\t\\t\\t\\t\\t\\t\\tcur.insert(w);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tw[i]=temp;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ts1=cur;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\t\\tunordered_set<string> s1;\\n\\t\\t\\tunordered_set<string> s2;\\n\\t\\t\\tunordered_set<string> dict(wordList.begin(),wordList.end());\\n\\t\\t\\tif(!dict.count(endWord)) return 0;\\n\\t\\t\\tint len=beginWord.size();\\n\\t\\t\\tint ans=0;\\n\\t\\t\\ts1.insert(beginWord);\\n\\t\\t\\ts2.insert(endWord);\\n\\t\\t\\twhile(!s1.empty() && !s2.empty()){\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t\\tif(s1.size()>s2.size()){\\n\\t\\t\\t\\t\\tswap(s1,s2);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 659447,
                "title": "javascript-heavily-commented-bfs-solution",
                "content": "This post is a more detailed explanation for a [solution](https://leetcode.com/problems/word-ladder/discuss/400673/Clean-JavaScript-BSF-solution) by Hongbo-Miao.\\n\\nThe time complexity is O(N * M * 26) where \\nN = number of words, \\nM = length of each word\\ntechnically you can drop the 26 since its a constant\\n```javascript\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    const wordSet = new Set(wordList)\\n    let queue = [beginWord];\\n    let steps = 1;\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        // loop over each word in the queue\\n        for(let word of queue) {\\n            if(word === endWord) return steps;\\n            \\n            // loop over each char of the word \\n            for(let i = 0; i < word.length; i++) {\\n                \\n                // and replace the char with letters from [a - z]\\n                for(let j = 0; j < 26; j++) {\\n                    const newWord = word.slice(0, i) + String.fromCharCode(j + 97) + word.slice(i+1);\\n                    \\n                    // if the new word exist in the word list add it to the queue\\n                    if(wordSet.has(newWord)) {\\n                        next.push(newWord);\\n                        wordSet.delete(newWord);\\n                    }\\n                }\\n            }\\n        }\\n        queue = next\\n        steps++;\\n    }\\n    return 0;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    const wordSet = new Set(wordList)\\n    let queue = [beginWord];\\n    let steps = 1;\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        // loop over each word in the queue\\n        for(let word of queue) {\\n            if(word === endWord) return steps;\\n            \\n            // loop over each char of the word \\n            for(let i = 0; i < word.length; i++) {\\n                \\n                // and replace the char with letters from [a - z]\\n                for(let j = 0; j < 26; j++) {\\n                    const newWord = word.slice(0, i) + String.fromCharCode(j + 97) + word.slice(i+1);\\n                    \\n                    // if the new word exist in the word list add it to the queue\\n                    if(wordSet.has(newWord)) {\\n                        next.push(newWord);\\n                        wordSet.delete(newWord);\\n                    }\\n                }\\n            }\\n        }\\n        queue = next\\n        steps++;\\n    }\\n    return 0;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40702,
                "title": "super-fast-java-solution-using-two-end-bfs",
                "content": "Thanks to prime_tang!\\n\\n    public class Solution {\\n        public int ladderLength(String start, String end, Set<String> dict) {\\n            Set<String> set1 = new HashSet<String>();\\n            Set<String> set2 = new HashSet<String>();\\n            \\n            set1.add(start);\\n            set2.add(end);\\n            \\n            return helper(dict, set1, set2, 1);\\n        }\\n        \\n        int helper(Set<String> dict, Set<String> set1, Set<String> set2, int level) {\\n            if (set1.isEmpty()) return 0;\\n            \\n            if (set1.size() > set2.size()) return helper(dict, set2, set1, level);\\n            \\n            // remove words from both ends\\n            for (String word : set1) { dict.remove(word); };\\n            for (String word : set2) { dict.remove(word); };\\n            \\n            // the set for next level\\n            Set<String> set = new HashSet<String>();\\n            \\n            // for each string in the current level\\n            for (String str : set1) {\\n                for (int i = 0; i < str.length(); i++) {\\n                    char[] chars = str.toCharArray();\\n                    \\n                    // change letter at every position\\n                    for (char ch = 'a'; ch <= 'z'; ch++) {\\n                        chars[i] = ch;\\n                        String word = new String(chars);\\n                        \\n                        // found the word in other end(set)\\n                        if (set2.contains(word)) {\\n                            return level + 1;\\n                        }\\n                        \\n                        // if not, add to the next level\\n                        if (dict.contains(word)) {\\n                            set.add(word);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return helper(dict, set2, set, level + 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public int ladderLength(String start, String end, Set<String> dict) {\\n            Set<String> set1 = new HashSet<String>();\\n            Set<String> set2 = new HashSet<String>();\\n            \\n            set1.add(start);\\n            set2.add(end);\\n            \\n            return helper(dict, set1, set2, 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 509769,
                "title": "java-python-bfs-solution-clean-concise",
                "content": "<iframe src=\"https://leetcode.com/playground/PtTNQFh7/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N * 26M * M)`, where `M <= 10` is the length of each word and `N <= 500` is the total number of words in the input word list\\n\\t- Explain: There are maximum `N` words to be consider in the queue, each word we need to generate up to `26 * M` new words as neighbors, each word have length `M`.\\n- Space: `O(M * N)`",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/PtTNQFh7/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N * 26M * M)`, where `M <= 10` is the length of each word and `N <= 500` is the total number of words in the input word list\\n\\t- Explain: There are maximum `N` words to be consider in the queue, each word we need to generate up to `26 * M` new words as neighbors, each word have length `M`.\\n- Space: `O(M * N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 1008731,
                "title": "python-o-26nm-2-bfs-solution-explained",
                "content": "In this problem we need to find shortest distance between two words, so the first idea you should think is classical bfs. \\n\\n1. Let `m` be length of each word and `n` be total number of words.\\n2. Let us also add `beginWord` to our list of words and create `words_inverse`: connections between words and their numbers.\\n3. Now, time to create `words_graph`. It can be done in the following way: iterate over each word and each place and find all possible neighbors for each word: for example for word `apple`, we have: `apple, bpple, cpple, ... zpple, aaple, abple,... azple, ..., appla, applb, ... applz`. In `words_graph` we will keep connections between indexes of words.\\n4. Run classical `bfs` for created graph, using deque: first, we mark all distances as `-1` and `0` for `endWord`. Then we extract left element fro queue, check if it is what we are looking for and if it is, we return distance. If it is not, then we visit all neighbors and if they are not visited yet, we add them to queue.\\n\\n**Complexity**: time complexity is `O(26nm^2)`, because for each of `n` words we need to check all `26m` neighbours and each comparison of words is `O(m)`. Also we have `bfs` step, where we have graph on `m` nodes with at most `26n` neighbours for each node, so traverse of this graph will be `O(26mn)`, which is less than previous term. Space complexity is `O(26mn)`.\\n\\n**Note**, that there is alternative way to create our graph: we can check each pair of words and we will have `O(mn^2)` time to create it. This method is preferable if `m*n*n < 26*n*m*m`, the is if `n < 26m`.\\n\\n```\\nclass Solution:\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        wordList.append(beginWord)\\n        m, n = len(wordList[0]), len(wordList)\\n        words_inverse = {w:i for i, w in enumerate(wordList)}\\n        \\n        words_graph = defaultdict(set)\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n\\n        if endWord not in words_inverse: return 0\\n        end_ind = words_inverse[endWord]\\n\\n        for word in wordList:\\n            for l in range(m):\\n                p1, p2 = word[0:l], word[l+1:]\\n                for i in alphabet:\\n                    tmp = p1 + i + p2\\n                    if tmp in words_inverse and tmp != word:\\n                        words_graph[words_inverse[word]].add(words_inverse[tmp])\\n\\n        depths = [-1] * (n-1) + [0]\\n        queue = deque([n-1])\\n\\n        while queue:\\n            curr = queue.popleft()\\n            if curr == end_ind:\\n                return depths[end_ind]  + 1\\n            for neib in words_graph[curr]:\\n                if depths[neib] == -1:\\n                    queue.append(neib)\\n                    depths[neib] = depths[curr] + 1\\n                    \\n        return 0\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        wordList.append(beginWord)\\n        m, n = len(wordList[0]), len(wordList)\\n        words_inverse = {w:i for i, w in enumerate(wordList)}\\n        \\n        words_graph = defaultdict(set)\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n\\n        if endWord not in words_inverse: return 0\\n        end_ind = words_inverse[endWord]\\n\\n        for word in wordList:\\n            for l in range(m):\\n                p1, p2 = word[0:l], word[l+1:]\\n                for i in alphabet:\\n                    tmp = p1 + i + p2\\n                    if tmp in words_inverse and tmp != word:\\n                        words_graph[words_inverse[word]].add(words_inverse[tmp])\\n\\n        depths = [-1] * (n-1) + [0]\\n        queue = deque([n-1])\\n\\n        while queue:\\n            curr = queue.popleft()\\n            if curr == end_ind:\\n                return depths[end_ind]  + 1\\n            for neib in words_graph[curr]:\\n                if depths[neib] == -1:\\n                    queue.append(neib)\\n                    depths[neib] = depths[curr] + 1\\n                    \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281178,
                "title": "java-9ms-bidirection-bfs-solution-which-beats-100-with-detailed-explanation",
                "content": "This problem is a variety of maze problem. The beginWord and endWord can be seen as the entry and exit of a maze respectively. A valid path exist between any two words which can transform to each other. \\nAn intuitive idea is bfs from the beginWord through queue. However, if ```wordList``` is very large, the queue could be too large before we can reach the endWord. In order to increase efficiency, we can make some changes of traditional bfs:\\n1. Search from entry and exit simultaneously. when entry and exit meets, stop bfs. To do so, we need two queues to save the current search status of entry and exit respectively.\\n2. Each step we pick the queue with less elements to implement bfs. Less elements means less time to traverse.\\n3. Replace queue with set so that we can judge whether entry and exit meets in O(1) time.\\n4. Remove visited word from wordList to decrease the search time\\n\\n```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n    Set<String> wordSet = new HashSet<String>(wordList);\\n    if( !wordSet.contains(endWord) )\\n        return 0;\\n\\t// 3. Use set instead of queue during bfs\\n    Set<String> forwardSet = new HashSet<String>(); \\n    Set<String> backwardSet = new HashSet<String>();\\n    forwardSet.add(beginWord);\\n    backwardSet.add(endWord);\\n    wordSet.remove(endWord);\\n    wordSet.remove(beginWord);\\n\\t// 1. Search from entry and exit simultaneously\\n    return transform(forwardSet, backwardSet, wordSet);\\n}\\n\\npublic int transform(Set<String> forwardSet, Set<String> backwardSet, Set<String> wordSet) {\\n    Set<String> newSet = new HashSet<String>();\\n    for(String fs : forwardSet) {\\n        char wordArray[] = fs.toCharArray();\\n        for(int i = 0; i < wordArray.length; i++) {\\n            for(int c = \\'a\\'; c <= \\'z\\'; c++) {\\n                char origin = wordArray[i];\\n                wordArray[i] = (char) c;\\n                String target = String.valueOf(wordArray);\\n                if( backwardSet.contains(target) )\\n                    return 2; // stop bfs when entry and exits meet\\n                else if( wordSet.contains(target) && !forwardSet.contains(target) ) {\\n                    wordSet.remove(target); // 4. Remove visited word from wordList to decrease the search time\\n                    newSet.add(target);\\n                }\\n                wordArray[i] = origin;\\n            }\\n        }\\n    }\\n    if( newSet.size() == 0 )\\n        return 0;\\n    forwardSet = newSet;\\n\\t// 2. Pick the queue with less elements to bfs\\n    int result = forwardSet.size() > backwardSet.size() ? \\n        transform(backwardSet, forwardSet, wordSet) : transform(forwardSet, backwardSet, wordSet);\\n    return result == 0 ? 0 : result + 1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```wordList```\n```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n    Set<String> wordSet = new HashSet<String>(wordList);\\n    if( !wordSet.contains(endWord) )\\n        return 0;\\n\\t// 3. Use set instead of queue during bfs\\n    Set<String> forwardSet = new HashSet<String>(); \\n    Set<String> backwardSet = new HashSet<String>();\\n    forwardSet.add(beginWord);\\n    backwardSet.add(endWord);\\n    wordSet.remove(endWord);\\n    wordSet.remove(beginWord);\\n\\t// 1. Search from entry and exit simultaneously\\n    return transform(forwardSet, backwardSet, wordSet);\\n}\\n\\npublic int transform(Set<String> forwardSet, Set<String> backwardSet, Set<String> wordSet) {\\n    Set<String> newSet = new HashSet<String>();\\n    for(String fs : forwardSet) {\\n        char wordArray[] = fs.toCharArray();\\n        for(int i = 0; i < wordArray.length; i++) {\\n            for(int c = \\'a\\'; c <= \\'z\\'; c++) {\\n                char origin = wordArray[i];\\n                wordArray[i] = (char) c;\\n                String target = String.valueOf(wordArray);\\n                if( backwardSet.contains(target) )\\n                    return 2; // stop bfs when entry and exits meet\\n                else if( wordSet.contains(target) && !forwardSet.contains(target) ) {\\n                    wordSet.remove(target); // 4. Remove visited word from wordList to decrease the search time\\n                    newSet.add(target);\\n                }\\n                wordArray[i] = origin;\\n            }\\n        }\\n    }\\n    if( newSet.size() == 0 )\\n        return 0;\\n    forwardSet = newSet;\\n\\t// 2. Pick the queue with less elements to bfs\\n    int result = forwardSet.size() > backwardSet.size() ? \\n        transform(backwardSet, forwardSet, wordSet) : transform(forwardSet, backwardSet, wordSet);\\n    return result == 0 ? 0 : result + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40963,
                "title": "a-c-bfs-solution-without-constructing-words",
                "content": "    int ladderLength(string start, string end, unordered_set<string> &dict) \\n    {\\n        if (dict.empty() || dict.find(start) == dict.end() || dict.find(end) == dict.end()) \\n            return 0;\\n        \\n        queue<string> q;\\n        q.push(start);\\n        unordered_map<string, int> visited;  // visited track the distance\\n        visited[start] = 1;\\n        unordered_set<string> unvisited = dict;  // unvisited prevent searching through the whole dict\\n        unvisited.erase(start);\\n        \\n        while (!q.empty()) {\\n            string word = q.front(); q.pop();\\n            auto itr = unvisited.begin();\\n            while (itr != unvisited.end()) {\\n                string adjWord = *itr;\\n                if (oneCharDiff(word, adjWord)) {\\n                    visited[adjWord] = visited[word] + 1;\\n                    if (adjWord == end) \\n                        return visited[adjWord];\\n                    itr = unvisited.erase(itr);  // tricky here\\n                    q.push(adjWord);\\n                }\\n                else\\n                    ++itr;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    inline bool oneCharDiff(const string& str1, const string& str2)\\n    {\\n        int diff = 0;\\n        for (int i = 0; i < str1.size(); ++i)  {\\n            if (str1[i] != str2[i]) \\n                ++diff;\\n            if (diff > 1) \\n                return false;  // perhaps quicker\\n        }\\n        return diff == 1;\\n    }\\n\\nThis solution provides a way without constructing the adjacent words, but just search it. But in order to make search efficient, I use an **unvisited** hash table to track the unvisited words, preventing searching through the whole word dictionary, making the algorithm a slightly efficient.",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "    int ladderLength(string start, string end, unordered_set<string> &dict) \\n    {\\n        if (dict.empty() || dict.find(start) == dict.end() || dict.find(end) == dict.end()) \\n            return 0;\\n        \\n        queue<string> q;\\n        q.push(start);\\n        unordered_map<string, int> visited;  // visited track the distance\\n        visited[start] = 1;\\n        unordered_set<string> unvisited = dict;  // unvisited prevent searching through the whole dict\\n        unvisited.erase(start);\\n        \\n        while (!q.empty()) {\\n            string word = q.front(); q.pop();\\n            auto itr = unvisited.begin();\\n            while (itr != unvisited.end()) {\\n                string adjWord = *itr;\\n                if (oneCharDiff(word, adjWord)) {\\n                    visited[adjWord] = visited[word] + 1;\\n                    if (adjWord == end) \\n                        return visited[adjWord];\\n                    itr = unvisited.erase(itr);  // tricky here\\n                    q.push(adjWord);\\n                }\\n                else\\n                    ++itr;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    inline bool oneCharDiff(const string& str1, const string& str2)\\n    {\\n        int diff = 0;\\n        for (int i = 0; i < str1.size(); ++i)  {\\n            if (str1[i] != str2[i]) \\n                ++diff;\\n            if (diff > 1) \\n                return false;  // perhaps quicker\\n        }\\n        return diff == 1;\\n    }\\n\\nThis solution provides a way without constructing the adjacent words, but just search it. But in order to make search efficient, I use an **unvisited** hash table to track the unvisited words, preventing searching through the whole word dictionary, making the algorithm a slightly efficient.",
                "codeTag": "Unknown"
            },
            {
                "id": 2634411,
                "title": "here-is-why-dp-dfs-fails-with-memoization-44th-test-case-failing",
                "content": "\\n\\nYour DP algorithm is probably eliminating the optimal path due to the visited nodes list (Cyclic and non directed nature of the problem.)  Inorder to avoid cycles (infiinte loop), dp algorithm would end up with a solution that is not optimal. (Refer the dotted area in the graph)\\n\\nConsider the graph in the picture\\nSource is **hbo**\\nTarget is **qbx**.\\nWords **[\"abo\",\"hbw\",\"abq\",\"qbq\",\"qbx\",\"qbw\"]**\\n\\nDP algoritm first chooses the path **(PATH1)** `hbo->abo->abq->qbq->qbw->hbw`\\n\\nAt this state, it would try to make the next move `hbw->qbw`, but it wont be able to because qbw is already visited in this path. So the dp algorithm would determine that there are no ways to reach the target(`qbx`) from hbw.\\n\\nSo later when the algorithm attempts to make the optimal **PATH 2** `hbo->hbw->qbw->qbx`, the process is cut off at the node hbw, as PATH1 determined that you cant reach the target from `hbw`.\\n\\nSo it would endup choosing some other non optimal path like **PATH 3** `hbo->abo->abq->qbq->qbx`.\\n\\n![image](https://assets.leetcode.com/users/images/680e37b1-d7f9-4f8c-8dac-b40adeb12735_1664365076.45187.png)\\n\\n\\nJust get the job done with BFS here.\\n\\nNote: DFS without memoization would give the the optimal path but time complexity would be exponential.\\n\\nUpvote and share if you like the explaination! :)\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "\\n\\nYour DP algorithm is probably eliminating the optimal path due to the visited nodes list (Cyclic and non directed nature of the problem.)  Inorder to avoid cycles (infiinte loop), dp algorithm would end up with a solution that is not optimal. (Refer the dotted area in the graph)\\n\\nConsider the graph in the picture\\nSource is **hbo**\\nTarget is **qbx**.\\nWords **[\"abo\",\"hbw\",\"abq\",\"qbq\",\"qbx\",\"qbw\"]**\\n\\nDP algoritm first chooses the path **(PATH1)** `hbo->abo->abq->qbq->qbw->hbw`\\n\\nAt this state, it would try to make the next move `hbw->qbw`, but it wont be able to because qbw is already visited in this path. So the dp algorithm would determine that there are no ways to reach the target(`qbx`) from hbw.\\n\\nSo later when the algorithm attempts to make the optimal **PATH 2** `hbo->hbw->qbw->qbx`, the process is cut off at the node hbw, as PATH1 determined that you cant reach the target from `hbw`.\\n\\nSo it would endup choosing some other non optimal path like **PATH 3** `hbo->abo->abq->qbq->qbx`.\\n\\n![image](https://assets.leetcode.com/users/images/680e37b1-d7f9-4f8c-8dac-b40adeb12735_1664365076.45187.png)\\n\\n\\nJust get the job done with BFS here.\\n\\nNote: DFS without memoization would give the the optimal path but time complexity would be exponential.\\n\\nUpvote and share if you like the explaination! :)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 394113,
                "title": "best-python-solution-explained-with-other-similar-problems",
                "content": "This problem is better using BFS. Because we need to find the shortest step.\\nUsing DFS, we may eventually find the `endWord` but not the shortest path.\\n\\nFirst, build a memo so that we can find the related word without going through a~z every time we pop out a new word from queue.\\nSo for example\\n```python\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nmemo = {\\n    \\'lo#\\': [\\'lot\\', \\'log\\'],\\n    \\'l#t\\': [\\'lot\\'],\\n    \\'#ot\\': [\\'hot\\', \\'dot\\', \\'lot\\'],\\n    \\'h#t\\': [\\'hot\\'],\\n    \\'do#\\': [\\'dot\\', \\'dog\\'],\\n    \\'l#g\\': [\\'log\\'],\\n    \\'co#\\': [\\'cog\\'],\\n    \\'#og\\': [\\'dog\\', \\'log\\', \\'cog\\'],\\n    \\'d#g\\': [\\'dog\\'],\\n    \\'d#t\\': [\\'dot\\'],\\n    \\'c#g\\': [\\'cog\\'],\\n    \\'ho#\\': [\\'hot\\']\\n}\\n```\\n\\nSecond build a queue to BFS from `beginWord` to `endWord`.\\nEverytime we pop a word we first check if it is visited.\\nThen check if it is `endWord`, if true, return the steps.\\nIf not, put all the neighbor to the queue.\\n\\nIf the queue ended and we did not find the `endWord`, return 0.\\n\\nThe time complexity is `O(W*C*C)`, W is the word count, C is the character count in each word.\\nThe space complexity is also `O(W*C)`.\\n```python\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        memo = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in xrange(len(word)):\\n                memo[word[:i]+\\'#\\'+word[i+1:]].append(word)\\n\\n        seen = set()\\n        q = collections.deque([(beginWord, 1)])\\n        while q:\\n            word, steps = q.popleft()\\n            if word==endWord: return steps\\n            seen.add(word)\\n\\n            for i in xrange(len(word)):\\n                for next_word in memo[word[:i]+\\'#\\'+word[i+1:]]:\\n                    if next_word not in seen:\\n                        q.append((next_word, steps+1))\\n        return 0\\n```\\n\\nWhen comparing to other solution, I made some changes.\\nWhich is the timing of adding the word to the `visited` hash-set.\\nI think by adding the word to the hash-set in the for loop, makes the queue smaller, so it would be slightly faster.\\nBut the time complexity is totally the same.\\n```python\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        memo = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in xrange(len(word)):\\n                memo[word[:i]+\\'#\\'+word[i+1:]].append(word)\\n\\n        seen = set()\\n        q = collections.deque([(beginWord, 1)])\\n        while q:\\n            word, steps = q.popleft()\\n            if word==endWord: return steps\\n\\n            for i in xrange(len(word)):\\n                for next_word in memo[word[:i]+\\'#\\'+word[i+1:]]:\\n                    if next_word not in seen:\\n                        q.append((next_word, steps+1))\\n                        seen.add(next_word) #HERE\\n        return 0\\n```\\n\\n\\n# More\\n1. Combination: 39, 40, 77, 78 90, 216 (See My Article [1 Method for 6 Problems](https://leetcode.com/problems/combination-sum/discuss/389405)).\\n2. Permutations: 47, 784, 943, 996\\n3. DFS: 22, 301\\n4. DFS2: 79, 212\\n5. BFS: 127, 126, 752\\n6. Check out my GitHub, https://github.com/wuduhren/leetcode-python for other topics.  \\nI really take time tried to make the best solution or explaination. Because I wanted to help others like me.  \\nIf you like my answer, a **star** on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me.\\n",
                "solutionTags": [],
                "code": "```python\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nmemo = {\\n    \\'lo#\\': [\\'lot\\', \\'log\\'],\\n    \\'l#t\\': [\\'lot\\'],\\n    \\'#ot\\': [\\'hot\\', \\'dot\\', \\'lot\\'],\\n    \\'h#t\\': [\\'hot\\'],\\n    \\'do#\\': [\\'dot\\', \\'dog\\'],\\n    \\'l#g\\': [\\'log\\'],\\n    \\'co#\\': [\\'cog\\'],\\n    \\'#og\\': [\\'dog\\', \\'log\\', \\'cog\\'],\\n    \\'d#g\\': [\\'dog\\'],\\n    \\'d#t\\': [\\'dot\\'],\\n    \\'c#g\\': [\\'cog\\'],\\n    \\'ho#\\': [\\'hot\\']\\n}\\n```\n```python\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        memo = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in xrange(len(word)):\\n                memo[word[:i]+\\'#\\'+word[i+1:]].append(word)\\n\\n        seen = set()\\n        q = collections.deque([(beginWord, 1)])\\n        while q:\\n            word, steps = q.popleft()\\n            if word==endWord: return steps\\n            seen.add(word)\\n\\n            for i in xrange(len(word)):\\n                for next_word in memo[word[:i]+\\'#\\'+word[i+1:]]:\\n                    if next_word not in seen:\\n                        q.append((next_word, steps+1))\\n        return 0\\n```\n```python\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        memo = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in xrange(len(word)):\\n                memo[word[:i]+\\'#\\'+word[i+1:]].append(word)\\n\\n        seen = set()\\n        q = collections.deque([(beginWord, 1)])\\n        while q:\\n            word, steps = q.popleft()\\n            if word==endWord: return steps\\n\\n            for i in xrange(len(word)):\\n                for next_word in memo[word[:i]+\\'#\\'+word[i+1:]]:\\n                    if next_word not in seen:\\n                        q.append((next_word, steps+1))\\n                        seen.add(next_word) #HERE\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40703,
                "title": "doubts-about-a-test-case",
                "content": "My below solution is failing for the following test case\\n\\nbeginWord : \"a\"\\nendWord : \"c\"\\nwordList : [\"a\",\"b\",\"c\"]\\n\\nmy result = 1\\nexpected result  = 2\\n\\nwhy it should be 2 not 1 ? can someone please explain me ?\\n\\n\\n```\\nclass Solution {\\n    \\n    private class Graph{\\n        private HashMap<String, ArrayList<String>> map;\\n        private int vertices;\\n        \\n        public Graph(int vertices){\\n            this.vertices = vertices;\\n            map = new HashMap<>();\\n        }\\n        \\n        public void makeGraph(List<String> words){\\n            for(String word : words){\\n                map.put(word,new ArrayList<String>());\\n            }\\n            for(int i = 0; i < words.size(); i++){\\n                for(int j = i+1; j < words.size(); j++){\\n                    if(isNeighbour(words.get(i),words.get(j))){\\n                        map.get(words.get(i)).add(words.get(j));\\n                        map.get(words.get(j)).add(words.get(i));\\n                    }\\n                }\\n            }\\n            print();\\n        }\\n        \\n        private void print(){\\n            for(String key : map.keySet()){\\n                System.out.print(\"KEY : \" +key+\" \");\\n                for(String s : map.get(key)){\\n                    System.out.print(s +\" \");\\n                }\\n                System.out.println();\\n            }\\n        }\\n        \\n        private boolean isNeighbour(String s, String t){\\n            int count = 0;\\n            char srr[] = s.toCharArray();\\n            char trr[] = t.toCharArray();\\n            for(int i = 0; i < srr.length; i++){\\n                if(srr[i]!=trr[i]){\\n                    count++;\\n                }    \\n            }\\n            return count == 1 ? true : false;\\n        }\\n        \\n        public int bfs(String begin, String end){\\n            int level = 0;\\n            \\n            Queue<String> queue = new LinkedList<String>();\\n            HashSet<String> set = new HashSet<>();\\n            \\n            queue.add(begin);\\n            \\n            while(!queue.isEmpty()){\\n                \\n                String curr = queue.poll();\\n                set.add(curr);\\n                \\n                ArrayList<String> list = map.get(curr);\\n                \\n                for(String s : list){\\n                    if(s.equals(end)){\\n                        return level+1;\\n                    }\\n                    if(!set.contains(s)){\\n                        queue.add(s);\\n                    }\\n                }\\n                level++;\\n            }\\n            \\n            return 0;\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        if(!wordList.contains(beginWord))\\n            wordList.add(beginWord);\\n        if(!wordList.contains(endWord))\\n            return 0;\\n        Graph g = new Graph(wordList.size());\\n        g.makeGraph(wordList);\\n        \\n        return g.bfs(beginWord,endWord);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private class Graph{\\n        private HashMap<String, ArrayList<String>> map;\\n        private int vertices;\\n        \\n        public Graph(int vertices){\\n            this.vertices = vertices;\\n            map = new HashMap<>();\\n        }\\n        \\n        public void makeGraph(List<String> words){\\n            for(String word : words){\\n                map.put(word,new ArrayList<String>());\\n            }\\n            for(int i = 0; i < words.size(); i++){\\n                for(int j = i+1; j < words.size(); j++){\\n                    if(isNeighbour(words.get(i),words.get(j))){\\n                        map.get(words.get(i)).add(words.get(j));\\n                        map.get(words.get(j)).add(words.get(i));\\n                    }\\n                }\\n            }\\n            print();\\n        }\\n        \\n        private void print(){\\n            for(String key : map.keySet()){\\n                System.out.print(\"KEY : \" +key+\" \");\\n                for(String s : map.get(key)){\\n                    System.out.print(s +\" \");\\n                }\\n                System.out.println();\\n            }\\n        }\\n        \\n        private boolean isNeighbour(String s, String t){\\n            int count = 0;\\n            char srr[] = s.toCharArray();\\n            char trr[] = t.toCharArray();\\n            for(int i = 0; i < srr.length; i++){\\n                if(srr[i]!=trr[i]){\\n                    count++;\\n                }    \\n            }\\n            return count == 1 ? true : false;\\n        }\\n        \\n        public int bfs(String begin, String end){\\n            int level = 0;\\n            \\n            Queue<String> queue = new LinkedList<String>();\\n            HashSet<String> set = new HashSet<>();\\n            \\n            queue.add(begin);\\n            \\n            while(!queue.isEmpty()){\\n                \\n                String curr = queue.poll();\\n                set.add(curr);\\n                \\n                ArrayList<String> list = map.get(curr);\\n                \\n                for(String s : list){\\n                    if(s.equals(end)){\\n                        return level+1;\\n                    }\\n                    if(!set.contains(s)){\\n                        queue.add(s);\\n                    }\\n                }\\n                level++;\\n            }\\n            \\n            return 0;\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        if(!wordList.contains(beginWord))\\n            wordList.add(beginWord);\\n        if(!wordList.contains(endWord))\\n            return 0;\\n        Graph g = new Graph(wordList.size());\\n        g.makeGraph(wordList);\\n        \\n        return g.bfs(beginWord,endWord);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383702,
                "title": "easy-bfs-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) \\n    {\\n        unordered_set<string>dict(wordList.begin(),wordList.end());\\n        if(dict.find(endWord)==dict.end())\\n        {\\n            return 0;\\n        }\\n        queue<string>q;\\n        q.push(beginWord);\\n        int steps=1;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n)\\n            {\\n                string node=q.front();\\n                q.pop();\\n                if(node==endWord)\\n                {\\n                    return steps;\\n                }\\n                for(int i=0;i<node.length();i++)\\n                {\\n                    for(char c=\\'a\\';c<=\\'z\\';c++)\\n                    {\\n                        char x=node[i];\\n                        node[i]=c;\\n                        if(dict.find(node)!=dict.end())\\n                        {\\n                            dict.erase(node);\\n                            q.push(node);\\n                        }\\n                        node[i]=x;\\n                    }\\n                }\\n                n--;\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n***Please upvote if you have found my code useful. Thank you.***",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) \\n    {\\n        unordered_set<string>dict(wordList.begin(),wordList.end());\\n        if(dict.find(endWord)==dict.end())\\n        {\\n            return 0;\\n        }\\n        queue<string>q;\\n        q.push(beginWord);\\n        int steps=1;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n)\\n            {\\n                string node=q.front();\\n                q.pop();\\n                if(node==endWord)\\n                {\\n                    return steps;\\n                }\\n                for(int i=0;i<node.length();i++)\\n                {\\n                    for(char c=\\'a\\';c<=\\'z\\';c++)\\n                    {\\n                        char x=node[i];\\n                        node[i]=c;\\n                        if(dict.find(node)!=dict.end())\\n                        {\\n                            dict.erase(node);\\n                            q.push(node);\\n                        }\\n                        node[i]=x;\\n                    }\\n                }\\n                n--;\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152214,
                "title": "javascript-bfs",
                "content": "```js\\nfunction ladderLength(beginWord, endWord, wordList) {\\n  let len = 1;\\n  let queue = [beginWord];\\n  const dict = new Set(wordList);\\n  const seen = new Set(queue);\\n  \\n  while (queue.length) {\\n    const next = [];\\n    for (let v of queue) {\\n      if (v === endWord) {\\n        return len;\\n      }\\n      \\n      const arr = v.split(\\'\\');\\n      for (let i = 0; i < arr.length; i++) {\\n        for (let d = 0; d < 26; d++) {\\n          arr[i] = String.fromCharCode(97+d);\\n          const nv = arr.join(\\'\\');\\n          if (!seen.has(nv) && dict.has(nv)) {\\n            next.push(nv);\\n            seen.add(nv);\\n          }\\n          arr[i] = v[i];\\n        }\\n      }\\n    }\\n    queue = next;\\n    len++;\\n  }\\n  \\n  return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction ladderLength(beginWord, endWord, wordList) {\\n  let len = 1;\\n  let queue = [beginWord];\\n  const dict = new Set(wordList);\\n  const seen = new Set(queue);\\n  \\n  while (queue.length) {\\n    const next = [];\\n    for (let v of queue) {\\n      if (v === endWord) {\\n        return len;\\n      }\\n      \\n      const arr = v.split(\\'\\');\\n      for (let i = 0; i < arr.length; i++) {\\n        for (let d = 0; d < 26; d++) {\\n          arr[i] = String.fromCharCode(97+d);\\n          const nv = arr.join(\\'\\');\\n          if (!seen.has(nv) && dict.has(nv)) {\\n            next.push(nv);\\n            seen.add(nv);\\n          }\\n          arr[i] = v[i];\\n        }\\n      }\\n    }\\n    queue = next;\\n    len++;\\n  }\\n  \\n  return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40719,
                "title": "updated-solution-based-on-new-requirement",
                "content": "```\\npublic class Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : wordList) {\\n            set.add(s);\\n        }\\n        if (!set.contains(endWord)) return 0;\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(beginWord);\\n        int step = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                String s = queue.poll();\\n                char[] arr = s.toCharArray();\\n                for (int j = 0; j < arr.length; j++) {\\n                    char original = arr[j];\\n                    for (char c = 'a'; c <= 'z'; c++) {\\n                        if (c == arr[j]) continue;\\n                        arr[j] = c;\\n                        String test = String.valueOf(arr);\\n                        if (test.equals(endWord)) return step + 1;\\n                        if (set.contains(test)) {\\n                            queue.offer(test);\\n                            set.remove(test);\\n                        }\\n                    }\\n                    arr[j] = original;\\n                }\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : wordList) {\\n            set.add(s);\\n        }\\n        if (!set.contains(endWord)) return 0;\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(beginWord);\\n        int step = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                String s = queue.poll();\\n                char[] arr = s.toCharArray();\\n                for (int j = 0; j < arr.length; j++) {\\n                    char original = arr[j];\\n                    for (char c = 'a'; c <= 'z'; c++) {\\n                        if (c == arr[j]) continue;\\n                        arr[j] = c;\\n                        String test = String.valueOf(arr);\\n                        if (test.equals(endWord)) return step + 1;\\n                        if (set.contains(test)) {\\n                            queue.offer(test);\\n                            set.remove(test);\\n                        }\\n                    }\\n                    arr[j] = original;\\n                }\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40920,
                "title": "python-easy-to-understand-bfs-solutions",
                "content": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):                 \\n        deque = collections.deque([beginWord])\\n        ls = string.ascii_lowercase\\n        wordList = set(wordList)\\n        dist = 1\\n        while deque:\\n            size = len(deque)\\n            for _ in range(size): # BFS level by level\\n                word = deque.popleft()\\n                if word == endWord:\\n                    return dist\\n                for i in range(len(word)):\\n                    for c in ls:\\n                        if word[i] != c:\\n                            newWord = word[:i]+c+word[i+1:]\\n                            if newWord in wordList:\\n                                wordList.remove(newWord)\\n                                deque.append(newWord)\\n            dist += 1\\n        return 0\\n    \\n    def ladderLength1(self, beginWord, endWord, wordList):                 \\n        deque = collections.deque([(beginWord, 1)])\\n        ls = string.ascii_lowercase\\n        wordList = set(wordList)\\n        while deque:\\n            word, dist = deque.popleft() # BFS one word by one word\\n            if word == endWord:\\n                return dist\\n            for i in range(len(word)):\\n                for c in ls:\\n                    if word[i] != c:\\n                        newWord = word[:i]+c+word[i+1:]\\n                        if newWord in wordList:\\n                            wordList.remove(newWord)\\n                            deque.append((newWord, dist+1))\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):                 \\n        deque = collections.deque([beginWord])\\n        ls = string.ascii_lowercase\\n        wordList = set(wordList)\\n        dist = 1\\n        while deque:\\n            size = len(deque)\\n            for _ in range(size): # BFS level by level\\n                word = deque.popleft()\\n                if word == endWord:\\n                    return dist\\n                for i in range(len(word)):\\n                    for c in ls:\\n                        if word[i] != c:\\n                            newWord = word[:i]+c+word[i+1:]\\n                            if newWord in wordList:\\n                                wordList.remove(newWord)\\n                                deque.append(newWord)\\n            dist += 1\\n        return 0\\n    \\n    def ladderLength1(self, beginWord, endWord, wordList):                 \\n        deque = collections.deque([(beginWord, 1)])\\n        ls = string.ascii_lowercase\\n        wordList = set(wordList)\\n        while deque:\\n            word, dist = deque.popleft() # BFS one word by one word\\n            if word == endWord:\\n                return dist\\n            for i in range(len(word)):\\n                for c in ls:\\n                    if word[i] != c:\\n                        newWord = word[:i]+c+word[i+1:]\\n                        if newWord in wordList:\\n                            wordList.remove(newWord)\\n                            deque.append((newWord, dist+1))\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400673,
                "title": "clean-javascript-bsf-solution",
                "content": "```\\nfunction ladderLength(beginWord, endWord, wordList) {\\n  const dict = new Set(wordList);\\n  let step = 1;\\n  let q = [beginWord];\\n\\n  while (q.length) {\\n    const next = [];\\n    for (let w of q) {\\n      if (w === endWord) return step;\\n\\n      for (let i = 0; i < w.length; i++) {\\n        for (let j = 0; j < 26; j++) {\\n          const w2 = w.slice(0, i) + String.fromCharCode(97 + j) + w.slice(i + 1);  // 97 -> \\'a\\'\\n\\n          if (dict.has(w2)) {\\n            next.push(w2);\\n            dict.delete(w2);\\n          }\\n        }\\n      }\\n    }\\n    q = next;\\n    step++;\\n  }\\n\\n  return 0;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction ladderLength(beginWord, endWord, wordList) {\\n  const dict = new Set(wordList);\\n  let step = 1;\\n  let q = [beginWord];\\n\\n  while (q.length) {\\n    const next = [];\\n    for (let w of q) {\\n      if (w === endWord) return step;\\n\\n      for (let i = 0; i < w.length; i++) {\\n        for (let j = 0; j < 26; j++) {\\n          const w2 = w.slice(0, i) + String.fromCharCode(97 + j) + w.slice(i + 1);  // 97 -> \\'a\\'\\n\\n          if (dict.has(w2)) {\\n            next.push(w2);\\n            dict.delete(w2);\\n          }\\n        }\\n      }\\n    }\\n    q = next;\\n    step++;\\n  }\\n\\n  return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 339810,
                "title": "python-bi-directional-bfs-great-improvement",
                "content": "Shortest word ladder length = shortest distance. So BFS can be implemented here.\\nEach word is a node. Each neighbour word is one-letter different from origin word and in word list as well:\\n```\\ndef gen_nei_word(word):\\n\\tfor i in range(len(word)):\\n\\t\\tfor c in \\'qwertyuiopasdfghjklzxcvbnm\\':\\n\\t\\t\\tif c != word[i]: yield word[:i]+c+word[i+1:]\\n# yielded nei_word should be in wordList as well.\\n```\\nAnd rest is a BFS routine:\\n```\\ndef ladderLength(beginWord, endWord, wordList):\\n\\twords = set(wordList),\\n\\tif endWord not in words: return 0\\n\\n\\tdef gen_nei_word(word):\\n\\t\\tfor i in range(len(word)):\\n\\t\\t\\tfor c in \\'qwertyuiopasdfghjklzxcvbnm\\':\\n\\t\\t\\t\\tif c != word[i]: yield word[:i]+c+word[i+1:]\\n\\n\\tq, seen = [(beginWord, 1)], {beginWord}\\n\\tfor word, d in q:\\n\\t\\tfor nei_word in gen_nei_word(word):\\n\\t\\t\\tif nei_word == endWord:\\n\\t\\t\\t\\treturn d+1\\n\\t\\t\\tif nei_word in words and nei_word not in seen:\\n\\t\\t\\t\\tseen.add(nei_word)\\n\\t\\t\\t\\tq.append((nei_word, d+1))\\n\\treturn 0\\n```\\nRunning time is 560ms. And we can greatly improve the performance by a bi-directional BFS. As we expand neighboring words group from both beginWord and endWord. For each BFS iteration, we pick the smaller neighboring group to save BFS time.\\nThe bi-directional BFS running time reduces to 100ms\\n```\\ndef ladderLength(beginWord, endWord, wordList):\\n\\twords = set(wordList)\\n\\tif endWord not in words: return 0\\n\\n\\tdef gen_nei_word(word):\\n\\t\\tfor i in range(len(word)):\\n\\t\\t\\tfor c in \\'qwertyuiopasdfghjklzxcvbnm\\':\\n\\t\\t\\t\\tif c != word[i]: yield word[:i]+c+word[i+1:]\\n\\n\\tbegins, ends, d, seen = {beginWord}, {endWord}, 1, {beginWord}\\n\\twhile begins and ends:\\n\\t\\tif len(begins) > len(ends):  # pick the smaller group for next BFS iteration\\n\\t\\t\\tbegins, ends = ends, begins\\n\\t\\tnext_begins = set()\\n\\t\\tfor word in begins:\\n\\t\\t\\tfor nei_word in gen_nei_word(word):\\n\\t\\t\\t\\tif nei_word in ends:\\n\\t\\t\\t\\t\\treturn d+1\\n\\t\\t\\t\\tif nei_word in words and nei_word not in seen:\\n\\t\\t\\t\\t\\tseen.add(nei_word)\\n\\t\\t\\t\\t\\tnext_begins.add(nei_word)\\n\\t\\tbegins, d = next_begins, d+1\\n\\treturn 0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef gen_nei_word(word):\\n\\tfor i in range(len(word)):\\n\\t\\tfor c in \\'qwertyuiopasdfghjklzxcvbnm\\':\\n\\t\\t\\tif c != word[i]: yield word[:i]+c+word[i+1:]\\n# yielded nei_word should be in wordList as well.\\n```\n```\\ndef ladderLength(beginWord, endWord, wordList):\\n\\twords = set(wordList),\\n\\tif endWord not in words: return 0\\n\\n\\tdef gen_nei_word(word):\\n\\t\\tfor i in range(len(word)):\\n\\t\\t\\tfor c in \\'qwertyuiopasdfghjklzxcvbnm\\':\\n\\t\\t\\t\\tif c != word[i]: yield word[:i]+c+word[i+1:]\\n\\n\\tq, seen = [(beginWord, 1)], {beginWord}\\n\\tfor word, d in q:\\n\\t\\tfor nei_word in gen_nei_word(word):\\n\\t\\t\\tif nei_word == endWord:\\n\\t\\t\\t\\treturn d+1\\n\\t\\t\\tif nei_word in words and nei_word not in seen:\\n\\t\\t\\t\\tseen.add(nei_word)\\n\\t\\t\\t\\tq.append((nei_word, d+1))\\n\\treturn 0\\n```\n```\\ndef ladderLength(beginWord, endWord, wordList):\\n\\twords = set(wordList)\\n\\tif endWord not in words: return 0\\n\\n\\tdef gen_nei_word(word):\\n\\t\\tfor i in range(len(word)):\\n\\t\\t\\tfor c in \\'qwertyuiopasdfghjklzxcvbnm\\':\\n\\t\\t\\t\\tif c != word[i]: yield word[:i]+c+word[i+1:]\\n\\n\\tbegins, ends, d, seen = {beginWord}, {endWord}, 1, {beginWord}\\n\\twhile begins and ends:\\n\\t\\tif len(begins) > len(ends):  # pick the smaller group for next BFS iteration\\n\\t\\t\\tbegins, ends = ends, begins\\n\\t\\tnext_begins = set()\\n\\t\\tfor word in begins:\\n\\t\\t\\tfor nei_word in gen_nei_word(word):\\n\\t\\t\\t\\tif nei_word in ends:\\n\\t\\t\\t\\t\\treturn d+1\\n\\t\\t\\t\\tif nei_word in words and nei_word not in seen:\\n\\t\\t\\t\\t\\tseen.add(nei_word)\\n\\t\\t\\t\\t\\tnext_begins.add(nei_word)\\n\\t\\tbegins, d = next_begins, d+1\\n\\treturn 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 201048,
                "title": "12ms-beat-100-java",
                "content": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> beginSet = new HashSet<>();\\n        Set<String> endSet = new HashSet<>();\\n        beginSet.add(beginWord);\\n        endSet.add(endWord);\\n        Set<String> dict = new HashSet<>(wordList);\\n        if(!dict.contains(endWord)) return 0;\\n        return search(beginSet, endSet, dict, true, 1);\\n    }\\n    \\n    private int search(Set<String> beginSet, Set<String> endSet, Set<String> dict, boolean isForward, int cnt){\\n        if(beginSet.isEmpty() || endSet.isEmpty()) return 0;\\n        cnt++;\\n        dict.removeAll(beginSet);\\n        Set<String> nextSet = new HashSet<>();\\n        for(String str : beginSet){\\n            char[] chs = str.toCharArray();\\n            for(int i = 0; i < chs.length; i++){\\n                char c = chs[i];\\n                for(char j = \\'a\\'; j <= \\'z\\'; j++){\\n                    chs[i] = j;\\n                    String tmp = new String(chs);\\n                    if(!dict.contains(tmp)) continue;\\n                    if(endSet.contains(tmp)) return cnt;\\n                    nextSet.add(tmp);\\n                }\\n                chs[i] = c;\\n            }\\n        }\\n        return nextSet.size() > endSet.size() ? search(endSet, nextSet, dict, false, cnt) : search(nextSet, endSet, dict, true, cnt);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> beginSet = new HashSet<>();\\n        Set<String> endSet = new HashSet<>();\\n        beginSet.add(beginWord);\\n        endSet.add(endWord);\\n        Set<String> dict = new HashSet<>(wordList);\\n        if(!dict.contains(endWord)) return 0;\\n        return search(beginSet, endSet, dict, true, 1);\\n    }\\n    \\n    private int search(Set<String> beginSet, Set<String> endSet, Set<String> dict, boolean isForward, int cnt){\\n        if(beginSet.isEmpty() || endSet.isEmpty()) return 0;\\n        cnt++;\\n        dict.removeAll(beginSet);\\n        Set<String> nextSet = new HashSet<>();\\n        for(String str : beginSet){\\n            char[] chs = str.toCharArray();\\n            for(int i = 0; i < chs.length; i++){\\n                char c = chs[i];\\n                for(char j = \\'a\\'; j <= \\'z\\'; j++){\\n                    chs[i] = j;\\n                    String tmp = new String(chs);\\n                    if(!dict.contains(tmp)) continue;\\n                    if(endSet.contains(tmp)) return cnt;\\n                    nextSet.add(tmp);\\n                }\\n                chs[i] = c;\\n            }\\n        }\\n        return nextSet.size() > endSet.size() ? search(endSet, nextSet, dict, false, cnt) : search(nextSet, endSet, dict, true, cnt);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40946,
                "title": "56ms-c-recursive-solution",
                "content": "Inspired by the 2-ended solution:\\nhttps://leetcode.com/discuss/28573/share-my-two-end-bfs-in-c-80ms\\n\\n\\n    class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordDict) {\\n            unordered_set<string> s1 = {beginWord}; // Front end\\n            unordered_set<string> s2 = {endWord}; // Back end\\n            wordDict.erase(beginWord);\\n            wordDict.erase(endWord);\\n    \\n            return ladderLength(s1, s2, wordDict, 1);\\n        }\\n        \\n    private:\\n        int ladderLength(unordered_set<string>& s1, unordered_set<string>& s2, unordered_set<string>& wordDict, int level) {\\n            if (s1.empty()) // We can't find one.\\n                return 0;\\n                \\n            unordered_set<string> s3; // s3 stores all words 1 step from s1.\\n            for (auto word : s1) {\\n                \\n                for (auto& ch : word) {\\n                    auto originalCh = ch;\\n                    \\n                    for (ch = 'a'; ch <= 'z'; ++ ch) {\\n                        \\n                        if (ch != originalCh) {\\n                           \\n                            if (s2.count(word))  // We found one.\\n                                return level + 1;\\n                            \\n                            if (wordDict.count(word)) {\\n                                wordDict.erase(word); // Avoid duplicates.\\n                                s3.insert(word);\\n                            }\\n                        }\\n                    }\\n                    \\n                    ch = originalCh;\\n                }\\n            }\\n            // Continue with the one with smaller size.    \\n            return (s2.size() <= s3.size()) ? ladderLength(s2, s3, wordDict, level + 1) : ladderLength(s3, s2, wordDict, level + 1);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordDict) {\\n            unordered_set<string> s1 = {beginWord}",
                "codeTag": "Java"
            },
            {
                "id": 337706,
                "title": "swift-swift-translated-example-of-leetcode-solution",
                "content": "This isn\\'t anything fancy. I just translated the solution from the Solution explanation tab, but I feel like this is easy to understand and pretty straightforward.\\n\\n```swift\\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\\n        \\n        var hash = [String: [String]]()\\n        \\n        for word in wordList {\\n            \\n            for i in 0..<beginWord.count {\\n                \\n                var w = Array(word)\\n                w[i] = \"*\"\\n                \\n                hash[String(w), default: [String]()].append(word)\\n            }\\n        }\\n        \\n        var q = [(word: String, level: Int)]()\\n        var visited = Set<String>()\\n        \\n        q.append((beginWord, 1))\\n        visited.insert(beginWord)\\n        \\n        while !q.isEmpty {\\n            \\n            let (word, level) = q.removeFirst()\\n            \\n            for i in 0..<beginWord.count {\\n                \\n                var w = Array(word)\\n                w[i] = \"*\"\\n                \\n                let words = hash[String(w), default: [String]()]\\n                \\n                if words.contains(endWord) {\\n                    return level + 1\\n                }\\n                \\n                for word in words {\\n                    if !visited.contains(word) {\\n                        q.append((word, level + 1))\\n                        visited.insert(word)\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return 0\\n    }\\n```",
                "solutionTags": [],
                "code": "```swift\\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\\n        \\n        var hash = [String: [String]]()\\n        \\n        for word in wordList {\\n            \\n            for i in 0..<beginWord.count {\\n                \\n                var w = Array(word)\\n                w[i] = \"*\"\\n                \\n                hash[String(w), default: [String]()].append(word)\\n            }\\n        }\\n        \\n        var q = [(word: String, level: Int)]()\\n        var visited = Set<String>()\\n        \\n        q.append((beginWord, 1))\\n        visited.insert(beginWord)\\n        \\n        while !q.isEmpty {\\n            \\n            let (word, level) = q.removeFirst()\\n            \\n            for i in 0..<beginWord.count {\\n                \\n                var w = Array(word)\\n                w[i] = \"*\"\\n                \\n                let words = hash[String(w), default: [String]()]\\n                \\n                if words.contains(endWord) {\\n                    return level + 1\\n                }\\n                \\n                for word in words {\\n                    if !visited.contains(word) {\\n                        q.append((word, level + 1))\\n                        visited.insert(word)\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return 0\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40845,
                "title": "my-c-bi-directional-bfs-solution-o-n-time-o-n-space-64ms",
                "content": "The basic idea is to do BFS to search the shortest path. The only trick is to speed up the search, we do bi-directional search, in the sense that we may expand the current path to the next level either from the beginWord side or the endWord side, depending on which side has less nodes to be expanded. To implement the BFS, we need the following data structure\\n1) unusedWords is an unordered_set that includes all the words in the dictionary that we haven't visited.\\n2) activeWords[startSet] is an unordered_set that includes all the nodes we are going to expand with BFS.\\n3) activeWords[endSet] is an unordered_set that includes all the ending nodes from the other side (or direction). If a BFS expanded path (from activeWords[startSet]) reaches one of the words in the endSet, then it means we find a shortest path.\\n4) activeWords[nextSet] is an unordered set that saves the ending nodes of  all the BFS expanded paths  \\n(from activeWords[startSet]).\\n5) For each BFS step, we will dynamically decide at which direction we should expand. We always do BFS on the set  that has less nodes. This will reduce the search complexity. So we may swap startSet and endSet.\\n\\nTo do BFS, we go through each word in the startSet, check all possible word it can generate by changing a char, if the new word is in the endSet, then we find a shortest path and just return the current depth. Otherwise, we check if the new word is unuseded (i.e. in unusedWords), if yes, add the new word to nextSet and remove it from unusedWords. If it is visited before, just skip it.\\n\\n    class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordDict) {\\n            \\n            int srcLen = beginWord.size(), destLen = endWord.size(), dictSize = wordDict.size();\\n            if((srcLen != destLen) || !srcLen || !dictSize) return 0; // abnormal cases, return 0; // abnormal cases, just return 0\\n            \\n            unordered_set<string> unusedWords = wordDict; // words that never visited before\\n            unordered_set<string> activeWords[3];\\n            int startSet = 0, endSet = 1, nextSet = 2, curDepth = 2, i;\\n            char tempC, j;\\n             \\n            activeWords[startSet].insert(beginWord);\\n            activeWords[endSet].insert(endWord);\\n            unusedWords.erase(beginWord);\\n            unusedWords.erase(endWord);\\n    \\n            while(!activeWords[startSet].empty()) \\n            { // do BFS on startSet\\n                for(auto it : activeWords[startSet])\\n                {\\n                    for(i = 0 ; i<srcLen; ++i)\\n                    {\\n                        for( tempC = it[i], j='a'; j<='z'; ++j)\\n                        {\\n                            if(tempC == j) continue;\\n                            it[i] = j;  \\n                            if(activeWords[endSet].count(it)>0)\\n                                return curDepth ;// if the new word is in the endSet, then we find a path\\n                            if(unusedWords.count(it))\\n                            { // otherwise, if it is a new word that has never been visited\\n                                activeWords[nextSet].insert(it);\\n                                unusedWords.erase(it); \\n                            }\\n                        }// FOR j\\n                        it[i] = tempC;\\n                    } // FOR i\\n                } //FOR it\\n                ++curDepth;\\n                swap(startSet, nextSet); // swap the startSet and the nextSet\\n                if(activeWords[startSet].size() > activeWords[endSet].size()) swap(startSet, endSet); // if needed, switch the search direction \\n                activeWords[nextSet].clear();\\n            }\\n            return 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordDict) {\\n            \\n            int srcLen = beginWord.size(), destLen = endWord.size(), dictSize = wordDict.size();\\n            if((srcLen != destLen) || !srcLen || !dictSize) return 0; // abnormal cases, return 0; // abnormal cases, just return 0\\n            \\n            unordered_set<string> unusedWords = wordDict; // words that never visited before\\n            unordered_set<string> activeWords[3];\\n            int startSet = 0, endSet = 1, nextSet = 2, curDepth = 2, i;\\n            char tempC, j;\\n             \\n            activeWords[startSet].insert(beginWord);\\n            activeWords[endSet].insert(endWord);\\n            unusedWords.erase(beginWord);\\n            unusedWords.erase(endWord);\\n    \\n            while(!activeWords[startSet].empty()) \\n            { // do BFS on startSet\\n                for(auto it : activeWords[startSet])\\n                {\\n                    for(i = 0 ; i<srcLen; ++i)\\n                    {\\n                        for( tempC = it[i], j='a'; j<='z'; ++j)\\n                        {\\n                            if(tempC == j) continue;\\n                            it[i] = j;  \\n                            if(activeWords[endSet].count(it)>0)\\n                                return curDepth ;// if the new word is in the endSet, then we find a path\\n                            if(unusedWords.count(it))\\n                            { // otherwise, if it is a new word that has never been visited\\n                                activeWords[nextSet].insert(it);\\n                                unusedWords.erase(it); \\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 1935353,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\\n\\t\\tvar res = false\\n\\t\\tvar count = 1\\n        var wordSet = Set(wordList)\\n\\t\\tvar queue: [String] = [beginWord]\\n\\t\\t\\n        loop: \\n        while queue.count > 0 {\\n\\t\\t\\tcount += 1\\n\\t\\t\\tvar list: [String] = []\\n\\t\\t\\t\\n            for word in queue {\\n\\t\\t\\t\\tlist += nextWords(word, &wordSet)\\n\\t\\t\\t\\tif list.contains(endWord) {\\n\\t\\t\\t\\t\\tres = true\\n\\t\\t\\t\\t\\tbreak loop\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n            queue = list\\n\\t\\t}\\n        \\n\\t\\treturn res == true ? count : 0\\n    }\\n    \\n    \\n    func nextWords(_ word: String, _ wordSet: inout Set<String>) -> [String] {\\n\\t\\tvar res: [String] = []\\n\\t\\tvar chars = Array(word)\\n\\t\\tlet alphabeta = Array(\"abcdefghijklmnopqrstvuwxyz\")\\n\\t\\t\\n        for (i, char) in chars.enumerated() {\\n\\t\\t\\tfor c in alphabeta {\\n\\t\\t\\t\\tif c == char { continue } \\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tchars[i] = c\\n\\t\\t\\t\\t\\tlet string = String(chars)\\n\\t\\t\\t\\t\\tif wordSet.contains(string) {\\n\\t\\t\\t\\t\\t\\tres.append(string)\\n\\t\\t\\t\\t\\t\\twordSet.remove(string)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                \\n\\t\\t\\t\\tchars[i] = char\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn res\\n\\t}\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\\n\\t\\tvar res = false\\n\\t\\tvar count = 1\\n        var wordSet = Set(wordList)\\n\\t\\tvar queue: [String] = [beginWord]\\n\\t\\t\\n        loop: \\n        while queue.count > 0 {\\n\\t\\t\\tcount += 1\\n\\t\\t\\tvar list: [String] = []\\n\\t\\t\\t\\n            for word in queue {\\n\\t\\t\\t\\tlist += nextWords(word, &wordSet)\\n\\t\\t\\t\\tif list.contains(endWord) {\\n\\t\\t\\t\\t\\tres = true\\n\\t\\t\\t\\t\\tbreak loop\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n            queue = list\\n\\t\\t}\\n        \\n\\t\\treturn res == true ? count : 0\\n    }\\n    \\n    \\n    func nextWords(_ word: String, _ wordSet: inout Set<String>) -> [String] {\\n\\t\\tvar res: [String] = []\\n\\t\\tvar chars = Array(word)\\n\\t\\tlet alphabeta = Array(\"abcdefghijklmnopqrstvuwxyz\")\\n\\t\\t\\n        for (i, char) in chars.enumerated() {\\n\\t\\t\\tfor c in alphabeta {\\n\\t\\t\\t\\tif c == char { continue } \\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tchars[i] = c\\n\\t\\t\\t\\t\\tlet string = String(chars)\\n\\t\\t\\t\\t\\tif wordSet.contains(string) {\\n\\t\\t\\t\\t\\t\\tres.append(string)\\n\\t\\t\\t\\t\\t\\twordSet.remove(string)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n                \\n\\t\\t\\t\\tchars[i] = char\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn res\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765593,
                "title": "easy-python-bfs-solution-96-50-faster",
                "content": "\\n```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        wordList=set(wordList)\\n        if endWord not in wordList:\\n            return 0\\n        que=[beginWord]\\n        j=0\\n        while que:\\n            j=j+1\\n            l=len(que)\\n            while l:\\n                curr=que[0]\\n                del que[0]\\n                for i in range(len(curr)):\\n                    for k in range(ord(\"a\"),ord(\"z\")+1):\\n                        new_word=curr[:i]+chr(k)+curr[i+1:]\\n                        if new_word==endWord:\\n                            return j+1\\n                        if new_word in wordList:\\n                            que.append(new_word)\\n                            wordList.remove(new_word)\\n                l=l-1\\n        return 0\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        wordList=set(wordList)\\n        if endWord not in wordList:\\n            return 0\\n        que=[beginWord]\\n        j=0\\n        while que:\\n            j=j+1\\n            l=len(que)\\n            while l:\\n                curr=que[0]\\n                del que[0]\\n                for i in range(len(curr)):\\n                    for k in range(ord(\"a\"),ord(\"z\")+1):\\n                        new_word=curr[:i]+chr(k)+curr[i+1:]\\n                        if new_word==endWord:\\n                            return j+1\\n                        if new_word in wordList:\\n                            que.append(new_word)\\n                            wordList.remove(new_word)\\n                l=l-1\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 40879,
                "title": "c-52ms-100-two-ends-bfs-solutions",
                "content": "    class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) {\\n            int res = 1;\\n            unordered_set<string> set1 {beginWord};\\n            unordered_set<string> set2 {endWord};\\n            \\n            while (set1.size()) {\\n                res++;\\n                unordered_set<string> set;\\n                for (auto word : set1) wordList.erase(word);\\n                for (auto word :set1) {\\n                    for (size_t i = 0; i < word.size(); ++i) {\\n                        string next = word;\\n                        for (char c = 'a'; c <= 'z'; ++c) {\\n                            next[i] = c;\\n                            if (wordList.find(next) == wordList.end()) continue;\\n                            if (set2.find(next) != set2.end()) return res;\\n                            set.insert(next);\\n                        }\\n                    }\\n                }\\n                set1 = set.size() < set2.size() ? set : set2;\\n                set2 = set.size() < set2.size() ? set2 : set;\\n            }\\n            \\n            return 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) {\\n            int res = 1;\\n            unordered_set<string> set1 {beginWord}",
                "codeTag": "Java"
            },
            {
                "id": 1664784,
                "title": "java-bfs-approach-time-complexity-explained",
                "content": "```\\nclass Solution {\\n    /*\\n    Approach:\\n    Similar to BFS, we will start from beginWord and insert that into a queue\\n    now from this word, we will see all possible words we can reach by replacing one character\\n    at a time with any character lying between a to z.\\n    If new word equals endWord and exists in dictionary we will return there adding 1 to counter.\\n    If new word exists in our dictionary, we will add that in our queue and remove that\\n    from our dictionary. We will do this for all possible words.\\n    Now whatever words are there in queue, they will be of same level \\n    (those words have been reached from same level word). So once all words of queue are processed at a \\n    level, we will increase our counter.\\n    */\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Queue<String> queue = new LinkedList<>();\\n        // converting to set as set remove() takes O(1) time while list remove() takes O(n)\\n        HashSet<String> dict = new HashSet<>(wordList);\\n        if(!dict.contains(endWord)){\\n            return 0;\\n        }\\n        if(beginWord.equals(endWord)){\\n            return 1;\\n        }\\n        \\n        queue.add(beginWord);\\n        int count = 1; // 1 for beginWord\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            // for all words at current level\\n            for(int i=0; i<size; i++){\\n                char[] word = queue.poll().toCharArray();\\n                // we will replace each char one by one with [a,z] and check if it exists in our dictionary\\n                for(int j=0; j<word.length; j++){\\n                    char tmp = word[j];\\n                    for(char c=\\'a\\'; c<=\\'z\\'; c++){\\n                        word[j] = c;\\n                        String newWord = new String(word); // next word after replacing jth character\\n                        if(dict.contains(newWord)){\\n                            if(newWord.equals(endWord)){\\n                                return count + 1;\\n                            }\\n                            queue.add(newWord);\\n                            dict.remove(newWord);\\n                        }\\n                    }\\n                    word[j] = tmp; // resetting to actual word for next iteration of inner for loop.\\n                }\\n            }\\n            // we have checked for all next words reachable from current queue, Hence\\n            count += 1; \\n        }\\n        // reaching here means we have not found endWord, yet return 0\\n        return 0;\\n    }\\n    \\n    /*\\n    Time Complexity: N is size of dictionary, M is say length of each word\\n    O(N) - to iterate over each word of dictionary\\n    O(M) - to convert word to char array\\n    O(M) - looping for each char\\n    26 - to reach each possible word from a word\\n    O(M) - to convert charArray to String\\n    O(M) - to compare two words\\n    Inner for loop --> O(M)*26* (O(M) + O(M)) --> O(M^2)\\n    Time Complexity including outer-inner for loop --> O(N) * ( O(M)+O(M^2) )\\n    Final Time Complexity - O(N*M^2)\\n    */\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Approach:\\n    Similar to BFS, we will start from beginWord and insert that into a queue\\n    now from this word, we will see all possible words we can reach by replacing one character\\n    at a time with any character lying between a to z.\\n    If new word equals endWord and exists in dictionary we will return there adding 1 to counter.\\n    If new word exists in our dictionary, we will add that in our queue and remove that\\n    from our dictionary. We will do this for all possible words.\\n    Now whatever words are there in queue, they will be of same level \\n    (those words have been reached from same level word). So once all words of queue are processed at a \\n    level, we will increase our counter.\\n    */\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Queue<String> queue = new LinkedList<>();\\n        // converting to set as set remove() takes O(1) time while list remove() takes O(n)\\n        HashSet<String> dict = new HashSet<>(wordList);\\n        if(!dict.contains(endWord)){\\n            return 0;\\n        }\\n        if(beginWord.equals(endWord)){\\n            return 1;\\n        }\\n        \\n        queue.add(beginWord);\\n        int count = 1; // 1 for beginWord\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            // for all words at current level\\n            for(int i=0; i<size; i++){\\n                char[] word = queue.poll().toCharArray();\\n                // we will replace each char one by one with [a,z] and check if it exists in our dictionary\\n                for(int j=0; j<word.length; j++){\\n                    char tmp = word[j];\\n                    for(char c=\\'a\\'; c<=\\'z\\'; c++){\\n                        word[j] = c;\\n                        String newWord = new String(word); // next word after replacing jth character\\n                        if(dict.contains(newWord)){\\n                            if(newWord.equals(endWord)){\\n                                return count + 1;\\n                            }\\n                            queue.add(newWord);\\n                            dict.remove(newWord);\\n                        }\\n                    }\\n                    word[j] = tmp; // resetting to actual word for next iteration of inner for loop.\\n                }\\n            }\\n            // we have checked for all next words reachable from current queue, Hence\\n            count += 1; \\n        }\\n        // reaching here means we have not found endWord, yet return 0\\n        return 0;\\n    }\\n    \\n    /*\\n    Time Complexity: N is size of dictionary, M is say length of each word\\n    O(N) - to iterate over each word of dictionary\\n    O(M) - to convert word to char array\\n    O(M) - looping for each char\\n    26 - to reach each possible word from a word\\n    O(M) - to convert charArray to String\\n    O(M) - to compare two words\\n    Inner for loop --> O(M)*26* (O(M) + O(M)) --> O(M^2)\\n    Time Complexity including outer-inner for loop --> O(N) * ( O(M)+O(M^2) )\\n    Final Time Complexity - O(N*M^2)\\n    */\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489534,
                "title": "classic-bfs-javascript-readable-code-for-humans-with-comments",
                "content": "```js\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    // building connections.\\n    // i.e) *ot: [hot, dot, lot], h*t: [hot], ...\\n    let adjacentWordsMap = {}\\n    for(let word of wordList) {\\n        for(let i =0; i<word.length; i++) {\\n            let newWord = word.substring(0, i) + \\'*\\' + word.substring(i+1)\\n            if(!adjacentWordsMap[newWord]) {\\n                adjacentWordsMap[newWord] = []\\n            }\\n            adjacentWordsMap[newWord].push(word)\\n            \\n        }\\n    }\\n    \\n    // BFS\\n    let queue = [[beginWord, 1]]\\n    let visited = {[beginWord]: true}\\n    while(queue.length !==0) {\\n        let [word, level] = queue.shift()\\n        for(let i =0; i<word.length; i++) {\\n            let newWord = word.substring(0,i) + \\'*\\' + word.substring(i+1)\\n            let adjacentWords = adjacentWordsMap[newWord]\\n            if(adjacentWords) {\\n                for(let item of adjacentWords) {\\n                    if(item === endWord) {\\n                        return level +1\\n                    }\\n                    if(!visited[item]) {\\n                        visited[item] = true\\n                        queue.push([item,level+1])\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    // not found, return 0\\n    return 0\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    // building connections.\\n    // i.e) *ot: [hot, dot, lot], h*t: [hot], ...\\n    let adjacentWordsMap = {}\\n    for(let word of wordList) {\\n        for(let i =0; i<word.length; i++) {\\n            let newWord = word.substring(0, i) + \\'*\\' + word.substring(i+1)\\n            if(!adjacentWordsMap[newWord]) {\\n                adjacentWordsMap[newWord] = []\\n            }\\n            adjacentWordsMap[newWord].push(word)\\n            \\n        }\\n    }\\n    \\n    // BFS\\n    let queue = [[beginWord, 1]]\\n    let visited = {[beginWord]: true}\\n    while(queue.length !==0) {\\n        let [word, level] = queue.shift()\\n        for(let i =0; i<word.length; i++) {\\n            let newWord = word.substring(0,i) + \\'*\\' + word.substring(i+1)\\n            let adjacentWords = adjacentWordsMap[newWord]\\n            if(adjacentWords) {\\n                for(let item of adjacentWords) {\\n                    if(item === endWord) {\\n                        return level +1\\n                    }\\n                    if(!visited[item]) {\\n                        visited[item] = true\\n                        queue.push([item,level+1])\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    // not found, return 0\\n    return 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40861,
                "title": "quite-neat-solution-yet-beating-95-submissions-in-c",
                "content": "The current accepted time is 60ms but if we remove this line \\n\\n> if(forward.size() > backward.size()) backward.swap(forward);\\n\\nit will dramatically fall back to 336ms, what a story!\\n\\nB.T.W. if we do not erase the words in the backward from wordList, we can further accelerate this solution to `56ms`. Little bit weird here.\\n\\n----------\\n\\n\\n    class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) \\n        {\\n            if(beginWord == endWord) return 2;\\n            int depth = 1;\\n            unordered_set<string> forward, backward;\\n            forward.insert(beginWord);\\n            backward.insert(endWord);\\n            while(!forward.empty())\\n            {\\n                unordered_set<string> nextLevel;\\n                for(auto& w: forward) wordList.erase(w);\\n                for(auto& w: backward) wordList.erase(w);\\n                for(auto& word: forward)\\n                {\\n                    string cur(word);\\n                    for(auto& c: cur)\\n                    {\\n                        char c0 = c;\\n                        for(c = 'a'; c <= 'z'; ++c)\\n                        {\\n                            if(c != c0)\\n                            {\\n                                if(backward.count(cur)) return depth+1;\\n                                if(wordList.count(cur)) nextLevel.insert(cur);\\n                            }\\n                        }\\n                        c = c0;\\n                    }\\n                }\\n                depth++;\\n                forward.swap(nextLevel);\\n                if(forward.size() > backward.size()) backward.swap(forward);\\n            }\\n            return 0;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) \\n        {\\n            if(beginWord == endWord) return 2;\\n            int depth = 1;\\n            unordered_set<string> forward, backward;\\n            forward.insert(beginWord);\\n            backward.insert(endWord);\\n            while(!forward.empty())\\n            {\\n                unordered_set<string> nextLevel;\\n                for(auto& w: forward) wordList.erase(w);\\n                for(auto& w: backward) wordList.erase(w);\\n                for(auto& word: forward)\\n                {\\n                    string cur(word);\\n                    for(auto& c: cur)\\n                    {\\n                        char c0 = c;\\n                        for(c = 'a'; c <= 'z'; ++c)\\n                        {\\n                            if(c != c0)\\n                            {\\n                                if(backward.count(cur)) return depth+1;\\n                                if(wordList.count(cur)) nextLevel.insert(cur);\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 40816,
                "title": "strange-c-code-failed-the-a-c-a-b-c-case-in-oj-but-passed-in-vs2012",
                "content": "The following code output '2' in VS 2012 for the test case below (please free to try it). But OJ kept output '0', so failed.\\n\\nInput:      \"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:    0\\nExpected:    2\\n\\nWhat's the problem?\\n\\nThanks!\\n\\n    public class Solution\\n            {\\n                public int LadderLength(string beginWord, string endWord, ISet<string> wordDict)\\n                {\\n                    Queue<string> q = new Queue<string>();\\n                    q.Enqueue(beginWord);\\n                    int qcc = 1, qcn = 0, N = beginWord.Length, level = 1;\\n                    while (q.Count() > 0)\\n                    {\\n                        string qf = q.Peek();\\n                        q.Dequeue();\\n                        qcc--;\\n                        //varying by 1\\n                        string qf0 = qf;\\n                        for (int i = 0; i < N; i++)\\n                        {\\n                            //char c=qf[i];\\n                            for (int j = 0; j < 26; j++)\\n                            {\\n                                if (qf[i] == (char)('a' + j))\\n                                    continue;\\n                                string sc = \"\";\\n                                sc += (char)('a' + j); //sick of this\\n                                string s2 = qf.Insert(i, sc).Remove(i + 1, 1);\\n                                if (wordDict.Contains(s2))\\n                                {\\n                                    if (s2 == endWord)\\n                                        return level + 1; //+1!\\n                                    q.Enqueue(s2);\\n                                    wordDict.Remove(s2);\\n                                    qcn++;\\n                                }\\n                                \\n                            }\\n                            //qf[i] = c;\\n                            qf = qf0;\\n                        }\\n                        if (qcc == 0)\\n                        {\\n                            qcc = qcn;\\n                            qcn = 0;\\n                            level++;\\n                        }\\n                    }\\n                    return 0;\\n                }\\n            }\\n            class Program\\n            {\\n                static void Main(string[] args)\\n                {\\n                    Solution sl = new Solution();\\n                    HashSet<string> hs3 = new HashSet<string> { \"a\", \"b\", \"c\" };\\n                    int yyue = sl.LadderLength(\"a\", \"c\", hs3);\\n                }\\n            }",
                "solutionTags": [],
                "code": "class Solution\\n            {\\n                public int LadderLength(string beginWord, string endWord, ISet<string> wordDict)\\n                {\\n                    Queue<string> q = new Queue<string>();\\n                    q.Enqueue(beginWord);\\n                    int qcc = 1, qcn = 0, N = beginWord.Length, level = 1;\\n                    while (q.Count() > 0)\\n                    {\\n                        string qf = q.Peek();\\n                        q.Dequeue();\\n                        qcc--;\\n                        //varying by 1\\n                        string qf0 = qf;\\n                        for (int i = 0; i < N; i++)\\n                        {\\n                            //char c=qf[i];\\n                            for (int j = 0; j < 26; j++)\\n                            {\\n                                if (qf[i] == (char)('a' + j))\\n                                    continue;\\n                                string sc = \"\";\\n                                sc += (char)('a' + j); //sick of this\\n                                string s2 = qf.Insert(i, sc).Remove(i + 1, 1);\\n                                if (wordDict.Contains(s2))\\n                                {\\n                                    if (s2 == endWord)\\n                                        return level + 1; //+1!\\n                                    q.Enqueue(s2);\\n                                    wordDict.Remove(s2);\\n                                    qcn++;\\n                                }",
                "codeTag": "Java"
            },
            {
                "id": 3414354,
                "title": "python-easy-bfs-solution",
                "content": "```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        wordList=set(wordList)\\n        if endWord not in wordList:\\n            return 0\\n        q=deque()\\n        q.append((beginWord,1))\\n        while q:\\n            word,step=q.popleft()\\n            for i in range(len(beginWord)):\\n                for j in range(26):\\n                    new=word[:i]+chr(97+j)+word[i+1:]\\n                    if new==endWord:\\n                        return step+1\\n                    if new in wordList:\\n                        q.append((new,step+1))\\n                        wordList.remove(new)\\n        return 0\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        wordList=set(wordList)\\n        if endWord not in wordList:\\n            return 0\\n        q=deque()\\n        q.append((beginWord,1))\\n        while q:\\n            word,step=q.popleft()\\n            for i in range(len(beginWord)):\\n                for j in range(26):\\n                    new=word[:i]+chr(97+j)+word[i+1:]\\n                    if new==endWord:\\n                        return step+1\\n                    if new in wordList:\\n                        q.append((new,step+1))\\n                        wordList.remove(new)\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1793712,
                "title": "solution-swift-word-ladder",
                "content": "```swift\\nclass Solution {\\n    private let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\\n        guard beginWord.count == endWord.count else { return 0 }\\n        \\n        var words = Set<String>(wordList)\\n        var queue: [(String, Int)] = [(beginWord, 1)]\\n        \\n        while !queue.isEmpty {\\n            let (word, step) = queue.removeFirst()\\n            guard word != endWord else { return step }\\n            \\n            for i in 0..<word.count {\\n                var chars = Array(word)\\n                for ch in alphabet where ch != chars[i] {\\n                    chars[i] = ch\\n                    let modified = String(chars)\\n                    guard words.contains(modified) else { continue }\\n                    words.remove(modified)\\n                    queue.append((modified, step + 1))\\n                }\\n            }\\n        }\\n        return 0\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.019 (0.021) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\\n    func test0() {\\n        let value = solution.ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\\n    func test1() {\\n        let value = solution.ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    private let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n    func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {\\n        guard beginWord.count == endWord.count else { return 0 }\\n        \\n        var words = Set<String>(wordList)\\n        var queue: [(String, Int)] = [(beginWord, 1)]\\n        \\n        while !queue.isEmpty {\\n            let (word, step) = queue.removeFirst()\\n            guard word != endWord else { return step }\\n            \\n            for i in 0..<word.count {\\n                var chars = Array(word)\\n                for ch in alphabet where ch != chars[i] {\\n                    chars[i] = ch\\n                    let modified = String(chars)\\n                    guard words.contains(modified) else { continue }\\n                    words.remove(modified)\\n                    queue.append((modified, step + 1))\\n                }\\n            }\\n        }\\n        return 0\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\\n    func test0() {\\n        let value = solution.ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\\n    func test1() {\\n        let value = solution.ladderLength(\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764673,
                "title": "c-bfs",
                "content": "This is a straightforward bfs problem. \\nIdea is to run bfs from beginword (i.e push it into the queue with distance from the begin word , here 0)and create all possible strings from it , If any of those strings are also present  in the wordlist and not visited earlier ,push them  into the queue , increment the distance value and mark it is as visited.(Don\\'t forget to mark the beginword visited as well.) \\nIf at any moment , we find the endword , returns its distance( It is the shortest distance from beginword to endword . )or return 0;\\n\\n```\\n    int ladderLength(string b, string e, vector<string>& l) {\\n        int n=b.size();\\n    string tot=\"abcdefghijklmnopqrstuvwxyz\";\\n\\n         unordered_set<string>hp;\\n         unordered_map<string,bool>vis;\\n        \\n        for(auto &i: l)\\n        {\\n            hp.insert(i);\\n        }\\n        \\n        if(hp.count(e)==0)return 0;\\n        \\n        queue<pair<string,int>>q;\\n        q.push({b,0});\\n        \\n        vis[b]=true;\\n        \\n        while(q.size())\\n        {\\n            auto it=q.front();\\n            q.pop();\\n            string s=it.first;\\n            int dis=it.second;\\n            if(s==e){\\n                return dis+1;\\n            }\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<tot.size();j++)\\n                {\\n                    string ao=s;\\n                    ao[i]=tot[j];\\n                    if(hp.count(ao) && vis[ao]!=true)\\n                    {\\n                        vis[ao]=true;\\n                        q.push({ao,dis+1});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }****",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "This is a straightforward bfs problem. \\nIdea is to run bfs from beginword (i.e push it into the queue with distance from the begin word , here 0)and create all possible strings from it , If any of those strings are also present  in the wordlist and not visited earlier ,push them  into the queue , increment the distance value and mark it is as visited.(Don\\'t forget to mark the beginword visited as well.) \\nIf at any moment , we find the endword , returns its distance( It is the shortest distance from beginword to endword . )or return 0;\\n\\n```\\n    int ladderLength(string b, string e, vector<string>& l) {\\n        int n=b.size();\\n    string tot=\"abcdefghijklmnopqrstuvwxyz\";\\n\\n         unordered_set<string>hp;\\n         unordered_map<string,bool>vis;\\n        \\n        for(auto &i: l)\\n        {\\n            hp.insert(i);\\n        }\\n        \\n        if(hp.count(e)==0)return 0;\\n        \\n        queue<pair<string,int>>q;\\n        q.push({b,0});\\n        \\n        vis[b]=true;\\n        \\n        while(q.size())\\n        {\\n            auto it=q.front();\\n            q.pop();\\n            string s=it.first;\\n            int dis=it.second;\\n            if(s==e){\\n                return dis+1;\\n            }\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<tot.size();j++)\\n                {\\n                    string ao=s;\\n                    ao[i]=tot[j];\\n                    if(hp.count(ao) && vis[ao]!=true)\\n                    {\\n                        vis[ao]=true;\\n                        q.push({ao,dis+1});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }****",
                "codeTag": "Unknown"
            },
            {
                "id": 1226030,
                "title": "easy-bfs-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int ladderLength(string b, string e, vector<string>& wordList)\\n    {\\n        unordered_set<string>dict;\\n        queue<pair<string,int>>q;\\n        for(int i=0;i<wordList.size();i++)\\n        {\\n            dict.insert(wordList[i]);\\n        }\\n        q.push({b,1});\\n        while(!q.empty())\\n        {\\n            auto node=q.front();\\n            q.pop();\\n            if(node.first==e)\\n            {\\n                return node.second;\\n            }\\n            for(int i=0;i<node.first.length();i++)\\n            {\\n                string tmp=node.first;\\n                for(char c=\\'a\\';c<=\\'z\\';c++)\\n                {\\n                    char x=tmp[i];\\n                    tmp[i]=c;\\n                    if(dict.find(tmp)!=dict.end())\\n                    {\\n                        q.push({tmp,node.second+1});\\n                        dict.erase(tmp);\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Please upvote if you have got any help from my code. Thank you.**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int ladderLength(string b, string e, vector<string>& wordList)\\n    {\\n        unordered_set<string>dict;\\n        queue<pair<string,int>>q;\\n        for(int i=0;i<wordList.size();i++)\\n        {\\n            dict.insert(wordList[i]);\\n        }\\n        q.push({b,1});\\n        while(!q.empty())\\n        {\\n            auto node=q.front();\\n            q.pop();\\n            if(node.first==e)\\n            {\\n                return node.second;\\n            }\\n            for(int i=0;i<node.first.length();i++)\\n            {\\n                string tmp=node.first;\\n                for(char c=\\'a\\';c<=\\'z\\';c++)\\n                {\\n                    char x=tmp[i];\\n                    tmp[i]=c;\\n                    if(dict.find(tmp)!=dict.end())\\n                    {\\n                        q.push({tmp,node.second+1});\\n                        dict.erase(tmp);\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523284,
                "title": "simple-python-bfs-solution-ac",
                "content": "```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        wordList = set(wordList)\\n        q=[(beginWord,1)]\\n        for word,d in q:\\n            if word==endWord:\\n                return d\\n            for i in range(len(word)):\\n                for char in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                    tmp=word[:i]+char+word[i+1:]\\n                    if tmp in wordList:\\n                        q.append([tmp,d+1])\\n                        wordList.remove(tmp)\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        wordList = set(wordList)\\n        q=[(beginWord,1)]\\n        for word,d in q:\\n            if word==endWord:\\n                return d\\n            for i in range(len(word)):\\n                for char in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                    tmp=word[:i]+char+word[i+1:]\\n                    if tmp in wordList:\\n                        q.append([tmp,d+1])\\n                        wordList.remove(tmp)\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444447,
                "title": "java-bfs-less-complicated-that-from-solution-with-comments",
                "content": "```\\nclass Solution {\\n    private class Node {\\n        String val;\\n        int level;\\n        \\n        Node(String val, int level) {\\n            this.val = val;\\n            this.level = level;\\n        }\\n    }\\n    \\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {       \\n        // Breadth First Search\\n        Queue<Node> queue = new LinkedList();\\n        \\n        // put original world as a root node\\n        queue.add(new Node(beginWord, 0));\\n        \\n        // don\\'t check words twice\\n        Set<String> checked = new HashSet();\\n        \\n        while(!queue.isEmpty()) {\\n            Node word = queue.remove();\\n            \\n            if(word.val.equals(endWord)) {\\n                return word.level + 1;\\n            }\\n            \\n            for(String w : wordList) {\\n                String key = w;\\n                if(!checked.contains(key) && isOnlyOneLetterDifference(w, word.val) ) {\\n                    queue.add(new Node(w, word.level + 1));\\n                    checked.add(key);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    /*\\n    * validate two strings\\n    * rule: only one letter can be changed at a time\\n    */\\n    private boolean isOnlyOneLetterDifference(String current, String destination) {\\n        // the rule: all words have the same length.\\n        if(current.length() != destination.length()) {\\n            return false;\\n        }\\n        \\n        int count = 0;\\n        for(int i=0; i < current.length(); i++) {\\n            if(current.charAt(i) != destination.charAt(i)) {\\n                count++;\\n                \\n                if(count > 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private class Node {\\n        String val;\\n        int level;\\n        \\n        Node(String val, int level) {\\n            this.val = val;\\n            this.level = level;\\n        }\\n    }\\n    \\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {       \\n        // Breadth First Search\\n        Queue<Node> queue = new LinkedList();\\n        \\n        // put original world as a root node\\n        queue.add(new Node(beginWord, 0));\\n        \\n        // don\\'t check words twice\\n        Set<String> checked = new HashSet();\\n        \\n        while(!queue.isEmpty()) {\\n            Node word = queue.remove();\\n            \\n            if(word.val.equals(endWord)) {\\n                return word.level + 1;\\n            }\\n            \\n            for(String w : wordList) {\\n                String key = w;\\n                if(!checked.contains(key) && isOnlyOneLetterDifference(w, word.val) ) {\\n                    queue.add(new Node(w, word.level + 1));\\n                    checked.add(key);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    /*\\n    * validate two strings\\n    * rule: only one letter can be changed at a time\\n    */\\n    private boolean isOnlyOneLetterDifference(String current, String destination) {\\n        // the rule: all words have the same length.\\n        if(current.length() != destination.length()) {\\n            return false;\\n        }\\n        \\n        int count = 0;\\n        for(int i=0; i < current.length(); i++) {\\n            if(current.charAt(i) != destination.charAt(i)) {\\n                count++;\\n                \\n                if(count > 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return count == 1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40876,
                "title": "clean-two-way-bfs-in-python",
                "content": "    class Solution(object):\\n        def ladderLength(self, beginWord, endWord, wordList):\\n            forward, backward, n, r = {beginWord}, {endWord}, len(beginWord), 2\\n            while forward and backward:\\n                if len(forward) > len(backward):\\n                    forward, backward = backward, forward\\n    \\n                next = set()\\n                for word in forward:\\n                    for i, char in enumerate(word):\\n                        first, second = word[:i], word[i + 1:]\\n                        for item in string.ascii_lowercase:\\n                            candidate = first + item + second\\n                            if candidate in backward:\\n                                return r\\n    \\n                            if candidate in wordList:\\n                                wordList.discard(candidate)\\n                                next.add(candidate)\\n                forward = next\\n                r += 1\\n            return 0",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution(object):\\n        def ladderLength(self, beginWord, endWord, wordList):\\n            forward, backward, n, r = {beginWord}",
                "codeTag": "Java"
            },
            {
                "id": 40888,
                "title": "a-25-line-1204ms-bfs-solution",
                "content": "The following is a BFS solution. Any suggestion for improvement of my code is welcome. Is there any other solution better than BFS?\\n\\n    class Solution {\\n        public:\\n            int ladderLength(string start, string end, unordered_set<string> &dict) {\\n                unordered_map<string, int> dis; // store the distance from start to the current word\\n                queue<string> q; // FIFO for bfs purpose\\n                dis[start] = 1;\\n                q.push(start);\\n                while (!q.empty()) {\\n                    string word = q.front(); q.pop();\\n                    if (word == end) break;\\n                    for (int i = 0; i < word.size(); i++) {\\n                        for (int j = 0; j < 26; j++) {\\n                            string newWord = word;\\n                            newWord[i] = 'a' + j;\\n                            if (dict.count(newWord) > 0 && dis.count(newWord) == 0) {\\n                                dis[newWord] = dis[word] + 1;\\n                                q.push(newWord);\\n                            }\\n                        }\\n                    }\\n                }\\n                if (dis.count(end) == 0) return 0;\\n                return dis[end];\\n            }\\n        };",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public:\\n            int ladderLength(string start, string end, unordered_set<string> &dict) {\\n                unordered_map<string, int> dis; // store the distance from start to the current word\\n                queue<string> q; // FIFO for bfs purpose\\n                dis[start] = 1;\\n                q.push(start);\\n                while (!q.empty()) {\\n                    string word = q.front(); q.pop();\\n                    if (word == end) break;\\n                    for (int i = 0; i < word.size(); i++) {\\n                        for (int j = 0; j < 26; j++) {\\n                            string newWord = word;\\n                            newWord[i] = 'a' + j;\\n                            if (dict.count(newWord) > 0 && dis.count(newWord) == 0) {\\n                                dis[newWord] = dis[word] + 1;\\n                                q.push(newWord);\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 1765042,
                "title": "python-3-breadth-first-search-solution-and-explanation",
                "content": "# [Python 3]  \\uD83D\\uDD0E\\uD83D\\uDD0D Breadth First Search Solution and Explanation\\n\\n### In order to solve this question we have put  hashMap and BFS together to save time we will explained it below. You can see by using hashMap we improved time complexity from O(M * N^2) to O(M^2 *N)\\n\\n\\n## \\u274C 1\\uFE0F\\u20E3 Approach 1: Just BFS (TLE)\\u274C\\n* We use BFS to find all possible transformation and keep track with level to find shortest sequence\\n### In BFS Queue\\n> Step 1. We naive search every other element in wordList\\n O(N)\\n>Step 2. Every time we see a new word. First check if it is visited, and we compare two words **letter by letter** and count different and put it in the queue if it\\'s valid\\nO(M)\\n## Complexity Analysis\\n* Time Complexity: **O(M * N^2)**, where M is the length of each word and N is the total number of words in the input word list.\\n> Because we have traverse through queue take O(N) and in the queue we search every word in wordList O(N) and compare letter by letter takes O(M) => **O(M * N^2)**\\n* Space: O(M * N) : Queue will at worst store every element in wordList\\n## BFS Code\\n```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        if endWord not in wordList:\\n            return 0\\n        return self.bfs(beginWord, endWord, wordList)\\n        \\n    def bfs(self, beginWord, endWord, wordList):\\n        visited = {}\\n        visited[beginWord] = True\\n        queue = deque([])\\n        self.appendInQueue(beginWord, 1, wordList, queue, visited)\\n        while queue:\\n            popWord, level = queue.popleft()\\n            visited[popWord] = True\\n            if popWord == endWord:\\n                return level\\n            self.appendInQueue(popWord, level, wordList, queue, visited)\\n        return 0\\n    \\n        \\n    def appendInQueue(self, word, level, wordList, queue, visited):\\n        for s in wordList:\\n            if s not in visited and self.checkOneLetter(word, s):\\n                queue.append((s, level + 1))\\n    \\n    def checkOneLetter(self, s1, s2):\\n        count = 0\\n        for c1, c2 in zip(s1, s2):\\n            if c1 != c2 :\\n                count +=1\\n            if count >1:\\n                return False\\n        return True\\n```\\n\\n## \\u2714\\uFE0F 2\\uFE0F\\u20E3 Improved Approach : Using HashMap \\u2714\\uFE0F\\n* This time we dont traverse through wordList and compare letter by letter.\\n* We build a hashMap, whichs key store \\'a*c\\', \\'*bc \\' for example, we use \\' * \\' sign to indicate that we can take transformation in that key and store as lists \\n* So in the buildHash function we build a wordHash, which store every possible transformation\\n\\n## Complexity Analysis\\n* Time Complexity: **O(M ^2 * N)**, where M is the length of each word and N is the total number of words in the input word list.\\n> We build hashMap iterate through wordList O(N) and each time we use iterate through length of word and addup \\'*\\', prefix and suffix takes O(M^2) => **O(M^2*N)**\\n> In breadth first search, we still at worst traverse through all element in wordList O(N), and iterate through popWord, and build the key of hashMap same as before take O(M^2) = > **O(M^2*N)**\\n* Space Complexity **O(M^2*N)** : O(M^2 *N) + O(M * N) + O(M * N)= O(M^2*N)\\n\\n\\n## Using HashMap Code\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        if endWord not in wordList:\\n            return 0\\n        \\n        wordHash = self.buildHash(wordList)\\n        \\n        return self.bfs(beginWord, endWord, wordHash)\\n        \\n    def bfs(self, beginWord, endWord, wordHash):\\n        visited = {}\\n        queue = deque([[beginWord, 1]]) # every element store [word, level]\\n        while queue:\\n            popWord, level = queue.popleft()\\n            visited[popWord] = True\\n            \\n            for i in range(len(popWord)):\\n                prefix = popWord[:i]\\n                suffix = popWord[i + 1:]\\n                key = prefix + \\'*\\' + suffix # key value\\n                # Traverse through and find next word to be append in queue\\n                for nextWord in wordHash[key]:\\n                    # End point\\n                    if nextWord == endWord:\\n                        return level + 1 \\n                    # Append next word in queue\\n                    if nextWord not in visited:\\n                        queue.append([nextWord, level + 1])\\n                # To prevent trverse same key again and find all visited\\n                wordHash[key] = [] \\n        return 0\\n    \\n    \\n    def buildHash(self, wordList):\\n        wordHash = defaultdict(list)\\n        for word in wordList:\\n            # Put * in every possible index and add up its prefix and suffix\\n            for i in range(len(wordList[0])):\\n                prefix = word[:i]\\n                suffix = word[i + 1:]\\n                wordHash[prefix + \\'*\\' + suffix].append(word)\\n        return wordHash\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        if endWord not in wordList:\\n            return 0\\n        return self.bfs(beginWord, endWord, wordList)\\n        \\n    def bfs(self, beginWord, endWord, wordList):\\n        visited = {}\\n        visited[beginWord] = True\\n        queue = deque([])\\n        self.appendInQueue(beginWord, 1, wordList, queue, visited)\\n        while queue:\\n            popWord, level = queue.popleft()\\n            visited[popWord] = True\\n            if popWord == endWord:\\n                return level\\n            self.appendInQueue(popWord, level, wordList, queue, visited)\\n        return 0\\n    \\n        \\n    def appendInQueue(self, word, level, wordList, queue, visited):\\n        for s in wordList:\\n            if s not in visited and self.checkOneLetter(word, s):\\n                queue.append((s, level + 1))\\n    \\n    def checkOneLetter(self, s1, s2):\\n        count = 0\\n        for c1, c2 in zip(s1, s2):\\n            if c1 != c2 :\\n                count +=1\\n            if count >1:\\n                return False\\n        return True\\n```\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        if endWord not in wordList:\\n            return 0\\n        \\n        wordHash = self.buildHash(wordList)\\n        \\n        return self.bfs(beginWord, endWord, wordHash)\\n        \\n    def bfs(self, beginWord, endWord, wordHash):\\n        visited = {}\\n        queue = deque([[beginWord, 1]]) # every element store [word, level]\\n        while queue:\\n            popWord, level = queue.popleft()\\n            visited[popWord] = True\\n            \\n            for i in range(len(popWord)):\\n                prefix = popWord[:i]\\n                suffix = popWord[i + 1:]\\n                key = prefix + \\'*\\' + suffix # key value\\n                # Traverse through and find next word to be append in queue\\n                for nextWord in wordHash[key]:\\n                    # End point\\n                    if nextWord == endWord:\\n                        return level + 1 \\n                    # Append next word in queue\\n                    if nextWord not in visited:\\n                        queue.append([nextWord, level + 1])\\n                # To prevent trverse same key again and find all visited\\n                wordHash[key] = [] \\n        return 0\\n    \\n    \\n    def buildHash(self, wordList):\\n        wordHash = defaultdict(list)\\n        for word in wordList:\\n            # Put * in every possible index and add up its prefix and suffix\\n            for i in range(len(wordList[0])):\\n                prefix = word[:i]\\n                suffix = word[i + 1:]\\n                wordHash[prefix + \\'*\\' + suffix].append(word)\\n        return wordHash\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009676,
                "title": "word-ladder-c-bfs-solution",
                "content": "This solution starts from endWord and uses breadth-first search to work its way back to find beginWord.\\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        queue<string> q;\\n        unordered_set<string> notSeen; \\n        \\n        for (string s : wordList) {\\n            notSeen.insert(s);\\n        }\\n        \\n        if (notSeen.count(endWord) > 0) {\\n            q.push(endWord);\\n        }\\n        else return 0; \\n        \\n        int length = 0;\\n        \\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n            length++;\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < beginWord.length(); j++) {\\n                    string front = q.front();\\n                    for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                        front[j] = c; \\n                        \\n                        if (front == beginWord) return length + 1;\\n\\t\\t\\t\\t\\t\\t\\n                        if (notSeen.count(front) > 0) {\\n                            q.push(front);\\n                            notSeen.erase(front);\\n                        }\\n                    }\\n                }\\n                q.pop(); \\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        queue<string> q;\\n        unordered_set<string> notSeen; \\n        \\n        for (string s : wordList) {\\n            notSeen.insert(s);\\n        }\\n        \\n        if (notSeen.count(endWord) > 0) {\\n            q.push(endWord);\\n        }\\n        else return 0; \\n        \\n        int length = 0;\\n        \\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n            length++;\\n            for (int i = 0; i < size; i++) {\\n                for (int j = 0; j < beginWord.length(); j++) {\\n                    string front = q.front();\\n                    for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                        front[j] = c; \\n                        \\n                        if (front == beginWord) return length + 1;\\n\\t\\t\\t\\t\\t\\t\\n                        if (notSeen.count(front) > 0) {\\n                            q.push(front);\\n                            notSeen.erase(front);\\n                        }\\n                    }\\n                }\\n                q.pop(); \\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767803,
                "title": "c-simple-bfs",
                "content": "```csharp\\npublic int LadderLength(string beginWord, string endWord, IList<string> wordList) \\n{\\n\\tHashSet<string> words = new HashSet<string>(wordList);\\n\\tHashSet<string> visited = new HashSet<string>();\\n\\tQueue<string> queue = new Queue<string>();\\n\\n\\tqueue.Enqueue(beginWord);\\n\\tvisited.Add(beginWord);\\n\\n\\tint level = 0;\\n\\twhile(queue.Count > 0)\\n\\t{\\n\\t\\tlevel++;\\n\\t\\tint count = queue.Count;\\n\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\tvar currentWord = queue.Dequeue();\\n\\t\\t\\tif(currentWord.Equals(endWord, StringComparison.Ordinal))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn level;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchar[] letters = currentWord.ToCharArray();\\n\\t\\t\\tfor(int j = 0; j < currentWord.Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int k = 0; k < 26; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tchar currentChar = letters[j];\\n\\t\\t\\t\\t\\tletters[j] = (char)(\\'a\\' + k);\\n\\n\\t\\t\\t\\t\\tstring newWord = new String(letters);\\n\\t\\t\\t\\t\\tif(words.Contains(newWord) && !visited.Contains(newWord))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvisited.Add(newWord);\\n\\t\\t\\t\\t\\t\\tqueue.Enqueue(newWord);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tletters[j] = currentChar;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}\\n\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int LadderLength(string beginWord, string endWord, IList<string> wordList) \\n{\\n\\tHashSet<string> words = new HashSet<string>(wordList);\\n\\tHashSet<string> visited = new HashSet<string>();\\n\\tQueue<string> queue = new Queue<string>();\\n\\n\\tqueue.Enqueue(beginWord);\\n\\tvisited.Add(beginWord);\\n\\n\\tint level = 0;\\n\\twhile(queue.Count > 0)\\n\\t{\\n\\t\\tlevel++;\\n\\t\\tint count = queue.Count;\\n\\n\\t\\tfor(int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\tvar currentWord = queue.Dequeue();\\n\\t\\t\\tif(currentWord.Equals(endWord, StringComparison.Ordinal))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn level;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchar[] letters = currentWord.ToCharArray();\\n\\t\\t\\tfor(int j = 0; j < currentWord.Length; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int k = 0; k < 26; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tchar currentChar = letters[j];\\n\\t\\t\\t\\t\\tletters[j] = (char)(\\'a\\' + k);\\n\\n\\t\\t\\t\\t\\tstring newWord = new String(letters);\\n\\t\\t\\t\\t\\tif(words.Contains(newWord) && !visited.Contains(newWord))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvisited.Add(newWord);\\n\\t\\t\\t\\t\\t\\tqueue.Enqueue(newWord);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tletters[j] = currentChar;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}\\n\\n\\treturn 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323362,
                "title": "c-100-beat-double-headed-dragon-greedy-pick-smallest-set",
                "content": "Okay, I have now thoroughly studied this problem and this is the most efficient way to do it.\\n\\nA single-directional BFS going forward or backwards ends up having too many branches towards the destination end of the search - so we start from both ends and try to meet in the middle.\\n\\nHowever, we don\\'t just blindly probe from both sides. Whichever running-solution is the smallest, we will continue our search from. This will tend towards faster performance (test it out if you don\\'t believe me, just flip the \"<\" with a \">\".\\n\\nOn average, we should not even visit all of the words in the list, so our performance should be better than O(N). However, we are building up a dictionary of all the words, which occurs in O(N) time, so our actual run-time complexity ends up being:\\n\\nO(WORD_LENGTH * WORD_COUNT)\\n\\nWe also have a worst case space complexity of:\\n\\nO(WORD_LENGTH * WORD_COUNT)\\n\\nnote: \"getNeighbors\" could word by searching through the list and finding words which are 1 letter different from the current word. For some test cases, this would be a faster approach. In this solution, we are trying every single letter at every single slot. This ends up performing faster for THIS DATA.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mWordLen;\\n    unordered_set<string> mDictionary;\\n    vector<string> mNeighbors;\\n    \\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        mWordLen = beginWord.size();\\n            \\n        mDictionary = unordered_set<string>(wordList.begin(), wordList.end());\\n        \\n        if (mDictionary.count(endWord) == 0) { return 0; }\\n        \\n        //\"hog\"\\n        //\"cog\"\\n        //[\"cog\"] We need the beginWord available as a neighbor for tricky test cases.\\n        mDictionary.insert(beginWord);\\n        \\n        unordered_set<string> aForwardSet, aBackwardSet, aNextSet, aBlockedSet;\\n        unordered_set<string> *aSmallSet, *aLargeSet;\\n        \\n        aForwardSet.emplace(beginWord);\\n        aBackwardSet.emplace(endWord);\\n        \\n        int aDepth = 1;\\n        \\n        while (aForwardSet.size() != 0 && aBackwardSet.size() != 0) {\\n            \\n            if (aForwardSet.size() < aBackwardSet.size()) {\\n                aSmallSet = &aForwardSet;\\n                aLargeSet = &aBackwardSet;\\n            } else {\\n                aSmallSet = &aBackwardSet;\\n                aLargeSet = &aForwardSet;\\n            }\\n            \\n            ++aDepth;\\n            \\n            for (auto aWord : *aSmallSet) {\\n                getNeighbors(aWord);\\n                for (auto aNeighbor : mNeighbors) {\\n                    if (aLargeSet->count(aNeighbor) != 0) { return aDepth; }\\n                    if (aBlockedSet.count(aNeighbor) != 0) { continue; }\\n                    \\n                    aNextSet.emplace(aNeighbor);\\n                    aBlockedSet.emplace(aNeighbor);\\n                }\\n            }\\n            \\n            aSmallSet->clear();\\n            swap(*aSmallSet, aNextSet);\\n            aNextSet.clear();\\n        }\\n        return 0;\\n    }\\n    \\n    void getNeighbors(string &pWord) {\\n        mNeighbors.clear();\\n        char aHold, aChar;\\n        for (int i=0;i<mWordLen;i++) {\\n            aHold = pWord[i];\\n            for (aChar=\\'a\\';aChar<=\\'z\\';aChar++) {\\n                if (aChar != aHold) {\\n                    pWord[i] = aChar;\\n                    if (mDictionary.count(pWord) != 0) {\\n                        mNeighbors.push_back(pWord);\\n                    }\\n                }\\n            }\\n            pWord[i] = aHold;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mWordLen;\\n    unordered_set<string> mDictionary;\\n    vector<string> mNeighbors;\\n    \\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        mWordLen = beginWord.size();\\n            \\n        mDictionary = unordered_set<string>(wordList.begin(), wordList.end());\\n        \\n        if (mDictionary.count(endWord) == 0) { return 0; }\\n        \\n        //\"hog\"\\n        //\"cog\"\\n        //[\"cog\"] We need the beginWord available as a neighbor for tricky test cases.\\n        mDictionary.insert(beginWord);\\n        \\n        unordered_set<string> aForwardSet, aBackwardSet, aNextSet, aBlockedSet;\\n        unordered_set<string> *aSmallSet, *aLargeSet;\\n        \\n        aForwardSet.emplace(beginWord);\\n        aBackwardSet.emplace(endWord);\\n        \\n        int aDepth = 1;\\n        \\n        while (aForwardSet.size() != 0 && aBackwardSet.size() != 0) {\\n            \\n            if (aForwardSet.size() < aBackwardSet.size()) {\\n                aSmallSet = &aForwardSet;\\n                aLargeSet = &aBackwardSet;\\n            } else {\\n                aSmallSet = &aBackwardSet;\\n                aLargeSet = &aForwardSet;\\n            }\\n            \\n            ++aDepth;\\n            \\n            for (auto aWord : *aSmallSet) {\\n                getNeighbors(aWord);\\n                for (auto aNeighbor : mNeighbors) {\\n                    if (aLargeSet->count(aNeighbor) != 0) { return aDepth; }\\n                    if (aBlockedSet.count(aNeighbor) != 0) { continue; }\\n                    \\n                    aNextSet.emplace(aNeighbor);\\n                    aBlockedSet.emplace(aNeighbor);\\n                }\\n            }\\n            \\n            aSmallSet->clear();\\n            swap(*aSmallSet, aNextSet);\\n            aNextSet.clear();\\n        }\\n        return 0;\\n    }\\n    \\n    void getNeighbors(string &pWord) {\\n        mNeighbors.clear();\\n        char aHold, aChar;\\n        for (int i=0;i<mWordLen;i++) {\\n            aHold = pWord[i];\\n            for (aChar=\\'a\\';aChar<=\\'z\\';aChar++) {\\n                if (aChar != aHold) {\\n                    pWord[i] = aChar;\\n                    if (mDictionary.count(pWord) != 0) {\\n                        mNeighbors.push_back(pWord);\\n                    }\\n                }\\n            }\\n            pWord[i] = aHold;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175476,
                "title": "bfs-java-with-path-print",
                "content": "**Thought**\\nThere is a binary relationship between two words, which is natural to Graph. If we regard a word as a node, its neighbour should be all possible words that exist in wordList and differ from the word by only one letter.\\nThe shortest distance is asked, so we apply BFS.\\nTo print the path is actually to figure out a way to save edges. Thus, we establish `nodeToParent`.\\n**Code**\\n```\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        Map<String, String> nodeToParent = new HashMap<>(); // key: node, value: its parent(the node it is transformed from); Also acts like visited set for BFS.\\n        \\n        Set<String> wordSet = new HashSet<>(wordList);\\n        \\n        // Corner cases.\\n        if (!wordSet.contains(endWord)) {\\n            return 0;\\n        }\\n        \\n        Queue<String> queue = new LinkedList<>(); // Queue for BFS.\\n        queue.offer(beginWord);\\n        nodeToParent.put(beginWord, beginWord);\\n        int level = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();        \\n            for (int k = 0; k < size; k++) {\\n                String node = queue.poll();           \\n                for (int i = 0; i < node.length(); i++) {\\n                    char[] charArray = node.toCharArray();\\n                    char curCh = charArray[i];\\n                    for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                        if (ch != curCh) {\\n                            charArray[i] = ch;\\n                            String neighbour = new String(charArray); \\n                            if (neighbour.equals(endWord)) {\\n                                // To print path.\\n                                nodeToParent.put(neighbour, node);\\n                                printPath(endWord, nodeToParent);\\n                                \\n                                return level + 1;\\n                            }\\n                            if (!nodeToParent.containsKey(neighbour) && wordSet.contains(neighbour)) {\\n                                nodeToParent.put(neighbour, node);\\n                                queue.offer(neighbour);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            level++;  \\n        }\\n        \\n        \\n        return 0;\\n    }\\n    \\n    public void printPath(String endWord, Map<String, String> nodeToParent) {\\n        \\n        Deque<String> deque = new ArrayDeque<>();\\n        String curWord = endWord;\\n        deque.push(curWord);\\n        while (!nodeToParent.get(curWord).equals(curWord)) {\\n            curWord = nodeToParent.get(curWord);\\n            deque.push(curWord);\\n        }\\n        while (!deque.isEmpty())\\n            System.out.print(deque.pop() + \" \");\\n    }\\n```\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        Map<String, String> nodeToParent = new HashMap<>(); // key: node, value: its parent(the node it is transformed from); Also acts like visited set for BFS.\\n        \\n        Set<String> wordSet = new HashSet<>(wordList);\\n        \\n        // Corner cases.\\n        if (!wordSet.contains(endWord)) {\\n            return 0;\\n        }\\n        \\n        Queue<String> queue = new LinkedList<>(); // Queue for BFS.\\n        queue.offer(beginWord);\\n        nodeToParent.put(beginWord, beginWord);\\n        int level = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();        \\n            for (int k = 0; k < size; k++) {\\n                String node = queue.poll();           \\n                for (int i = 0; i < node.length(); i++) {\\n                    char[] charArray = node.toCharArray();\\n                    char curCh = charArray[i];\\n                    for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                        if (ch != curCh) {\\n                            charArray[i] = ch;\\n                            String neighbour = new String(charArray); \\n                            if (neighbour.equals(endWord)) {\\n                                // To print path.\\n                                nodeToParent.put(neighbour, node);\\n                                printPath(endWord, nodeToParent);\\n                                \\n                                return level + 1;\\n                            }\\n                            if (!nodeToParent.containsKey(neighbour) && wordSet.contains(neighbour)) {\\n                                nodeToParent.put(neighbour, node);\\n                                queue.offer(neighbour);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            level++;  \\n        }\\n        \\n        \\n        return 0;\\n    }\\n    \\n    public void printPath(String endWord, Map<String, String> nodeToParent) {\\n        \\n        Deque<String> deque = new ArrayDeque<>();\\n        String curWord = endWord;\\n        deque.push(curWord);\\n        while (!nodeToParent.get(curWord).equals(curWord)) {\\n            curWord = nodeToParent.get(curWord);\\n            deque.push(curWord);\\n        }\\n        while (!deque.isEmpty())\\n            System.out.print(deque.pop() + \" \");\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 115990,
                "title": "c-clean-and-simple-solution-using-bfs-accepted",
                "content": "```\npublic struct LadderEntry\n{\n    public string word;\n    public int ladderLength;\n    public LadderEntry(string word, int ladderLength)\n    {\n        this.ladderLength = ladderLength;\n        this.word = word;\n    }\n}\n\npublic class Solution \n{\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) \n    {\n        Queue<LadderEntry> queue = new Queue<LadderEntry>();\n        queue.Enqueue(new LadderEntry(beginWord, 1));\n        bool[] visited = new bool[wordList.Count];\n        while (queue.Count > 0)\n        {\n            LadderEntry curr = queue.Dequeue();\n            for (int i = 0; i < wordList.Count; i++)\n            {\n                if (!visited[i] && IsOneLetterApart(curr.word, wordList[i]))\n                {\n                    if (wordList[i] == endWord) return curr.ladderLength + 1;   //If we reached target.\n                    queue.Enqueue(new LadderEntry(wordList[i], curr.ladderLength + 1));\n                    visited[i] = true;   //This word is not processed again.\n                }\n            }\n        }\n        return 0;\n    }   \n    \n    private static bool IsOneLetterApart(string firstWord, string secondWord)\n    {\n        int diff = 0;\n        for (int i = 0; i < firstWord.Length; i++)\n        {\n            if (firstWord[i] != secondWord[i]) diff++;\n            if (diff > 1) return false;\n        }\n        return diff == 1;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\npublic struct LadderEntry\n{\n    public string word;\n    public int ladderLength;\n    public LadderEntry(string word, int ladderLength)\n    {\n        this.ladderLength = ladderLength;\n        this.word = word;\n    }\n}\n\npublic class Solution \n{\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) \n    {\n        Queue<LadderEntry> queue = new Queue<LadderEntry>();\n        queue.Enqueue(new LadderEntry(beginWord, 1));\n        bool[] visited = new bool[wordList.Count];\n        while (queue.Count > 0)\n        {\n            LadderEntry curr = queue.Dequeue();\n            for (int i = 0; i < wordList.Count; i++)\n            {\n                if (!visited[i] && IsOneLetterApart(curr.word, wordList[i]))\n                {\n                    if (wordList[i] == endWord) return curr.ladderLength + 1;   //If we reached target.\n                    queue.Enqueue(new LadderEntry(wordList[i], curr.ladderLength + 1));\n                    visited[i] = true;   //This word is not processed again.\n                }\n            }\n        }\n        return 0;\n    }   \n    \n    private static bool IsOneLetterApart(string firstWord, string secondWord)\n    {\n        int diff = 0;\n        for (int i = 0; i < firstWord.Length; i++)\n        {\n            if (firstWord[i] != secondWord[i]) diff++;\n            if (diff > 1) return false;\n        }\n        return diff == 1;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 40776,
                "title": "clear-javascript-solution-using-bidirectional-bfs-of-graph",
                "content": "```\\nclass GraphNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.children = [];\\n    }\\n    \\n    addChild(node) {\\n        this.children.push(node);\\n        return this;\\n    }\\n}\\n\\nclass Graph {\\n    constructor() {\\n        this.nodes = new Map();\\n    }\\n    \\n    add(val1, val2) {\\n        const node1 = this.nodes.get(val1) || new GraphNode(val1);\\n        const node2 = this.nodes.get(val2) || new GraphNode(val2);\\n        this.nodes.set(val1, node1.addChild(node2));\\n        this.nodes.set(val2, node2.addChild(node1));\\n    }\\n    \\n    get(val) {\\n        return this.nodes.get(val);\\n    }\\n}\\n\\nfunction ladderLength(beginWord, endWord, wordList) {\\n    wordList.push(beginWord);\\n    const graph = buildGraph(wordList);\\n\\n    let nodeBegin = graph.get(beginWord);\\n    let nodeEnd = graph.get(endWord);\\n    if (!nodeEnd) return 0;\\n    nodeBegin.distance = nodeEnd.distance = 1;\\n    nodeBegin.visitedBegin = nodeEnd.visitedEnd = true;\\n    \\n    const queueBegin = [nodeBegin];\\n    const queueEnd = [nodeEnd];\\n    \\n    while (queueBegin.length || queueEnd.length) {\\n        nodeBegin = queueBegin.shift() || new GraphNode();\\n        nodeEnd = queueEnd.shift() || new GraphNode();\\n\\n        for (let child of nodeBegin.children) {\\n            if (child.visitedEnd) {\\n                return nodeBegin.distance + child.distance;\\n            } else if (!child.visitedBegin) {\\n                child.distance = nodeBegin.distance + 1;\\n                child.visitedBegin = true;\\n                queueBegin.push(child);\\n            }\\n        }\\n        \\n        for (let child of nodeEnd.children) {\\n            if (child.visitedBegin) {\\n                return nodeEnd.distance + child.distance;\\n            } else if (!child.visitedEnd) {\\n                child.distance = nodeEnd.distance + 1;\\n                child.visitedEnd = true;\\n                queueEnd.push(child);\\n            }\\n        }\\n    }\\n    \\n    return 0;\\n}\\n\\nfunction buildGraph(wordList) {\\n    const graph = new Graph();\\n    const wordSet = new Set(wordList);\\n    const a = 'a'.charCodeAt(0);\\n\\n    for (let word of wordSet) {\\n        for (let i = 0; i < word.length; i++) {\\n            for (let j = 0; j < 26; j++) {\\n                let transWord = word.substring(0, i) + String.fromCharCode(a + j) + word.substr(i + 1);\\n                if (wordSet.has(transWord) && transWord !== word) {\\n                    graph.add(word, transWord);\\n                }\\n            }\\n        }\\n    }\\n\\n    return graph;\\n}\\n```\\n`shift` is O(n) but fast in practice for non-large arrays - fast queues don't improve the speed of this particular problem.\\n\\nIf you prefer a less redundant version, `ladderLength` can be factored to:\\n```\\nfunction ladderLength(beginWord, endWord, wordList) {\\n    wordList.push(beginWord);\\n    const graph = buildGraph(wordList);\\n\\n    const nodeEnds = [graph.get(beginWord), graph.get(endWord)];\\n    if (!nodeEnds[1]) return 0;\\n    nodeEnds[0].distance = nodeEnds[1].distance = 1;\\n    nodeEnds[0].visited = [true, false];\\n    nodeEnds[1].visited = [false, true];\\n    \\n    const queues = [[nodeEnds[0]], [nodeEnds[1]]];\\n    \\n    while (queues[0].length || queues[1].length) {\\n        for (let i = 0; i < 2; i++) {\\n            nodeEnds[i] = queues[i].shift() || new GraphNode();\\n            \\n            for (let child of nodeEnds[i].children) {\\n                if (child.visited && child.visited[+!i]) {\\n                    return nodeEnds[i].distance + child.distance;\\n                } else if (!child.visited || !child.visited[i]) {\\n                    child.distance = nodeEnds[i].distance + 1;\\n                    child.visited = child.visited || [false, false];\\n                    child.visited[i] = true;\\n                    queues[i].push(child);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass GraphNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.children = [];\\n    }\\n    \\n    addChild(node) {\\n        this.children.push(node);\\n        return this;\\n    }\\n}\\n\\nclass Graph {\\n    constructor() {\\n        this.nodes = new Map();\\n    }\\n    \\n    add(val1, val2) {\\n        const node1 = this.nodes.get(val1) || new GraphNode(val1);\\n        const node2 = this.nodes.get(val2) || new GraphNode(val2);\\n        this.nodes.set(val1, node1.addChild(node2));\\n        this.nodes.set(val2, node2.addChild(node1));\\n    }\\n    \\n    get(val) {\\n        return this.nodes.get(val);\\n    }\\n}\\n\\nfunction ladderLength(beginWord, endWord, wordList) {\\n    wordList.push(beginWord);\\n    const graph = buildGraph(wordList);\\n\\n    let nodeBegin = graph.get(beginWord);\\n    let nodeEnd = graph.get(endWord);\\n    if (!nodeEnd) return 0;\\n    nodeBegin.distance = nodeEnd.distance = 1;\\n    nodeBegin.visitedBegin = nodeEnd.visitedEnd = true;\\n    \\n    const queueBegin = [nodeBegin];\\n    const queueEnd = [nodeEnd];\\n    \\n    while (queueBegin.length || queueEnd.length) {\\n        nodeBegin = queueBegin.shift() || new GraphNode();\\n        nodeEnd = queueEnd.shift() || new GraphNode();\\n\\n        for (let child of nodeBegin.children) {\\n            if (child.visitedEnd) {\\n                return nodeBegin.distance + child.distance;\\n            } else if (!child.visitedBegin) {\\n                child.distance = nodeBegin.distance + 1;\\n                child.visitedBegin = true;\\n                queueBegin.push(child);\\n            }\\n        }\\n        \\n        for (let child of nodeEnd.children) {\\n            if (child.visitedBegin) {\\n                return nodeEnd.distance + child.distance;\\n            } else if (!child.visitedEnd) {\\n                child.distance = nodeEnd.distance + 1;\\n                child.visitedEnd = true;\\n                queueEnd.push(child);\\n            }\\n        }\\n    }\\n    \\n    return 0;\\n}\\n\\nfunction buildGraph(wordList) {\\n    const graph = new Graph();\\n    const wordSet = new Set(wordList);\\n    const a = 'a'.charCodeAt(0);\\n\\n    for (let word of wordSet) {\\n        for (let i = 0; i < word.length; i++) {\\n            for (let j = 0; j < 26; j++) {\\n                let transWord = word.substring(0, i) + String.fromCharCode(a + j) + word.substr(i + 1);\\n                if (wordSet.has(transWord) && transWord !== word) {\\n                    graph.add(word, transWord);\\n                }\\n            }\\n        }\\n    }\\n\\n    return graph;\\n}\\n```\n```\\nfunction ladderLength(beginWord, endWord, wordList) {\\n    wordList.push(beginWord);\\n    const graph = buildGraph(wordList);\\n\\n    const nodeEnds = [graph.get(beginWord), graph.get(endWord)];\\n    if (!nodeEnds[1]) return 0;\\n    nodeEnds[0].distance = nodeEnds[1].distance = 1;\\n    nodeEnds[0].visited = [true, false];\\n    nodeEnds[1].visited = [false, true];\\n    \\n    const queues = [[nodeEnds[0]], [nodeEnds[1]]];\\n    \\n    while (queues[0].length || queues[1].length) {\\n        for (let i = 0; i < 2; i++) {\\n            nodeEnds[i] = queues[i].shift() || new GraphNode();\\n            \\n            for (let child of nodeEnds[i].children) {\\n                if (child.visited && child.visited[+!i]) {\\n                    return nodeEnds[i].distance + child.distance;\\n                } else if (!child.visited || !child.visited[i]) {\\n                    child.distance = nodeEnds[i].distance + 1;\\n                    child.visited = child.visited || [false, false];\\n                    child.visited[i] = true;\\n                    queues[i].push(child);\\n                }\\n            }\\n        }\\n    }\\n    \\n    return 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631602,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> st(wordList.begin() , wordList.end());\\n        queue<pair<string , int>> q;\\n        q.push({beginWord , 1});\\n        st.erase(beginWord);\\n\\n        while(!q.empty()){\\n            string word = q.front().first;\\n            int steps = q.front().second;\\n            if(word == endWord) return steps;\\n            q.pop();\\n            for(int i=0 ; i<word.size() ; i++){\\n                char original = word[i];\\n                for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++){\\n                    word[i] = ch;                  \\n                    if(st.find(word) != st.end()){\\n                        st.erase(word);\\n                        q.push({word , steps+1});  \\n                    }\\n                }\\n                word[i] = original;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> st(wordList.begin() , wordList.end());\\n        queue<pair<string , int>> q;\\n        q.push({beginWord , 1});\\n        st.erase(beginWord);\\n\\n        while(!q.empty()){\\n            string word = q.front().first;\\n            int steps = q.front().second;\\n            if(word == endWord) return steps;\\n            q.pop();\\n            for(int i=0 ; i<word.size() ; i++){\\n                char original = word[i];\\n                for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++){\\n                    word[i] = ch;                  \\n                    if(st.find(word) != st.end()){\\n                        st.erase(word);\\n                        q.push({word , steps+1});  \\n                    }\\n                }\\n                word[i] = original;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200142,
                "title": "127-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe time complexity of this algorithm is O(M^2 * N), where M is the length of each word and N is the total number of words in the list. The space complexity is also O(M^2 * N) due to the use of the set and queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        # Create a set of words for faster lookup\\n        wordSet = set(wordList)\\n        if endWord not in wordSet:\\n            return 0\\n        \\n        # Initialize queue with the beginWord and set of visited words\\n        queue = deque([(beginWord, 1)])\\n        visited = set([beginWord])\\n        \\n        while queue:\\n            # Dequeue the word and its level\\n            word, level = queue.popleft()\\n            \\n            # Iterate over each character in the word\\n            for i in range(len(word)):\\n                # Iterate over all possible lowercase letters\\n                for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                    # Skip if the character is the same as in the original word\\n                    if c == word[i]:\\n                        continue\\n                    \\n                    # Create the new word by replacing the character at index i\\n                    newWord = word[:i] + c + word[i+1:]\\n                    \\n                    # Check if the new word is in the wordSet and has not been visited before\\n                    if newWord in wordSet and newWord not in visited:\\n                        # Check if the new word is the endWord\\n                        if newWord == endWord:\\n                            return level + 1\\n                        \\n                        # Enqueue the new word and its level\\n                        queue.append((newWord, level + 1))\\n                        \\n                        # Add the new word to the set of visited words\\n                        visited.add(newWord)\\n        \\n        # No transformation sequence exists\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        # Create a set of words for faster lookup\\n        wordSet = set(wordList)\\n        if endWord not in wordSet:\\n            return 0\\n        \\n        # Initialize queue with the beginWord and set of visited words\\n        queue = deque([(beginWord, 1)])\\n        visited = set([beginWord])\\n        \\n        while queue:\\n            # Dequeue the word and its level\\n            word, level = queue.popleft()\\n            \\n            # Iterate over each character in the word\\n            for i in range(len(word)):\\n                # Iterate over all possible lowercase letters\\n                for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                    # Skip if the character is the same as in the original word\\n                    if c == word[i]:\\n                        continue\\n                    \\n                    # Create the new word by replacing the character at index i\\n                    newWord = word[:i] + c + word[i+1:]\\n                    \\n                    # Check if the new word is in the wordSet and has not been visited before\\n                    if newWord in wordSet and newWord not in visited:\\n                        # Check if the new word is the endWord\\n                        if newWord == endWord:\\n                            return level + 1\\n                        \\n                        # Enqueue the new word and its level\\n                        queue.append((newWord, level + 1))\\n                        \\n                        # Add the new word to the set of visited words\\n                        visited.add(newWord)\\n        \\n        # No transformation sequence exists\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991722,
                "title": "o-n-solution-using-string-hashing-hashmap-bfs",
                "content": "# Intuition\\ntry doing brute force\\n\\n# Approach\\n1>Go for brute force\\n2>use bfs as memoization.\\n3>use hashing for matching and changing string.\\n\\n# Complexity\\n- Time complexity:\\nlength of wordList(o(n))\\n\\n- Space complexity:\\nspace of the dictionary i.e. o(n)\\n\\n# Code\\n```\\nfrom collections import deque\\ndef hashword(word):\\n    h=0\\n    c=1\\n    for i in word:\\n        h+=c*(ord(i)-97)\\n        c=c*26\\n    return h\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        d={}\\n        for i in range(len(wordList)):\\n            d[hashword(wordList[i])]=0\\n        h=hashword(beginWord)\\n        q=deque()\\n        q.append(h)\\n        f=hashword(endWord)\\n        q=deque()\\n        q.append([h,1])\\n        if h in d:\\n            d[h]=1\\n        while q:\\n            x=q.popleft()\\n            h=x[0]\\n            ans=x[1]\\n            if h==f:\\n                return ans\\n            c=1\\n            for i in range(10):\\n                for j in range(26):\\n                    y=h-(((h%(c*26))//c)*c)+(c*j)\\n                    if y in d:\\n                        if d[y]==0:\\n                            d[y]=1\\n                            q.append([y,ans+1])\\n                c=c*26\\n        return 0\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search",
                    "Rolling Hash"
                ],
                "code": "```\\nfrom collections import deque\\ndef hashword(word):\\n    h=0\\n    c=1\\n    for i in word:\\n        h+=c*(ord(i)-97)\\n        c=c*26\\n    return h\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        d={}\\n        for i in range(len(wordList)):\\n            d[hashword(wordList[i])]=0\\n        h=hashword(beginWord)\\n        q=deque()\\n        q.append(h)\\n        f=hashword(endWord)\\n        q=deque()\\n        q.append([h,1])\\n        if h in d:\\n            d[h]=1\\n        while q:\\n            x=q.popleft()\\n            h=x[0]\\n            ans=x[1]\\n            if h==f:\\n                return ans\\n            c=1\\n            for i in range(10):\\n                for j in range(26):\\n                    y=h-(((h%(c*26))//c)*c)+(c*j)\\n                    if y in d:\\n                        if d[y]==0:\\n                            d[y]=1\\n                            q.append([y,ans+1])\\n                c=c*26\\n        return 0\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424791,
                "title": "python-97-bfs-brutal-force-and-optimized-bidirectional-bfs-explantion",
                "content": "The main idea: Use BFS to find the shortest path \\n\\nIn **Brutal force** solution:\\n\\tWe simply go through all the possible permutation, until we find the word we want.\\n\\t\\nIn **Bidirectional BFS** solution:\\n\\tWe do almost the same thing, but do it from the front and back simultaneously.\\n\\tIf the front BFS meet the back BFS, we find the shortest route.\\n\\tWith Bidirectional BFS, we can reduce time complexity from O(b^d) to O(b^d/2)\\n\\tThis is how Bidirectional BFS work:\\n\\t![image](https://assets.leetcode.com/users/images/c0fc9adc-a063-4c3e-97a5-9dd2c4c767de_1660486583.5584373.png)\\n\\n\\t\\nHere\\'s the difference between normal BFS and bidirectional BFS: \\n![image](https://assets.leetcode.com/users/images/31a3e83e-3912-4f85-96c7-0a52ad05bc76_1660484943.547603.png)\\n\\n\\t\\n\\nBrutal force BFS solution:\\n(661 ms)\\n```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        # BFS brutal force\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0    # impossible to find route\\n        \\n        wlen = len(beginWord)\\n        \\n        # how many steps to each word\\n        steps = {beginWord: 1}\\n        \\n        q = deque([beginWord])\\n        \\n        while len(q) > 0:\\n            word = q.popleft()\\n            step = steps[word]\\n            \\n            # change every single charactor\\n            for i in range(wlen):\\n                c = word[i]\\n                \\n                # \\'a\\' ~ \\'z\\'\\n                for t in string.ascii_lowercase:\\n                    if c == t: continue     # the chractor is the same \\n                    \\n                    new_word = word[:i] + t + word[i + 1:]\\n                    if new_word == endWord: return step + 1\\n                    if new_word not in wordDict: continue\\n                    \\n                    # remove it from dictionary, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# so we won\\'t go through the same word twice\\n                    wordDict.remove(new_word)        \\n                    steps[new_word] = step + 1\\n                    q.append(new_word)\\n                    \\n        return 0\\n```\\n\\nBidrection BFS solution:\\n(128 ms)\\n```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        # Bidirectional BFS\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0       # impossible to find a route\\n        \\n        wlen = len(beginWord)\\n        s1 = {beginWord}        # s1 starts from the front\\n        s2 = {endWord}          # s2 starts from the back\\n        step = 0\\n        \\n        wordDict.remove(endWord)\\n        \\n        while len(s1) > 0 and len(s2) > 0:\\n            step += 1\\n            \\n            # swap s1 and s2 if s2 is shorter\\n            if len(s1) > len(s2): s1, s2 = s2, s1\\n                \\n            s = set()\\n            for w in s1:\\n                new_words = []\\n                new_words = [w[:i] + t + w[i+1:] for t in string.ascii_lowercase for i in range(wlen)]\\n                \\n                for new_word in new_words:\\n                    \\n                    if new_word in s2: return step + 1    # front and back BFS meet\\n                    if new_word not in wordDict: continue\\n                        \\n                    # remove it from dictionary, \\n                    # so we won\\'t go through the same word twice\\n                    wordDict.remove(new_word)\\n                    s.add(new_word)\\n            s1 = s\\n                    \\n        return 0\\n```\\n**Please UPVOTE if you LIKE**\\n\\n![image](https://assets.leetcode.com/users/images/eb3ece60-4a0a-4fbe-a476-dba4ac358abe_1660484045.4845588.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        # BFS brutal force\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0    # impossible to find route\\n        \\n        wlen = len(beginWord)\\n        \\n        # how many steps to each word\\n        steps = {beginWord: 1}\\n        \\n        q = deque([beginWord])\\n        \\n        while len(q) > 0:\\n            word = q.popleft()\\n            step = steps[word]\\n            \\n            # change every single charactor\\n            for i in range(wlen):\\n                c = word[i]\\n                \\n                # \\'a\\' ~ \\'z\\'\\n                for t in string.ascii_lowercase:\\n                    if c == t: continue     # the chractor is the same \\n                    \\n                    new_word = word[:i] + t + word[i + 1:]\\n                    if new_word == endWord: return step + 1\\n                    if new_word not in wordDict: continue\\n                    \\n                    # remove it from dictionary, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# so we won\\'t go through the same word twice\\n                    wordDict.remove(new_word)        \\n                    steps[new_word] = step + 1\\n                    q.append(new_word)\\n                    \\n        return 0\\n```\n```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        # Bidirectional BFS\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0       # impossible to find a route\\n        \\n        wlen = len(beginWord)\\n        s1 = {beginWord}        # s1 starts from the front\\n        s2 = {endWord}          # s2 starts from the back\\n        step = 0\\n        \\n        wordDict.remove(endWord)\\n        \\n        while len(s1) > 0 and len(s2) > 0:\\n            step += 1\\n            \\n            # swap s1 and s2 if s2 is shorter\\n            if len(s1) > len(s2): s1, s2 = s2, s1\\n                \\n            s = set()\\n            for w in s1:\\n                new_words = []\\n                new_words = [w[:i] + t + w[i+1:] for t in string.ascii_lowercase for i in range(wlen)]\\n                \\n                for new_word in new_words:\\n                    \\n                    if new_word in s2: return step + 1    # front and back BFS meet\\n                    if new_word not in wordDict: continue\\n                        \\n                    # remove it from dictionary, \\n                    # so we won\\'t go through the same word twice\\n                    wordDict.remove(new_word)\\n                    s.add(new_word)\\n            s1 = s\\n                    \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764295,
                "title": "c-fast-easy-solution-explained-commented",
                "content": "**Welcome to abivilion\\'s solution. Kindly Upvote for supporting this article**.\\n\\n\\n**SOLUTION**\\n\\n```\\nclass Solution {\\npublic:\\n    int ladder;\\n    \\n    int bfs(string &beginword,string &endword,unordered_set<string> &st )\\n    {\\n        queue<string> qq; // BFS\\n        \\n        qq.push(beginword);\\n       \\n        while(!qq.empty())\\n        {\\n            int n=qq.size();// I need to traverse every word in q (if word exist > 1)\\n            ladder++;\\n            \\n            while(n--)\\n            { \\n                // working on each word by popping each iteration\\n                string cur=qq.front(); // getting top-most word\\n                qq.pop();\\n               \\n                \\n                \\n                for(int i=0;i<cur.length();i++) // traversing string\\n                {   \\n                    string temp=cur;\\n                    \\n                //now changing each letter to find out any similar word present or not\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n                {\\n                    temp[i]=ch; // changing  letters of word\\n                    \\n                    if(temp==cur) // if any letter made it to its ancestor OR parent again\\n                        continue;\\n                    \\n                    if(temp==endword) return ladder+1; // ENDWORD reached \\n                    \\n                    if(st.count(temp)) // if exist in set\\n                    {\\n                        qq.push(temp); // adding in queue\\n                        st.erase(temp);// removing string from the set\\n                    }\\n                }\\n                } \\n                }\\n                }\\n          return 0;\\n    }\\n    \\n    \\n    \\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n     \\n        unordered_set<string> st;\\n        int ladder=0;\\n        \\n        \\n        \\n        for(auto &it:wordList) st.insert(it);\\n        \\n        if(st.count(endWord)==0) return ladder;\\n        \\n        //now traversing begin word through BFS\\n        return bfs(beginWord,endWord,st);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladder;\\n    \\n    int bfs(string &beginword,string &endword,unordered_set<string> &st )\\n    {\\n        queue<string> qq; // BFS\\n        \\n        qq.push(beginword);\\n       \\n        while(!qq.empty())\\n        {\\n            int n=qq.size();// I need to traverse every word in q (if word exist > 1)\\n            ladder++;\\n            \\n            while(n--)\\n            { \\n                // working on each word by popping each iteration\\n                string cur=qq.front(); // getting top-most word\\n                qq.pop();\\n               \\n                \\n                \\n                for(int i=0;i<cur.length();i++) // traversing string\\n                {   \\n                    string temp=cur;\\n                    \\n                //now changing each letter to find out any similar word present or not\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n                {\\n                    temp[i]=ch; // changing  letters of word\\n                    \\n                    if(temp==cur) // if any letter made it to its ancestor OR parent again\\n                        continue;\\n                    \\n                    if(temp==endword) return ladder+1; // ENDWORD reached \\n                    \\n                    if(st.count(temp)) // if exist in set\\n                    {\\n                        qq.push(temp); // adding in queue\\n                        st.erase(temp);// removing string from the set\\n                    }\\n                }\\n                } \\n                }\\n                }\\n          return 0;\\n    }\\n    \\n    \\n    \\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n     \\n        unordered_set<string> st;\\n        int ladder=0;\\n        \\n        \\n        \\n        for(auto &it:wordList) st.insert(it);\\n        \\n        if(st.count(endWord)==0) return ladder;\\n        \\n        //now traversing begin word through BFS\\n        return bfs(beginWord,endWord,st);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190358,
                "title": "straightforward-clean-python-bfs",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        idxs = collections.defaultdict(set)\\n        words = set(wordList)\\n\\t\\t\\n        if endWord not in words:\\n            return 0\\n        # store indices and all letters in that position from word list.\\n\\t\\t# {0: {\\'h\\', \\'l\\', \\'d\\', \\'c\\'}, 1: {\\'o\\'}, 2: {\\'t\\', \\'g\\'}}\\n        for i in wordList:\\n            for idx, l in enumerate(i):\\n                idxs[idx].add(l)\\n        \\n        q = collections.deque()\\n        q.append((beginWord, 1))\\n\\n        seen = set()\\n        seen.add(beginWord)\\n        \\n        while q:\\n            w, s = q.popleft()\\n            if w == endWord:\\n                return s\\n            for i in range(len(w)):\\n                for j in idxs[i]:\\n                    nw = w[:i] + j + w[i+1:]\\n                    if nw in words and nw not in seen:\\n                        q.append((nw, s + 1))\\n                        seen.add(nw)\\n        \\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        idxs = collections.defaultdict(set)\\n        words = set(wordList)\\n\\t\\t\\n        if endWord not in words:\\n            return 0\\n        # store indices and all letters in that position from word list.\\n\\t\\t# {0: {\\'h\\', \\'l\\', \\'d\\', \\'c\\'}, 1: {\\'o\\'}, 2: {\\'t\\', \\'g\\'}}\\n        for i in wordList:\\n            for idx, l in enumerate(i):\\n                idxs[idx].add(l)\\n        \\n        q = collections.deque()\\n        q.append((beginWord, 1))\\n\\n        seen = set()\\n        seen.add(beginWord)\\n        \\n        while q:\\n            w, s = q.popleft()\\n            if w == endWord:\\n                return s\\n            for i in range(len(w)):\\n                for j in idxs[i]:\\n                    nw = w[:i] + j + w[i+1:]\\n                    if nw in words and nw not in seen:\\n                        q.append((nw, s + 1))\\n                        seen.add(nw)\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008554,
                "title": "word-ladder-python-bfs-pre-processed-word-map",
                "content": "Word map is first built to group all words that differ by only one letter, so we don\\'t need to keep calculating for every word. Then we do a simple BFS, keeping track of how many steps we take.\\n\\t\\n\\tdef ladderLength(self, beginWord, endWord, wordList):\\n        \\n        word_map = collections.defaultdict(list)\\n        L = len(beginWord)\\n        \\n        for word in wordList:\\n            for i in range(L):\\n                word_map[word[:i] + \\'*\\' + word[i + 1:]].append(word)\\n        \\n        q = [beginWord]\\n        transformations = 1\\n        visited = set([beginWord])\\n        \\n        while q:\\n            transformations += 1\\n            new_q = []\\n            for w1 in q:\\n                for i in range(L):\\n                    for w2 in word_map[w1[:i] + \\'*\\' + w1[i + 1:]]:\\n                        if w2 in visited:\\n                            continue\\n                        if w2 == endWord:\\n                            return transformations\\n                        new_q.append(w2)\\n                        visited.add(w2)\\n            \\n            q = new_q\\n            \\n        \\n        return 0",
                "solutionTags": [],
                "code": "Word map is first built to group all words that differ by only one letter, so we don\\'t need to keep calculating for every word. Then we do a simple BFS, keeping track of how many steps we take.\\n\\t\\n\\tdef ladderLength(self, beginWord, endWord, wordList):\\n        \\n        word_map = collections.defaultdict(list)\\n        L = len(beginWord)\\n        \\n        for word in wordList:\\n            for i in range(L):\\n                word_map[word[:i] + \\'*\\' + word[i + 1:]].append(word)\\n        \\n        q = [beginWord]\\n        transformations = 1\\n        visited = set([beginWord])\\n        \\n        while q:\\n            transformations += 1\\n            new_q = []\\n            for w1 in q:\\n                for i in range(L):\\n                    for w2 in word_map[w1[:i] + \\'*\\' + w1[i + 1:]]:\\n                        if w2 in visited:\\n                            continue\\n                        if w2 == endWord:\\n                            return transformations\\n                        new_q.append(w2)\\n                        visited.add(w2)\\n            \\n            q = new_q\\n            \\n        \\n        return 0",
                "codeTag": "Python3"
            },
            {
                "id": 752720,
                "title": "c-bfs-solution-in-great-detail",
                "content": "**This is a pretty easy question once you understand the main concept and how all the data structures work together. I will be focusing mailny on the concept part of this.**\\n\\n**There are 3 crutial parts to this question.**\\n* Pre-Processed Wordlist.\\n* Making the Graph.\\n* BFS and keep track of levels.\\n\\n**Data Structures.**\\n* unordered_map<string, bool> visited;\\n* unordered_map<string, int> level;\\n* unordered_map<string, vector\\\\<string\\\\> \\\\> same; ( generic value )\\n* unordered_map\\\\<string, vector\\\\<string\\\\> \\\\> G; ( main Graph )\\n* queue<string> Q; ( for BFS )\\n\\nLets look into each part in detail.\\n\\n------\\n\\n**Pre-Processed Wordlist**\\n\\nlets take a small example - \\n```\\nstartWord = \"hit\"\\nendWord   = \"dot\"\\nwordList  = [\"hot\", \"dot\"]\\n```\\n\\nNow is take each word and consider their **Generic Form**.By replacing each character with \\'*\\'.\\nEg: `hit => [*it, h*t, hi*]`\\n\\nThen we construct the 1<sup>st</sup> map that will contain \\n* Key as the Generic Form.\\n* Value is a vector of strings theat have the same Generic Form.\\n\\nFor the above example the map is as follows : \\n\\n![Generic](https://user-images.githubusercontent.com/66634743/88387158-f8d0bb80-cdc2-11ea-9197-6a0f77d27861.png)\\n\\nNotice that there are **unwanted edges**(The ones with vector size = 1)\\nFor the main example the the map (ignoring the unwanted edges) is as follows:\\n\\n```text\\ndo* | dot, dog\\n*ot | hot, dot, lot\\nlo* | lot, log\\n*og | dog, log, cog\\nh*t | hot, hit\\n```\\n\\n------\\n\\n**Making the Graph**\\n\\nOnce we perform the pre-computation and make the map, we can easily construct the graph of the related words.\\n\\nWe just iterate over the pre-computed map and insert into the main map for those values where the `vector size > 1`.\\n\\nFor the main example the map is as follows :\\n\\n![Graph](https://user-images.githubusercontent.com/66634743/88387156-f79f8e80-cdc2-11ea-841b-b85c253d43f6.png)\\n\\n\\n```text\\nhit | hot\\ncog | dog, log,\\ndog | dot, log, cog\\ndot | dog, hot, lot\\nhot | dot, lot, hit\\nlot | hot, dot, log\\nlog | lot, dog, cog\\n```\\n\\n------\\n\\n**BFS and keep track of levels**\\n\\nThis is the Heart of the Program but also the most trivial.\\n\\nFew things to keep in mind\\n* Keep track of the levels.\\n* Keep visited to avoid loops.\\n\\nTo keep track of levels i have used this logic : [GFG levels](https://www.***.org/level-node-tree-source-node-using-bfs/)\\n\\n> If you are curious how the **level map** looks like :\\n\\n```\\nlevel => \\ncog | 5     <- found it :)\\nlog | 4\\nhot | 2\\nhit | 1\\ndog | 4\\ndot | 3\\nlot | 3\\n```\\nThis contains the levels of all the words in the list. \\n\\n**Complete Code**\\n```\\nint ladderLength(string beginWord, string endWord, vector<string>& wordList) \\n    {\\n        // check if endWord is in wordList\\n        if(find(wordList.begin(), wordList.end(), endWord) == wordList.end()) return 0;\\n        \\n        wordList.push_back(beginWord);\\n        \\n        // Different Data Structures.\\n        unordered_map<string, bool> visited;\\n        unordered_map<string, int> level;\\n        unordered_map<string, vector<string> > same, G;\\n        queue<string> Q;\\n\\n        // Pre-Processed Wordlist\\n        for(string s : wordList)\\n        {\\n            string word = s;\\n            for(int i=0;i<s.size();++i)\\n            {\\n                s[i] = \\'*\\';                // change the ith letter to \\'*\\'\\n                same[s].push_back(word);   // push into the map\\n                s[i] = word[i];            // replace the ith char to the original char \\n            }\\n            \\n            visited[word] = false;         // initialize visited[] in the same loop\\n        }\\n        \\n        // Making the Graph\\n        for(auto i : same)\\n        {\\n            int size = i.second.size();\\n            if(size == 1) continue;\\n            \\n            for(int j=0;j<size-1;++j)\\n                for(int k=j+1;k<size;++k)\\n                {\\n                    G[i.second[j]].push_back(i.second[k]);\\n                    G[i.second[k]].push_back(i.second[j]);\\n                }\\n        }\\n        \\n        // BFS and keep track of levels\\n        Q.push(beginWord);\\n        visited[beginWord] = true;\\n        level[beginWord] = 1;\\n\\n        while(!Q.empty())\\n        {\\n            string curr = Q.front();\\n            Q.pop();\\n            \\n            for(string i : G[curr])\\n            {\\n                if(!visited[i])\\n                {\\n                    Q.push(i);\\n                    level[i] = level[curr] + 1;\\n                    visited[i] = true;\\n                    \\n                    if(i == endWord) return level[endWord];\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n```\\n\\n*If you made it this far, I hope you could learn something new*\\n*To be honest most of the logic came from leetcodes solution*",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nstartWord = \"hit\"\\nendWord   = \"dot\"\\nwordList  = [\"hot\", \"dot\"]\\n```\n```text\\ndo* | dot, dog\\n*ot | hot, dot, lot\\nlo* | lot, log\\n*og | dog, log, cog\\nh*t | hot, hit\\n```\n```text\\nhit | hot\\ncog | dog, log,\\ndog | dot, log, cog\\ndot | dog, hot, lot\\nhot | dot, lot, hit\\nlot | hot, dot, log\\nlog | lot, dog, cog\\n```\n```\\nlevel => \\ncog | 5     <- found it :)\\nlog | 4\\nhot | 2\\nhit | 1\\ndog | 4\\ndot | 3\\nlot | 3\\n```\n```\\nint ladderLength(string beginWord, string endWord, vector<string>& wordList) \\n    {\\n        // check if endWord is in wordList\\n        if(find(wordList.begin(), wordList.end(), endWord) == wordList.end()) return 0;\\n        \\n        wordList.push_back(beginWord);\\n        \\n        // Different Data Structures.\\n        unordered_map<string, bool> visited;\\n        unordered_map<string, int> level;\\n        unordered_map<string, vector<string> > same, G;\\n        queue<string> Q;\\n\\n        // Pre-Processed Wordlist\\n        for(string s : wordList)\\n        {\\n            string word = s;\\n            for(int i=0;i<s.size();++i)\\n            {\\n                s[i] = \\'*\\';                // change the ith letter to \\'*\\'\\n                same[s].push_back(word);   // push into the map\\n                s[i] = word[i];            // replace the ith char to the original char \\n            }\\n            \\n            visited[word] = false;         // initialize visited[] in the same loop\\n        }\\n        \\n        // Making the Graph\\n        for(auto i : same)\\n        {\\n            int size = i.second.size();\\n            if(size == 1) continue;\\n            \\n            for(int j=0;j<size-1;++j)\\n                for(int k=j+1;k<size;++k)\\n                {\\n                    G[i.second[j]].push_back(i.second[k]);\\n                    G[i.second[k]].push_back(i.second[j]);\\n                }\\n        }\\n        \\n        // BFS and keep track of levels\\n        Q.push(beginWord);\\n        visited[beginWord] = true;\\n        level[beginWord] = 1;\\n\\n        while(!Q.empty())\\n        {\\n            string curr = Q.front();\\n            Q.pop();\\n            \\n            for(string i : G[curr])\\n            {\\n                if(!visited[i])\\n                {\\n                    Q.push(i);\\n                    level[i] = level[curr] + 1;\\n                    visited[i] = true;\\n                    \\n                    if(i == endWord) return level[endWord];\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538333,
                "title": "c-fast-one-end-two-end-bfs",
                "content": "Two-end BFS is much faster than one-end BFS.\\n\\n******************************************************************************************\\n\\n# One-end BFS\\n\\n* Runtime: 64 ms, faster than 91.49%\\n* Memory Usage: 12.1 MB, less than 100.00%\\n\\n```c++\\n\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> d(wordList.begin(), wordList.end());\\n        if(d.count(endWord) == 0) return 0;\\n        queue<string> q;\\n        q.push(beginWord);\\n        int res = 0;\\n        while(!q.empty()){\\n            res++;\\n            int q_size = q.size();\\n            for(int i = 0; i < q_size; i++){\\n                auto curr = q.front();\\n                if(curr == endWord) return res;\\n                q.pop();\\n                for(int j = 0; j < curr.size(); j++){\\n                    auto tmp = curr[j];\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        curr[j] = c;\\n                        if(d.count(curr) != 0){\\n                            d.erase(curr);\\n                            q.push(curr);\\n                        }\\n                    }\\n                    curr[j] = tmp;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n\\n******************************************************************************************\\n\\n# Two-end BFS\\n\\n* Runtime: 24 ms, faster than 99.42%\\n* Memory Usage: 11.7 MB, less than 100.00%\\n\\n```c++\\n\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> d(wordList.begin(), wordList.end()), beginSet, endSet, *forwardSet, *targetSet;\\n        if(d.count(endWord) == 0) return 0;\\n        beginSet.insert(beginWord);\\n        endSet.insert(endWord);\\n        int res = 1;\\n        while(!beginSet.empty() && !endSet.empty()){\\n            res++;\\n            if(beginSet.size() <= endSet.size()){\\n                forwardSet = &beginSet;\\n                targetSet = &endSet;\\n            }else{\\n                forwardSet = &endSet;\\n                targetSet = &beginSet;\\n            }\\n            unordered_set<string> nextForwardSet;\\n            for(auto curr: *forwardSet){\\n                for(int i = 0; i < curr.size(); i++){\\n                    auto tmp = curr[i];\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        curr[i] = c;\\n                        if(targetSet->count(curr) != 0) return res;\\n                        if(d.count(curr) != 0){\\n                            nextForwardSet.insert(curr);\\n                            d.erase(curr);\\n                        }\\n                    }\\n                    curr[i] = tmp;\\n                }\\n            }\\n            swap(*forwardSet, nextForwardSet);\\n        }\\n        return 0;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```c++\\n\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> d(wordList.begin(), wordList.end());\\n        if(d.count(endWord) == 0) return 0;\\n        queue<string> q;\\n        q.push(beginWord);\\n        int res = 0;\\n        while(!q.empty()){\\n            res++;\\n            int q_size = q.size();\\n            for(int i = 0; i < q_size; i++){\\n                auto curr = q.front();\\n                if(curr == endWord) return res;\\n                q.pop();\\n                for(int j = 0; j < curr.size(); j++){\\n                    auto tmp = curr[j];\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        curr[j] = c;\\n                        if(d.count(curr) != 0){\\n                            d.erase(curr);\\n                            q.push(curr);\\n                        }\\n                    }\\n                    curr[j] = tmp;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```\n```c++\\n\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> d(wordList.begin(), wordList.end()), beginSet, endSet, *forwardSet, *targetSet;\\n        if(d.count(endWord) == 0) return 0;\\n        beginSet.insert(beginWord);\\n        endSet.insert(endWord);\\n        int res = 1;\\n        while(!beginSet.empty() && !endSet.empty()){\\n            res++;\\n            if(beginSet.size() <= endSet.size()){\\n                forwardSet = &beginSet;\\n                targetSet = &endSet;\\n            }else{\\n                forwardSet = &endSet;\\n                targetSet = &beginSet;\\n            }\\n            unordered_set<string> nextForwardSet;\\n            for(auto curr: *forwardSet){\\n                for(int i = 0; i < curr.size(); i++){\\n                    auto tmp = curr[i];\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        curr[i] = c;\\n                        if(targetSet->count(curr) != 0) return res;\\n                        if(d.count(curr) != 0){\\n                            nextForwardSet.insert(curr);\\n                            d.erase(curr);\\n                        }\\n                    }\\n                    curr[i] = tmp;\\n                }\\n            }\\n            swap(*forwardSet, nextForwardSet);\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 352659,
                "title": "python-simple-bfs-solution-similar-problems-listed",
                "content": "Level-by-level BFS visit can be used to solve a lot of problems of finding discrete shortest distance.\\nPlease see and vote for my solutions for these similar problems\\n[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1651394/Python-level-by-level-BFS-Solution)\\n[127. Word Ladder](https://leetcode.com/problems/word-ladder/discuss/352659/Simple-Python-BFS-solution)\\n[126. Word Ladder II](https://leetcode.com/problems/word-ladder-ii/discuss/352661/Simple-Python-BFS-solution)\\n[301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/discuss/327481/Python-DFS-solution-with-pruning-(28-ms-beat-99.56)-%2B-BFS-solution)\\n[317. Shortest Distance from All Buildings](https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/331983/Python-BFS-solution-(52-ms-beat-98.27))\\n[529. Minesweeper](https://leetcode.com/problems/minesweeper/discuss/1651414/python-level-by-level-bfs-solution)\\n[773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/discuss/412586/Standard-Python-BFS-solution-(level-by-level-traversal))\\n[815. Bus Routes](https://leetcode.com/problems/bus-routes/discuss/1651399/Python-Level-by-level-BFS-solution)\\n[854. K-Similar Strings](https://leetcode.com/problems/k-similar-strings/discuss/420506/Python-BFS-solution)\\n[864. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/discuss/364604/Simple-Python-BFS-Solution-(292-ms-beat-97.78))\\n[1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313229/Python-BFS-solution)\\n[1210. Minimum Moves to Reach Target with Rotations](https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/392940/Standard-Python-BFS-solution)\\n[1263. Minimum Moves to Move a Box to Their Target Location](https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431138/Python-straightforward-BFS-solution)\\n[1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/discuss/1651383/Python-level-by-level-BFS-Solution)\\n\\n```\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)\\n        if endWord not in wordList:\\n            return 0\\n        # BFS visit\\n        curr_level = {beginWord}\\n        dist = 1\\n        while curr_level:\\n            wordList -= curr_level\\n            next_level = set()\\n            for word in curr_level:\\n                for i in range(len(word)):\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        new_word = word[:i] + c + word[i+1:]\\n                        if new_word == endWord:\\n                            return 1 + dist\\n                        if new_word in wordList:\\n                            next_level.add(new_word)\\n            curr_level = next_level\\n            dist += 1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)\\n        if endWord not in wordList:\\n            return 0\\n        # BFS visit\\n        curr_level = {beginWord}\\n        dist = 1\\n        while curr_level:\\n            wordList -= curr_level\\n            next_level = set()\\n            for word in curr_level:\\n                for i in range(len(word)):\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        new_word = word[:i] + c + word[i+1:]\\n                        if new_word == endWord:\\n                            return 1 + dist\\n                        if new_word in wordList:\\n                            next_level.add(new_word)\\n            curr_level = next_level\\n            dist += 1\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 111181,
                "title": "incorrect-test-case",
                "content": "```\\nOne of the test cases is:\\n\\nbeginWord = \"leet\"\\nendWord = \"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nthe correct answer as per Leecode is 6. \\n\\nHowever, I believe it is 5 \\nshortest path: 'leet' -> lest'-> 'lost'-> 'lose'-> 'lode'-> 'code'\\nnotice there are 5 changes from beingWord to endWord. So why is it expecting 6 as the correct answer?\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nOne of the test cases is:\\n\\nbeginWord = \"leet\"\\nendWord = \"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nthe correct answer as per Leecode is 6. \\n\\nHowever, I believe it is 5 \\nshortest path: 'leet' -> lest'-> 'lost'-> 'lose'-> 'lode'-> 'code'\\nnotice there are 5 changes from beingWord to endWord. So why is it expecting 6 as the correct answer?\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40891,
                "title": "weird-python-tle-problem-potential-oj-bug",
                "content": "I'm helping a friend of mine debug her program which gets TLE.\\nHere's her original solution:\\n\\n    class Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: Set[str]\\n        :rtype: int\\n        \"\"\"\\n        charSet = set(beginWord + endWord + ''.join(wordList))\\n        current = [beginWord]\\n        level = 1\\n        while current:\\n            next = []\\n            for word in current:\\n                for i in range(len(word)):\\n                    for c in charSet:\\n                        if c == word[i]: continue\\n                        tmp = word[:i] + c + word[i+1:]\\n                        if tmp == endWord: return level + 1\\n                        if tmp in wordList:\\n                            wordList.remove(tmp)\\n                            next.append(tmp)\\n            current = next\\n            level += 1\\n        return 0\\n\\nIt's a simple, straight-forward BFS, and gets TLE on a test case where beginWord == 'nape', endWord == 'mild', and wordList consists of 336 four-letter words.\\n\\nI made a small change to the program -- replacing the first line in the function by:\\n\\n    charSet = set('abcdefghijklmnopqrstuvwxyz')\\n\\nand the program was accepted.\\n\\nNow this is already weird enough -- both version of code run between 20~30 ms on my local computer, but they get different judgments.\\n\\n======================\\n\\nI made two hypotheses about why my friend's original program got TLE:\\n\\n 1. The original first line alone already exceeded the time limit;\\n 2. The first line ran fast enough, but the constructed set would be traversed many times in the procedure of the BFS, which exceeded the time limit.\\n\\nActually, both hypotheses are unlikely to me... but I did some experiments to find out which was true, anyway.\\n\\n======================\\n\\nEXPERIMENT 1:\\n\\nI kept both ways of constructing charSet, at the beginning of the function:\\n\\n    charSet = set(beginWord + endWord + ''.join(wordList))\\n    charSet = set('abcdefghijklmnopqrstuvwxyz')\\n\\nNow the program would get TLE iff Hyp. 1 was true.\\nThe result was accepted, which seemed to support Hyp. 2.\\n\\n======================\\n\\nTo further confirm that the charSet construction wasn't the cause of the TLE, I did experiment 2.\\n\\nEXPERIMENT 2:\\n\\nI added a line of \"cheating code\" after the first line of the function:\\n\\n    charSet = set(beginWord + endWord + ''.join(wordList))\\n    if beginWord == 'nape' and endWord == 'mild': return 6\\n    #charSet = set('abcdefghijklmnopqrstuvwxyz')\\n\\nStill, the program would get TLE on the same test case iff Hyp. 1 was true.\\nBut this time, I did get TLE!\\n\\n======================\\n\\nEXPERIMENT 3:\\n\\nCuriously, if I uncommented the third line:\\n\\n    charSet = set(beginWord + endWord + ''.join(wordList))\\n    if beginWord == 'nape' and endWord == 'mild': return 6\\n    charSet = set('abcdefghijklmnopqrstuvwxyz')\\n\\nI thought this shouldn't have any effect on this particular test case, as this line goes after the \"return\" statement.\\nBut this time, the program got accepted!\\n\\nThis makes me suspect that LeetCode is executing code after the \"return\" statement.\\n\\n======================\\n\\nAnyway, not only wasn't I able to find out the reason why my friend's original solution got TLE, but also I discovered some weird behavior of the LeetCode OJ.\\n\\nCan anyone (esp. admins) explain what's going on?",
                "solutionTags": [
                    "Python"
                ],
                "code": "I'm helping a friend of mine debug her program which gets TLE.\\nHere's her original solution:\\n\\n    class Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: Set[str]\\n        :rtype: int\\n        \"\"\"\\n        charSet = set(beginWord + endWord + ''.join(wordList))\\n        current = [beginWord]\\n        level = 1\\n        while current:\\n            next = []\\n            for word in current:\\n                for i in range(len(word)):\\n                    for c in charSet:\\n                        if c == word[i]: continue\\n                        tmp = word[:i] + c + word[i+1:]\\n                        if tmp == endWord: return level + 1\\n                        if tmp in wordList:\\n                            wordList.remove(tmp)\\n                            next.append(tmp)\\n            current = next\\n            level += 1\\n        return 0\\n\\nIt's a simple, straight-forward BFS, and gets TLE on a test case where beginWord == 'nape', endWord == 'mild', and wordList consists of 336 four-letter words.\\n\\nI made a small change to the program -- replacing the first line in the function by:\\n\\n    charSet = set('abcdefghijklmnopqrstuvwxyz')\\n\\nand the program was accepted.\\n\\nNow this is already weird enough -- both version of code run between 20~30 ms on my local computer, but they get different judgments.\\n\\n======================\\n\\nI made two hypotheses about why my friend's original program got TLE:\\n\\n 1. The original first line alone already exceeded the time limit;\\n 2. The first line ran fast enough, but the constructed set would be traversed many times in the procedure of the BFS, which exceeded the time limit.\\n\\nActually, both hypotheses are unlikely to me... but I did some experiments to find out which was true, anyway.\\n\\n======================\\n\\nEXPERIMENT 1:\\n\\nI kept both ways of constructing charSet, at the beginning of the function:\\n\\n    charSet = set(beginWord + endWord + ''.join(wordList))\\n    charSet = set('abcdefghijklmnopqrstuvwxyz')\\n\\nNow the program would get TLE iff Hyp. 1 was true.\\nThe result was accepted, which seemed to support Hyp. 2.\\n\\n======================\\n\\nTo further confirm that the charSet construction wasn't the cause of the TLE, I did experiment 2.\\n\\nEXPERIMENT 2:\\n\\nI added a line of \"cheating code\" after the first line of the function:\\n\\n    charSet = set(beginWord + endWord + ''.join(wordList))\\n    if beginWord == 'nape' and endWord == 'mild': return 6\\n    #charSet = set('abcdefghijklmnopqrstuvwxyz')\\n\\nStill, the program would get TLE on the same test case iff Hyp. 1 was true.\\nBut this time, I did get TLE!\\n\\n======================\\n\\nEXPERIMENT 3:\\n\\nCuriously, if I uncommented the third line:\\n\\n    charSet = set(beginWord + endWord + ''.join(wordList))\\n    if beginWord == 'nape' and endWord == 'mild': return 6\\n    charSet = set('abcdefghijklmnopqrstuvwxyz')\\n\\nI thought this shouldn't have any effect on this particular test case, as this line goes after the \"return\" statement.\\nBut this time, the program got accepted!\\n\\nThis makes me suspect that LeetCode is executing code after the \"return\" statement.\\n\\n======================\\n\\nAnyway, not only wasn't I able to find out the reason why my friend's original solution got TLE, but also I discovered some weird behavior of the LeetCode OJ.\\n\\nCan anyone (esp. admins) explain what's going on?",
                "codeTag": "Java"
            },
            {
                "id": 40912,
                "title": "concise-java-solution-based-on-bfs",
                "content": "**Explanation**\\n\\nThe basic idea is to build a graph based on characters of word, and then set 'a' to 'z' as neighbors of each character in the word. Replace one character with 'a' to 'z' one time, using level by level BFS to find the shortest transformation sequence path. As the following:\\n\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n    \\tQueue<String> queue = new LinkedList<String>();\\n    \\tHashSet<String> visited = new HashSet<String>();// Visited words\\n    \\t\\n    \\tint length = 1;\\n    \\tqueue.offer(beginWord);\\t\\t\\t\\t\\n    \\tvisited.add(beginWord);    \\t\\n    \\twhile (!queue.isEmpty()) {\\n    \\t\\tint count = queue.size();// Level by level BFS \\n    \\t\\t\\n    \\t\\tfor (int k = 0; k < count; k++) {\\n    \\t\\t\\tchar[] chs = queue.poll().toCharArray();\\n\\n    \\t\\t    for (int i = 0 ; i < chs.length; i++) {// Outer loop should be string\\n    \\t\\t      for (char ch = 'a'; ch <= 'z'; ch++) {// Inner loop should be 'a' - 'z' \\n    \\t\\t\\t\\tchar chOld = chs[i];\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif (chs[i] == ch)\\n    \\t\\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tchs[i] = ch;\\n    \\t\\t\\t\\t\\tString cur = String.valueOf(chs);\\n    \\t\\t\\t\\t\\tif (endWord.equals(cur)) \\n    \\t\\t\\t\\t\\t\\treturn length + 1;\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif (!visited.contains(cur) && wordList.contains(cur)) {\\n    \\t\\t\\t\\t\\t\\tqueue.offer(cur);\\n    \\t\\t\\t\\t\\t\\tvisited.add(cur);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tchs[i] = chOld; \\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\t\\t\\t    \\n    \\t\\t}    \\t\\t\\n    \\t\\tlength++; // Next round of longer transformation sequence\\n    \\t}\\n    \\treturn 0;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is to build a graph based on characters of word, and then set 'a' to 'z' as neighbors of each character in the word. Replace one character with 'a' to 'z' one time, using level by level BFS to find the shortest transformation sequence path. As the following:\\n\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n    \\tQueue<String> queue = new LinkedList<String>();\\n    \\tHashSet<String> visited = new HashSet<String>();// Visited words\\n    \\t\\n    \\tint length = 1;\\n    \\tqueue.offer(beginWord);\\t\\t\\t\\t\\n    \\tvisited.add(beginWord);    \\t\\n    \\twhile (!queue.isEmpty()) {\\n    \\t\\tint count = queue.size();// Level by level BFS \\n    \\t\\t\\n    \\t\\tfor (int k = 0; k < count; k++) {\\n    \\t\\t\\tchar[] chs = queue.poll().toCharArray();\\n\\n    \\t\\t    for (int i = 0 ; i < chs.length; i++) {// Outer loop should be string\\n    \\t\\t      for (char ch = 'a'; ch <= 'z'; ch++) {// Inner loop should be 'a' - 'z' \\n    \\t\\t\\t\\tchar chOld = chs[i];\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif (chs[i] == ch)\\n    \\t\\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tchs[i] = ch;\\n    \\t\\t\\t\\t\\tString cur = String.valueOf(chs);\\n    \\t\\t\\t\\t\\tif (endWord.equals(cur)) \\n    \\t\\t\\t\\t\\t\\treturn length + 1;\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tif (!visited.contains(cur) && wordList.contains(cur)) {\\n    \\t\\t\\t\\t\\t\\tqueue.offer(cur);\\n    \\t\\t\\t\\t\\t\\tvisited.add(cur);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tchs[i] = chOld; \\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\t\\t\\t    \\n    \\t\\t}    \\t\\t\\n    \\t\\tlength++; // Next round of longer transformation sequence\\n    \\t}\\n    \\treturn 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 40910,
                "title": "concise-c-solution-with-only-queue-no-other-data-structure-used",
                "content": "    class Solution {\\n    private:\\n        bool isOneDiff(const string& A, const string& B) {\\n            if (A.size() != B.size())\\n                return false;\\n            int diff = 0;\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] != B[i])\\n                    ++diff;\\n                if (diff > 1)\\n                    return false;\\n            }\\n            return diff == 1;\\n        }\\n    public:\\n        int ladderLength(string beginWord, string endWord, unordered_set<string>& dict) {\\n            if (dict.count(beginWord) == 0 || dict.count(endWord) == 0)\\n                return 0;\\n    \\n            queue<pair<string, int> > que;\\n            que.push(make_pair(beginWord, 1));\\n            dict.erase(beginWord);\\n            \\n            while (!que.empty()) {\\n                pair<string, int> cur = que.front(); que.pop();\\n                for (auto it = dict.begin(); it != dict.end(); ) {\\n                    if (isOneDiff(cur.first, *it)) {\\n                        if (*it == endWord) return cur.second + 1;\\n                        que.push(make_pair(*it, cur.second + 1));\\n                        it = dict.erase(it);\\n                    } else ++it;\\n                }\\n            }\\n            return 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        bool isOneDiff(const string& A, const string& B) {\\n            if (A.size() != B.size())\\n                return false;\\n            int diff = 0;\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] != B[i])\\n                    ++diff;\\n                if (diff > 1)\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 41022,
                "title": "time-limit-exceeded-bfs",
                "content": "using bfs, got right answer in my own computer immediately,but got Time Limit Exceeded online.\\n\\nmy code:\\n\\n   \\tclass Solution {\\n\\tpublic:\\n\\t\\tint ladderLength(string start, string end, unordered_set<string> &dict) {\\n\\t\\t\\tif (end == start){\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\t\\t\\tsize_ = start.size();\\n\\t\\t\\tqueue<string> q;   //queue for BFS\\n\\n\\t\\t\\t// depth[word] = the length of shortest transformation sequence \\n\\t\\t\\t//\\t\\t\\t\\t\\tfrom start to word\\n\\t\\t\\tunordered_map<string, int> depth;\\n\\n\\t\\t\\tq.push(start);\\n\\t\\t\\tdepth[start] = 1;\\n\\t\\t\\twhile (!q.empty()){\\n\\t\\t\\t\\tstring& s = q.front();\\n\\t\\t\\t\\tif (isNeighbor(s, end)){ // got answer  \\n\\t\\t\\t\\t\\treturn depth[s] + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (const auto& word : dict){ \\n\\t\\t\\t\\t\\t// for words(in dict) that are neighbor of current word \\n                    //          and haven't appear before\\n\\t\\t            //\\t\\t    set their depth and push them into queue\\n\\t\\t\\t\\t\\tif (isNeighbor(s, word) && depth.count(word) == 0){\\n\\t\\t\\t\\t\\t\\tdepth[word] = depth[s] + 1;\\n\\t\\t\\t\\t\\t\\tq.push(word);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// return true if there is only one different char between s1 and s2\\n\\t\\tbool isNeighbor(const string& s1, const string& s2){\\n\\t\\t\\tint dis = 0;\\n\\t\\t\\tfor (int i = 0; i < size_; ++i){\\n\\t\\t\\t\\tdis += (s1[i] != s2[i]);\\n\\t\\t\\t\\tif (dis > 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn (dis == 1);\\n\\t\\t}\\n\\tprivate:\\n\\t\\tint size_;    //  start.size()\\n\\t};\\n\\nTime Limit Exceeded case:\\n\\n\\tint _tmain(int argc, _TCHAR* argv[])\\n\\t{\\n\\n\\t\\tstring start = \"nape\"; \\n\\t\\tstring end = \"mild\";\\n\\t\\tunordered_set<string> dict = { \"dose\", \"ends\", \"dine\", \"jars\", \"prow\", \"soap\", \"guns\", \"hops\", \"cray\", \"hove\", \"ella\", \"hour\", \"lens\", \"jive\", \"wiry\", \"earl\", \"mara\", \"part\", \"flue\", \"putt\", \"rory\", \"bull\", \"york\", \"ruts\", \"lily\", \"vamp\", \"bask\", \"peer\", \"boat\", \"dens\", \"lyre\", \"jets\", \"wide\", \"rile\", \"boos\", \"down\", \"path\", \"onyx\", \"mows\", \"toke\", \"soto\", \"dork\", \"nape\", \"mans\", \"loin\", \"jots\", \"male\", \"sits\", \"minn\", \"sale\", \"pets\", \"hugo\", \"woke\", \"suds\", \"rugs\", \"vole\", \"warp\", \"mite\", \"pews\", \"lips\", \"pals\", \"nigh\", \"sulk\", \"vice\", \"clod\", \"iowa\", \"gibe\", \"shad\", \"carl\", \"huns\", \"coot\", \"sera\", \"mils\", \"rose\", \"orly\", \"ford\", \"void\", \"time\", \"eloy\", \"risk\", \"veep\", \"reps\", \"dolt\", \"hens\", \"tray\", \"melt\", \"rung\", \"rich\", \"saga\", \"lust\", \"yews\", \"rode\", \"many\", \"cods\", \"rape\", \"last\", \"tile\", \"nosy\", \"take\", \"nope\", \"toni\", \"bank\", \"jock\", \"jody\", \"diss\", \"nips\", \"bake\", \"lima\", \"wore\", \"kins\", \"cult\", \"hart\", \"wuss\", \"tale\", \"sing\", \"lake\", \"bogy\", \"wigs\", \"kari\", \"magi\", \"bass\", \"pent\", \"tost\", \"fops\", \"bags\", \"duns\", \"will\", \"tart\", \"drug\", \"gale\", \"mold\", \"disk\", \"spay\", \"hows\", \"naps\", \"puss\", \"gina\", \"kara\", \"zorn\", \"boll\", \"cams\", \"boas\", \"rave\", \"sets\", \"lego\", \"hays\", \"judy\", \"chap\", \"live\", \"bahs\", \"ohio\", \"nibs\", \"cuts\", \"pups\", \"data\", \"kate\", \"rump\", \"hews\", \"mary\", \"stow\", \"fang\", \"bolt\", \"rues\", \"mesh\", \"mice\", \"rise\", \"rant\", \"dune\", \"jell\", \"laws\", \"jove\", \"bode\", \"sung\", \"nils\", \"vila\", \"mode\", \"hued\", \"cell\", \"fies\", \"swat\", \"wags\", \"nate\", \"wist\", \"honk\", \"goth\", \"told\", \"oise\", \"wail\", \"tels\", \"sore\", \"hunk\", \"mate\", \"luke\", \"tore\", \"bond\", \"bast\", \"vows\", \"ripe\", \"fond\", \"benz\", \"firs\", \"zeds\", \"wary\", \"baas\", \"wins\", \"pair\", \"tags\", \"cost\", \"woes\", \"buns\", \"lend\", \"bops\", \"code\", \"eddy\", \"siva\", \"oops\", \"toed\", \"bale\", \"hutu\", \"jolt\", \"rife\", \"darn\", \"tape\", \"bold\", \"cope\", \"cake\", \"wisp\", \"vats\", \"wave\", \"hems\", \"bill\", \"cord\", \"pert\", \"type\", \"kroc\", \"ucla\", \"albs\", \"yoko\", \"silt\", \"pock\", \"drub\", \"puny\", \"fads\", \"mull\", \"pray\", \"mole\", \"talc\", \"east\", \"slay\", \"jamb\", \"mill\", \"dung\", \"jack\", \"lynx\", \"nome\", \"leos\", \"lade\", \"sana\", \"tike\", \"cali\", \"toge\", \"pled\", \"mile\", \"mass\", \"leon\", \"sloe\", \"lube\", \"kans\", \"cory\", \"burs\", \"race\", \"toss\", \"mild\", \"tops\", \"maze\", \"city\", \"sadr\", \"bays\", \"poet\", \"volt\", \"laze\", \"gold\", \"zuni\", \"shea\", \"gags\", \"fist\", \"ping\", \"pope\", \"cora\", \"yaks\", \"cosy\", \"foci\", \"plan\", \"colo\", \"hume\", \"yowl\", \"craw\", \"pied\", \"toga\", \"lobs\", \"love\", \"lode\", \"duds\", \"bled\", \"juts\", \"gabs\", \"fink\", \"rock\", \"pant\", \"wipe\", \"pele\", \"suez\", \"nina\", \"ring\", \"okra\", \"warm\", \"lyle\", \"gape\", \"bead\", \"lead\", \"jane\", \"oink\", \"ware\", \"zibo\", \"inns\", \"mope\", \"hang\", \"made\", \"fobs\", \"gamy\", \"fort\", \"peak\", \"gill\", \"dino\", \"dina\", \"tier\"};\\n\\t\\tSolution solution;\\n\\t\\tint result = solution.ladderLength(start, end, dict);\\n\\t\\treturn 0;\\n\\t}",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint ladderLength(string start, string end, unordered_set<string> &dict) {\\n\\t\\t\\tif (end == start){\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3704406,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        queue<pair<string, int>> q;\\n        q.push({beginWord, 1});\\n        unordered_set<string> st(wordList.begin(), wordList.end());\\n        st.erase(beginWord);\\n        while(!q.empty()){\\n            string word = q.front().first;\\n            int steps = q.front().second;\\n            q.pop();\\n            if(word == endWord)\\n                return steps;\\n            for(int i=0;i<word.size();i++){\\n                char original = word[i];\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n                    word[i] = ch;\\n                    if (st.find(word) != st.end()){\\n                        st.erase(word);\\n                        q.push({word, steps + 1});\\n                    }\\n                }\\n                word[i] = original;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        queue<pair<string, int>> q;\\n        q.push({beginWord, 1});\\n        unordered_set<string> st(wordList.begin(), wordList.end());\\n        st.erase(beginWord);\\n        while(!q.empty()){\\n            string word = q.front().first;\\n            int steps = q.front().second;\\n            q.pop();\\n            if(word == endWord)\\n                return steps;\\n            for(int i=0;i<word.size();i++){\\n                char original = word[i];\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n                    word[i] = ch;\\n                    if (st.find(word) != st.end()){\\n                        st.erase(word);\\n                        q.push({word, steps + 1});\\n                    }\\n                }\\n                word[i] = original;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469776,
                "title": "graph-with-bfs-approach",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        if endWord not in wordList:\\n            return 0\\n        nei=defaultdict(list)\\n        wordList.append(beginWord)\\n        for word in wordList:\\n            for j in range(len(word)):\\n                pattern=word[:j]+\"*\"+word[j+1:]\\n                nei[pattern].append(word)\\n        visit=set([beginWord])\\n        q=deque([beginWord])\\n        count=1\\n        while q:\\n            for i in range(len(q)):\\n                word=q.popleft()\\n                if word==endWord:\\n                    return count\\n                for j in range(len(word)):\\n                    pattern=word[:j]+\"*\"+word[j+1:]\\n                    for neiword in nei[pattern]:\\n                        if neiword not in visit:\\n                            visit.add(neiword)\\n                            q.append(neiword)\\n            count+=1\\n        return 0        \\n  ```\\n  # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        if endWord not in wordList:\\n            return 0\\n        nei=defaultdict(list)\\n        wordList.append(beginWord)\\n        for word in wordList:\\n            for j in range(len(word)):\\n                pattern=word[:j]+\"*\"+word[j+1:]\\n                nei[pattern].append(word)\\n        visit=set([beginWord])\\n        q=deque([beginWord])\\n        count=1\\n        while q:\\n            for i in range(len(q)):\\n                word=q.popleft()\\n                if word==endWord:\\n                    return count\\n                for j in range(len(word)):\\n                    pattern=word[:j]+\"*\"+word[j+1:]\\n                    for neiword in nei[pattern]:\\n                        if neiword not in visit:\\n                            visit.add(neiword)\\n                            q.append(neiword)\\n            count+=1\\n        return 0        \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2936625,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        int n = beginWord.size();\\n        unordered_map<string, int> mp, vis;\\n        for(auto x: wordList) mp[x] = 1;\\n        if(!mp[endWord]) return 0;\\n        queue<string> q;\\n        q.push(beginWord);\\n        vis[beginWord] = 1;\\n        int ans = 0;\\n        while(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                string u = q.front();\\n                q.pop();\\n                if(u == endWord) {\\n                    return ans + 1;\\n                }\\n                for(int i=0; i<n; i++) {\\n                    for(char c=\\'a\\'; c<=\\'z\\'; c++) {\\n                        string v = u;\\n                        v[i] = c;\\n                        if(!vis[v] and mp[v]) {\\n                            q.push(v);\\n                            vis[v] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        int n = beginWord.size();\\n        unordered_map<string, int> mp, vis;\\n        for(auto x: wordList) mp[x] = 1;\\n        if(!mp[endWord]) return 0;\\n        queue<string> q;\\n        q.push(beginWord);\\n        vis[beginWord] = 1;\\n        int ans = 0;\\n        while(!q.empty()) {\\n            int len = q.size();\\n            while(len--) {\\n                string u = q.front();\\n                q.pop();\\n                if(u == endWord) {\\n                    return ans + 1;\\n                }\\n                for(int i=0; i<n; i++) {\\n                    for(char c=\\'a\\'; c<=\\'z\\'; c++) {\\n                        string v = u;\\n                        v[i] = c;\\n                        if(!vis[v] and mp[v]) {\\n                            q.push(v);\\n                            vis[v] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877547,
                "title": "java-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBFS Solution\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\n        HashMap< String , ArrayList<String> > graph = new HashMap<>();\\n        TreeSet<String> visted = new TreeSet<>( wordList );\\n\\n        visted.add( beginWord );\\n        graph.put( beginWord , new ArrayList<>() );\\n\\n        for (String s : wordList) graph.put(s, new ArrayList<>());\\n\\n        if( !visted.contains( endWord ) ) return 0;\\n\\n        for( String i : graph.keySet() ){\\n            for( int j=0; j< wordList.size(); j++ ){\\n                if( checkDifferentChar( wordList.get( j ) , i ) ){\\n                    graph.get( i ).add( wordList.get(j) );\\n                }\\n            }\\n        }\\n\\n        LinkedList<String> q = new LinkedList<>();\\n        q.add(beginWord);\\n        int level = 1;\\n\\n        while( !q.isEmpty() ){\\n\\n            int len = q.size();\\n\\n            for (int i=0; i<len; i++){\\n\\n                String s = q.removeFirst();\\n                ArrayList<String> connections = graph.get( s );\\n\\n                for( String x:connections ){\\n\\n                    if( x.equals( endWord ) ) return level+1;\\n                    if(visted.contains(x)){\\n                        q.add(x);\\n                        visted.remove(x);\\n                    }\\n\\n                }\\n\\n            }\\n            level++;\\n\\n        }\\n\\n        return 0;\\n    }\\n    boolean checkDifferentChar( String s1 , String s2 ){\\n\\n        int differentChar = 0;\\n        for( int j=0; j<s1.length(); j++ ){\\n            if( s1.charAt( j ) != s2.charAt( j ) )\\n                differentChar++;\\n            if( differentChar > 1 ) break;\\n        }\\n        return differentChar == 1;\\n\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\n        HashMap< String , ArrayList<String> > graph = new HashMap<>();\\n        TreeSet<String> visted = new TreeSet<>( wordList );\\n\\n        visted.add( beginWord );\\n        graph.put( beginWord , new ArrayList<>() );\\n\\n        for (String s : wordList) graph.put(s, new ArrayList<>());\\n\\n        if( !visted.contains( endWord ) ) return 0;\\n\\n        for( String i : graph.keySet() ){\\n            for( int j=0; j< wordList.size(); j++ ){\\n                if( checkDifferentChar( wordList.get( j ) , i ) ){\\n                    graph.get( i ).add( wordList.get(j) );\\n                }\\n            }\\n        }\\n\\n        LinkedList<String> q = new LinkedList<>();\\n        q.add(beginWord);\\n        int level = 1;\\n\\n        while( !q.isEmpty() ){\\n\\n            int len = q.size();\\n\\n            for (int i=0; i<len; i++){\\n\\n                String s = q.removeFirst();\\n                ArrayList<String> connections = graph.get( s );\\n\\n                for( String x:connections ){\\n\\n                    if( x.equals( endWord ) ) return level+1;\\n                    if(visted.contains(x)){\\n                        q.add(x);\\n                        visted.remove(x);\\n                    }\\n\\n                }\\n\\n            }\\n            level++;\\n\\n        }\\n\\n        return 0;\\n    }\\n    boolean checkDifferentChar( String s1 , String s2 ){\\n\\n        int differentChar = 0;\\n        for( int j=0; j<s1.length(); j++ ){\\n            if( s1.charAt( j ) != s2.charAt( j ) )\\n                differentChar++;\\n            if( differentChar > 1 ) break;\\n        }\\n        return differentChar == 1;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2623390,
                "title": "error-in-one-of-test-cases",
                "content": "For following input \\n\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\ntest case is expecting output 2. \\n\\nShouldn\\'t it be 1?  As I can change just one letter \"a\" to \"c\"",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1766317,
                "title": "c-efficient-bfs-solution-full-explanation-time-space-complexity",
                "content": "### **Idea : Simple BFS, but instead of integers we have strings as a Nodes [boils to : Shortest Path between Two Nodes]**\\n* **C++ Code [~60ms]**         \\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string &beginWord, string &endWord, vector<string> &wordList){\\n    \\tunordered_set<string> s(wordList.begin(), wordList.end());\\n\\n    \\tif(s.find(endWord) == s.end()) return 0;   // if our destination is not present in our list, return 0\\n    \\tint cnt = 0;\\t      // to count the number of nodes/steps needed to reach the destination word\\n    \\tqueue<string> q;\\n    \\tq.push(beginWord);\\t  // push the starting node into queue, as we did in BFS [beginWord is our root]\\n    \\t\\n    \\twhile(!q.empty()){\\n    \\t\\tauto size = q.size();\\n    \\t\\tcnt++;\\n    \\t\\twhile(size--){\\n    \\t\\t\\tauto currWord = q.front(); q.pop();\\n    \\t\\t\\t// find the next word which can be formed after currWord by changing it\\'s letter(s)\\n    \\t\\t\\tfor(int i = 0; i < currWord.size(); ++i){\\n    \\t\\t\\t\\tstring tmp = currWord;\\n    \\t\\t\\t\\t// try to change each character, make a new word find in set\\n    \\t\\t\\t\\tfor(char ch = \\'a\\'; ch <= \\'z\\'; ++ch){\\n    \\t\\t\\t\\t\\ttmp[i] = ch;\\t\\t\\t// makin\\' newWord\\n    \\t\\t\\t\\t\\t// if new word is same as curr word simply ignore\\n    \\t\\t\\t\\t\\tif(tmp.compare(currWord) == 0) continue;\\n    \\t\\t\\t\\t\\tif(tmp.compare(endWord) == 0) return cnt + 1;\\t// found the endWord return cnt\\n\\n    \\t\\t\\t\\t\\t// if we find the newWord is present in our map. put in the queue \\n                        // as the next destination node, which will help is to reach our endWord\\n                        if(s.find(tmp) != s.end()){\\n                        \\tq.push(tmp);\\t\\t// push the newWord or a node into queue \\n                        \\ts.erase(tmp);\\t\\t// remove that word, cuz it\\'s taken into the queue\\n                        }\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn 0;\\n    }\\n};\\n```\\n**Time   Complexity : `O(N * L * 26)`, where N : size of wordList**\\n**Space Complexity : `O(N)`, where L : len of words** \\n\\nIf you find any mistakes pls, drop a comment\\n& If it makes any sense **Please Upvote : }**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string &beginWord, string &endWord, vector<string> &wordList){\\n    \\tunordered_set<string> s(wordList.begin(), wordList.end());\\n\\n    \\tif(s.find(endWord) == s.end()) return 0;   // if our destination is not present in our list, return 0\\n    \\tint cnt = 0;\\t      // to count the number of nodes/steps needed to reach the destination word\\n    \\tqueue<string> q;\\n    \\tq.push(beginWord);\\t  // push the starting node into queue, as we did in BFS [beginWord is our root]\\n    \\t\\n    \\twhile(!q.empty()){\\n    \\t\\tauto size = q.size();\\n    \\t\\tcnt++;\\n    \\t\\twhile(size--){\\n    \\t\\t\\tauto currWord = q.front(); q.pop();\\n    \\t\\t\\t// find the next word which can be formed after currWord by changing it\\'s letter(s)\\n    \\t\\t\\tfor(int i = 0; i < currWord.size(); ++i){\\n    \\t\\t\\t\\tstring tmp = currWord;\\n    \\t\\t\\t\\t// try to change each character, make a new word find in set\\n    \\t\\t\\t\\tfor(char ch = \\'a\\'; ch <= \\'z\\'; ++ch){\\n    \\t\\t\\t\\t\\ttmp[i] = ch;\\t\\t\\t// makin\\' newWord\\n    \\t\\t\\t\\t\\t// if new word is same as curr word simply ignore\\n    \\t\\t\\t\\t\\tif(tmp.compare(currWord) == 0) continue;\\n    \\t\\t\\t\\t\\tif(tmp.compare(endWord) == 0) return cnt + 1;\\t// found the endWord return cnt\\n\\n    \\t\\t\\t\\t\\t// if we find the newWord is present in our map. put in the queue \\n                        // as the next destination node, which will help is to reach our endWord\\n                        if(s.find(tmp) != s.end()){\\n                        \\tq.push(tmp);\\t\\t// push the newWord or a node into queue \\n                        \\ts.erase(tmp);\\t\\t// remove that word, cuz it\\'s taken into the queue\\n                        }\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031862,
                "title": "simple-bfs-solution",
                "content": "The solution lies in a BFS traversal of graph with the begin word as the root node and the end word as the end solution. The main trick is to find the next node in the traversal. For that need to preprocess the word list provided to create a word store with a regex pattern which will help us to find the next probable word at each step of our traversal easily.\\n\\nThe solution can be divided into 2 steps\\n\\nStep 1: Preprocess the word list into a dictionary with key being something similar to a regex pattern so that if one intends to find a word in it with all the characters except for one it will be able to return all probable words.\\n\\nFor eg: lets assume the `word_list = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]`\\nWe need to create a pre processed dictionary of words which will look something like this\\n\\n```\\n{\\n\\t\\'*ot\\': [\\'hot\\', \\'dot\\', \\'lot\\'],\\n\\t\\'h*t\\': [\\'hot\\'], \\n\\t\\'ho*\\': [\\'hot\\'],\\n\\t\\'d*t\\': [\\'dot\\'], \\n\\t\\'do*\\': [\\'dot\\', \\'dog\\'], \\n\\t\\'*og\\': [\\'dog\\', \\'log\\', \\'cog\\'],\\n\\t\\'d*g\\': [\\'dog\\'],\\n\\t\\'l*t\\': [\\'lot\\'],\\n\\t\\'lo*\\': [\\'lot\\', \\'log\\'], \\n\\t\\'l*g\\': [\\'log\\'],\\n\\t\\'c*g\\': [\\'cog\\'],\\n\\t\\'co*\\': [\\'cog\\']\\n}\\n```\\n\\nStep 2: Start a BFS graph traversal with the begin word as the root node. In order to find the next node in the traversal we need to first find out all possible regex patterns which can be formed from the word.\\nFor eg: Lets assume the word is \"hit\", then all the patterns will be `[ \"*it\", \"h*t\", \"hi*\"]`\\nThis can be done in pyton simply by running the below loop\\n```\\nfor idx in range(len(word)):\\n\\tnew_word = word[:idx] + \\'*\\' + word[idx + 1:]\\n\\tstore[new_word].append(word)\\n```\\n\\nUsing the above generated pattern we will find all the next possible words from the dictionary which we prepared in the pre process. We will also keep track of the words visited all the while in order to avoid cyclic paths.\\n\\n```\\n        if not beginWord or not endWord or not wordList:\\n            return 0\\n\\n        words_set = set(wordList)\\n        if endWord not in words_set:\\n            return 0\\n\\n        store = defaultdict(list)\\n        for word in wordList:\\n            for idx in range(len(word)):\\n                new_word = word[:idx] + \\'*\\' + word[idx + 1:]\\n                store[new_word].append(word)\\n\\n        qu = [(beginWord, 1)]\\n        visited_word = set()\\n        while qu:\\n            current_word, current_count = qu.pop(0)\\n\\n            if current_word == endWord:\\n                return current_count\\n\\n            next_word_patterns = []\\n            for idx in range(len(current_word)):\\n                next_word_patterns.append(current_word[:idx] + \\'*\\' + current_word[idx + 1:])\\n\\n            for next_word_pattern in next_word_patterns:\\n                next_probable_words = store[next_word_pattern]\\n                for next_probable_word in set(next_probable_words) - visited_word:\\n                    qu.append((next_probable_word, current_count + 1))\\n                    visited_word.add(next_probable_word)\\n\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n{\\n\\t\\'*ot\\': [\\'hot\\', \\'dot\\', \\'lot\\'],\\n\\t\\'h*t\\': [\\'hot\\'], \\n\\t\\'ho*\\': [\\'hot\\'],\\n\\t\\'d*t\\': [\\'dot\\'], \\n\\t\\'do*\\': [\\'dot\\', \\'dog\\'], \\n\\t\\'*og\\': [\\'dog\\', \\'log\\', \\'cog\\'],\\n\\t\\'d*g\\': [\\'dog\\'],\\n\\t\\'l*t\\': [\\'lot\\'],\\n\\t\\'lo*\\': [\\'lot\\', \\'log\\'], \\n\\t\\'l*g\\': [\\'log\\'],\\n\\t\\'c*g\\': [\\'cog\\'],\\n\\t\\'co*\\': [\\'cog\\']\\n}\\n```\n```\\nfor idx in range(len(word)):\\n\\tnew_word = word[:idx] + \\'*\\' + word[idx + 1:]\\n\\tstore[new_word].append(word)\\n```\n```\\n        if not beginWord or not endWord or not wordList:\\n            return 0\\n\\n        words_set = set(wordList)\\n        if endWord not in words_set:\\n            return 0\\n\\n        store = defaultdict(list)\\n        for word in wordList:\\n            for idx in range(len(word)):\\n                new_word = word[:idx] + \\'*\\' + word[idx + 1:]\\n                store[new_word].append(word)\\n\\n        qu = [(beginWord, 1)]\\n        visited_word = set()\\n        while qu:\\n            current_word, current_count = qu.pop(0)\\n\\n            if current_word == endWord:\\n                return current_count\\n\\n            next_word_patterns = []\\n            for idx in range(len(current_word)):\\n                next_word_patterns.append(current_word[:idx] + \\'*\\' + current_word[idx + 1:])\\n\\n            for next_word_pattern in next_word_patterns:\\n                next_probable_words = store[next_word_pattern]\\n                for next_probable_word in set(next_probable_words) - visited_word:\\n                    qu.append((next_probable_word, current_count + 1))\\n                    visited_word.add(next_probable_word)\\n\\n        return 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008476,
                "title": "c-graphs-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n\\n        unordered_set <string > ourmap;\\n        bool found = false;\\n        \\n        for (auto w : wordList)\\n        {\\n            if (endWord == w)\\n                found = true;\\n            \\n            ourmap.insert(w);\\n        }\\n        \\n        if (!found)\\n        return 0;\\n       \\n        \\n        queue <string> pendingNodes;\\n        pendingNodes.push(beginWord);\\n        int level = 0;\\n        \\n        while (pendingNodes.size() != 0)\\n        {\\n            \\n            level ++;\\n            int size = pendingNodes.size();\\n            \\n            for (int i = 0 ; i < size ; i ++)\\n            {\\n                string current = pendingNodes.front();\\n                pendingNodes.pop();\\n                \\n             \\n                for (int j = 0 ; j < current.size() ;j ++)\\n                { \\n                    string temp = current;\\n                    for (char c = \\'a\\' ; c <= \\'z\\';  c++)\\n                    {\\n                        temp[j] = c;\\n                        \\n                     \\n                        \\n                        if (temp == current)\\n                            continue;\\n                        \\n                        else if (endWord == temp)\\n                            return level + 1;\\n                        \\n                        else if (ourmap.find(temp) != ourmap.end())\\n                        {\\n                            pendingNodes.push(temp);\\n                            ourmap.erase(temp);\\n                        }\\n                        \\n                    }\\n                }\\n\\n            }\\n   \\n        }\\n\\n        return 0;\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n\\n        unordered_set <string > ourmap;\\n        bool found = false;\\n        \\n        for (auto w : wordList)\\n        {\\n            if (endWord == w)\\n                found = true;\\n            \\n            ourmap.insert(w);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 878515,
                "title": "c-bfs-easy-to-understand-intuitive",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\tusing ll = long long int;\\n\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\tqueue<pair<string, ll>> q;\\n\\t\\tq.push({beginWord, 0});\\n\\n\\t\\tunordered_set<string> s;\\n\\t\\tunordered_map<string, bool> vis;\\n\\t\\tfor (auto &word : wordList) {\\n\\t\\t\\ts.insert(word);\\n\\t\\t}\\n\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tauto tp = q.front();\\n\\n\\t\\t\\tif (tp.first == endWord) return tp.second + 1;\\n\\t\\t\\tq.pop();\\n\\n\\t\\t\\tif (vis[tp.first]) continue;\\n\\t\\t\\tvis[tp.first] = 1;\\n\\n\\t\\t\\tfor (int i = 0; i < 26; ++i) {\\n\\t\\t\\t\\tchar c = \\'a\\' + i;\\n\\t\\t\\t\\tfor (int j = 0; j < tp.first.size(); ++j) {\\n\\t\\t\\t\\t\\tstring &temp = tp.first;\\n\\t\\t\\t\\t\\tchar orig = temp[j];\\n\\t\\t\\t\\t\\ttemp[j] = c;\\n\\t\\t\\t\\t\\tif (s.find(temp) != s.end()) q.push({temp, tp.second + 1});\\n\\t\\t\\t\\t\\ttemp[j] = orig;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\tusing ll = long long int;\\n\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n\\t\\tqueue<pair<string, ll>> q;\\n\\t\\tq.push({beginWord, 0});\\n\\n\\t\\tunordered_set<string> s;\\n\\t\\tunordered_map<string, bool> vis;\\n\\t\\tfor (auto &word : wordList) {\\n\\t\\t\\ts.insert(word);\\n\\t\\t}\\n\\n\\t\\twhile (!q.empty()) {\\n\\t\\t\\tauto tp = q.front();\\n\\n\\t\\t\\tif (tp.first == endWord) return tp.second + 1;\\n\\t\\t\\tq.pop();\\n\\n\\t\\t\\tif (vis[tp.first]) continue;\\n\\t\\t\\tvis[tp.first] = 1;\\n\\n\\t\\t\\tfor (int i = 0; i < 26; ++i) {\\n\\t\\t\\t\\tchar c = \\'a\\' + i;\\n\\t\\t\\t\\tfor (int j = 0; j < tp.first.size(); ++j) {\\n\\t\\t\\t\\t\\tstring &temp = tp.first;\\n\\t\\t\\t\\t\\tchar orig = temp[j];\\n\\t\\t\\t\\t\\ttemp[j] = c;\\n\\t\\t\\t\\t\\tif (s.find(temp) != s.end()) q.push({temp, tp.second + 1});\\n\\t\\t\\t\\t\\ttemp[j] = orig;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813941,
                "title": "why-does-dfs-memo-get-wrong-answer-37-43-test-cases-passed",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        wordList = set(wordList)\\n        step =  self.helper(beginWord, endWord, wordList, [], {})\\n        if step > len(wordList):\\n            return 0\\n        return step\\n        \\n    def helper(self, beginWord, endWord, wordList, path, memo):\\n        if beginWord == endWord:\\n            return 1\\n        if beginWord in memo:\\n            return memo[beginWord]\\n        min_step = len(wordList) + 1\\n        for i, char in enumerate(beginWord):\\n            for j in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                if j != char:\\n                    new_word = beginWord[:i] + j + beginWord[i + 1:]\\n                    if new_word in wordList and new_word not in path:\\n                        path.append(new_word)\\n                        step = self.helper(new_word, endWord, wordList, path, memo) + 1\\n                        path.pop()\\n                        min_step = min(step, min_step)      \\n        memo[beginWord] = min_step\\n        return min_step\\n\\t\\t\\ninput:\\n\"cet\"\\n\"ism\"\\n[\"kid\",\"tag\",\"pup\",\"ail\",\"tun\",\"woo\",\"erg\",\"luz\",\"brr\",\"gay\",\"sip\",\"kay\",\"per\",\"val\",\"mes\",\"ohs\",\"now\",\"boa\",\"cet\",\"pal\",\\n\"bar\",\"die\",\"war\",\"hay\",\"eco\",\"pub\",\"lob\",\"rue\",\"fry\",\"lit\",\"rex\",\"jan\",\"cot\",\"bid\",\"ali\",\"pay\",\"col\",\"gum\",\"ger\",\"row\",\"won\",\\n\"dan\",\"rum\",\"fad\",\"tut\",\"sag\",\"yip\",\"sui\",\"ark\",\"has\",\"zip\",\"fez\",\"own\",\"ump\",\"dis\",\"ads\",\"max\",\"jaw\",\"out\",\"btu\",\"ana\",\\n\"gap\",\"cry\",\"led\",\"abe\",\"box\",\"ore\",\"pig\",\"fie\",\"toy\",\"fat\",\"cal\",\"lie\",\"noh\",\"sew\",\"ono\",\"tam\",\"flu\",\"mgm\",\"ply\",\"awe\",\"pry\",\\n\"tit\",\"tie\",\"yet\",\"too\",\"tax\",\"jim\",\"san\",\"pan\",\"map\",\"ski\",\"ova\",\"wed\",\"non\",\"wac\",\"nut\",\"why\",\"bye\",\"lye\",\"oct\",\"old\",\"fin\",\\n\"feb\",\"chi\",\"sap\",\"owl\",\"log\",\"tod\",\"dot\",\"bow\",\"fob\",\"for\",\"joe\",\"ivy\",\"fan\",\"age\",\"fax\",\"hip\",\"jib\",\"mel\",\"hus\",\"sob\",\"ifs\",\"tab\",\\n\"ara\",\"dab\",\"jag\",\"jar\",\"arm\",\"lot\",\"tom\",\"sax\",\"tex\",\"yum\",\"pei\",\"wen\",\"wry\",\"ire\",\"irk\",\"far\",\"mew\",\"wit\",\"doe\",\"gas\",\"rte\",\"ian\",\\n\"pot\",\"ask\",\"wag\",\"hag\",\"amy\",\"nag\",\"ron\",\"soy\",\"gin\",\"don\",\"tug\",\"fay\",\"vic\",\"boo\",\"nam\",\"ave\",\"buy\",\"sop\",\"but\",\"orb\",\"fen\",\\n\"paw\",\"his\",\"sub\",\"bob\",\"yea\",\"oft\",\"inn\",\"rod\",\"yam\",\"pew\",\"web\",\"hod\",\"hun\",\"gyp\",\"wei\",\"wis\",\"rob\",\"gad\",\"pie\",\"mon\",\"dog\",\\n\"bib\",\"rub\",\"ere\",\"dig\",\"era\",\"cat\",\"fox\",\"bee\",\"mod\",\"day\",\"apr\",\"vie\",\"nev\",\"jam\",\"pam\",\"new\",\"aye\",\"ani\",\"and\",\"ibm\",\"yap\",\"can\",\\n\"pyx\",\"tar\",\"kin\",\"fog\",\"hum\",\"pip\",\"cup\",\"dye\",\"lyx\",\"jog\",\"nun\",\"par\",\"wan\",\"fey\",\"bus\",\"oak\",\"bad\",\"ats\",\"set\",\"qom\",\"vat\",\"eat\",\\n\"pus\",\"rev\",\"axe\",\"ion\",\"six\",\"ila\",\"lao\",\"mom\",\"mas\",\"pro\",\"few\",\"opt\",\"poe\",\"art\",\"ash\",\"oar\",\"cap\",\"lop\",\"may\",\"shy\",\"rid\",\"bat\",\\n\"sum\",\"rim\",\"fee\",\"bmw\",\"sky\",\"maj\",\"hue\",\"thy\",\"ava\",\"rap\",\"den\",\"fla\",\"auk\",\"cox\",\"ibo\",\"hey\",\"saw\",\"vim\",\"sec\",\"ltd\",\"you\",\"its\"\\n,\"tat\",\"dew\",\"eva\",\"tog\",\"ram\",\"let\",\"see\",\"zit\",\"maw\",\"nix\",\"ate\",\"gig\",\"rep\",\"owe\",\"ind\",\"hog\",\"eve\",\"sam\",\"zoo\",\"any\",\"dow\",\"cod\",\\n\"bed\",\"vet\",\"ham\",\"sis\",\"hex\",\"via\",\"fir\",\"nod\",\"mao\",\"aug\",\"mum\",\"hoe\",\"bah\",\"hal\",\"keg\",\"hew\",\"zed\",\"tow\",\"gog\",\"ass\",\"dem\",\"who\",\\n\"bet\",\"gos\",\"son\",\"ear\",\"spy\",\"kit\",\"boy\",\"due\",\"sen\",\"oaf\",\"mix\",\"hep\",\"fur\",\"ada\",\"bin\",\"nil\",\"mia\",\"ewe\",\"hit\",\"fix\",\"sad\",\"rib\",\"eye\",\\n\"hop\",\"haw\",\"wax\",\"mid\",\"tad\",\"ken\",\"wad\",\"rye\",\"pap\",\"bog\",\"gut\",\"ito\",\"woe\",\"our\",\"ado\",\"sin\",\"mad\",\"ray\",\"hon\",\"roy\",\"dip\",\"hen\",\"iva\",\\n\"lug\",\"asp\",\"hui\",\"yak\",\"bay\",\"poi\",\"yep\",\"bun\",\"try\",\"lad\",\"elm\",\"nat\",\"wyo\",\"gym\",\"dug\",\"toe\",\"dee\",\"wig\",\"sly\",\"rip\",\"geo\",\"cog\",\"pas\",\"zen\",\\n\"odd\",\"nan\",\"lay\",\"pod\",\"fit\",\"hem\",\"joy\",\"bum\",\"rio\",\"yon\",\"dec\",\"leg\",\"put\",\"sue\",\"dim\",\"pet\",\"yaw\",\"nub\",\"bit\",\"bur\",\"sid\",\"sun\",\"oil\",\"red\",\\n\"doc\",\"moe\",\"caw\",\"eel\",\"dix\",\"cub\",\"end\",\"gem\",\"off\",\"yew\",\"hug\",\"pop\",\"tub\",\"sgt\",\"lid\",\"pun\",\"ton\",\"sol\",\"din\",\"yup\",\"jab\",\"pea\",\"bug\",\"gag\",\\n\"mil\",\"jig\",\"hub\",\"low\",\"did\",\"tin\",\"get\",\"gte\",\"sox\",\"lei\",\"mig\",\"fig\",\"lon\",\"use\",\"ban\",\"flo\",\"nov\",\"jut\",\"bag\",\"mir\",\"sty\",\"lap\",\"two\",\"ins\",\"con\",\"ant\",\\n\"net\",\"tux\",\"ode\",\"stu\",\"mug\",\"cad\",\"nap\",\"gun\",\"fop\",\"tot\",\"sow\",\"sal\",\"sic\",\"ted\",\"wot\",\"del\",\"imp\",\"cob\",\"way\",\"ann\",\"tan\",\"mci\",\"job\",\"wet\",\"ism\",\\n\"err\",\"him\",\"all\",\"pad\",\"hah\",\"hie\",\"aim\",\"ike\",\"jed\",\"ego\",\"mac\",\"baa\",\"min\",\"com\",\"ill\",\"was\",\"cab\",\"ago\",\"ina\",\"big\",\"ilk\",\"gal\",\"tap\",\"duh\",\"ola\",\"ran\",\\n\"lab\",\"top\",\"gob\",\"hot\",\"ora\",\"tia\",\"kip\",\"han\",\"met\",\"hut\",\"she\",\"sac\",\"fed\",\"goo\",\"tee\",\"ell\",\"not\",\"act\",\"gil\",\"rut\",\"ala\",\"ape\",\"rig\",\"cid\",\"god\",\"duo\",\\n\"lin\",\"aid\",\"gel\",\"awl\",\"lag\",\"elf\",\"liz\",\"ref\",\"aha\",\"fib\",\"oho\",\"tho\",\"her\",\"nor\",\"ace\",\"adz\",\"fun\",\"ned\",\"coo\",\"win\",\"tao\",\"coy\",\"van\",\"man\",\"pit\",\"guy\",\\n\"foe\",\"hid\",\"mai\",\"sup\",\"jay\",\"hob\",\"mow\",\"jot\",\"are\",\"pol\",\"arc\",\"lax\",\"aft\",\"alb\",\"len\",\"air\",\"pug\",\"pox\",\"vow\",\"got\",\"meg\",\"zoe\",\"amp\",\"ale\",\"bud\",\\n\"gee\",\"pin\",\"dun\",\"pat\",\"ten\",\"mob\"]\\n\\nOutput: 12\\nExpected: 11\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        wordList = set(wordList)\\n        step =  self.helper(beginWord, endWord, wordList, [], {}",
                "codeTag": "Java"
            },
            {
                "id": 776651,
                "title": "javascript-solution-with-bfs-commented-for-clarity",
                "content": "```\\nfunction ladderLength (beginWord, endWord, wordList) {\\n  // Because \\'wordList\\' is an array, lookups for values\\n  // will be a linear search ( O(n) ), so we\\'ll convert\\n  // it to a Set so we can get O(1) lookup time for words\\n  const wordsSet = new Set(wordList)\\n\\n  // Check if our endWord is in our set\\n  if (!wordsSet.has(endWord)) return 0\\n\\n  // Initialize our queue to support BFS\\n  // NOTE: Arrays are not the best data structure to\\n  // model a queue, however, it is built into JS and\\n  // works well enough for this example. There is a\\n  // potencial for performance gains by replacing this\\n  // with a custom SLL implementation.\\n  const queue = []\\n  queue.push(beginWord)\\n\\n  // Initialize our Set to keep track of words we\\'ve seen\\n  const seenWords = new Set()\\n  seenWords.add(beginWord)\\n\\n  // Because we know there is a path to our end word we\\'ll\\n  // initialize our changes counter to 1\\n  let changes = 1\\n\\n  while (queue.length !== 0) {\\n    // Keep track of our queue size, when we\\'ve looped through\\n    // the current size, we\\'ll increment our \\'changes\\' counter\\n    // and then resume working the queue\\n    const size = queue.length\\n    for (let i = 0; i < size; i++) {\\n      // Pull the first word out of our queue\\n      const word = queue.shift()\\n\\n      // Check if we\\'ve found our end word\\n      if (word === endWord) return changes\\n\\n      // Loop over all chars in the word, changing them, to\\n      // see if we can construct new words that are in our\\n      // word list\\n      for (let i = 0; i < word.length; i++) {\\n        // Replace each char with a-z using unicode (97=a, 122=z)\\n        for (let j = 97; j < 123; j++) {\\n          const newWord = (\\n            word.substring(0, i) + String.fromCharCode(j)\\n          ).concat(word.substring(i + 1))\\n\\n          // Check if we found a new word that is in our list, but\\n          // hasn\\'t been encountered before\\n          if (wordsSet.has(newWord) && !seenWords.has(newWord)) {\\n            // It\\'s a new word, track it in our sets\\n            queue.push(newWord)\\n            seenWords.add(newWord)\\n          }\\n        }\\n      }\\n    }\\n\\n    // Increment our changes counter\\n    ++changes\\n  }\\n\\n  // We were unable to find a path to our \\'endWord\\', so we\\'ll return\\n  // 0 here\\n  return 0\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction ladderLength (beginWord, endWord, wordList) {\\n  // Because \\'wordList\\' is an array, lookups for values\\n  // will be a linear search ( O(n) ), so we\\'ll convert\\n  // it to a Set so we can get O(1) lookup time for words\\n  const wordsSet = new Set(wordList)\\n\\n  // Check if our endWord is in our set\\n  if (!wordsSet.has(endWord)) return 0\\n\\n  // Initialize our queue to support BFS\\n  // NOTE: Arrays are not the best data structure to\\n  // model a queue, however, it is built into JS and\\n  // works well enough for this example. There is a\\n  // potencial for performance gains by replacing this\\n  // with a custom SLL implementation.\\n  const queue = []\\n  queue.push(beginWord)\\n\\n  // Initialize our Set to keep track of words we\\'ve seen\\n  const seenWords = new Set()\\n  seenWords.add(beginWord)\\n\\n  // Because we know there is a path to our end word we\\'ll\\n  // initialize our changes counter to 1\\n  let changes = 1\\n\\n  while (queue.length !== 0) {\\n    // Keep track of our queue size, when we\\'ve looped through\\n    // the current size, we\\'ll increment our \\'changes\\' counter\\n    // and then resume working the queue\\n    const size = queue.length\\n    for (let i = 0; i < size; i++) {\\n      // Pull the first word out of our queue\\n      const word = queue.shift()\\n\\n      // Check if we\\'ve found our end word\\n      if (word === endWord) return changes\\n\\n      // Loop over all chars in the word, changing them, to\\n      // see if we can construct new words that are in our\\n      // word list\\n      for (let i = 0; i < word.length; i++) {\\n        // Replace each char with a-z using unicode (97=a, 122=z)\\n        for (let j = 97; j < 123; j++) {\\n          const newWord = (\\n            word.substring(0, i) + String.fromCharCode(j)\\n          ).concat(word.substring(i + 1))\\n\\n          // Check if we found a new word that is in our list, but\\n          // hasn\\'t been encountered before\\n          if (wordsSet.has(newWord) && !seenWords.has(newWord)) {\\n            // It\\'s a new word, track it in our sets\\n            queue.push(newWord)\\n            seenWords.add(newWord)\\n          }\\n        }\\n      }\\n    }\\n\\n    // Increment our changes counter\\n    ++changes\\n  }\\n\\n  // We were unable to find a path to our \\'endWord\\', so we\\'ll return\\n  // 0 here\\n  return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536869,
                "title": "simple-javascript-bfs-solution",
                "content": "```\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) return 0;\\n    \\n    const wordIn = new Array(wordList.length).fill(true);\\n    let q = [];\\n    q.push({ wrd: beginWord, level: 1});\\n    \\n    while (q.length) {\\n        let curr = q.pop();\\n        if (curr.wrd === endWord) return curr.level;\\n\\n        for (let i = 0; i < wordList.length; i++) {\\n            if(!wordIn[i]) continue;\\n\\n            let charDiff = 0\\n            for (let j = 0; j < wordList[i].length; j++) {\\n                if (wordList[i].charAt(j) !== curr.wrd.charAt(j)) charDiff += 1;\\n            }\\n\\n            if (charDiff === 1) {\\n                q.unshift({ wrd: wordList[i], level: curr.level + 1});\\n                wordIn[i] = false;\\n            }\\n        }\\n    }\\n     \\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    if (!wordList.includes(endWord)) return 0;\\n    \\n    const wordIn = new Array(wordList.length).fill(true);\\n    let q = [];\\n    q.push({ wrd: beginWord, level: 1});\\n    \\n    while (q.length) {\\n        let curr = q.pop();\\n        if (curr.wrd === endWord) return curr.level;\\n\\n        for (let i = 0; i < wordList.length; i++) {\\n            if(!wordIn[i]) continue;\\n\\n            let charDiff = 0\\n            for (let j = 0; j < wordList[i].length; j++) {\\n                if (wordList[i].charAt(j) !== curr.wrd.charAt(j)) charDiff += 1;\\n            }\\n\\n            if (charDiff === 1) {\\n                q.unshift({ wrd: wordList[i], level: curr.level + 1});\\n                wordIn[i] = false;\\n            }\\n        }\\n    }\\n     \\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 268307,
                "title": "two-solutions-in-python-much-better-than-the-official-solutions",
                "content": "Approach 1: Breadth First Search\\n\\n```python\\n\\nclass Solution1:\\n    def ladderLength(self, beginWord, endWord, wordList):\\n          \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype step: int\\n        \"\"\"\\n        visited = set()\\n        wordSet = set(wordList)\\n        \\n        queue = [(beginWord, 1)]\\n        \\n        while len(queue) > 0: #queue is not empty \\n            word, step = queue.pop(0)\\n            #logging.debug(f\"word: {word}, step:{step}\")\\n\\n            #base case \\n            if word == endWord:\\n                return step #get the result.\\n            if word in visited: #better than multiple conditions later.\\n                continue\\n            #visited.add(word) # paint word as visited\\n            \\n            #traverse all the  variants \\n            for i in range(len(word)):\\n                for j in range(0, 26): \\n                    ordinal = ord(\\'a\\') + j\\n                    next_word = word[0:i] + chr(ordinal) + word[i + 1:]\\n                    #logging.debug(f\"changed_word: {next_word}\")\\n                    if next_word in wordSet: \\n                        queue.append((next_word, step + 1)) #contiue next stretch \\n            visited.add(word) # paint word as visited\\n        \\n        return 0 \\n```\\n\\n\\n\\n> Runtime: 740 ms, faster than 22.79% of Python3 online submissions for Word Ladder.\\n>\\n> Memory Usage: 15.9 MB, less than 13.09% of Python3 online submissions for Word Ladder.\\n\\nApproach 2: Bidirectional Breadth First Search\\n\\n```python\\n\\nclass Solution2(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        #base case\\n        if (endWord not in wordList) or (not endWord) or (not beginWord) or (not wordList):\\n            return 0\\n        size = len(beginWord)\\n        word_set = set(wordList)    \\n        forwards, backwards = {beginWord}, {endWord}\\n        visited = set()\\n        step = 0\\n        while forwards and backwards:\\n            step += 1 #treat the first word as step 1\\n            if len(forwards) > len(backwards): \\n                forwards, backwards = backwards, forwards #switch process\\n            #logging.debug(f\"step: {step}, forwards: {forwards}, backwords: {backwards}\")\\n\\n            neighbors= set()   \\n            for word in forwards:#visit words on this level\\n                if word in visited: continue\\n\\n                for i in range(size):\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        next_word = word[:i] + c + word[i+1:]\\n                        if next_word in backwards: return step +  1 #terminating case\\n                        if next_word in word_set: neighbors.add(next_word)\\n                        #logging.debug(f\"next_word{next_word}, step: {step}\")\\n                visited.add(word) #add visited word as the final step \\n            forwards = neighbors \\n        #logging.debug(f\"final: {step}\")\\n        return 0\\n```\\n\\n\\n\\n> Runtime: 80 ms, faster than 98.38% of Python3 online submissions for Word Ladder.\\n>\\n> Memory Usage: 13.6 MB, less than 28.37% of Python3 online submissions for Word Ladder.\\n>\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\n\\nclass Solution1:\\n    def ladderLength(self, beginWord, endWord, wordList):\\n          \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype step: int\\n        \"\"\"\\n        visited = set()\\n        wordSet = set(wordList)\\n        \\n        queue = [(beginWord, 1)]\\n        \\n        while len(queue) > 0: #queue is not empty \\n            word, step = queue.pop(0)\\n            #logging.debug(f\"word: {word}, step:{step}\")\\n\\n            #base case \\n            if word == endWord:\\n                return step #get the result.\\n            if word in visited: #better than multiple conditions later.\\n                continue\\n            #visited.add(word) # paint word as visited\\n            \\n            #traverse all the  variants \\n            for i in range(len(word)):\\n                for j in range(0, 26): \\n                    ordinal = ord(\\'a\\') + j\\n                    next_word = word[0:i] + chr(ordinal) + word[i + 1:]\\n                    #logging.debug(f\"changed_word: {next_word}\")\\n                    if next_word in wordSet: \\n                        queue.append((next_word, step + 1)) #contiue next stretch \\n            visited.add(word) # paint word as visited\\n        \\n        return 0 \\n```\n```python\\n\\nclass Solution2(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        #base case\\n        if (endWord not in wordList) or (not endWord) or (not beginWord) or (not wordList):\\n            return 0\\n        size = len(beginWord)\\n        word_set = set(wordList)    \\n        forwards, backwards = {beginWord}, {endWord}\\n        visited = set()\\n        step = 0\\n        while forwards and backwards:\\n            step += 1 #treat the first word as step 1\\n            if len(forwards) > len(backwards): \\n                forwards, backwards = backwards, forwards #switch process\\n            #logging.debug(f\"step: {step}, forwards: {forwards}, backwords: {backwards}\")\\n\\n            neighbors= set()   \\n            for word in forwards:#visit words on this level\\n                if word in visited: continue\\n\\n                for i in range(size):\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        next_word = word[:i] + c + word[i+1:]\\n                        if next_word in backwards: return step +  1 #terminating case\\n                        if next_word in word_set: neighbors.add(next_word)\\n                        #logging.debug(f\"next_word{next_word}, step: {step}\")\\n                visited.add(word) #add visited word as the final step \\n            forwards = neighbors \\n        #logging.debug(f\"final: {step}\")\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179048,
                "title": "concise-python-bfs-solution",
                "content": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        d = defaultdict(list)  # build a graph like this {\\'h*t\\': [\\'hit\\', \\'hot\\']}\\n        for word in wordList:\\n            for i in range(len(word)):\\n                d[word[:i] + \\'*\\' + word[i + 1:]].append(word)\\n        q, visited = deque([(beginWord, 1)]), set()\\n        while q:\\n            word, length = q.popleft()\\n            if word == endWord:\\n                return length\\n            visited.add(word)\\n            for i in range(len(word)):\\n                for w in d[word[:i] + \\'*\\' + word[i + 1:]]:\\n                    if w not in visited:\\n                        q.append((w, length + 1))\\n        return 0\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        d = defaultdict(list)  # build a graph like this {\\'h*t\\': [\\'hit\\', \\'hot\\']}\\n        for word in wordList:\\n            for i in range(len(word)):\\n                d[word[:i] + \\'*\\' + word[i + 1:]].append(word)\\n        q, visited = deque([(beginWord, 1)]), set()\\n        while q:\\n            word, length = q.popleft()\\n            if word == endWord:\\n                return length\\n            visited.add(word)\\n            for i in range(len(word)):\\n                for w in d[word[:i] + \\'*\\' + word[i + 1:]]:\\n                    if w not in visited:\\n                        q.append((w, length + 1))\\n        return 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164906,
                "title": "python-basic-bfs",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        visited = set()\\n        wordSet = set(wordList)\\n        \\n        queue = [(beginWord, 1)]\\n        \\n        while len(queue) > 0:\\n            word, count = queue.pop(0)\\n            if word == endWord:\\n                return count\\n            if word in visited:\\n                continue\\n                \\n            for i in range(len(word)):\\n                for j in range(0, 26): # try all possible one character permutations\\n                    char = ord(\\'a\\') + j\\n                    changed_word = word[0:i] + chr(char) + word[i + 1:]\\n                    if changed_word in wordSet: # if permuted word is in word list then add children\\n                        queue.append((changed_word, count + 1))\\n            visited.add(word) # mark word as visited\\n        \\n        return 0 # if queue is exhausted and code reachers here then its impossible to reach endWord\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        visited = set()\\n        wordSet = set(wordList)\\n        \\n        queue = [(beginWord, 1)]\\n        \\n        while len(queue) > 0:\\n            word, count = queue.pop(0)\\n            if word == endWord:\\n                return count\\n            if word in visited:\\n                continue\\n                \\n            for i in range(len(word)):\\n                for j in range(0, 26): # try all possible one character permutations\\n                    char = ord(\\'a\\') + j\\n                    changed_word = word[0:i] + chr(char) + word[i + 1:]\\n                    if changed_word in wordSet: # if permuted word is in word list then add children\\n                        queue.append((changed_word, count + 1))\\n            visited.add(word) # mark word as visited\\n        \\n        return 0 # if queue is exhausted and code reachers here then its impossible to reach endWord\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 139753,
                "title": "bfs-solution-full-discussion-with-pictures-and-how-to-adapt-to-word-ladder-ii",
                "content": "Imagine the problem as a graph, then this is just a bfs:\\n```python\\n# beginWord - string, endWord - string, wordList - list of string\\ndef ladderLength(beginWord, endWord, wordList):\\n    # We use q to keep track of the next nodes to process in the BFS.\\n    # Each item in the queue is a list with two items:\\n    #   item[0] = word\\n    #   item[1] = steps to reach word + 1 (i.e. number of nodes in list of nodes \\n    #             traversed to reach word - (format of Word Ladder I output)).\\n    q = collections.deque([ [beginWord,1] ])\\n    # We keep track of words we\\'ve processed to avoid getting stuck in a loop.\\n    seen = set([beginWord])\\n    # wordList is given as a list but we want O(1) lookup so we convert to a set.\\n    wordList = set(wordList)\\n    while q:\\n        q_item = q.popleft()\\n        for candidate in generateNeighbors(q_item[0], wordList):\\n            if candidate == endWord:\\n                return q_item[1] + 1\\n            elif candidate in seen:\\n                continue\\n            seen.add(candidate)\\n            q.append([candidate, q_item[1] + 1])\\n    return 0\\n```\\nThe tricky part is generate neighbors. Don\\'t look through the whole wordlist, just do something that is constant time per node, like:\\n```python\\ndef generateNeighbors(word, wordList):\\n    for i in range(len(word)):\\n        for letter in string.ascii_lowercase:\\n            candidate = word[:i] + letter + word[i+1:]\\n            if candidate in wordList:\\n                yield candidate\\n```\\nThere is also another option for generate neighbors.  For example say word is fish, hash:\\n_ish -> fish\\nf_sh -> fish\\nfi_h -> fish\\nfis_ -> fish\\n\\nNow, when you look up a word, say wish: look up _ish, w_sh, wi_h, wis_, and you will find all neighbors.\\n\\nFull explanation of this and how to adapt for word ladder II:\\nhttps://fizzbuzzed.com/top-interview-questions-4/\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\n# beginWord - string, endWord - string, wordList - list of string\\ndef ladderLength(beginWord, endWord, wordList):\\n    # We use q to keep track of the next nodes to process in the BFS.\\n    # Each item in the queue is a list with two items:\\n    #   item[0] = word\\n    #   item[1] = steps to reach word + 1 (i.e. number of nodes in list of nodes \\n    #             traversed to reach word - (format of Word Ladder I output)).\\n    q = collections.deque([ [beginWord,1] ])\\n    # We keep track of words we\\'ve processed to avoid getting stuck in a loop.\\n    seen = set([beginWord])\\n    # wordList is given as a list but we want O(1) lookup so we convert to a set.\\n    wordList = set(wordList)\\n    while q:\\n        q_item = q.popleft()\\n        for candidate in generateNeighbors(q_item[0], wordList):\\n            if candidate == endWord:\\n                return q_item[1] + 1\\n            elif candidate in seen:\\n                continue\\n            seen.add(candidate)\\n            q.append([candidate, q_item[1] + 1])\\n    return 0\\n```\n```python\\ndef generateNeighbors(word, wordList):\\n    for i in range(len(word)):\\n        for letter in string.ascii_lowercase:\\n            candidate = word[:i] + letter + word[i+1:]\\n            if candidate in wordList:\\n                yield candidate\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 40785,
                "title": "share-the-vector-version-of-two-end-bfs-in-c-32ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> beginlist;\\n        unordered_set<string> endlist;\\n        unordered_set<string> rest;\\n        for(int i=0;i<wordList.size();i++) rest.insert(wordList[i]);\\n        if (rest.find(endWord) != rest.end()) {\\n            rest.erase(endWord);\\n        }else{\\n            return 0;\\n        }\\n        int depth = 2;\\n        beginlist.insert(beginWord);\\n        endlist.insert(endWord);\\n        while(!beginlist.empty() && !endlist.empty()){\\n            unordered_set<string> * pb;\\n            unordered_set<string> * pe;\\n            if (beginlist.size() < endlist.size()) {\\n                pb = &beginlist; \\n                pe = &endlist; \\n            } else {\\n                pe = &beginlist; \\n                pb = &endlist; \\n            }\\n            unordered_set<string> tmp;\\n            for(unordered_set<string>::iterator it = pb->begin();it!=pb->end();it++){\\n                string w = *it;\\n                for(int i=0;i<w.length();i++)\\n                {\\n                    char c = w[i];\\n                    for(int j=0;j<26;j++)\\n                    {\\n                        w[i] = 'a'+j;\\n                        if (w[i] == c) continue;\\n                        // printf(\"%s\\\\n\", w.c_str());\\n                        if (pe->find(w) != pe->end()) {\\n                            // printf(\"now find %s in pe.\\\\n\", w.c_str());\\n                            return depth;\\n                        }\\n                        if (rest.find(w) != rest.end()) {\\n                            tmp.insert(w);\\n                            rest.erase(w);\\n                        }\\n                    }\\n                    w[i] = c;\\n                }\\n            }\\n            depth++;\\n            *pb = tmp;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\xb7\\xb7\\xb7",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> beginlist;\\n        unordered_set<string> endlist;\\n        unordered_set<string> rest;\\n        for(int i=0;i<wordList.size();i++) rest.insert(wordList[i]);\\n        if (rest.find(endWord) != rest.end()) {\\n            rest.erase(endWord);\\n        }else{\\n            return 0;\\n        }\\n        int depth = 2;\\n        beginlist.insert(beginWord);\\n        endlist.insert(endWord);\\n        while(!beginlist.empty() && !endlist.empty()){\\n            unordered_set<string> * pb;\\n            unordered_set<string> * pe;\\n            if (beginlist.size() < endlist.size()) {\\n                pb = &beginlist; \\n                pe = &endlist; \\n            } else {\\n                pe = &beginlist; \\n                pb = &endlist; \\n            }\\n            unordered_set<string> tmp;\\n            for(unordered_set<string>::iterator it = pb->begin();it!=pb->end();it++){\\n                string w = *it;\\n                for(int i=0;i<w.length();i++)\\n                {\\n                    char c = w[i];\\n                    for(int j=0;j<26;j++)\\n                    {\\n                        w[i] = 'a'+j;\\n                        if (w[i] == c) continue;\\n                        // printf(\"%s\\\\n\", w.c_str());\\n                        if (pe->find(w) != pe->end()) {\\n                            // printf(\"now find %s in pe.\\\\n\", w.c_str());\\n                            return depth;\\n                        }\\n                        if (rest.find(w) != rest.end()) {\\n                            tmp.insert(w);\\n                            rest.erase(w);\\n                        }\\n                    }\\n                    w[i] = c;\\n                }\\n            }\\n            depth++;\\n            *pb = tmp;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40856,
                "title": "java-bidirectional-search-18ms-beats-99-54",
                "content": "```\\npublic class Solution {\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n        Set<String> set1 = new HashSet<String>();\\n        set1.add(beginWord);\\n        \\n        Set<String> set2 = new HashSet<String>();\\n        set2.add(endWord);\\n        \\n        wordList.remove(beginWord);\\n        wordList.remove(endWord);\\n        \\n        return minLengthBidirectionalSearch(set1, set2, wordList, 2);\\n    }\\n    \\n    public int minLengthBidirectionalSearch(Set<String> set1, Set<String> set2, Set<String> wordList, int length) {\\n        if(set1.size() == 0) return 0;\\n        \\n        Set<String> newSet = new HashSet<String>();\\n        \\n        for(String s : set1) {\\n            char[] str = s.toCharArray();\\n            for(int j = 0; j < str.length; j++) {\\n                char og = str[j];\\n                for(char c = 'a'; c <= 'z'; c++) {\\n                    str[j] = c;\\n                    String newStr = String.valueOf(str);\\n                    if(set2.contains(newStr)) return length;\\n                    if(wordList.contains(newStr)) {\\n                        newSet.add(newStr);\\n                        wordList.remove(newStr);\\n                    }\\n                }\\n                str[j] = og;\\n            }\\n        }\\n\\n        // This part is KEY to bringing your run-time down. Otherwise sets with more neighbours \\n        // will skew the benefit that can be obtained from searching outward from two nodes.\\n        if(newSet.size() < set2.size()) {\\n            return minLengthBidirectionalSearch(newSet, set2, wordList, length+1);\\n        } else {\\n            return minLengthBidirectionalSearch(set2, newSet, wordList, length+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {\\n        Set<String> set1 = new HashSet<String>();\\n        set1.add(beginWord);\\n        \\n        Set<String> set2 = new HashSet<String>();\\n        set2.add(endWord);\\n        \\n        wordList.remove(beginWord);\\n        wordList.remove(endWord);\\n        \\n        return minLengthBidirectionalSearch(set1, set2, wordList, 2);\\n    }\\n    \\n    public int minLengthBidirectionalSearch(Set<String> set1, Set<String> set2, Set<String> wordList, int length) {\\n        if(set1.size() == 0) return 0;\\n        \\n        Set<String> newSet = new HashSet<String>();\\n        \\n        for(String s : set1) {\\n            char[] str = s.toCharArray();\\n            for(int j = 0; j < str.length; j++) {\\n                char og = str[j];\\n                for(char c = 'a'; c <= 'z'; c++) {\\n                    str[j] = c;\\n                    String newStr = String.valueOf(str);\\n                    if(set2.contains(newStr)) return length;\\n                    if(wordList.contains(newStr)) {\\n                        newSet.add(newStr);\\n                        wordList.remove(newStr);\\n                    }\\n                }\\n                str[j] = og;\\n            }\\n        }\\n\\n        // This part is KEY to bringing your run-time down. Otherwise sets with more neighbours \\n        // will skew the benefit that can be obtained from searching outward from two nodes.\\n        if(newSet.size() < set2.size()) {\\n            return minLengthBidirectionalSearch(newSet, set2, wordList, length+1);\\n        } else {\\n            return minLengthBidirectionalSearch(set2, newSet, wordList, length+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40860,
                "title": "52-ms-c-solution-with-18-lines-only",
                "content": "two-end BFS + hash table\\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) {\\n        unordered_set<string> head({ beginWord }), tail({ endWord }), next;\\n        int dist = 2, size = beginWord.size();\\n        while (!head.empty()) {\\n            for (auto& h : head) wordList.erase(h);\\n            for (auto src : head) {\\n                for (int i = 0; i<size; ++i) {\\n                    char tmp = src[i];\\n                    for (src[i] = 'a'; src[i] <= 'z'; ++src[i]) {\\n                        auto it = wordList.find(src);\\n                        if (it != wordList.end()) {\\n                            if (tail.find(*it) != tail.end()) return dist;\\n                            next.insert(*it);\\n                        }\\n                    }\\n                    src[i] = tmp;\\n                }\\n            }\\n            ++dist;\\n            head.swap(next);\\n            next.clear();\\n            if (head.size()>tail.size()) head.swap(tail);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) {\\n        unordered_set<string> head({ beginWord }), tail({ endWord }), next;\\n        int dist = 2, size = beginWord.size();\\n        while (!head.empty()) {\\n            for (auto& h : head) wordList.erase(h);\\n            for (auto src : head) {\\n                for (int i = 0; i<size; ++i) {\\n                    char tmp = src[i];\\n                    for (src[i] = 'a'; src[i] <= 'z'; ++src[i]) {\\n                        auto it = wordList.find(src);\\n                        if (it != wordList.end()) {\\n                            if (tail.find(*it) != tail.end()) return dist;\\n                            next.insert(*it);\\n                        }\\n                    }\\n                    src[i] = tmp;\\n                }\\n            }\\n            ++dist;\\n            head.swap(next);\\n            next.clear();\\n            if (head.size()>tail.size()) head.swap(tail);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40935,
                "title": "short-java-bfs-solution",
                "content": "    public int ladderLength(String start, String end, Set<String> dict) {\\n        LinkedList<String> queue = new LinkedList<String>();\\n        queue.add(start);\\n        dict.add(end);\\n        int step = 0;\\n        while (!queue.isEmpty()) {\\n            LinkedList<String> level = new LinkedList<String>();\\n            step++;\\n            while (!queue.isEmpty()) {\\n                String q = queue.pollFirst();\\n                if (q.equals(end))\\n                    return step;\\n                for (int i = 0; i < start.length(); i++) {\\n                    for (char c = 'a'; c <= 'z'; c++) {\\n                        String s = q.substring(0, i) + c + q.substring(i + 1, start.length());\\n                        if (dict.contains(s)) {\\n                            level.add(s);\\n                            dict.remove(s);\\n                        }\\n                    }\\n                }\\n            }\\n            queue = level;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "    public int ladderLength(String start, String end, Set<String> dict) {\\n        LinkedList<String> queue = new LinkedList<String>();\\n        queue.add(start);\\n        dict.add(end);\\n        int step = 0;\\n        while (!queue.isEmpty()) {\\n            LinkedList<String> level = new LinkedList<String>();\\n            step++;\\n            while (!queue.isEmpty()) {\\n                String q = queue.pollFirst();\\n                if (q.equals(end))\\n                    return step;\\n                for (int i = 0; i < start.length(); i++) {\\n                    for (char c = 'a'; c <= 'z'; c++) {\\n                        String s = q.substring(0, i) + c + q.substring(i + 1, start.length());\\n                        if (dict.contains(s)) {\\n                            level.add(s);\\n                            dict.remove(s);\\n                        }\\n                    }\\n                }\\n            }\\n            queue = level;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2851782,
                "title": "using-queue-and-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate a queue and push the begin word to queue. Also convert wordList to hashSet. find all words in wordList which have one char different with begin word, push them to the queue and remove the from our hashset. continue there is item in queue and until we reach to the end word.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot 2022-11-26 at 5.41.45 PM.png](https://assets.leetcode.com/users/images/f996adee-2dde-448a-9296-8b794d135c12_1669513400.7970853.png)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) {\\n        var hashSet= new HashSet<string>(wordList);\\n        if(!hashSet.Contains(endWord)) return 0;\\n        var queue= new Queue<(string word, int count)>();\\n        queue.Enqueue((beginWord,1));\\n        hashSet.Remove(beginWord);\\n        while(queue.Count>0){\\n            var curr=queue.Dequeue();\\n            if(curr.word==endWord) return curr.count;\\n            foreach(var word in hashSet){\\n                if(DiffOneChar(curr.word,word)){\\n                    queue.Enqueue((word,curr.count+1));\\n                    hashSet.Remove(word);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    private bool DiffOneChar(string word1,string word2){\\n        int count=0;\\n        for(int i=0; i<word1.Length; i++){\\n            if(word1[i]!=word2[i]) count++;\\n        }\\n        return count==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) {\\n        var hashSet= new HashSet<string>(wordList);\\n        if(!hashSet.Contains(endWord)) return 0;\\n        var queue= new Queue<(string word, int count)>();\\n        queue.Enqueue((beginWord,1));\\n        hashSet.Remove(beginWord);\\n        while(queue.Count>0){\\n            var curr=queue.Dequeue();\\n            if(curr.word==endWord) return curr.count;\\n            foreach(var word in hashSet){\\n                if(DiffOneChar(curr.word,word)){\\n                    queue.Enqueue((word,curr.count+1));\\n                    hashSet.Remove(word);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    private bool DiffOneChar(string word1,string word2){\\n        int count=0;\\n        for(int i=0; i<word1.Length; i++){\\n            if(word1[i]!=word2[i]) count++;\\n        }\\n        return count==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723192,
                "title": "fastest-solution-tc-o-n-sc-o-n-dfs-aproach",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, bw: str, ew: str, wordList: List[str]) -> int:\\n        dc=defaultdict(int)\\n        for a in wordList:\\n            dc[a]=1\\n        stk=[bw]\\n        dp=0\\n        alp=\"abcdefghijklmnopqrstuvwxyz\"\\n        while(len(stk)>0):\\n            dp+=1\\n            nstk=[]\\n            for a in stk:\\n                if(a==ew):\\n                    return dp\\n                for i in range(len(a)):\\n                    for j in range(26):\\n                        x=a[:i]+alp[j]+a[i+1:]\\n                        if(dc[x]==1):\\n                            nstk.append(x)\\n                            dc[x]=0\\n            stk=nstk\\n        return 0\\n                            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, bw: str, ew: str, wordList: List[str]) -> int:\\n        dc=defaultdict(int)\\n        for a in wordList:\\n            dc[a]=1\\n        stk=[bw]\\n        dp=0\\n        alp=\"abcdefghijklmnopqrstuvwxyz\"\\n        while(len(stk)>0):\\n            dp+=1\\n            nstk=[]\\n            for a in stk:\\n                if(a==ew):\\n                    return dp\\n                for i in range(len(a)):\\n                    for j in range(26):\\n                        x=a[:i]+alp[j]+a[i+1:]\\n                        if(dc[x]==1):\\n                            nstk.append(x)\\n                            dc[x]=0\\n            stk=nstk\\n        return 0\\n                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423236,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n\\n\\t\\t\\tunordered_set<string> st;\\n\\t\\t\\tbool isPresent = false; //Checks if endWord is present in Dictionary\\n\\n\\t\\t\\t//Insert all words from Dict in set\\n\\t\\t\\tfor(auto x : wordList){\\n\\t\\t\\t\\tif(endWord.compare(x) == 0){\\n\\t\\t\\t\\t\\tisPresent = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.insert(x);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If endWord is not present in Dict\\n\\t\\t\\tif(isPresent == false){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tqueue<string> q;\\n\\t\\t\\tq.push(beginWord);\\n\\t\\t\\tint depth = 0;\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\n\\t\\t\\t\\tdepth += 1;\\n\\t\\t\\t\\tint lsize = q.size(); //No of elements at a level\\n\\n\\t\\t\\t\\twhile(lsize--){\\n\\n\\t\\t\\t\\t\\tstring curr = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\t//check for all possible 1 depth words\\n\\t\\t\\t\\t\\tfor(int i=0 ; i<curr.length() ; i++){ //For each index\\n\\n\\t\\t\\t\\t\\t\\tstring temp = curr;\\n\\t\\t\\t\\t\\t\\tfor(char c=\\'a\\' ; c<=\\'z\\' ; c++){ //Try all possible chars\\n\\n\\t\\t\\t\\t\\t\\t\\ttemp[i] = c;\\n\\n\\t\\t\\t\\t\\t\\t\\t// Skip the same word\\n\\t\\t\\t\\t\\t\\t\\tif(curr.compare(temp) == 0){\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t//endWord found\\n\\t\\t\\t\\t\\t\\t\\tif(temp.compare(endWord) == 0){\\n\\t\\t\\t\\t\\t\\t\\t\\treturn depth + 1;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif(st.find(temp) != st.end()){\\n\\t\\t\\t\\t\\t\\t\\t\\tq.push(temp);\\n\\t\\t\\t\\t\\t\\t\\t\\tst.erase(temp);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n\\n\\t\\t\\tunordered_set<string> st;\\n\\t\\t\\tbool isPresent = false; //Checks if endWord is present in Dictionary\\n\\n\\t\\t\\t//Insert all words from Dict in set\\n\\t\\t\\tfor(auto x : wordList){\\n\\t\\t\\t\\tif(endWord.compare(x) == 0){\\n\\t\\t\\t\\t\\tisPresent = true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1814121,
                "title": "c-solution-bfs-easy-to-understand",
                "content": "**Why BFS ?**\\n* Since we are looking for **shortest transformation sequence**, if makes a lot more sense to go **level by level** i.e. BFS.\\n* In general opt for level order if you are looking for shortest path as it requires lesser time.\\n\\n**Problem**\\nWe have to go from **beginWord** to **endWord** by changing **1 character** in beginWord at a time such that new word formed must present in **wordList**(given in question). And we have to return minimum number from transformation in beginWord to reach endWord.\\n\\n**Example**\\n\\nbeginWord = \"hit\"\\nendWord = \"cog\"\\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\n\\tlv 1-\\t\\t\\t\\t\\thit = beginWord\\n\\t\\t\\t\\t\\t\\t\\t |\\n\\tlv 2-    \\t\\t\\t\\thot\\n\\t\\t\\t\\t\\t\\t /       \\\\\\n\\tlv 3-   \\t\\t  dot         lot\\n\\t\\t\\t         / \\n\\tlv 4-       dog\\n\\t\\t\\t\\t/\\n\\tlv 5-    cog = endWord\\n\\t\\n**Hence answer is 5 that is the number of level in BFS.**\\nNote that every word in tree in **present in WordList** provided in question and we are changing **one character at a time**.\\n\\nTry making trees couple of times and you will get it\\n\\nGo through comments for better understanding\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList)\\n    {\\n        unordered_set<string> s;  // set to know possible words to visit\\n        \\n\\t\\tbool flag = false; // flag to check if endWord is present in wordlist or not\\n        for(auto i:wordList)\\n        {\\n            s.insert(i);  // insert words from wordlist to set\\n            if(i==endWord)flag=true;    \\n        }\\n\\t\\t\\n\\t\\t// if endWord is not present in wordlist\\n\\t\\t// we cant go from startWord to endWord\\n\\t\\t// in short you cannot travel without a destination :)\\n        if(flag==false)return 0;\\n        \\n\\t\\t// rest is simple BFS\\n\\t\\t\\n        queue<string> q; // queue for performing bfs \\n        q.push(beginWord); // starting from startword\\n        int depth = 0; // depth is basically level which we have to return\\n        \\n        while(!q.empty())\\n        {\\n            depth++; // incrementing level\\n            int lsize=q.size(); // size of current level\\n            while(lsize--) // process current level\\n            {\\n                string temp = q.front(); //current word\\n                q.pop();\\n                \\n                for(int i=0;i<temp.size();++i)\\n                {\\n                    string copy = temp; // copy of current word\\n                    for(char c=\\'a\\';c<=\\'z\\';++c) // try every char a-z\\n                    {\\n                        copy[i]=c; // make change in at ith position\\n                        if(copy==temp)continue; // if same then move on\\n                        if(copy==endWord)return depth+1; // if reached endWord return level+1\\n                        \\n\\t\\t\\t\\t\\t\\t// if changed word is valid(present in set) \\n\\t\\t\\t\\t\\t\\tif(s.find(copy)!=s.end()) \\n                        {\\n                            q.push(copy);//  then add it in queue\\n                            s.erase(copy);// remove it from valid as it is already used\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t // if not found in bfs\\n\\t\\t // then it is not possible to go from startWord to endWord\\n\\t\\t // hence return zero\\n        return 0;\\n    }\\n};\\n```\\n\\n**Upvote this post if it helps you, feel free to ask any doubt\\nSee you in another post, untill then TATAKAE :)**\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList)\\n    {\\n        unordered_set<string> s;  // set to know possible words to visit\\n        \\n\\t\\tbool flag = false; // flag to check if endWord is present in wordlist or not\\n        for(auto i:wordList)\\n        {\\n            s.insert(i);  // insert words from wordlist to set\\n            if(i==endWord)flag=true;    \\n        }\\n\\t\\t\\n\\t\\t// if endWord is not present in wordlist\\n\\t\\t// we cant go from startWord to endWord\\n\\t\\t// in short you cannot travel without a destination :)\\n        if(flag==false)return 0;\\n        \\n\\t\\t// rest is simple BFS\\n\\t\\t\\n        queue<string> q; // queue for performing bfs \\n        q.push(beginWord); // starting from startword\\n        int depth = 0; // depth is basically level which we have to return\\n        \\n        while(!q.empty())\\n        {\\n            depth++; // incrementing level\\n            int lsize=q.size(); // size of current level\\n            while(lsize--) // process current level\\n            {\\n                string temp = q.front(); //current word\\n                q.pop();\\n                \\n                for(int i=0;i<temp.size();++i)\\n                {\\n                    string copy = temp; // copy of current word\\n                    for(char c=\\'a\\';c<=\\'z\\';++c) // try every char a-z\\n                    {\\n                        copy[i]=c; // make change in at ith position\\n                        if(copy==temp)continue; // if same then move on\\n                        if(copy==endWord)return depth+1; // if reached endWord return level+1\\n                        \\n\\t\\t\\t\\t\\t\\t// if changed word is valid(present in set) \\n\\t\\t\\t\\t\\t\\tif(s.find(copy)!=s.end()) \\n                        {\\n                            q.push(copy);//  then add it in queue\\n                            s.erase(copy);// remove it from valid as it is already used\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\t\\t // if not found in bfs\\n\\t\\t // then it is not possible to go from startWord to endWord\\n\\t\\t // hence return zero\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765261,
                "title": "c-bfs-graphs-solution-o-n-n-w-time-complexity",
                "content": "## Word-Ladder\\n\\n#### C++ Code\\n```\\nclass Solution {\\n\\t// To Create a edges from \"word\" to all other words with difference one\\n    void createGraph(unordered_map<string, vector<string>>&G, vector<string>& wordList, string word, int i, int n)\\n    {\\n        for(int j=i; j<n; j++)\\n        {\\n            int set=0,ans=0;\\n\\t\\t\\t\\n\\t\\t\\t// Comparing alphanets.\\n            for(int k=0; k<word.length(); k++)\\n            {\\n\\t\\t\\t\\t// if one alphabet is different\\n                if(!set && word[k]!=wordList[j][k]) {set=1, ans=1;}\\n\\t\\t\\t\\t// if more than one alphabet is different\\n                else if(set && word[k]!=wordList[j][k]) {ans=0; break;}\\n            }\\n\\t\\t\\t// creating an undirected edge from node \"word\" to node \"wordList[j]\"\\n            if(ans)\\n            {\\n                G[word].push_back(wordList[j]);\\n                G[wordList[j]].push_back(word);\\n            }\\n        }  \\n    }\\n\\t\\n\\t// Function with the shorted path of undirected graph\\n    int shortestPath(unordered_map<string, vector<string>>&G, string source, string sink, vector<string>& wordList)\\n    {\\n\\t\\t// ds to store dist from the source to the node\\n        unordered_map<string,int>dist;\\n\\t\\t// initializing dist with max value\\n        for(auto c:wordList) dist[c]=INT_MAX;\\n\\t\\t\\n\\t\\t// Queue to perform BFS\\n        queue<string>Q;\\n        Q.push(source);\\n        dist[source]=0;\\n        \\n        while(!Q.empty())\\n        {\\n            string s = Q.front();\\n            Q.pop();\\n            for(auto u:G[s])\\n            {\\n                if(dist[u]>dist[s]+1)\\n                {\\n                    dist[u]=dist[s]+1;\\n                    Q.push(u);\\n                }\\n            }\\n        }\\n        return dist[sink];\\n    }\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        bool isPresent=0;\\n        int n=wordList.size();\\n        \\n\\t\\t// checking if endWord is not present in the wordList\\n        for(auto it:wordList) if(it==endWord) isPresent=1;\\n        if(!isPresent) return 0;\\n        \\n\\t\\t// Map is used bcuz we need string to access the index\\n        unordered_map<string, vector<string>>G;\\n\\t\\t\\n\\t\\t// Adding edge from node \"beginWord\" to all other words of the wordList that contain one different alphabet\\n        createGraph(G,wordList, beginWord, 0, n);\\n        \\n        for(int i=0; i<n; i++)\\n            createGraph(G,wordList, wordList[i], i+1, n);\\n        \\n        int a = shortestPath(G, beginWord, endWord, wordList);\\n\\t\\t\\n\\t\\t// if there is no path from beginWord to endWord \\n        if(a==INT_MAX) a=-1;\\n        return a+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\t// To Create a edges from \"word\" to all other words with difference one\\n    void createGraph(unordered_map<string, vector<string>>&G, vector<string>& wordList, string word, int i, int n)\\n    {\\n        for(int j=i; j<n; j++)\\n        {\\n            int set=0,ans=0;\\n\\t\\t\\t\\n\\t\\t\\t// Comparing alphanets.\\n            for(int k=0; k<word.length(); k++)\\n            {\\n\\t\\t\\t\\t// if one alphabet is different\\n                if(!set && word[k]!=wordList[j][k]) {set=1, ans=1;}\\n\\t\\t\\t\\t// if more than one alphabet is different\\n                else if(set && word[k]!=wordList[j][k]) {ans=0; break;}\\n            }\\n\\t\\t\\t// creating an undirected edge from node \"word\" to node \"wordList[j]\"\\n            if(ans)\\n            {\\n                G[word].push_back(wordList[j]);\\n                G[wordList[j]].push_back(word);\\n            }\\n        }  \\n    }\\n\\t\\n\\t// Function with the shorted path of undirected graph\\n    int shortestPath(unordered_map<string, vector<string>>&G, string source, string sink, vector<string>& wordList)\\n    {\\n\\t\\t// ds to store dist from the source to the node\\n        unordered_map<string,int>dist;\\n\\t\\t// initializing dist with max value\\n        for(auto c:wordList) dist[c]=INT_MAX;\\n\\t\\t\\n\\t\\t// Queue to perform BFS\\n        queue<string>Q;\\n        Q.push(source);\\n        dist[source]=0;\\n        \\n        while(!Q.empty())\\n        {\\n            string s = Q.front();\\n            Q.pop();\\n            for(auto u:G[s])\\n            {\\n                if(dist[u]>dist[s]+1)\\n                {\\n                    dist[u]=dist[s]+1;\\n                    Q.push(u);\\n                }\\n            }\\n        }\\n        return dist[sink];\\n    }\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        bool isPresent=0;\\n        int n=wordList.size();\\n        \\n\\t\\t// checking if endWord is not present in the wordList\\n        for(auto it:wordList) if(it==endWord) isPresent=1;\\n        if(!isPresent) return 0;\\n        \\n\\t\\t// Map is used bcuz we need string to access the index\\n        unordered_map<string, vector<string>>G;\\n\\t\\t\\n\\t\\t// Adding edge from node \"beginWord\" to all other words of the wordList that contain one different alphabet\\n        createGraph(G,wordList, beginWord, 0, n);\\n        \\n        for(int i=0; i<n; i++)\\n            createGraph(G,wordList, wordList[i], i+1, n);\\n        \\n        int a = shortestPath(G, beginWord, endWord, wordList);\\n\\t\\t\\n\\t\\t// if there is no path from beginWord to endWord \\n        if(a==INT_MAX) a=-1;\\n        return a+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360141,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        int n = wordList.size();\\n        set<string>s;\\n        bool ispresent = false;\\n        \\n//push all strings in set, also make ispresent true if endword is present in wordlist\\n        for(auto i : wordList){\\n            if(i == endWord)\\n                ispresent = true;\\n            s.insert(i);\\n        }\\n        \\n//if endword is not present in wordlist then return 0\\n        if(!ispresent) return 0;\\n        \\n//initialize the queue and push beginword\\n        queue<string>q;\\n        int lsize = 0, depth = 0;\\n        q.push(beginWord);\\n        \\n        while(!q.empty()) {\\n            int lsize = q.size();\\n            depth++;\\n            while(lsize--) {\\n                string curr = q.front();\\n                q.pop();\\n                for(int i = 0; i < curr.size(); i++) {\\n                    string temp = curr;\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                        temp[i] = c;\\n                        if(curr.compare(temp) == 0)  continue; //skip the same word \\n                        if(endWord.compare(temp) == 0) return depth+1;//endword found\\n                        else{\\n                            if(s.find(temp) != s.end()) {\\n                                q.push(temp);\\n                                s.erase(temp);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        int n = wordList.size();\\n        set<string>s;\\n        bool ispresent = false;\\n        \\n//push all strings in set, also make ispresent true if endword is present in wordlist\\n        for(auto i : wordList){\\n            if(i == endWord)\\n                ispresent = true;\\n            s.insert(i);\\n        }\\n        \\n//if endword is not present in wordlist then return 0\\n        if(!ispresent) return 0;\\n        \\n//initialize the queue and push beginword\\n        queue<string>q;\\n        int lsize = 0, depth = 0;\\n        q.push(beginWord);\\n        \\n        while(!q.empty()) {\\n            int lsize = q.size();\\n            depth++;\\n            while(lsize--) {\\n                string curr = q.front();\\n                q.pop();\\n                for(int i = 0; i < curr.size(); i++) {\\n                    string temp = curr;\\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                        temp[i] = c;\\n                        if(curr.compare(temp) == 0)  continue; //skip the same word \\n                        if(endWord.compare(temp) == 0) return depth+1;//endword found\\n                        else{\\n                            if(s.find(temp) != s.end()) {\\n                                q.push(temp);\\n                                s.erase(temp);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332551,
                "title": "elegant-python-iterative-bfs",
                "content": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n\\n        graph = defaultdict(list)\\n        for word in wordList:\\n            for index in range(len(beginWord)):\\n                graph[word[:index] + \"_\" + word[index+1:]].append(word)\\n\\n        queue = deque()\\n        queue.append((beginWord, 1))\\n        visited = set()\\n        while queue:\\n            current_node, current_level = queue.popleft()\\n            if current_node == endWord: return current_level\\n            for index in range(len(beginWord)):\\n                node = current_node[:index] + \"_\" + current_node[index+1:]\\n                for neighbour in graph[node]:\\n                    if neighbour not in visited:\\n                        queue.append((neighbour, current_level + 1))\\n                        visited.add(neighbour)\\n                graph[node] = []\\n                \\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n\\n        graph = defaultdict(list)\\n        for word in wordList:\\n            for index in range(len(beginWord)):\\n                graph[word[:index] + \"_\" + word[index+1:]].append(word)\\n\\n        queue = deque()\\n        queue.append((beginWord, 1))\\n        visited = set()\\n        while queue:\\n            current_node, current_level = queue.popleft()\\n            if current_node == endWord: return current_level\\n            for index in range(len(beginWord)):\\n                node = current_node[:index] + \"_\" + current_node[index+1:]\\n                for neighbour in graph[node]:\\n                    if neighbour not in visited:\\n                        queue.append((neighbour, current_level + 1))\\n                        visited.add(neighbour)\\n                graph[node] = []\\n                \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908755,
                "title": "javascript-solution-with-detailed-explanation",
                "content": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {number}\\n */\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    /**\\n        Concept:\\n        -- The problem can be thought of as looking for neighbors of a word, wherein each neighbor\\n           differs by one character at each position of the word. This is similar to BFS.\\n        \\n        Approach:\\n        1. Push the beginWord to a queue\\n        2. For each element removed from queue, check if it\\'s equivalent to endWord and exit if true\\n        3. If not, try replacing each character of the word with one of the possible characters derived\\n           from all words\\n           -- Push all unseen valid characters onto queue for consideration at next level\\n           -- Increment number of transitions\\n           \\n        Steps 2 and 3 can be very exhaustive and repetitive for invalid words.\\n        As on optimization, we can create a map of word roots for each word with 1 substitution and\\n        group all words that can lead up to that state. For example, the 3 states for word \\'hot\\' are:\\n        [\\'*ot\\', \\'h*t\\', \\'ho*\\'] and valid words that map to those combinations are:\\n        \\'*ot\\' -> [hot, dot, lot]\\n        \\'h*t\\' -> [hot]\\n        \\'ho*\\' -> [hot]\\n    */\\n\\t\\n\\t// Time Complexity: O(WordLength^2 * numWords)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// => WordLength * (substring ops = O(WordLength)) * numWords\\n\\t// Space Complexity: O(WordLength^2 * numWords)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// => WordLength * (substring ops = O(WordLength)) * numWords\\n\\t\\n    const combinations = {};\\n    // Mapping wordRoot to word. For example, \\'*ot\\' -> [hot, dot, lot]\\n    wordList.forEach(word => {\\n        for (let i = 0; i < word.length; i++) {\\n            let wordRoot = word.substring(0, i) + \\'*\\' + word.substring(i + 1);\\n            if (combinations[wordRoot] === undefined) {\\n                combinations[wordRoot] = [];\\n            }\\n            combinations[wordRoot].push(word);\\n        }\\n    });\\n    \\n    let queue = [beginWord];\\n    let transitions = 0;\\n    const visitedWords = new Set();\\n    \\n    while (queue.length > 0) {\\n        const neighbors = [];\\n        \\n        while (queue.length > 0) {\\n            let word = queue.pop();\\n            if (word === endWord) {\\n                return transitions + 1;\\n            }\\n            \\n            // Consider all roots possible from this word\\n            for (let i = 0; i < word.length; i++) {\\n                let wordRoot = word.substring(0, i) + \\'*\\' + word.substring(i + 1);\\n                \\n                // Consider all words that have the same root\\n                for (const neighbor of (combinations[wordRoot] || [])) {\\n                    // If this word has been visited before, continue, else consider it\\n                    if (!visitedWords.has(neighbor)) {\\n                        visitedWords.add(neighbor);\\n                        neighbors.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue = neighbors;\\n        transitions++;\\n    }\\n    \\n    return 0;// If endWord was found, transitions would\\'ve been returned before\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} beginWord\\n * @param {string} endWord\\n * @param {string[]} wordList\\n * @return {number}\\n */\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    /**\\n        Concept:\\n        -- The problem can be thought of as looking for neighbors of a word, wherein each neighbor\\n           differs by one character at each position of the word. This is similar to BFS.\\n        \\n        Approach:\\n        1. Push the beginWord to a queue\\n        2. For each element removed from queue, check if it\\'s equivalent to endWord and exit if true\\n        3. If not, try replacing each character of the word with one of the possible characters derived\\n           from all words\\n           -- Push all unseen valid characters onto queue for consideration at next level\\n           -- Increment number of transitions\\n           \\n        Steps 2 and 3 can be very exhaustive and repetitive for invalid words.\\n        As on optimization, we can create a map of word roots for each word with 1 substitution and\\n        group all words that can lead up to that state. For example, the 3 states for word \\'hot\\' are:\\n        [\\'*ot\\', \\'h*t\\', \\'ho*\\'] and valid words that map to those combinations are:\\n        \\'*ot\\' -> [hot, dot, lot]\\n        \\'h*t\\' -> [hot]\\n        \\'ho*\\' -> [hot]\\n    */\\n\\t\\n\\t// Time Complexity: O(WordLength^2 * numWords)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// => WordLength * (substring ops = O(WordLength)) * numWords\\n\\t// Space Complexity: O(WordLength^2 * numWords)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// => WordLength * (substring ops = O(WordLength)) * numWords\\n\\t\\n    const combinations = {};\\n    // Mapping wordRoot to word. For example, \\'*ot\\' -> [hot, dot, lot]\\n    wordList.forEach(word => {\\n        for (let i = 0; i < word.length; i++) {\\n            let wordRoot = word.substring(0, i) + \\'*\\' + word.substring(i + 1);\\n            if (combinations[wordRoot] === undefined) {\\n                combinations[wordRoot] = [];\\n            }\\n            combinations[wordRoot].push(word);\\n        }\\n    });\\n    \\n    let queue = [beginWord];\\n    let transitions = 0;\\n    const visitedWords = new Set();\\n    \\n    while (queue.length > 0) {\\n        const neighbors = [];\\n        \\n        while (queue.length > 0) {\\n            let word = queue.pop();\\n            if (word === endWord) {\\n                return transitions + 1;\\n            }\\n            \\n            // Consider all roots possible from this word\\n            for (let i = 0; i < word.length; i++) {\\n                let wordRoot = word.substring(0, i) + \\'*\\' + word.substring(i + 1);\\n                \\n                // Consider all words that have the same root\\n                for (const neighbor of (combinations[wordRoot] || [])) {\\n                    // If this word has been visited before, continue, else consider it\\n                    if (!visitedWords.has(neighbor)) {\\n                        visitedWords.add(neighbor);\\n                        neighbors.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue = neighbors;\\n        transitions++;\\n    }\\n    \\n    return 0;// If endWord was found, transitions would\\'ve been returned before\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 748901,
                "title": "java-a-algorithm-faster-than-bfs-or-bidirectional-bfs-with-explanation",
                "content": "A* is much faster compared to BFS or Bidirectional BFS.\\n\\nFor those of you who are beginners to A* Algorithm. Look at link below before proceeding with the code.\\nhttps://www.redblobgames.com/pathfinding/a-star/introduction.html\\n#### \\n----\\nAlso, please go through Approach 1: Breadth First Search solution here:\\nhttps://leetcode.com/problems/word-ladder/solution/\\n####\\n-----\\n\\n```\\nclass Pair<U,V>{\\n    //first is the current word\\n    //second is the priority for the priority queue\\n    U first;\\n    V second;\\n    \\n    Pair(U _first, V _second){\\n        first = _first;\\n        second = _second;\\n    }\\n}\\n\\nclass Solution {\\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\n    // Since all words are of same length.\\n    int L = beginWord.length();\\n\\n    // Dictionary to hold combination of words that can be formed,\\n    // from any given word. By changing one letter at a time.\\n    Map<String, List<String>> allComboDict = new HashMap<>();\\n\\n    for(String word : wordList){\\n        for (int i = 0; i < L; i++) {\\n            // Key is the generic word\\n            // Value is a list of words which have the same intermediate generic word.\\n            String newWord = word.substring(0, i) + \\'*\\' + word.substring(i + 1, L);\\n            List<String> transformations = allComboDict.getOrDefault(newWord, new ArrayList<>());\\n            transformations.add(word);\\n            allComboDict.put(newWord, transformations);\\n         }\\n    }\\n\\n    // Queue for A*\\n    PriorityQueue<Pair<String, Integer>> PQ = new PriorityQueue<>((a,b)-> a.second - b.second);\\n    PQ.add(new Pair(beginWord, 0));\\n\\n    // Visited is used to keep track of the cost of the nodes that we have already visited and the cost it takes to \\n\\t// reach the node. \\n    Map<String, Integer> visited = new HashMap<>();\\n    //we start with a default cost of 1\\n\\tvisited.put(beginWord, 1);\\n\\n    while (!PQ.isEmpty()) {\\n      Pair<String, Integer> node = PQ.poll();\\n      String word = node.first;\\n\\n      for(int i = 0; i < L; i++) {\\n\\n        // Intermediate words for current word\\n        String newWord = word.substring(0, i) + \\'*\\' + word.substring(i + 1, L);\\n\\n        // Next states are all the words which share the same intermediate state.\\n        for (String adjacentWord : allComboDict.getOrDefault(newWord, new ArrayList<>())) {\\n          \\n          //the cost to the adjacent word is 1 plus the cost to reach the word  \\n          int new_cost =  visited.get(word) + 1;\\n          \\n            // If at any point if we find what we are looking for\\n          // i.e. the end word - we can return with the answer.    \\n          if (adjacentWord.equals(endWord)) {\\n            return new_cost;\\n          }\\n        \\n          if (!visited.containsKey(adjacentWord) || (new_cost < visited.get(adjacentWord))){\\n            visited.put(adjacentWord, new_cost);\\n            int heuristic_value = h(adjacentWord, endWord);\\n            int priority = new_cost + heuristic_value;\\n            PQ.offer(new Pair(adjacentWord, priority));\\n          }\\n        }\\n      }\\n    }\\n\\n    return 0;\\n  }\\n\\n    \\n    //The heuristic function - The distance from the current word to the end word is atleast as many steps to change the unequal characters in both the strings\\n    private int h(String word, String word1){\\n        int diff = 0;\\n        \\n        for(int i=0;i<word.length();i++){\\n            if(word.charAt(i)!=word1.charAt(i))\\n                diff++;    \\n        }\\n        \\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair<U,V>{\\n    //first is the current word\\n    //second is the priority for the priority queue\\n    U first;\\n    V second;\\n    \\n    Pair(U _first, V _second){\\n        first = _first;\\n        second = _second;\\n    }\\n}\\n\\nclass Solution {\\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\n    // Since all words are of same length.\\n    int L = beginWord.length();\\n\\n    // Dictionary to hold combination of words that can be formed,\\n    // from any given word. By changing one letter at a time.\\n    Map<String, List<String>> allComboDict = new HashMap<>();\\n\\n    for(String word : wordList){\\n        for (int i = 0; i < L; i++) {\\n            // Key is the generic word\\n            // Value is a list of words which have the same intermediate generic word.\\n            String newWord = word.substring(0, i) + \\'*\\' + word.substring(i + 1, L);\\n            List<String> transformations = allComboDict.getOrDefault(newWord, new ArrayList<>());\\n            transformations.add(word);\\n            allComboDict.put(newWord, transformations);\\n         }\\n    }\\n\\n    // Queue for A*\\n    PriorityQueue<Pair<String, Integer>> PQ = new PriorityQueue<>((a,b)-> a.second - b.second);\\n    PQ.add(new Pair(beginWord, 0));\\n\\n    // Visited is used to keep track of the cost of the nodes that we have already visited and the cost it takes to \\n\\t// reach the node. \\n    Map<String, Integer> visited = new HashMap<>();\\n    //we start with a default cost of 1\\n\\tvisited.put(beginWord, 1);\\n\\n    while (!PQ.isEmpty()) {\\n      Pair<String, Integer> node = PQ.poll();\\n      String word = node.first;\\n\\n      for(int i = 0; i < L; i++) {\\n\\n        // Intermediate words for current word\\n        String newWord = word.substring(0, i) + \\'*\\' + word.substring(i + 1, L);\\n\\n        // Next states are all the words which share the same intermediate state.\\n        for (String adjacentWord : allComboDict.getOrDefault(newWord, new ArrayList<>())) {\\n          \\n          //the cost to the adjacent word is 1 plus the cost to reach the word  \\n          int new_cost =  visited.get(word) + 1;\\n          \\n            // If at any point if we find what we are looking for\\n          // i.e. the end word - we can return with the answer.    \\n          if (adjacentWord.equals(endWord)) {\\n            return new_cost;\\n          }\\n        \\n          if (!visited.containsKey(adjacentWord) || (new_cost < visited.get(adjacentWord))){\\n            visited.put(adjacentWord, new_cost);\\n            int heuristic_value = h(adjacentWord, endWord);\\n            int priority = new_cost + heuristic_value;\\n            PQ.offer(new Pair(adjacentWord, priority));\\n          }\\n        }\\n      }\\n    }\\n\\n    return 0;\\n  }\\n\\n    \\n    //The heuristic function - The distance from the current word to the end word is atleast as many steps to change the unequal characters in both the strings\\n    private int h(String word, String word1){\\n        int diff = 0;\\n        \\n        for(int i=0;i<word.length();i++){\\n            if(word.charAt(i)!=word1.charAt(i))\\n                diff++;    \\n        }\\n        \\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670010,
                "title": "am-i-misunderstanding-the-problem-statement",
                "content": "The accepted output for the following testcase is 2. \\n\\n```\\n\"a\"\\n\"c\"\\n[\"a\", \"b\", \"c\"]\\n```\\n\\nBut shouldn\\'t it be 1, since you can transform a to c in one step: \"a\" -> \"c\"?\\n",
                "solutionTags": [],
                "code": "```\\n\"a\"\\n\"c\"\\n[\"a\", \"b\", \"c\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 659428,
                "title": "javascript-simple-bfs-solution",
                "content": "```javascript\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    const graph = {};\\n    const fullWordList = [beginWord, ...wordList];\\n    \\n    // construct adjacency list\\n    for(let word of fullWordList) {\\n        const arr = [];\\n        for(let otherWord of fullWordList) {\\n            if(word === otherWord) continue;\\n            let i = 0\\n            let diff = 0;\\n            // compare the char difference between the two words\\n            while(i < word.length || i < otherWord.length) {\\n                if(word[i] !== otherWord[i]) diff++;\\n                i++;\\n            }\\n            // if the difference is only 1 char add to the adjacency list \\n            if(diff === 1) arr.push(otherWord);\\n        }\\n        graph[word] = arr;\\n    }\\n    \\n    //BFS\\n    const queue = [[beginWord, 1]];\\n    const visited = new Set();\\n    \\n    while(queue.length) {\\n\\t\\t// gen is the generation depth \\n        const [node, gen] = queue.shift();\\n        if(node === endWord) return gen;\\n        if(visited.has(node) || !graph[node]) continue;\\n        visited.add(node);\\n        \\n        for(let vertex of graph[node]) {\\n            queue.push([vertex, gen+1]);\\n        }\\n    }    \\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    const graph = {};\\n    const fullWordList = [beginWord, ...wordList];\\n    \\n    // construct adjacency list\\n    for(let word of fullWordList) {\\n        const arr = [];\\n        for(let otherWord of fullWordList) {\\n            if(word === otherWord) continue;\\n            let i = 0\\n            let diff = 0;\\n            // compare the char difference between the two words\\n            while(i < word.length || i < otherWord.length) {\\n                if(word[i] !== otherWord[i]) diff++;\\n                i++;\\n            }\\n            // if the difference is only 1 char add to the adjacency list \\n            if(diff === 1) arr.push(otherWord);\\n        }\\n        graph[word] = arr;\\n    }\\n    \\n    //BFS\\n    const queue = [[beginWord, 1]];\\n    const visited = new Set();\\n    \\n    while(queue.length) {\\n\\t\\t// gen is the generation depth \\n        const [node, gen] = queue.shift();\\n        if(node === endWord) return gen;\\n        if(visited.has(node) || !graph[node]) continue;\\n        visited.add(node);\\n        \\n        for(let vertex of graph[node]) {\\n            queue.push([vertex, gen+1]);\\n        }\\n    }    \\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 650367,
                "title": "python-bidirectional-bfs",
                "content": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: int\\n        \"\"\"\\n        \\n        wordList = set(wordList)\\n        if endWord not in wordList:\\n            return 0\\n\\n        if beginWord == endWord:\\n            return 1\\n\\n        forward = {beginWord}                  # Forward BFS level\\n        backward = {endWord}                 # Backward BFS level\\n        wordList.discard(beginWord)\\n        wordList.discard(endWord)\\n\\n        ALPHABET = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        distance = 2\\n\\n        while forward:\\n            # Construct a new level with possible next words in the ladder.\\n            newLevel = set()\\n            for word in forward:\\n                for ch in ALPHABET:\\n                    for i in range(len(word)):\\n                        newWord = word[:i] + ch + word[i+1:]\\n\\n                        # If the new word is present in backward, we\\'ve intersected and found the path.\\n                        if newWord in backward:\\n                            return distance\\n                        # Otherwise, add the word to the new level and remove it from wordlist.\\n                        if newWord in wordList:\\n                            newLevel.add(newWord)\\n                            wordList.discard(newWord)\\n            forward = newLevel\\n\\n            # If length of forward gets bigger, swap the levels  \\n            if len(forward) > len(backward):\\n                forward, backward = backward, forward\\n\\n            distance += 1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: List[str]\\n        :rtype: int\\n        \"\"\"\\n        \\n        wordList = set(wordList)\\n        if endWord not in wordList:\\n            return 0\\n\\n        if beginWord == endWord:\\n            return 1\\n\\n        forward = {beginWord}                  # Forward BFS level\\n        backward = {endWord}                 # Backward BFS level\\n        wordList.discard(beginWord)\\n        wordList.discard(endWord)\\n\\n        ALPHABET = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        distance = 2\\n\\n        while forward:\\n            # Construct a new level with possible next words in the ladder.\\n            newLevel = set()\\n            for word in forward:\\n                for ch in ALPHABET:\\n                    for i in range(len(word)):\\n                        newWord = word[:i] + ch + word[i+1:]\\n\\n                        # If the new word is present in backward, we\\'ve intersected and found the path.\\n                        if newWord in backward:\\n                            return distance\\n                        # Otherwise, add the word to the new level and remove it from wordlist.\\n                        if newWord in wordList:\\n                            newLevel.add(newWord)\\n                            wordList.discard(newWord)\\n            forward = newLevel\\n\\n            # If length of forward gets bigger, swap the levels  \\n            if len(forward) > len(backward):\\n                forward, backward = backward, forward\\n\\n            distance += 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528992,
                "title": "test-case-for-one-letter",
                "content": "One of the test case is\\n```\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n```\\n\\nAnd the expected output is 2.\\n\\nShouldn\\'t the expected output be 1 since it takes just one letter to change from `a` to `c`? am I missing something here?\\n\\nThank you in advance!",
                "solutionTags": [],
                "code": "```\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430062,
                "title": "a-search-solution-c-83-speed-97-memory",
                "content": "Whenever you\\'re doing a BFS, it\\'s always interesting to think of whether there is an admissible heuristic that could change the problem to A*.\\nIn this case, the number of different letters between word W and the end word E is always less than or equal to the distance to to the end word, therefore it\\'s an admissible heuristic.\\n\\nI hadn\\'t seen anyone else do A* for this so I thought I\\'d give it a go.\\nFor those that don\\'t know what A* is, essentially this search will always try to expand the node that it thinks is will have the lowest cost to the end, where in BFS you just expand the first one in the queue no matter how far away from the end you think it is. This can speed up search because it usually explores in the direction of the goal.\\n\\n```\\nstruct WordAndVal {\\n    std::string word;\\n    int level;\\n    int heuristic;\\n};\\n\\nstruct AStarCompare {\\n    bool operator()(const WordAndVal& wv1, const WordAndVal& wv2) {\\n        return wv1.level + wv1.heuristic > wv2.level + wv2.heuristic;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        std::priority_queue<WordAndVal, vector<WordAndVal>, AStarCompare> words;\\n        \\n        std::unordered_set<string> unseen(wordList.begin(), wordList.end());\\n        \\n        words.push({beginWord, 1, difference(beginWord, endWord)});\\n        unseen.erase(beginWord);\\n        \\n        while (!words.empty()) {\\n            const WordAndVal wv = words.top();\\n            words.pop();\\n            \\n            if (wv.word == endWord) {\\n                return wv.level;\\n            }\\n            \\n            // Find neighbors\\n            std::string next_word(wv.word);\\n            for (int i = 0; i < next_word.size(); i++) {\\n                char original_letter = next_word[i];\\n                for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                    next_word[i] = c;\\n                    if (unseen.find(next_word) != unseen.end()) {\\n                        //cout << wv.word << \\' \\' << next_word << endl;\\n                        int new_heuristic = wv.heuristic;\\n                        if (endWord[i] == original_letter && endWord[i] != c) {\\n                            new_heuristic++;\\n                        } else if (endWord[i] != original_letter && endWord[i] == c) {\\n                            new_heuristic--;\\n                        }\\n                        words.push({next_word, wv.level+1, new_heuristic});\\n                        unseen.erase(next_word);\\n                    }\\n                }\\n                next_word[i] = original_letter;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int difference(const string& s1, const string& s2) {\\n        int total = 0;\\n        for (int i = 0; i < s1.size(); i++) {\\n            if (s1[i] != s2[i]) ++total;\\n        }\\n        return total;\\n    }\\n};\\n```\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct WordAndVal {\\n    std::string word;\\n    int level;\\n    int heuristic;\\n};\\n\\nstruct AStarCompare {\\n    bool operator()(const WordAndVal& wv1, const WordAndVal& wv2) {\\n        return wv1.level + wv1.heuristic > wv2.level + wv2.heuristic;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        std::priority_queue<WordAndVal, vector<WordAndVal>, AStarCompare> words;\\n        \\n        std::unordered_set<string> unseen(wordList.begin(), wordList.end());\\n        \\n        words.push({beginWord, 1, difference(beginWord, endWord)});\\n        unseen.erase(beginWord);\\n        \\n        while (!words.empty()) {\\n            const WordAndVal wv = words.top();\\n            words.pop();\\n            \\n            if (wv.word == endWord) {\\n                return wv.level;\\n            }\\n            \\n            // Find neighbors\\n            std::string next_word(wv.word);\\n            for (int i = 0; i < next_word.size(); i++) {\\n                char original_letter = next_word[i];\\n                for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                    next_word[i] = c;\\n                    if (unseen.find(next_word) != unseen.end()) {\\n                        //cout << wv.word << \\' \\' << next_word << endl;\\n                        int new_heuristic = wv.heuristic;\\n                        if (endWord[i] == original_letter && endWord[i] != c) {\\n                            new_heuristic++;\\n                        } else if (endWord[i] != original_letter && endWord[i] == c) {\\n                            new_heuristic--;\\n                        }\\n                        words.push({next_word, wv.level+1, new_heuristic});\\n                        unseen.erase(next_word);\\n                    }\\n                }\\n                next_word[i] = original_letter;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int difference(const string& s1, const string& s2) {\\n        int total = 0;\\n        for (int i = 0; i < s1.size(); i++) {\\n            if (s1[i] != s2[i]) ++total;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 390860,
                "title": "3-solution-explanation-easy-to-understand",
                "content": "Since we need to transform the \\'`begin`\\' word to \\'`end`\\' word with constraint to change only 1 letter at a time, that means the word list either contain the \\'`begin`\\' word\\nor word list should contain words that is `1` distance away from \\'begin\\' word.\\nNow, once we find the word to start, we need to traverse all the word that is `1` distance away and present in the word list.\\n\\nIt boils down to a `undirected graph with weight 1`. Here weight shows the number of character need to change from a word to a word. In our case its 1. **{we can generalize it }.**\\n\\nNow, to efficiently find all the nodes which is 1 weight away from a node, we should pre-process the given word list and find all the nodes that are 1 distance away and hence form the unweighted\\ngraph.\\n\\nNow, we just need to start form the \\'`begin`\\' node and see all the nodes in the graph which is 1 distance away and keep moving in that path. Since we need \\'shortest transformation sequence\\'\\nwe can use BFS to achieve it.\\n\\nAlgorithm:\\n1. Convert given list to undirected graph which are 1 distance away only.\\n2. Start from \\'begin\\' node and explore all the path that are 1 distance away\\n3. as soon as you hit end word, return the distance travelled.\\n\\nN - Length of list of word\\nM - maximum length of a word\\n\\nTime: O(N*M)\\nSpace: O(N*M)\\n\\n```\\n\\nclass WordLadderIBFS {\\n\\n\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\n        if (wordList == null || wordList.isEmpty())\\n            return 0;\\n\\n        final Set<String> uniqueWords = new HashSet<>(wordList);\\n\\n        //if end word is not present then no way to transform\\n        if (!uniqueWords.contains(endWord))\\n            return 0;\\n\\n        if (beginWord.equals(endWord))\\n            return 1;\\n\\n        //O(N*M)\\n        final Map<String, List<String>> graph = buildUnDirectedWeightedGraph(wordList, uniqueWords);\\n\\n        //get mapping corresponding to begin word too.\\n        //O(M)\\n        final Map<String, List<String>> beginWordGraph = buildUnDirectedWeightedGraph(Collections.singletonList(beginWord), uniqueWords);\\n\\n        //append\\n        graph.putAll(beginWordGraph);\\n\\n        //O(N*M)\\n        return bfs(beginWord, endWord, graph);\\n\\n    }\\n\\n\\n    /**\\n     * This will build undirected weighted 1.\\n     * Algorithm:\\n     * 1. Take all word one by one.\\n     * 2. Change each character of this word from [a,z] and test does new word exist in list or not\\n     * 3. if exist, create a edge from this word to new word\\n     * <p>\\n     * Time Complexity:  N is length of list, M is length of longest word\\n     * Step 1: O(N)\\n     * Step 2: O(M * 26 )\\n     * Step 3: O(1)\\n     * <p>\\n     * Hence : O(N*M)\\n     * <p>\\n     * Space Complexity: O(N*M)\\n     *\\n     * @param wordList Graph nodes\\n     * @return undirected weighted {@code weight}\\n     */\\n    private Map<String, List<String>> buildUnDirectedWeightedGraph(List<String> wordList, final Set<String> uniqueWord) {\\n\\n        //represent the undirected weighted(1) graph.\\n        //Key -> word node\\n        //Value -> all node that is weight distance away\\n        final Map<String, List<String>> graph = new HashMap<>();\\n\\n        for (String s : wordList) { //O(N)\\n\\n            char[] node = s.toCharArray();\\n            int length = node.length;\\n\\n            //change every char of node.\\n            //O(M*26)\\n            for (int i = 0; i < length; i++) { //O(M)\\n\\n                char old = node[i];\\n                //try every node char to change other and test\\n                //O(26)\\n                for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\n                    if (node[i] == c) //no need to change\\n                        continue;\\n\\n                    //change this char\\n                    node[i] = c;\\n                    String temp = new String(node);\\n                    if (uniqueWord.contains(temp))\\n                        graph.computeIfAbsent(s, list -> new ArrayList<>()).add(temp);\\n                }\\n                node[i] = old;\\n            }\\n\\n            if (!graph.getOrDefault(s, new ArrayList<>()).isEmpty())\\n                graph.get(s).remove(s);\\n\\n        }\\n\\n\\n        return graph;\\n    }\\n\\n\\n    /**\\n     * Find the shortest path from source to destination\\n     * O(N*M)\\n     *\\n     * @param source      source node\\n     * @param destination destination node\\n     * @param graph       graph\\n     * @return shortest distance otherwise 0 if not reachable\\n     */\\n    private int bfs(String source, String destination, Map<String, List<String>> graph) {\\n\\n        class Node {\\n            String word;\\n            int distance = 0;\\n\\n            public Node(String word, int distance) {\\n                this.word = word;\\n                this.distance = distance;\\n            }\\n        }\\n\\n        final Queue<Node> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.offer(new Node(source, 0)); //distance of source to source is 0\\n        visited.add(source);\\n\\n        while (!queue.isEmpty()) {\\n\\n            final Node node = queue.poll();\\n            final int distance = node.distance;\\n\\n            //if we reached the destination node\\n            if (node.word.equals(destination)) {\\n                return distance + 1;\\n            }\\n\\n            //try all word which is 1 weight away\\n            for (String neighbour : graph.getOrDefault(node.word, new ArrayList<>())) {\\n                if (!visited.contains(neighbour)) {\\n                    visited.add(neighbour);\\n                    queue.offer(new Node(neighbour, distance + 1));\\n                }\\n            }\\n\\n\\n        }\\n        return 0;\\n    }\\n\\n}\\n```\\n\\nIn Above solution, we pre-build the graph and do bfs. It may possible we build the graph for lot of nodes that does not even come in path. So instead of this, we can create connected node on the fly. \\n\\n```\\n\\n/**\\n * Same as above, instead pre-processing. We\\'ll do post processing for each word\\n * Time: O(N*M)\\n * Space: O(N*M)\\n * <p>\\n * Runtime: 69 ms, faster than 48.37% of Java online submissions for Word Ladder.\\n * Memory Usage: 41.1 MB, less than 68.61% of Java online submissions for Word Ladder.\\n */\\nclass WordLadderIBFSV2 {\\n\\n\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\n        if (wordList == null || wordList.isEmpty())\\n            return 0;\\n\\n        final Set<String> uniqueWords = new HashSet<>(wordList);\\n\\n        //if end word is not present then no way to transform\\n        if (!uniqueWords.contains(endWord))\\n            return 0;\\n\\n        if (beginWord.equals(endWord))\\n            return 1;\\n\\n        //O(N*M)\\n        return bfs(beginWord, endWord, uniqueWords);\\n\\n    }\\n\\n\\n    /**\\n     * Find the shortest path from source to destination\\n     * O(N*M)\\n     *\\n     * @param source      source node\\n     * @param destination destination node\\n     * @param uniqueWords graph\\n     * @return shortest distance otherwise 0 if not reachable\\n     */\\n    private int bfs(String source, String destination, final Set<String> uniqueWords) {\\n\\n        class Node {\\n            String word;\\n            int distance;\\n\\n            public Node(String word, int distance) {\\n                this.word = word;\\n                this.distance = distance;\\n            }\\n        }\\n\\n        final Queue<Node> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.offer(new Node(source, 0)); //distance of source to source is 0\\n        visited.add(source);\\n\\n        while (!queue.isEmpty()) {\\n\\n            final Node node = queue.poll();\\n            final int distance = node.distance;\\n\\n            //if we reached the destination node\\n            if (node.word.equals(destination))\\n                return distance + 1;\\n\\n            //try all word which is 1 weight away\\n            for (String neighbour : getNeighbour(node.word, uniqueWords)) {\\n                if (!visited.contains(neighbour)) {\\n                    visited.add(neighbour);\\n                    queue.offer(new Node(neighbour, distance + 1));\\n                }\\n            }\\n\\n\\n        }\\n        return 0;\\n    }\\n\\n\\n    /**\\n     * Algorithm:\\n     * 2. Change each character of this word from [a,z] and test does new word exist in list or not\\n     * 3. if exist, create a edge from this word to new word\\n     * <p>\\n     * Time Complexity:  M is length of longest word\\n     * Step 2: O(M * 26 )\\n     * Step 3: O(1)\\n     * <p>\\n     * Hence : O(M)\\n     * <p>\\n     * Space Complexity: O(M)\\n     *\\n     * @param word Graph nodes\\n     * @return neighbours of weight 1\\n     */\\n    private Set<String> getNeighbour(String word, final Set<String> uniqueWord) {\\n\\n        final Set<String> neighbour = new HashSet<>();\\n\\n\\n        char[] node = word.toCharArray();\\n        int length = node.length;\\n\\n        //change every char of node.\\n        //O(M*26)\\n        for (int i = 0; i < length; i++) { //O(M)\\n\\n            char old = node[i];\\n            //try every node char to change other and test\\n            //O(26)\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\n                if (node[i] == c) //no need to change\\n                    continue;\\n\\n                //change this char\\n                node[i] = c;\\n                String temp = new String(node);\\n                if (uniqueWord.contains(temp))\\n                    neighbour.add(temp);\\n            }\\n            node[i] = old;\\n        }\\n\\n\\n        neighbour.remove(word);\\n\\n\\n        return neighbour;\\n    }\\n\\n}\\n```\\n\\nIn both above solution we do 1 direction search, we can do two direction search. \\n![image](https://assets.leetcode.com/users/nits2010/image_1569491701.png)\\n![image](https://assets.leetcode.com/users/nits2010/image_1569491710.png)\\n\\n\\n```\\n\\n/**\\n * Instead of running single BFS as in {@link WordLadderIBFS} we can do bi-directional bfs.\\n * One bfs from source to destination node\\n * one bfs from destination to source node\\n * at the same time.\\n * <p>\\n * When we reach a state, where both of the current node are same, we are done with the process.\\n * <p>\\n * Bidirectional Search uses 2 simultaneous BFS searches to find the distance between 2 nodes (by alternating between the searches)\\n * <p>\\n * Bidirectional Search\\n * <p>\\n * For BFS, if d is the distance between the 2 nodes, and b is the branching factor, 1 way to represent the runtime is O(bd).\\n * <p>\\n * For Bidirectional search, the runtime is O(b(d/2)) + O(b(d/2)) = O(2*b(d/2)) = O(b(d/2)) since each search only has to search halfway before meeting the other search.\\n * <p>\\n * Applying Bidirectional Search to our original solution\\n * <p>\\n * Our original solution used 1 Deque as a queue, and 1 Set to mark visited Strings. Since we are running 2 BFS searches, we will make 2 of these Deques and 2 of these Sets.\\n * To simulate 2 BFS searches \"simultaneously\", we alter between which of the 2 Deques we deque from.\\n * We now have 2 Deques to deque from, and 2 \"visited\" Sets, but we don\\'t want to duplicate code. We will create a general function called checkNeighbors() that takes a Deque and Set as input, to help us alternate between the 2 BFS searches.\\n * If at any time a String gets dequed, and one of its neighbors has already been visited from the opposite side\\'s parallel search, we\\'ve found a solution.\\n * <p>\\n * Runtime: 13 ms, faster than 97.07% of Java online submissions for Word Ladder.\\n * Memory Usage: 38.8 MB, less than 97.81% of Java online submissions for Word Ladder.\\n */\\nclass WordLadderIBiDirectionalBFS {\\n    static class Node {\\n        String word;\\n        int distance;\\n\\n        public Node(String word, int distance) {\\n            this.word = word;\\n            this.distance = distance;\\n        }\\n    }\\n\\n    public int ladderLength(String source, String destination, List<String> wordList) {\\n\\n        if (wordList == null || wordList.isEmpty())\\n            return 0;\\n\\n        final Set<String> uniqueWords = new HashSet<>(wordList);\\n\\n        //if end word is not present then no way to transform\\n        if (!uniqueWords.contains(destination))\\n            return 0;\\n\\n        if (source.equals(destination))\\n            return 1;\\n\\n\\n        //One direction from source to destination\\n        final Queue<Node> queueSourceToDestination = new LinkedList<>();\\n        //contains [string,distance]\\n        final Map<String, Integer> visitedSourceDestination = new HashMap<>();\\n\\n        //One direction from destination to source\\n        final Queue<Node> queueDestinationToSource = new LinkedList<>();\\n        //contains [string,distance]\\n        final Map<String, Integer> visitedDestinationSource = new HashMap<>();\\n\\n\\n        queueSourceToDestination.offer(new Node(source, 0)); //distance of source to source is 0\\n        visitedSourceDestination.put(source, 0);\\n\\n        queueDestinationToSource.offer(new Node(destination, 0)); //distance of source to source is 0\\n        visitedDestinationSource.put(destination, 0);\\n\\n        int distance;\\n        while (!queueSourceToDestination.isEmpty() && !queueDestinationToSource.isEmpty()) {\\n\\n            if ((distance = move(queueSourceToDestination, visitedSourceDestination, visitedDestinationSource, uniqueWords)) >= 0)\\n                return distance + 2;//source and destination included\\n\\n            if ((distance = move(queueDestinationToSource, visitedDestinationSource, visitedSourceDestination, uniqueWords)) >= 0)\\n                return distance + 2;//source and destination included\\n\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * Search in neighbours, and check does same string came again which was visited earlier in other path\\n     *\\n     * @param queue\\n     * @param mainPath    Denotes the main path for this bfs\\n     * @param otherPath   Denotes the other path for this bfs\\n     * @param uniqueWords wordList\\n     * @return return the minimum distance of this path\\n     */\\n    private int move(Queue<Node> queue, Map<String, Integer> mainPath, Map<String, Integer> otherPath, Set<String> uniqueWords) {\\n\\n        if (queue.isEmpty())\\n            return -1;\\n\\n        final Node node = queue.poll();\\n        final int distance = node.distance;\\n        String word = node.word;\\n\\n        //try all word which is 1 weight away\\n        for (String neighbour : getNeighbour(word, uniqueWords)) {\\n\\n            if (otherPath.containsKey(neighbour))\\n                return distance + otherPath.get(neighbour);\\n\\n            if (!mainPath.containsKey(neighbour)) {\\n                mainPath.put(neighbour, distance + 1);\\n                queue.offer(new Node(neighbour, distance + 1));\\n            }\\n        }\\n\\n\\n        return -1;\\n    }\\n\\n\\n    /**\\n     * Algorithm:\\n     * 2. Change each character of this word from [a,z] and test does new word exist in list or not\\n     * 3. if exist, create a edge from this word to new word\\n     * <p>\\n     * Time Complexity:  M is length of longest word\\n     * Step 2: O(M * 26 )\\n     * Step 3: O(1)\\n     * <p>\\n     * Hence : O(M)\\n     * <p>\\n     * Space Complexity: O(M)\\n     *\\n     * @param word Graph nodes\\n     * @return neighbours of weight 1\\n     */\\n    private Set<String> getNeighbour(String word, final Set<String> uniqueWord) {\\n\\n        final Set<String> neighbour = new HashSet<>();\\n\\n\\n        char[] node = word.toCharArray();\\n        int length = node.length;\\n\\n        //change every char of node.\\n        //O(M*26)\\n        for (int i = 0; i < length; i++) { //O(M)\\n\\n            char old = node[i];\\n            //try every node char to change other and test\\n            //O(26)\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\n                if (node[i] == c) //no need to change\\n                    continue;\\n\\n                //change this char\\n                node[i] = c;\\n                String temp = new String(node);\\n                if (uniqueWord.contains(temp))\\n                    neighbour.add(temp);\\n            }\\n            node[i] = old;\\n        }\\n\\n\\n        neighbour.remove(word);\\n\\n\\n        return neighbour;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass WordLadderIBFS {\\n\\n\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\n        if (wordList == null || wordList.isEmpty())\\n            return 0;\\n\\n        final Set<String> uniqueWords = new HashSet<>(wordList);\\n\\n        //if end word is not present then no way to transform\\n        if (!uniqueWords.contains(endWord))\\n            return 0;\\n\\n        if (beginWord.equals(endWord))\\n            return 1;\\n\\n        //O(N*M)\\n        final Map<String, List<String>> graph = buildUnDirectedWeightedGraph(wordList, uniqueWords);\\n\\n        //get mapping corresponding to begin word too.\\n        //O(M)\\n        final Map<String, List<String>> beginWordGraph = buildUnDirectedWeightedGraph(Collections.singletonList(beginWord), uniqueWords);\\n\\n        //append\\n        graph.putAll(beginWordGraph);\\n\\n        //O(N*M)\\n        return bfs(beginWord, endWord, graph);\\n\\n    }\\n\\n\\n    /**\\n     * This will build undirected weighted 1.\\n     * Algorithm:\\n     * 1. Take all word one by one.\\n     * 2. Change each character of this word from [a,z] and test does new word exist in list or not\\n     * 3. if exist, create a edge from this word to new word\\n     * <p>\\n     * Time Complexity:  N is length of list, M is length of longest word\\n     * Step 1: O(N)\\n     * Step 2: O(M * 26 )\\n     * Step 3: O(1)\\n     * <p>\\n     * Hence : O(N*M)\\n     * <p>\\n     * Space Complexity: O(N*M)\\n     *\\n     * @param wordList Graph nodes\\n     * @return undirected weighted {@code weight}\\n     */\\n    private Map<String, List<String>> buildUnDirectedWeightedGraph(List<String> wordList, final Set<String> uniqueWord) {\\n\\n        //represent the undirected weighted(1) graph.\\n        //Key -> word node\\n        //Value -> all node that is weight distance away\\n        final Map<String, List<String>> graph = new HashMap<>();\\n\\n        for (String s : wordList) { //O(N)\\n\\n            char[] node = s.toCharArray();\\n            int length = node.length;\\n\\n            //change every char of node.\\n            //O(M*26)\\n            for (int i = 0; i < length; i++) { //O(M)\\n\\n                char old = node[i];\\n                //try every node char to change other and test\\n                //O(26)\\n                for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\n                    if (node[i] == c) //no need to change\\n                        continue;\\n\\n                    //change this char\\n                    node[i] = c;\\n                    String temp = new String(node);\\n                    if (uniqueWord.contains(temp))\\n                        graph.computeIfAbsent(s, list -> new ArrayList<>()).add(temp);\\n                }\\n                node[i] = old;\\n            }\\n\\n            if (!graph.getOrDefault(s, new ArrayList<>()).isEmpty())\\n                graph.get(s).remove(s);\\n\\n        }\\n\\n\\n        return graph;\\n    }\\n\\n\\n    /**\\n     * Find the shortest path from source to destination\\n     * O(N*M)\\n     *\\n     * @param source      source node\\n     * @param destination destination node\\n     * @param graph       graph\\n     * @return shortest distance otherwise 0 if not reachable\\n     */\\n    private int bfs(String source, String destination, Map<String, List<String>> graph) {\\n\\n        class Node {\\n            String word;\\n            int distance = 0;\\n\\n            public Node(String word, int distance) {\\n                this.word = word;\\n                this.distance = distance;\\n            }\\n        }\\n\\n        final Queue<Node> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.offer(new Node(source, 0)); //distance of source to source is 0\\n        visited.add(source);\\n\\n        while (!queue.isEmpty()) {\\n\\n            final Node node = queue.poll();\\n            final int distance = node.distance;\\n\\n            //if we reached the destination node\\n            if (node.word.equals(destination)) {\\n                return distance + 1;\\n            }\\n\\n            //try all word which is 1 weight away\\n            for (String neighbour : graph.getOrDefault(node.word, new ArrayList<>())) {\\n                if (!visited.contains(neighbour)) {\\n                    visited.add(neighbour);\\n                    queue.offer(new Node(neighbour, distance + 1));\\n                }\\n            }\\n\\n\\n        }\\n        return 0;\\n    }\\n\\n}\\n```\n```\\n\\n/**\\n * Same as above, instead pre-processing. We\\'ll do post processing for each word\\n * Time: O(N*M)\\n * Space: O(N*M)\\n * <p>\\n * Runtime: 69 ms, faster than 48.37% of Java online submissions for Word Ladder.\\n * Memory Usage: 41.1 MB, less than 68.61% of Java online submissions for Word Ladder.\\n */\\nclass WordLadderIBFSV2 {\\n\\n\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\n        if (wordList == null || wordList.isEmpty())\\n            return 0;\\n\\n        final Set<String> uniqueWords = new HashSet<>(wordList);\\n\\n        //if end word is not present then no way to transform\\n        if (!uniqueWords.contains(endWord))\\n            return 0;\\n\\n        if (beginWord.equals(endWord))\\n            return 1;\\n\\n        //O(N*M)\\n        return bfs(beginWord, endWord, uniqueWords);\\n\\n    }\\n\\n\\n    /**\\n     * Find the shortest path from source to destination\\n     * O(N*M)\\n     *\\n     * @param source      source node\\n     * @param destination destination node\\n     * @param uniqueWords graph\\n     * @return shortest distance otherwise 0 if not reachable\\n     */\\n    private int bfs(String source, String destination, final Set<String> uniqueWords) {\\n\\n        class Node {\\n            String word;\\n            int distance;\\n\\n            public Node(String word, int distance) {\\n                this.word = word;\\n                this.distance = distance;\\n            }\\n        }\\n\\n        final Queue<Node> queue = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        queue.offer(new Node(source, 0)); //distance of source to source is 0\\n        visited.add(source);\\n\\n        while (!queue.isEmpty()) {\\n\\n            final Node node = queue.poll();\\n            final int distance = node.distance;\\n\\n            //if we reached the destination node\\n            if (node.word.equals(destination))\\n                return distance + 1;\\n\\n            //try all word which is 1 weight away\\n            for (String neighbour : getNeighbour(node.word, uniqueWords)) {\\n                if (!visited.contains(neighbour)) {\\n                    visited.add(neighbour);\\n                    queue.offer(new Node(neighbour, distance + 1));\\n                }\\n            }\\n\\n\\n        }\\n        return 0;\\n    }\\n\\n\\n    /**\\n     * Algorithm:\\n     * 2. Change each character of this word from [a,z] and test does new word exist in list or not\\n     * 3. if exist, create a edge from this word to new word\\n     * <p>\\n     * Time Complexity:  M is length of longest word\\n     * Step 2: O(M * 26 )\\n     * Step 3: O(1)\\n     * <p>\\n     * Hence : O(M)\\n     * <p>\\n     * Space Complexity: O(M)\\n     *\\n     * @param word Graph nodes\\n     * @return neighbours of weight 1\\n     */\\n    private Set<String> getNeighbour(String word, final Set<String> uniqueWord) {\\n\\n        final Set<String> neighbour = new HashSet<>();\\n\\n\\n        char[] node = word.toCharArray();\\n        int length = node.length;\\n\\n        //change every char of node.\\n        //O(M*26)\\n        for (int i = 0; i < length; i++) { //O(M)\\n\\n            char old = node[i];\\n            //try every node char to change other and test\\n            //O(26)\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\n                if (node[i] == c) //no need to change\\n                    continue;\\n\\n                //change this char\\n                node[i] = c;\\n                String temp = new String(node);\\n                if (uniqueWord.contains(temp))\\n                    neighbour.add(temp);\\n            }\\n            node[i] = old;\\n        }\\n\\n\\n        neighbour.remove(word);\\n\\n\\n        return neighbour;\\n    }\\n\\n}\\n```\n```\\n\\n/**\\n * Instead of running single BFS as in {@link WordLadderIBFS} we can do bi-directional bfs.\\n * One bfs from source to destination node\\n * one bfs from destination to source node\\n * at the same time.\\n * <p>\\n * When we reach a state, where both of the current node are same, we are done with the process.\\n * <p>\\n * Bidirectional Search uses 2 simultaneous BFS searches to find the distance between 2 nodes (by alternating between the searches)\\n * <p>\\n * Bidirectional Search\\n * <p>\\n * For BFS, if d is the distance between the 2 nodes, and b is the branching factor, 1 way to represent the runtime is O(bd).\\n * <p>\\n * For Bidirectional search, the runtime is O(b(d/2)) + O(b(d/2)) = O(2*b(d/2)) = O(b(d/2)) since each search only has to search halfway before meeting the other search.\\n * <p>\\n * Applying Bidirectional Search to our original solution\\n * <p>\\n * Our original solution used 1 Deque as a queue, and 1 Set to mark visited Strings. Since we are running 2 BFS searches, we will make 2 of these Deques and 2 of these Sets.\\n * To simulate 2 BFS searches \"simultaneously\", we alter between which of the 2 Deques we deque from.\\n * We now have 2 Deques to deque from, and 2 \"visited\" Sets, but we don\\'t want to duplicate code. We will create a general function called checkNeighbors() that takes a Deque and Set as input, to help us alternate between the 2 BFS searches.\\n * If at any time a String gets dequed, and one of its neighbors has already been visited from the opposite side\\'s parallel search, we\\'ve found a solution.\\n * <p>\\n * Runtime: 13 ms, faster than 97.07% of Java online submissions for Word Ladder.\\n * Memory Usage: 38.8 MB, less than 97.81% of Java online submissions for Word Ladder.\\n */\\nclass WordLadderIBiDirectionalBFS {\\n    static class Node {\\n        String word;\\n        int distance;\\n\\n        public Node(String word, int distance) {\\n            this.word = word;\\n            this.distance = distance;\\n        }\\n    }\\n\\n    public int ladderLength(String source, String destination, List<String> wordList) {\\n\\n        if (wordList == null || wordList.isEmpty())\\n            return 0;\\n\\n        final Set<String> uniqueWords = new HashSet<>(wordList);\\n\\n        //if end word is not present then no way to transform\\n        if (!uniqueWords.contains(destination))\\n            return 0;\\n\\n        if (source.equals(destination))\\n            return 1;\\n\\n\\n        //One direction from source to destination\\n        final Queue<Node> queueSourceToDestination = new LinkedList<>();\\n        //contains [string,distance]\\n        final Map<String, Integer> visitedSourceDestination = new HashMap<>();\\n\\n        //One direction from destination to source\\n        final Queue<Node> queueDestinationToSource = new LinkedList<>();\\n        //contains [string,distance]\\n        final Map<String, Integer> visitedDestinationSource = new HashMap<>();\\n\\n\\n        queueSourceToDestination.offer(new Node(source, 0)); //distance of source to source is 0\\n        visitedSourceDestination.put(source, 0);\\n\\n        queueDestinationToSource.offer(new Node(destination, 0)); //distance of source to source is 0\\n        visitedDestinationSource.put(destination, 0);\\n\\n        int distance;\\n        while (!queueSourceToDestination.isEmpty() && !queueDestinationToSource.isEmpty()) {\\n\\n            if ((distance = move(queueSourceToDestination, visitedSourceDestination, visitedDestinationSource, uniqueWords)) >= 0)\\n                return distance + 2;//source and destination included\\n\\n            if ((distance = move(queueDestinationToSource, visitedDestinationSource, visitedSourceDestination, uniqueWords)) >= 0)\\n                return distance + 2;//source and destination included\\n\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * Search in neighbours, and check does same string came again which was visited earlier in other path\\n     *\\n     * @param queue\\n     * @param mainPath    Denotes the main path for this bfs\\n     * @param otherPath   Denotes the other path for this bfs\\n     * @param uniqueWords wordList\\n     * @return return the minimum distance of this path\\n     */\\n    private int move(Queue<Node> queue, Map<String, Integer> mainPath, Map<String, Integer> otherPath, Set<String> uniqueWords) {\\n\\n        if (queue.isEmpty())\\n            return -1;\\n\\n        final Node node = queue.poll();\\n        final int distance = node.distance;\\n        String word = node.word;\\n\\n        //try all word which is 1 weight away\\n        for (String neighbour : getNeighbour(word, uniqueWords)) {\\n\\n            if (otherPath.containsKey(neighbour))\\n                return distance + otherPath.get(neighbour);\\n\\n            if (!mainPath.containsKey(neighbour)) {\\n                mainPath.put(neighbour, distance + 1);\\n                queue.offer(new Node(neighbour, distance + 1));\\n            }\\n        }\\n\\n\\n        return -1;\\n    }\\n\\n\\n    /**\\n     * Algorithm:\\n     * 2. Change each character of this word from [a,z] and test does new word exist in list or not\\n     * 3. if exist, create a edge from this word to new word\\n     * <p>\\n     * Time Complexity:  M is length of longest word\\n     * Step 2: O(M * 26 )\\n     * Step 3: O(1)\\n     * <p>\\n     * Hence : O(M)\\n     * <p>\\n     * Space Complexity: O(M)\\n     *\\n     * @param word Graph nodes\\n     * @return neighbours of weight 1\\n     */\\n    private Set<String> getNeighbour(String word, final Set<String> uniqueWord) {\\n\\n        final Set<String> neighbour = new HashSet<>();\\n\\n\\n        char[] node = word.toCharArray();\\n        int length = node.length;\\n\\n        //change every char of node.\\n        //O(M*26)\\n        for (int i = 0; i < length; i++) { //O(M)\\n\\n            char old = node[i];\\n            //try every node char to change other and test\\n            //O(26)\\n            for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n\\n                if (node[i] == c) //no need to change\\n                    continue;\\n\\n                //change this char\\n                node[i] = c;\\n                String temp = new String(node);\\n                if (uniqueWord.contains(temp))\\n                    neighbour.add(temp);\\n            }\\n            node[i] = old;\\n        }\\n\\n\\n        neighbour.remove(word);\\n\\n\\n        return neighbour;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354573,
                "title": "python3-bfs-by-deque-bfs-by-set-bidirectionalbfs-readable-fast-beats-96",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n    #---------------BFS-1-deque--Naive-------------------#\\n        from collections import deque\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        \\n        wordLen = len(beginWord)\\n        levels = {beginWord: 1}\\n        dq = deque([beginWord])\\n        \\n        while dq:\\n            currWord = dq.popleft()  \\n            currLevel = levels[currWord]\\n            for i in range(wordLen):\\n                c = currWord[i]\\n                for t in string.ascii_lowercase:\\n                    if c == t: continue\\n                    newWord = currWord[:i] + t + currWord[i + 1:]  #Try all 26 cases\\n                    if newWord == endWord:\\n                        return currLevel + 1\\n                    if newWord in wordDict:\\n                        wordDict.remove(newWord)\\n                        dq.append(newWord)\\n                        levels[newWord] = currLevel + 1\\n        return 0\\n    \\n    ---------------BFS-1-deque-Improved--Using--adjacent--list------------------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        \\n        adj = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in range(wordLen):\\n                adj[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n                \\n        dq = collections.deque([(beginWord, 1)])\\n        while dq:\\n            word, level = dq.popleft()\\n            for i in range(wordLen):\\n                dummyWord = word[:i] + \\'*\\' + word[i+1:]\\n                for newWord in adj[dummyWord]:\\n                    if newWord == endWord:\\n                        return level + 1\\n                    if newWord in wordDict:\\n                        wordDict.remove(newWord)\\n                        dq.append((newWord, level+1))\\n        return 0\\n    \\n    #---------------BFS-2-set---Naive------------------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        level = 1\\n        dq = {beginWord} \\n        while dq:\\n            currWords = []\\n            for word in dq:\\n                currWords.append(word)\\n            newdp = set()\\n            for currWord in currWords:\\n                for i in range(wordLen):\\n                    c = currWord[i]\\n                    for t in string.ascii_lowercase:\\n                        if c == t: continue\\n                        newWord = currWord[:i] + t + currWord[i + 1:] #Try all 26 cases\\n                        if newWord == endWord:\\n                            return level + 1\\n                        if newWord in wordDict:\\n                            wordDict.remove(newWord)\\n                            newdp.add(newWord)\\n            level += 1\\n            dq = newdp\\n        return 0\\n    \\n    #---------------BFS-2-set--Improved-------------------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        level = 1\\n        dq = {beginWord} \\n        \\n        adj = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in range(wordLen):\\n                adj[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n        while dq:\\n            currWords = []\\n            for word in dq:\\n                currWords.append(word)\\n            newdp = set()\\n            for currWord in currWords:\\n                for i in range(wordLen):\\n                    dummyWord = currWord[:i] + \\'*\\' + currWord[i+1:]\\n                    for newWord in adj[dummyWord]:\\n                        if newWord == endWord:\\n                            return level + 1\\n                        if newWord in wordDict:\\n                            wordDict.remove(newWord)\\n                            newdp.add(newWord)\\n            level += 1\\n            dq = newdp\\n        return 0\\n\\n                        \\n    #--------------BidirectionBFS--------------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        level = 0\\n        forwards = {beginWord}\\n        backwards = {endWord}\\n        wordDict.remove(endWord)\\n        \\n        while backwards and forwards:\\n            level += 1\\n            if len(forwards) > len(backwards): forwards, backwards = backwards, forwards # a little trick here, always explore nodes in the smaller set\\n            newSet = set()\\n            for word in forwards:\\n                newWords = [ word[:i] + t + word[i+1:]  for t in string.ascii_lowercase for i in range(wordLen)]\\n                for newWord in newWords:\\n                    if newWord in backwards: return level + 1\\n                    if newWord not in wordDict: continue\\n                    wordDict.remove(newWord)                        \\n                    newSet.add(newWord)\\n            forwards = newSet\\n        return 0\\n    \\n     #--------------BidirectionBFS---Improved-----------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        level = 0\\n        forwards = {beginWord}\\n        backwards = {endWord}\\n        wordDict.remove(endWord)\\n        \\n        adj = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in range(wordLen):\\n                adj[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n        \\n        while backwards and forwards:\\n            level += 1\\n            if len(forwards) > len(backwards): forwards, backwards = backwards, forwards\\n            newSet = set()\\n            for currWord in forwards:\\n                newWords = []\\n                for i in range(wordLen):\\n                    for newWord in adj[currWord[:i] + \\'*\\' + currWord[i+1:]]:\\n                        newWords.append(newWord)\\n                for newWord in newWords:\\n                    if newWord in backwards: return level + 1\\n                    if newWord not in wordDict: continue\\n                    wordDict.remove(newWord)                        \\n                    newSet.add(newWord)\\n            forwards = newSet\\n        return 0\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n    #---------------BFS-1-deque--Naive-------------------#\\n        from collections import deque\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        \\n        wordLen = len(beginWord)\\n        levels = {beginWord: 1}\\n        dq = deque([beginWord])\\n        \\n        while dq:\\n            currWord = dq.popleft()  \\n            currLevel = levels[currWord]\\n            for i in range(wordLen):\\n                c = currWord[i]\\n                for t in string.ascii_lowercase:\\n                    if c == t: continue\\n                    newWord = currWord[:i] + t + currWord[i + 1:]  #Try all 26 cases\\n                    if newWord == endWord:\\n                        return currLevel + 1\\n                    if newWord in wordDict:\\n                        wordDict.remove(newWord)\\n                        dq.append(newWord)\\n                        levels[newWord] = currLevel + 1\\n        return 0\\n    \\n    ---------------BFS-1-deque-Improved--Using--adjacent--list------------------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        \\n        adj = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in range(wordLen):\\n                adj[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n                \\n        dq = collections.deque([(beginWord, 1)])\\n        while dq:\\n            word, level = dq.popleft()\\n            for i in range(wordLen):\\n                dummyWord = word[:i] + \\'*\\' + word[i+1:]\\n                for newWord in adj[dummyWord]:\\n                    if newWord == endWord:\\n                        return level + 1\\n                    if newWord in wordDict:\\n                        wordDict.remove(newWord)\\n                        dq.append((newWord, level+1))\\n        return 0\\n    \\n    #---------------BFS-2-set---Naive------------------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        level = 1\\n        dq = {beginWord} \\n        while dq:\\n            currWords = []\\n            for word in dq:\\n                currWords.append(word)\\n            newdp = set()\\n            for currWord in currWords:\\n                for i in range(wordLen):\\n                    c = currWord[i]\\n                    for t in string.ascii_lowercase:\\n                        if c == t: continue\\n                        newWord = currWord[:i] + t + currWord[i + 1:] #Try all 26 cases\\n                        if newWord == endWord:\\n                            return level + 1\\n                        if newWord in wordDict:\\n                            wordDict.remove(newWord)\\n                            newdp.add(newWord)\\n            level += 1\\n            dq = newdp\\n        return 0\\n    \\n    #---------------BFS-2-set--Improved-------------------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        level = 1\\n        dq = {beginWord} \\n        \\n        adj = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in range(wordLen):\\n                adj[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n        while dq:\\n            currWords = []\\n            for word in dq:\\n                currWords.append(word)\\n            newdp = set()\\n            for currWord in currWords:\\n                for i in range(wordLen):\\n                    dummyWord = currWord[:i] + \\'*\\' + currWord[i+1:]\\n                    for newWord in adj[dummyWord]:\\n                        if newWord == endWord:\\n                            return level + 1\\n                        if newWord in wordDict:\\n                            wordDict.remove(newWord)\\n                            newdp.add(newWord)\\n            level += 1\\n            dq = newdp\\n        return 0\\n\\n                        \\n    #--------------BidirectionBFS--------------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        level = 0\\n        forwards = {beginWord}\\n        backwards = {endWord}\\n        wordDict.remove(endWord)\\n        \\n        while backwards and forwards:\\n            level += 1\\n            if len(forwards) > len(backwards): forwards, backwards = backwards, forwards # a little trick here, always explore nodes in the smaller set\\n            newSet = set()\\n            for word in forwards:\\n                newWords = [ word[:i] + t + word[i+1:]  for t in string.ascii_lowercase for i in range(wordLen)]\\n                for newWord in newWords:\\n                    if newWord in backwards: return level + 1\\n                    if newWord not in wordDict: continue\\n                    wordDict.remove(newWord)                        \\n                    newSet.add(newWord)\\n            forwards = newSet\\n        return 0\\n    \\n     #--------------BidirectionBFS---Improved-----------#\\n        wordDict = set(wordList)\\n        if endWord not in wordDict: return 0\\n        wordLen = len(beginWord)\\n        level = 0\\n        forwards = {beginWord}\\n        backwards = {endWord}\\n        wordDict.remove(endWord)\\n        \\n        adj = collections.defaultdict(list)\\n        for word in wordList:\\n            for i in range(wordLen):\\n                adj[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n        \\n        while backwards and forwards:\\n            level += 1\\n            if len(forwards) > len(backwards): forwards, backwards = backwards, forwards\\n            newSet = set()\\n            for currWord in forwards:\\n                newWords = []\\n                for i in range(wordLen):\\n                    for newWord in adj[currWord[:i] + \\'*\\' + currWord[i+1:]]:\\n                        newWords.append(newWord)\\n                for newWord in newWords:\\n                    if newWord in backwards: return level + 1\\n                    if newWord not in wordDict: continue\\n                    wordDict.remove(newWord)                        \\n                    newSet.add(newWord)\\n            forwards = newSet\\n        return 0\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 323187,
                "title": "c-5-beat-level-order-search-straight-forward-sol-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        unordered_set aDictionary(wordList.begin(), wordList.end());\\n        if (aDictionary.count(endWord) == 0) { return 0; }\\n        \\n        queue<string> aQueue;\\n        aQueue.push(beginWord);\\n        \\n        int aWordListCount = wordList.size();\\n        int aWordLen = beginWord.size();\\n        int aCount, aLevel, i, j, aLetterIndex, aDiffCount;\\n        char aLetter;\\n        string aWord1, aWord2;\\n        \\n        int aDepth = 1;\\n        \\n        unordered_set<string> aVisited;\\n        aVisited.insert(beginWord);\\n        \\n        while (aQueue.size() > 0) {\\n            \\n            ++aDepth;\\n            \\n            aCount = aQueue.size();\\n            for (aLevel=0;aLevel<aCount;aLevel++) {\\n                \\n                aWord1 = aQueue.front();\\n                aQueue.pop();\\n                \\n                for (j=0;j<aWordListCount;j++) {\\n                    aWord2 = wordList[j];\\n                    aDiffCount = 0;\\n                    for (aLetterIndex=0;aLetterIndex<aWordLen;aLetterIndex++) {\\n                        if (aWord1[aLetterIndex] != aWord2[aLetterIndex]) { ++aDiffCount; }\\n                    }\\n                    if (aDiffCount == 1) {\\n                        if (aVisited.count(aWord2) == 0) {\\n                            if (aWord2 == endWord) { return aDepth; }\\n                            aVisited.insert(aWord2);\\n                            aQueue.push(aWord2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nWouldn\\'t mind trying a solution which did backwards and forward probing both at the same time.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        unordered_set aDictionary(wordList.begin(), wordList.end());\\n        if (aDictionary.count(endWord) == 0) { return 0; }\\n        \\n        queue<string> aQueue;\\n        aQueue.push(beginWord);\\n        \\n        int aWordListCount = wordList.size();\\n        int aWordLen = beginWord.size();\\n        int aCount, aLevel, i, j, aLetterIndex, aDiffCount;\\n        char aLetter;\\n        string aWord1, aWord2;\\n        \\n        int aDepth = 1;\\n        \\n        unordered_set<string> aVisited;\\n        aVisited.insert(beginWord);\\n        \\n        while (aQueue.size() > 0) {\\n            \\n            ++aDepth;\\n            \\n            aCount = aQueue.size();\\n            for (aLevel=0;aLevel<aCount;aLevel++) {\\n                \\n                aWord1 = aQueue.front();\\n                aQueue.pop();\\n                \\n                for (j=0;j<aWordListCount;j++) {\\n                    aWord2 = wordList[j];\\n                    aDiffCount = 0;\\n                    for (aLetterIndex=0;aLetterIndex<aWordLen;aLetterIndex++) {\\n                        if (aWord1[aLetterIndex] != aWord2[aLetterIndex]) { ++aDiffCount; }\\n                    }\\n                    if (aDiffCount == 1) {\\n                        if (aVisited.count(aWord2) == 0) {\\n                            if (aWord2 == endWord) { return aDepth; }\\n                            aVisited.insert(aWord2);\\n                            aQueue.push(aWord2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226869,
                "title": "elegent-scala-solution-one-way-bfs",
                "content": "```scala\\nimport scala.collection._\\n\\nobject Solution {\\n    def isNeighbour(s1: String, s2: String): Boolean = {\\n        var count = 0\\n        for(i <- 0 until s1.length) {\\n            if (s1(i) != s2(i)) count += 1 \\n            if (count > 1) return false\\n        }\\n        count == 1\\n    }\\n    def ladderLength(beginWord: String, endWord: String, wordList: List[String]): Int = {\\n        val neighbourLookup = (beginWord :: wordList).map(s => s -> wordList.filter(t => isNeighbour(s, t))).toMap\\n        val visited = mutable.Set.empty[String]\\n        val queue = mutable.Queue(beginWord)\\n        var step = 1\\n        while(queue.nonEmpty) {\\n            val numLevel = queue.size\\n            for(i <- 0 until numLevel) {\\n                val current = queue.dequeue()\\n                if(current == endWord) return step\\n                visited += current\\n                val children = neighbourLookup(current).filterNot(visited)\\n                queue ++= children\\n            }\\n            step += 1\\n        }\\n        0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nimport scala.collection._\\n\\nobject Solution {\\n    def isNeighbour(s1: String, s2: String): Boolean = {\\n        var count = 0\\n        for(i <- 0 until s1.length) {\\n            if (s1(i) != s2(i)) count += 1 \\n            if (count > 1) return false\\n        }\\n        count == 1\\n    }\\n    def ladderLength(beginWord: String, endWord: String, wordList: List[String]): Int = {\\n        val neighbourLookup = (beginWord :: wordList).map(s => s -> wordList.filter(t => isNeighbour(s, t))).toMap\\n        val visited = mutable.Set.empty[String]\\n        val queue = mutable.Queue(beginWord)\\n        var step = 1\\n        while(queue.nonEmpty) {\\n            val numLevel = queue.size\\n            for(i <- 0 until numLevel) {\\n                val current = queue.dequeue()\\n                if(current == endWord) return step\\n                visited += current\\n                val children = neighbourLookup(current).filterNot(visited)\\n                queue ++= children\\n            }\\n            step += 1\\n        }\\n        0\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 218253,
                "title": "c-20ms-100-solution-using-bidirectional-search-w-explanations-for-optimizations",
                "content": "This problem is rather difficult since it requires a lot of thinking, beyond the obvious BFS solution. The optimizations used based on BFS solution are as follows:\\n\\n1. Switch to bidirectional search instead of BFS (known target and source), which will square-root the time complexity. The link for this algorithm is here: https://www.geeksforgeeks.org/bidirectional-search/\\n\\nBasically this algorithm is like BFS, but doing it to both source and destination, so destination starts a BFS looking for source, and source starts a search looking for destination. Once their searches collide (reach the same word), there is the solution. However, the algorithm requires that the number of expansions from both searches are about the same.  Thus, to implement this, I made the BFS searches take turns, and when one search has too many nodes, switch to the other search to even things out.\\n\\n2. Build adj-list on the fly. This is because the search area is often much smaller than the node count, so building a full adj-list from the start will waste a lot of time since most of the nodes will not be used. Instead, we make the adj list on the spot for nodes we actually need. (Went from 650-680ms to 624 ms)\\n3. Use indexing instead of strings for adj-list. This saves time since string comparison is O(n) for string of length n, but O(1) for its index.  \\n4. (test-case specific) Use a map to store the wordList, then build adj-list for a word by going through all possible combinations of single character mutation in that word, and checking if it exist in the map, and add its index as adjacent if it exist. This is test-case specific since most of the test cases have very small character count for the strings (usually 3). The complexity of this operation is O(26 * n), which is comparatively smaller than the usual wordList size, so traversing the wordList looking for adjacent words will be extremely slow compared to this. This is the MAJOR time-saver for this problem (I went from 624 ms pure BFS to 150 ms from this one trick).\\n5. Use a set for storing current nodes instead of a queue. The idea behind this is that there are bound to be some repeated nodes when adding every reachable node from every node inthe adjacency list. If using a queue, the repeated nodes would have to be popped again and again. But if using a set, they won\\'t exist, so there are fewer iterations for BFS. \\n\\nAdd all of these together? You get a 20ms solution. \\n\\nNot included in code but good idea for BFS: Map erasure. Erase words from map that are encountered, using pure BFS. This way, the map operation becomes faster and faster. This allowed my BFS solution to reach 80 ms (from 150 ms). \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        int size = wordList.size(), target = -1;\\n        wordList.push_back(beginWord);\\n        vector<bool> visited(size+1, false);\\n\\n        unordered_map<string, int> words;\\n        for(int i = 0; i < size; ++i) {\\n            if(wordList[i] == endWord) target = i;\\n            words[wordList[i]] = i;\\n        }\\n        if(target == -1) return 0;\\n\\n        return biSearch(wordList, words, visited, size, target);\\n    }\\n\\n    int biSearch(const vector<string>& wordList, const unordered_map<string, int>& words, vector<bool>& visited, const int src, const int dest) {\\n        \\n        unordered_set<int> curSet{src}, otherSet{dest}, buf;\\n        int dist = 1;\\n        while(!curSet.empty()) {\\n\\n            ++dist;\\n            for(auto cur: curSet) {\\n                vector<int> adjList;\\n                string word = wordList[cur];\\n                for(auto &c: word) {\\n                    char tmp = c;\\n                    for(int i = \\'a\\'; i <= \\'z\\'; ++i) {\\n                        c = i;\\n                        auto it = words.find(word);\\n                        if(it != words.end()) {\\n                            adjList.push_back(it->second);\\n                        }\\n                    }\\n                    c = tmp;\\n                }\\n\\n                for(auto n: adjList) {\\n                    if(otherSet.find(n) != otherSet.end()) return dist;\\n                    if(!visited[n]) {visited[n] = true; buf.insert(n);}\\n                }\\n            }\\n            curSet = move(buf);\\n            if(curSet.size() > otherSet.size()) swap(curSet, otherSet);\\n\\n        }\\n        return 0;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        int size = wordList.size(), target = -1;\\n        wordList.push_back(beginWord);\\n        vector<bool> visited(size+1, false);\\n\\n        unordered_map<string, int> words;\\n        for(int i = 0; i < size; ++i) {\\n            if(wordList[i] == endWord) target = i;\\n            words[wordList[i]] = i;\\n        }\\n        if(target == -1) return 0;\\n\\n        return biSearch(wordList, words, visited, size, target);\\n    }\\n\\n    int biSearch(const vector<string>& wordList, const unordered_map<string, int>& words, vector<bool>& visited, const int src, const int dest) {\\n        \\n        unordered_set<int> curSet{src}, otherSet{dest}, buf;\\n        int dist = 1;\\n        while(!curSet.empty()) {\\n\\n            ++dist;\\n            for(auto cur: curSet) {\\n                vector<int> adjList;\\n                string word = wordList[cur];\\n                for(auto &c: word) {\\n                    char tmp = c;\\n                    for(int i = \\'a\\'; i <= \\'z\\'; ++i) {\\n                        c = i;\\n                        auto it = words.find(word);\\n                        if(it != words.end()) {\\n                            adjList.push_back(it->second);\\n                        }\\n                    }\\n                    c = tmp;\\n                }\\n\\n                for(auto n: adjList) {\\n                    if(otherSet.find(n) != otherSet.end()) return dist;\\n                    if(!visited[n]) {visited[n] = true; buf.insert(n);}\\n                }\\n            }\\n            curSet = move(buf);\\n            if(curSet.size() > otherSet.size()) swap(curSet, otherSet);\\n\\n        }\\n        return 0;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 40762,
                "title": "c-solution",
                "content": "```\\npublic int LadderLength(string beginWord, string endWord, IList<string> wordList) {\\n        int count = 1,\\n            countInLevel = 0;\\n        Queue<string> queue = new Queue<string>();\\n        string currentWord = string.Empty;\\n        HashSet<string> dictionary = new HashSet<string>(wordList);\\n        char[] temp = null;\\n        \\n        queue.Enqueue(beginWord);\\n        \\n        while (queue.Count != 0)\\n        {\\n            countInLevel = queue.Count();\\n            \\n            while (countInLevel-- > 0)\\n            {\\n                currentWord = queue.Dequeue();\\n                \\n                if (currentWord == endWord)\\n                    return count;\\n                \\n                temp = currentWord.ToCharArray();\\n                for (int i = 0; i <= temp.Length - 1; i++)\\n                {\\n                    temp = currentWord.ToCharArray();\\n\\n                    for (int j = 0; j < 26; j++)\\n                    {\\n                        temp[i] = (char)('a' + j);\\n\\n                        if (dictionary.Contains(new string(temp)))\\n                        {\\n                            queue.Enqueue(new string(temp));\\n                            dictionary.Remove(new string(temp));\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            count++;\\n        }\\n        \\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int LadderLength(string beginWord, string endWord, IList<string> wordList) {\\n        int count = 1,\\n            countInLevel = 0;\\n        Queue<string> queue = new Queue<string>();\\n        string currentWord = string.Empty;\\n        HashSet<string> dictionary = new HashSet<string>(wordList);\\n        char[] temp = null;\\n        \\n        queue.Enqueue(beginWord);\\n        \\n        while (queue.Count != 0)\\n        {\\n            countInLevel = queue.Count();\\n            \\n            while (countInLevel-- > 0)\\n            {\\n                currentWord = queue.Dequeue();\\n                \\n                if (currentWord == endWord)\\n                    return count;\\n                \\n                temp = currentWord.ToCharArray();\\n                for (int i = 0; i <= temp.Length - 1; i++)\\n                {\\n                    temp = currentWord.ToCharArray();\\n\\n                    for (int j = 0; j < 26; j++)\\n                    {\\n                        temp[i] = (char)('a' + j);\\n\\n                        if (dictionary.Contains(new string(temp)))\\n                        {\\n                            queue.Enqueue(new string(temp));\\n                            dictionary.Remove(new string(temp));\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            count++;\\n        }\\n        \\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 40764,
                "title": "new-java-ac-solution-revised-from-previous-set-version",
                "content": "Previous word ladder problem uses Set as wordList, and in previous test cases, the endWord seems always in the wordList (correct me if I am wrong). I still use the same idea as described here: https://discuss.leetcode.com/topic/17890/another-accepted-java-solution-bfs/8\\nModified a bit since we need to check if the transformed word is in wordList or not.\\n```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> words = new HashSet<>();\\n        words.addAll(wordList);\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(beginWord);\\n\\n        Set<String> reached = new HashSet<>();\\n        reached.add(beginWord);\\n        \\n        int level = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                String word = queue.poll();\\n                for (int j = 0; j < word.length(); j++) {\\n                    char[] chars = word.toCharArray();\\n                    \\n                    for (char c = 'a'; c <= 'z'; c++) {\\n                        chars[j] = c;\\n                        String newWord = new String(chars);\\n                        if (words.contains(newWord)) {\\n                            if (newWord.equals(endWord)) return level + 1;\\n                            else if (reached.add(newWord)) queue.add(newWord);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> words = new HashSet<>();\\n        words.addAll(wordList);\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.add(beginWord);\\n\\n        Set<String> reached = new HashSet<>();\\n        reached.add(beginWord);\\n        \\n        int level = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                String word = queue.poll();\\n                for (int j = 0; j < word.length(); j++) {\\n                    char[] chars = word.toCharArray();\\n                    \\n                    for (char c = 'a'; c <= 'z'; c++) {\\n                        chars[j] = c;\\n                        String newWord = new String(chars);\\n                        if (words.contains(newWord)) {\\n                            if (newWord.equals(endWord)) return level + 1;\\n                            else if (reached.add(newWord)) queue.add(newWord);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 40833,
                "title": "python-a-solution",
                "content": "Below my solution to the Word Ladder problem using the A* search algorithm.  It is far from the fastest solution out there (not even close to two-sided BFS) but A* is both optimal and complete, and in a situation with a larger search space it would quickly outpace most other options (it would also help if I could use the C code for calculating Hamming distance from the pylevenshtien package).  I used hamming distance (the number of letter swaps in the same position) as the A* heuristic as it seemed to make the most sense and it's both admissible and consistent.\\n\\nCode:\\n\\n```\\nimport operator\\nimport collections\\nimport heapq\\n\\n\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: Set[str]\\n        :rtype: int\\n        \"\"\"        \\n        # Check inputs\\n        # Empty or identical\\n        if len(beginWord)==0 or len(wordList)==0 or beginWord==endWord:\\n            return 0\\n        # Single char\\n        if len(beginWord)==1:\\n            return 2\\n        \\n        \\n        # Funcs\\n        # Evertything is definied here in order to avoid penalties for out of scope references\\n        def make_p2w(words, w_idxs):  \\n            \"\"\"Creates a map of all combinations of words with missing letters mapped \\n            to all words in the list that match that pattern.\\n            E.g. hot -> {'_ot': ['hot'], 'h_t': ['hot'], 'ho_': ['hot']}\\n            \"\"\"\\n            # Patterns to words and words to patterns\\n            p2w = collections.defaultdict(list)\\n\\n            for w in words:\\n                for i,j in w_idxs:\\n                    p = w[:i] + '_' + w[j:]\\n                    p2w[p].append(w)\\n            return p2w\\n                \\n        # The search function!!!\\n        def a_star(start, goal, w_idxs, p2w):\\n            # Node structure: (int d+h, int d, int h, str word)\\n            # where d is the depth            \\n            visited = set([start])\\n            q = [(0, 1, 0, start)]\\n\\n            while q:\\n                # Get the next node\\n                score, depth, h, word = heapq.heappop(q)\\n                child_depth = depth+1\\n                                \\n                # Get the node's children\\n                for i,j in w_idxs:\\n                    p = word[:i] + \"_\" + word[j:]\\n                    neighbor_words = p2w[p]\\n\\n                    # Iterate through children\\n                    for nw in neighbor_words:\\n                        if nw not in visited:\\n                            # Goal check (before adding to the queue)\\n                            if nw == goal:\\n                                return child_depth\\n                            visited.add(nw)\\n                            # Calculate the A* heurisitc\\n                            # In order to be optimal for a search on a graph the heuristic must be both admissible and \\n                            # consistent.  In order to meet those criteria I'm using the number of different letters \\n                            # (hamming distance) between the given word and the goal word.  This should never \\n                            # overestimate the distance to the goal word and should also maintain the triangle \\n                            # inequality for the graph (consistency). \\n                            # See Chapter 3 of \"Artificial Intelligence a Modern Approach\" for details.\\n                            # Compute the number of swaps between two words by doing a boolean comparision \\n                            # on each pair of letters and then using sum to caste the bools to ints.  \\n                            # E.g. if two words are neighbors, the sum should be 1.         \\n                            h = sum(map(operator.ne, nw, goal)) \\n                            # Add to the q\\n                            heapq.heappush(q, (child_depth+h, child_depth, h, nw))\\n            # No route to goal \\n            return 0\\n        \\n        # Get word length\\n        wl = len(beginWord)\\n        w_indexes = zip(range(wl), range(1, wl+1))\\n        # Preprocess the wordlist to make finding neighbors easy\\n        patterns2words = make_p2w(wordList, w_indexes)\\n        # Do the search\\n        return a_star(beginWord, endWord, w_indexes, patterns2words)\\n```\\n\\n**EDIT**\\nI spent a bit more time with this and realized that I wasn't accounting for the case where a word is encountered a second (or more) time after it has already been encountered before from a longer path.  E.g. given a word, w, that we put on the queue as Node(h_w, depth=5, w), we might come across w again from a different direction and have Node(h_w, depth=3, w).  This is completely possible and it even happens in a couple of the leetcode test cases.  The thing is, none of the test cases actually have the shortest path to the goal pass through any of those words.  In fact, changing the code to account for this actually leads to visiting (though not expanding) _more_ nodes than the way the code is above.  \\n\\nThe way this _should_ work is that if a ward that is already in the visited set is encountered and the depth this time is less than when it was added to the queue, the depth and the heuristic score should be updated for that node in the queue and the queue should be re-heapified.\\n\\n**A Note on Performance**\\nEven though it's not as fast as BFS it does expand as much as 200+ fewer nodes than an equivalent BFS solution.  The problem is that calculating the heuristic is slow.  If the search space were much larger A* would win.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport operator\\nimport collections\\nimport heapq\\n\\n\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        \"\"\"\\n        :type beginWord: str\\n        :type endWord: str\\n        :type wordList: Set[str]\\n        :rtype: int\\n        \"\"\"        \\n        # Check inputs\\n        # Empty or identical\\n        if len(beginWord)==0 or len(wordList)==0 or beginWord==endWord:\\n            return 0\\n        # Single char\\n        if len(beginWord)==1:\\n            return 2\\n        \\n        \\n        # Funcs\\n        # Evertything is definied here in order to avoid penalties for out of scope references\\n        def make_p2w(words, w_idxs):  \\n            \"\"\"Creates a map of all combinations of words with missing letters mapped \\n            to all words in the list that match that pattern.\\n            E.g. hot -> {'_ot': ['hot'], 'h_t': ['hot'], 'ho_': ['hot']}\\n            \"\"\"\\n            # Patterns to words and words to patterns\\n            p2w = collections.defaultdict(list)\\n\\n            for w in words:\\n                for i,j in w_idxs:\\n                    p = w[:i] + '_' + w[j:]\\n                    p2w[p].append(w)\\n            return p2w\\n                \\n        # The search function!!!\\n        def a_star(start, goal, w_idxs, p2w):\\n            # Node structure: (int d+h, int d, int h, str word)\\n            # where d is the depth            \\n            visited = set([start])\\n            q = [(0, 1, 0, start)]\\n\\n            while q:\\n                # Get the next node\\n                score, depth, h, word = heapq.heappop(q)\\n                child_depth = depth+1\\n                                \\n                # Get the node's children\\n                for i,j in w_idxs:\\n                    p = word[:i] + \"_\" + word[j:]\\n                    neighbor_words = p2w[p]\\n\\n                    # Iterate through children\\n                    for nw in neighbor_words:\\n                        if nw not in visited:\\n                            # Goal check (before adding to the queue)\\n                            if nw == goal:\\n                                return child_depth\\n                            visited.add(nw)\\n                            # Calculate the A* heurisitc\\n                            # In order to be optimal for a search on a graph the heuristic must be both admissible and \\n                            # consistent.  In order to meet those criteria I'm using the number of different letters \\n                            # (hamming distance) between the given word and the goal word.  This should never \\n                            # overestimate the distance to the goal word and should also maintain the triangle \\n                            # inequality for the graph (consistency). \\n                            # See Chapter 3 of \"Artificial Intelligence a Modern Approach\" for details.\\n                            # Compute the number of swaps between two words by doing a boolean comparision \\n                            # on each pair of letters and then using sum to caste the bools to ints.  \\n                            # E.g. if two words are neighbors, the sum should be 1.         \\n                            h = sum(map(operator.ne, nw, goal)) \\n                            # Add to the q\\n                            heapq.heappush(q, (child_depth+h, child_depth, h, nw))\\n            # No route to goal \\n            return 0\\n        \\n        # Get word length\\n        wl = len(beginWord)\\n        w_indexes = zip(range(wl), range(1, wl+1))\\n        # Preprocess the wordlist to make finding neighbors easy\\n        patterns2words = make_p2w(wordList, w_indexes)\\n        # Do the search\\n        return a_star(beginWord, endWord, w_indexes, patterns2words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 40943,
                "title": "accepted-java-solution-based-on-dijkstra-s-algorithm",
                "content": "I use a Dijkstra's algorithm for solving problem. Each node (vertex) is a word with neigbours of one letter difference. Distance between neigbour nodes is 1. Please see comments.\\n\\n    public int ladderLength(String start, String end, Set<String> dict) {\\n\\t\\t\\n\\t\\t// Init vertices\\n\\t\\tWordVertex startVertex = new WordVertex(start);\\n\\t\\tWordVertex endVertex = new WordVertex(end);\\n\\t\\tstartVertex.dist = 0;\\n\\t\\tList<WordVertex> vertices = new ArrayList<WordVertex>();\\n\\t\\tvertices.add(startVertex);\\n\\t\\tvertices.add(endVertex);\\n\\t\\tfor (String word:dict) {\\n\\t\\t\\tvertices.add(new WordVertex(word));\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Construct graph\\n\\t\\tfor(int i=0; i<vertices.size(); i++) {\\n\\t\\t\\tWordVertex vertex = vertices.get(i);\\n\\t\\t\\tfor(int j=i+1; j<vertices.size(); j++) {\\n\\t\\t\\t\\tWordVertex neighbor = vertices.get(j);\\n\\t\\t\\t\\tint diff = 0;\\n\\t\\t\\t\\tfor (int k=0; k<vertex.word.length(); k++) {\\n\\t\\t\\t\\t\\tif (vertex.word.charAt(k) != neighbor.word.charAt(k) && diff++ == 1) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (diff == 1) {\\n\\t\\t\\t\\t\\tvertex.neighbors.add(neighbor);\\n\\t\\t\\t\\t\\tneighbor.neighbors.add(vertex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Find shortest path. Dijkstra's algorithm.\\n\\t\\tPriorityQueue<WordVertex> queue = new PriorityQueue<WordVertex>();\\n\\t\\tfor (WordVertex v:vertices) {\\n\\t\\t\\tqueue.add(v);\\n\\t\\t}\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\tWordVertex v = queue.poll();\\n\\t\\t\\tif (v.dist == Integer.MAX_VALUE) continue;\\n\\t\\t\\tfor (WordVertex n:v.neighbors) {\\n\\t\\t\\t\\tif (!n.visited) {\\n\\t\\t\\t\\t\\tif (v.dist + 1 < n.dist) {\\n\\t\\t\\t\\t\\t\\tn.dist = v.dist + 1;\\n\\t\\t\\t\\t\\t\\tqueue.remove(n);\\n\\t\\t\\t\\t\\t\\tqueue.add(n);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv.visited = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn endVertex.dist == Integer.MAX_VALUE ? 0 : endVertex.dist + 1;\\n    }",
                "solutionTags": [],
                "code": "I use a Dijkstra's algorithm for solving problem. Each node (vertex) is a word with neigbours of one letter difference. Distance between neigbour nodes is 1. Please see comments.\\n\\n    public int ladderLength(String start, String end, Set<String> dict) {\\n\\t\\t\\n\\t\\t// Init vertices\\n\\t\\tWordVertex startVertex = new WordVertex(start);\\n\\t\\tWordVertex endVertex = new WordVertex(end);\\n\\t\\tstartVertex.dist = 0;\\n\\t\\tList<WordVertex> vertices = new ArrayList<WordVertex>();\\n\\t\\tvertices.add(startVertex);\\n\\t\\tvertices.add(endVertex);\\n\\t\\tfor (String word:dict) {\\n\\t\\t\\tvertices.add(new WordVertex(word));\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Construct graph\\n\\t\\tfor(int i=0; i<vertices.size(); i++) {\\n\\t\\t\\tWordVertex vertex = vertices.get(i);\\n\\t\\t\\tfor(int j=i+1; j<vertices.size(); j++) {\\n\\t\\t\\t\\tWordVertex neighbor = vertices.get(j);\\n\\t\\t\\t\\tint diff = 0;\\n\\t\\t\\t\\tfor (int k=0; k<vertex.word.length(); k++) {\\n\\t\\t\\t\\t\\tif (vertex.word.charAt(k) != neighbor.word.charAt(k) && diff++ == 1) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (diff == 1) {\\n\\t\\t\\t\\t\\tvertex.neighbors.add(neighbor);\\n\\t\\t\\t\\t\\tneighbor.neighbors.add(vertex);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Find shortest path. Dijkstra's algorithm.\\n\\t\\tPriorityQueue<WordVertex> queue = new PriorityQueue<WordVertex>();\\n\\t\\tfor (WordVertex v:vertices) {\\n\\t\\t\\tqueue.add(v);\\n\\t\\t}\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\tWordVertex v = queue.poll();\\n\\t\\t\\tif (v.dist == Integer.MAX_VALUE) continue;\\n\\t\\t\\tfor (WordVertex n:v.neighbors) {\\n\\t\\t\\t\\tif (!n.visited) {\\n\\t\\t\\t\\t\\tif (v.dist + 1 < n.dist) {\\n\\t\\t\\t\\t\\t\\tn.dist = v.dist + 1;\\n\\t\\t\\t\\t\\t\\tqueue.remove(n);\\n\\t\\t\\t\\t\\t\\tqueue.add(n);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv.visited = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn endVertex.dist == Integer.MAX_VALUE ? 0 : endVertex.dist + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2750155,
                "title": "java-if-you-are-getting-tle-and-even-if-you-don-t",
                "content": "so if you are having tle here are somethings you can try before jumping to the answer\\n1.try bfs,don\\'t use dfs you will just end up spending same intial path before which graph branch of multiple time and here goal isn\\'t to reach the goal is to reach efficiently, here it is explained more beautifully kudos for the visuals https://leetcode.com/problems/word-ladder/discuss/2634411/Here-is-Why-DP-DFS-fails-with-Memoization.-44th-test-case-failing.\\n2.use hashset it will do traversal in O(1)\\n3.actually you don\\'t need N^2 to make graph, here 26*x*K*x*N is much cheaper.\\n4.use stringbuilder or chararray for string manipulation.\\n5.the removal of word from set should be done as soon as word is added into queue,the word you are dealing with will come after a lot of word which already exist in the queue and some of those words might end up traversing it again and adding it again to the queue.\\n```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        HashSet<String> set=new HashSet<>();\\n        Queue<Pair> q=new LinkedList<>();\\n        for(int i=0;i<wordList.size();i++)set.add(wordList.get(i));\\n        // set.remove(beginWord); //don\\'t delay it to here.\\n        q.add(new Pair(beginWord,1));\\n        while(!q.isEmpty()){\\n            Pair p=q.poll();\\n            String word=p.str;\\n            set.remove(word);\\n            if(word.equals(endWord)) return p.price;\\n            if(word.length()!=beginWord.length()) continue;\\n            for(int i=0;i<word.length();i++){\\n                StringBuilder sb=new StringBuilder(word);\\n                for(int j=0;j<26;j++){\\n                    sb.setCharAt(i,(char)(97+j));\\n                    if(set.contains(sb.toString())){\\n                        set.remove(sb.toString());//implement right here.\\n                        q.add(new Pair(sb.toString(),p.price+1));\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        HashSet<String> set=new HashSet<>();\\n        Queue<Pair> q=new LinkedList<>();\\n        for(int i=0;i<wordList.size();i++)set.add(wordList.get(i));\\n        // set.remove(beginWord); //don\\'t delay it to here.\\n        q.add(new Pair(beginWord,1));\\n        while(!q.isEmpty()){\\n            Pair p=q.poll();\\n            String word=p.str;\\n            set.remove(word);\\n            if(word.equals(endWord)) return p.price;\\n            if(word.length()!=beginWord.length()) continue;\\n            for(int i=0;i<word.length();i++){\\n                StringBuilder sb=new StringBuilder(word);\\n                for(int j=0;j<26;j++){\\n                    sb.setCharAt(i,(char)(97+j));\\n                    if(set.contains(sb.toString())){\\n                        set.remove(sb.toString());//implement right here.\\n                        q.add(new Pair(sb.toString(),p.price+1));\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727609,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution { bool isAdj(string & a, string & b) {\\n        int diff = 0;\\n        \\n        for(int i = 0; i < a.length(); ++i) {\\n            if(a[i] != b[i]) {\\n                diff++;\\n            }\\n        }\\n        \\n        return diff == 1;\\n    }\\n    \\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string> & wordList) {\\n        \\n        wordList.insert(wordList.begin(), beginWord);\\n        \\n        int n = wordList.size();\\n        \\n        vector<vector<int>> adjList(n, vector<int>(0, 0));\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                if(isAdj(wordList[i], wordList[j])) {\\n                    adjList[i].push_back(j);\\n                    adjList[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        \\n        queue<int> queue;\\n        queue.push(0);\\n        \\n        int pathLen = 0;\\n    \\n        while(!queue.empty()) {\\n            \\n            int size = queue.size();\\n            \\n            pathLen++;\\n            \\n            for(int k = 0; k < size; k++) {\\n                \\n                int node = queue.front();\\n                queue.pop();\\n                \\n                if(visited[node])\\n                    continue;\\n                \\n                visited[node] = true;\\n                \\n                if(wordList[node] == endWord)\\n                    return pathLen;\\n                \\n                for(auto e : adjList[node]) {\\n                    if(visited[e])\\n                        continue;\\n    \\n                    queue.push(e);\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { bool isAdj(string & a, string & b) {\\n        int diff = 0;\\n        \\n        for(int i = 0; i < a.length(); ++i) {\\n            if(a[i] != b[i]) {\\n                diff++;\\n            }\\n        }\\n        \\n        return diff == 1;\\n    }\\n    \\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string> & wordList) {\\n        \\n        wordList.insert(wordList.begin(), beginWord);\\n        \\n        int n = wordList.size();\\n        \\n        vector<vector<int>> adjList(n, vector<int>(0, 0));\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                if(isAdj(wordList[i], wordList[j])) {\\n                    adjList[i].push_back(j);\\n                    adjList[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        \\n        queue<int> queue;\\n        queue.push(0);\\n        \\n        int pathLen = 0;\\n    \\n        while(!queue.empty()) {\\n            \\n            int size = queue.size();\\n            \\n            pathLen++;\\n            \\n            for(int k = 0; k < size; k++) {\\n                \\n                int node = queue.front();\\n                queue.pop();\\n                \\n                if(visited[node])\\n                    continue;\\n                \\n                visited[node] = true;\\n                \\n                if(wordList[node] == endWord)\\n                    return pathLen;\\n                \\n                for(auto e : adjList[node]) {\\n                    if(visited[e])\\n                        continue;\\n    \\n                    queue.push(e);\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558735,
                "title": "python-bfs-simple",
                "content": "```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        deq = collections.deque()\\n        bank = set(wordList)\\n        deq.append(beginWord)\\n        count = 0\\n        n = len(beginWord)\\n        while deq:\\n            for _ in range(len(deq)):\\n                cur_word = deq.popleft()\\n                if cur_word == endWord:\\n                    return count + 1\\n                for i in range(n):\\n                    for ch in [chr(ord(\\'a\\') + i) for i in range(26)]:\\n                        new_word = f\\'{cur_word[:i]}{ch}{cur_word[i + 1:]}\\'\\n                        if new_word in bank:\\n                            deq.append(new_word)\\n                            bank.discard(new_word)\\n            count += 1\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        deq = collections.deque()\\n        bank = set(wordList)\\n        deq.append(beginWord)\\n        count = 0\\n        n = len(beginWord)\\n        while deq:\\n            for _ in range(len(deq)):\\n                cur_word = deq.popleft()\\n                if cur_word == endWord:\\n                    return count + 1\\n                for i in range(n):\\n                    for ch in [chr(ord(\\'a\\') + i) for i in range(26)]:\\n                        new_word = f\\'{cur_word[:i]}{ch}{cur_word[i + 1:]}\\'\\n                        if new_word in bank:\\n                            deq.append(new_word)\\n                            bank.discard(new_word)\\n            count += 1\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2506114,
                "title": "python-solution-bfs-faster-than-94-solutions",
                "content": "**Runtime**: 138 ms, faster than **94.30%** of Python3 online submissions for Word Ladder.\\n**Memory Usage:** 17.4 MB, less than **58.37%** of Python3 online submissions for Word Ladder.\\n\\n**Solution**\\n\\n\\n\\tclass Solution:\\n\\t\\tdef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n\\t\\t\\tif endWord not in wordList:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tnei = collections.defaultdict(list)\\n\\t\\t\\twordList.append(beginWord)\\n\\n\\t\\t\\tfor word in wordList:\\n\\t\\t\\t\\tfor j in range(len(word)):\\n\\t\\t\\t\\t\\tpattern = word[:j] + \"*\" + word[j + 1:]\\n\\t\\t\\t\\t\\tnei[pattern].append(word)\\n\\n\\t\\t\\tvisit = set([beginWord])\\n\\t\\t\\tq = deque([beginWord])\\n\\t\\t\\tres = 1\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tfor i in range(len(q)):\\n\\t\\t\\t\\t\\tword = q.popleft()\\n\\t\\t\\t\\t\\tif word == endWord:\\n\\t\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\tfor j in range(len(word)):\\n\\t\\t\\t\\t\\t\\tpattern = word[:j] + \"*\" + word[j + 1:]\\n\\t\\t\\t\\t\\t\\tfor neiWord in nei[pattern]:\\n\\t\\t\\t\\t\\t\\t\\tif neiWord not in visit:\\n\\t\\t\\t\\t\\t\\t\\t\\tvisit.add(neiWord)\\n\\t\\t\\t\\t\\t\\t\\t\\tq.append(neiWord)\\n\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn 0\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "**Runtime**: 138 ms, faster than **94.30%** of Python3 online submissions for Word Ladder.\\n**Memory Usage:** 17.4 MB, less than **58.37%** of Python3 online submissions for Word Ladder.\\n\\n**Solution**\\n\\n\\n\\tclass Solution:\\n\\t\\tdef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n\\t\\t\\tif endWord not in wordList:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tnei = collections.defaultdict(list)\\n\\t\\t\\twordList.append(beginWord)\\n\\n\\t\\t\\tfor word in wordList:\\n\\t\\t\\t\\tfor j in range(len(word)):\\n\\t\\t\\t\\t\\tpattern = word[:j] + \"*\" + word[j + 1:]\\n\\t\\t\\t\\t\\tnei[pattern].append(word)\\n\\n\\t\\t\\tvisit = set([beginWord])\\n\\t\\t\\tq = deque([beginWord])\\n\\t\\t\\tres = 1\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tfor i in range(len(q)):\\n\\t\\t\\t\\t\\tword = q.popleft()\\n\\t\\t\\t\\t\\tif word == endWord:\\n\\t\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\tfor j in range(len(word)):\\n\\t\\t\\t\\t\\t\\tpattern = word[:j] + \"*\" + word[j + 1:]\\n\\t\\t\\t\\t\\t\\tfor neiWord in nei[pattern]:\\n\\t\\t\\t\\t\\t\\t\\tif neiWord not in visit:\\n\\t\\t\\t\\t\\t\\t\\t\\tvisit.add(neiWord)\\n\\t\\t\\t\\t\\t\\t\\t\\tq.append(neiWord)\\n\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 2488424,
                "title": "java-simple-readable-level-order-traversal",
                "content": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        if (beginWord == null && endWord == null && wordList.size() == 0)\\n            return 0;\\n        Map<String, List<String>> graph = new HashMap();\\n        List<String> words = new ArrayList();\\n        words.add(beginWord);\\n        words.addAll(wordList);\\n       \\n        for (String word : words) {\\n            graph.put(word, new ArrayList());\\n        }\\n        \\n        for (int i = 0; i<words.size()-1; i++) {\\n            for (int j = i+1; j<words.size(); j++) {\\n                String w1 = words.get(i);\\n                String w2 = words.get(j);\\n                if (isOneEditAway(w1, w2)) {\\n                    graph.get(w1).add(w2);\\n                    graph.get(w2).add(w1);\\n                }\\n            }\\n        }\\n        return levelOrderTraverse(graph, beginWord, endWord, new HashSet<String>());\\n    }\\n    \\n    private int levelOrderTraverse(Map<String, List<String>> graph, String s, String d, HashSet<String> visited) {\\n        LinkedList<String> q = new LinkedList();\\n        q.add(s);\\n        int level = 0;\\n        while(!q.isEmpty()) {\\n            level++;\\n            int size = q.size();\\n            for (int i = 0; i<size; i++) {\\n                String word = q.poll();\\n                if (visited.contains(word))\\n                    continue;\\n                visited.add(word);\\n                if (word.equals(d))\\n                    return level;\\n                for (String adj : graph.get(word))\\n                    if (!visited.contains(adj))\\n                        q.add(adj);\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    private boolean isOneEditAway(String w1, String w2) {\\n        boolean diffFound = false;\\n        for (int i = 0; i<Math.min(w1.length(), w2.length()); i++) {\\n            if (w1.charAt(i) != w2.charAt(i)) {\\n                if (diffFound) {\\n                    return false;\\n                } else {\\n                    diffFound = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        if (beginWord == null && endWord == null && wordList.size() == 0)\\n            return 0;\\n        Map<String, List<String>> graph = new HashMap();\\n        List<String> words = new ArrayList();\\n        words.add(beginWord);\\n        words.addAll(wordList);\\n       \\n        for (String word : words) {\\n            graph.put(word, new ArrayList());\\n        }\\n        \\n        for (int i = 0; i<words.size()-1; i++) {\\n            for (int j = i+1; j<words.size(); j++) {\\n                String w1 = words.get(i);\\n                String w2 = words.get(j);\\n                if (isOneEditAway(w1, w2)) {\\n                    graph.get(w1).add(w2);\\n                    graph.get(w2).add(w1);\\n                }\\n            }\\n        }\\n        return levelOrderTraverse(graph, beginWord, endWord, new HashSet<String>());\\n    }\\n    \\n    private int levelOrderTraverse(Map<String, List<String>> graph, String s, String d, HashSet<String> visited) {\\n        LinkedList<String> q = new LinkedList();\\n        q.add(s);\\n        int level = 0;\\n        while(!q.isEmpty()) {\\n            level++;\\n            int size = q.size();\\n            for (int i = 0; i<size; i++) {\\n                String word = q.poll();\\n                if (visited.contains(word))\\n                    continue;\\n                visited.add(word);\\n                if (word.equals(d))\\n                    return level;\\n                for (String adj : graph.get(word))\\n                    if (!visited.contains(adj))\\n                        q.add(adj);\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    private boolean isOneEditAway(String w1, String w2) {\\n        boolean diffFound = false;\\n        for (int i = 0; i<Math.min(w1.length(), w2.length()); i++) {\\n            if (w1.charAt(i) != w2.charAt(i)) {\\n                if (diffFound) {\\n                    return false;\\n                } else {\\n                    diffFound = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434625,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> wordSet = new HashSet(wordList);\\n        Queue<String>  q = new LinkedList<>();\\n        q.add(beginWord);\\n        int level = 1;\\n        while(!q.isEmpty()){\\n            int lsize = q.size();\\n            while(lsize-- > 0){\\n                String cur = q.remove();\\n                if(cur.equals(endWord)) return level;\\n                char word[] = cur.toCharArray();\\n                for(int i=0; i<word.length; i++){\\n                    for(char j=\\'a\\'; j<=\\'z\\'; j++){\\n                        word[i] = j;\\n                        String newWord = String.valueOf(word);\\n                        if(wordSet.contains(newWord)){\\n                            wordSet.remove(newWord);\\n                            q.add(newWord);\\n                        }\\n                        word[i] = cur.charAt(i);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    let wordSet = new Set(wordList)\\n    let  q = [beginWord]\\n    let level = 1\\n    while(q.length){\\n        let lsize = q.length\\n        while(lsize-- > 0){\\n            let word = q.shift()\\n            if(word === endWord)     return level\\n            for(let i=0; i<word.length; i++){\\n                for(let j=0; j<26; j++){\\n                    let newWord = word.slice(0, i) + String.fromCharCode(j+97) + word.slice(i+1)\\n                    if(wordSet.has(newWord)){\\n                        wordSet.delete(newWord);\\n                        q.push(newWord)\\n                    }\\n                }\\n            }\\n        }\\n        level++\\n    }\\n    return 0\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        wordSet = set(wordList)\\n        q = [beginWord]\\n        level = 1\\n        while q:\\n            lsize = len(q)\\n            for _ in range(lsize):\\n                word = q.pop(0)\\n                if word == endWord:\\n                    return level\\n                for i in range(len(word)):\\n                    for j in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        newWord = word[:i] + j + word[i+1:]\\n                        if newWord in wordSet:\\n                            wordSet.remove(newWord);\\n                            q.append(newWord)\\n            level += 1\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> wordSet = new HashSet(wordList);\\n        Queue<String>  q = new LinkedList<>();\\n        q.add(beginWord);\\n        int level = 1;\\n        while(!q.isEmpty()){\\n            int lsize = q.size();\\n            while(lsize-- > 0){\\n                String cur = q.remove();\\n                if(cur.equals(endWord)) return level;\\n                char word[] = cur.toCharArray();\\n                for(int i=0; i<word.length; i++){\\n                    for(char j=\\'a\\'; j<=\\'z\\'; j++){\\n                        word[i] = j;\\n                        String newWord = String.valueOf(word);\\n                        if(wordSet.contains(newWord)){\\n                            wordSet.remove(newWord);\\n                            q.add(newWord);\\n                        }\\n                        word[i] = cur.charAt(i);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    let wordSet = new Set(wordList)\\n    let  q = [beginWord]\\n    let level = 1\\n    while(q.length){\\n        let lsize = q.length\\n        while(lsize-- > 0){\\n            let word = q.shift()\\n            if(word === endWord)     return level\\n            for(let i=0; i<word.length; i++){\\n                for(let j=0; j<26; j++){\\n                    let newWord = word.slice(0, i) + String.fromCharCode(j+97) + word.slice(i+1)\\n                    if(wordSet.has(newWord)){\\n                        wordSet.delete(newWord);\\n                        q.push(newWord)\\n                    }\\n                }\\n            }\\n        }\\n        level++\\n    }\\n    return 0\\n};\\n```\n```\\nclass Solution(object):\\n    def ladderLength(self, beginWord, endWord, wordList):\\n        wordSet = set(wordList)\\n        q = [beginWord]\\n        level = 1\\n        while q:\\n            lsize = len(q)\\n            for _ in range(lsize):\\n                word = q.pop(0)\\n                if word == endWord:\\n                    return level\\n                for i in range(len(word)):\\n                    for j in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        newWord = word[:i] + j + word[i+1:]\\n                        if newWord in wordSet:\\n                            wordSet.remove(newWord);\\n                            q.append(newWord)\\n            level += 1\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395336,
                "title": "java-bfs-easy-understanding-solution-hashmap-set-queue",
                "content": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        if(wordList.size() == 0)  return 0;\\n        HashMap<String, List<String>> connection = new HashMap<>();\\n        wordList.add(beginWord);\\n        for(String s : wordList) {\\n            connection.put(s, new ArrayList<String>());\\n        }\\n        for(String s1 : wordList) {\\n            for(String s2 : wordList) {\\n                if(canTransform(s1,s2)){\\n                    connection.get(s1).add(s2);\\n                    connection.get(s2).add(s1);\\n                }\\n            }\\n        }\\n        Queue<String> queue = new LinkedList();\\n        queue.add(beginWord);\\n        int dist = 0;\\n        Set<String> visited = new HashSet();\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            dist++;\\n            for(int i=0;i<size;i++){\\n                String cur = queue.poll();\\n                if(cur.equals(endWord)) {\\n                    return dist;\\n                }\\n                for(String s : connection.get(cur)) {\\n                    if(!visited.contains(s)) {\\n                        visited.add(s);\\n                        queue.add(s);\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public boolean canTransform(String s1, String s2) {\\n        int count = 0;\\n        for(int i=0;i<s1.length();i++){\\n            if(s1.charAt(i) != s2.charAt(i)){\\n                count++;\\n            }\\n        }\\n        return count == 1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        if(wordList.size() == 0)  return 0;\\n        HashMap<String, List<String>> connection = new HashMap<>();\\n        wordList.add(beginWord);\\n        for(String s : wordList) {\\n            connection.put(s, new ArrayList<String>());\\n        }\\n        for(String s1 : wordList) {\\n            for(String s2 : wordList) {\\n                if(canTransform(s1,s2)){\\n                    connection.get(s1).add(s2);\\n                    connection.get(s2).add(s1);\\n                }\\n            }\\n        }\\n        Queue<String> queue = new LinkedList();\\n        queue.add(beginWord);\\n        int dist = 0;\\n        Set<String> visited = new HashSet();\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            dist++;\\n            for(int i=0;i<size;i++){\\n                String cur = queue.poll();\\n                if(cur.equals(endWord)) {\\n                    return dist;\\n                }\\n                for(String s : connection.get(cur)) {\\n                    if(!visited.contains(s)) {\\n                        visited.add(s);\\n                        queue.add(s);\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public boolean canTransform(String s1, String s2) {\\n        int count = 0;\\n        for(int i=0;i<s1.length();i++){\\n            if(s1.charAt(i) != s2.charAt(i)){\\n                count++;\\n            }\\n        }\\n        return count == 1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327912,
                "title": "c-easy-bfs-solution",
                "content": "\\n\\t\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> s(wordList.begin(),wordList.end());\\n        unordered_set<string> vis;\\n        queue<string> q;\\n        q.push(beginWord);\\n        vis.insert(beginWord);\\n        int count=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            count++;\\n            while(sz--){\\n                string str=q.front();\\n                q.pop();\\n                if(str==endWord)\\n                    return count;\\n                for(int i=0;i<str.length();i++){\\n                    string temp=str;\\n                    for(int j=0;j<26;j++){\\n                        temp[i]=\\'a\\'+ j;\\n                        if(s.find(temp)!=s.end() && vis.find(temp)==vis.end()){\\n                            q.push(temp);\\n                            vis.insert(temp);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return 0;\\n    }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "\\n\\t\\tint ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> s(wordList.begin(),wordList.end());\\n        unordered_set<string> vis;\\n        queue<string> q;\\n        q.push(beginWord);\\n        vis.insert(beginWord);\\n        int count=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            count++;\\n            while(sz--){\\n                string str=q.front();\\n                q.pop();\\n                if(str==endWord)\\n                    return count;\\n                for(int i=0;i<str.length();i++){\\n                    string temp=str;\\n                    for(int j=0;j<26;j++){\\n                        temp[i]=\\'a\\'+ j;\\n                        if(s.find(temp)!=s.end() && vis.find(temp)==vis.end()){\\n                            q.push(temp);\\n                            vis.insert(temp);\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1962684,
                "title": "simple-javascript-bfs-adjacency-list-iterative",
                "content": "Simple solution, create adjacency list like course schedule, include the starting word. Then initialize a stack with the beginning word. Use BFS as any word that have been visited do not need to be\\nvisited again (because part of the chain already, and since visited earlier, part of the better solution). Use counter to keep track of the length of the chain. Cheers!\\n\\n```\\nconst differs = (word1, word2) => {\\n    let diffCounter = 0;\\n    for (let i = 0; i < word1.length; i++) {\\n        if (word1[i] !== word2[i]) {\\n            diffCounter++;\\n        }\\n    }\\n    return diffCounter === 1;\\n}\\n\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    const adjList = {};\\n    for (let k of [...wordList, beginWord]) {\\n        adjList[k] = [];\\n        for (const nextWord of wordList) {\\n            if (differs(k, nextWord)) {\\n                adjList[k].push(nextWord);\\n            }\\n        }\\n    }\\n    \\n    let stack = [...adjList[beginWord]];\\n    let tmpStack = [];\\n    const visited = new Set();\\n    let counter = 1;\\n    while (stack.length) {\\n        const word = stack.pop();\\n        if (word === endWord) {\\n            return counter + 1;\\n        }\\n        if (!visited.has(word)) {\\n            visited.add(word);\\n            for (const k of adjList[word]) {\\n              if (!visited.has(k)) {\\n                  tmpStack.push(k);\\n              }   \\n            }\\n        }\\n        \\n       if (!stack.length) {\\n           stack = tmpStack;\\n           tmpStack = [];\\n           counter++;\\n       }\\n    }\\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst differs = (word1, word2) => {\\n    let diffCounter = 0;\\n    for (let i = 0; i < word1.length; i++) {\\n        if (word1[i] !== word2[i]) {\\n            diffCounter++;\\n        }\\n    }\\n    return diffCounter === 1;\\n}\\n\\nvar ladderLength = function(beginWord, endWord, wordList) {\\n    const adjList = {};\\n    for (let k of [...wordList, beginWord]) {\\n        adjList[k] = [];\\n        for (const nextWord of wordList) {\\n            if (differs(k, nextWord)) {\\n                adjList[k].push(nextWord);\\n            }\\n        }\\n    }\\n    \\n    let stack = [...adjList[beginWord]];\\n    let tmpStack = [];\\n    const visited = new Set();\\n    let counter = 1;\\n    while (stack.length) {\\n        const word = stack.pop();\\n        if (word === endWord) {\\n            return counter + 1;\\n        }\\n        if (!visited.has(word)) {\\n            visited.add(word);\\n            for (const k of adjList[word]) {\\n              if (!visited.has(k)) {\\n                  tmpStack.push(k);\\n              }   \\n            }\\n        }\\n        \\n       if (!stack.length) {\\n           stack = tmpStack;\\n           tmpStack = [];\\n           counter++;\\n       }\\n    }\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1923834,
                "title": "using-queue-unordered-set-c",
                "content": "Implementation\\n\\n**BFS Approach\\nUsing Queue & Unordered Set\\nTime Complexity = O(N * M * 26), Where N is the length of the wordList, M is the size of the word present into the wordList, and 26 means, from a to z we are running the loop\\nSpace Complexity = O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> st;\\n        \\n        for(auto word : wordList){\\n            st.insert(word);\\n        }\\n        \\n        if(st.find(endWord) == st.end()) return 0;\\n        \\n        int count = 0;\\n        queue<string> word;\\n        word.push(beginWord);\\n        \\n        while(!word.empty()){\\n            count++;\\n            int size = word.size();\\n            \\n            for(int i = 0; i < size; i++){\\n                string top = word.front();\\n                word.pop();\\n                \\n                for(int j = 0; j < top.size(); j++){\\n                    char ch = top[j];\\n                    \\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        top[j] = c;\\n                        \\n                        if(top == endWord) return count+1;\\n                        if(st.find(top) == st.end()) continue;\\n                        \\n                        st.erase(top);\\n                        word.push(top);\\n                    }\\n                    top[j] = ch;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> st;\\n        \\n        for(auto word : wordList){\\n            st.insert(word);\\n        }\\n        \\n        if(st.find(endWord) == st.end()) return 0;\\n        \\n        int count = 0;\\n        queue<string> word;\\n        word.push(beginWord);\\n        \\n        while(!word.empty()){\\n            count++;\\n            int size = word.size();\\n            \\n            for(int i = 0; i < size; i++){\\n                string top = word.front();\\n                word.pop();\\n                \\n                for(int j = 0; j < top.size(); j++){\\n                    char ch = top[j];\\n                    \\n                    for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                        top[j] = c;\\n                        \\n                        if(top == endWord) return count+1;\\n                        if(st.find(top) == st.end()) continue;\\n                        \\n                        st.erase(top);\\n                        word.push(top);\\n                    }\\n                    top[j] = ch;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815276,
                "title": "go-bfs-simple-doesn-t-use",
                "content": "```\\nfunc ladderLength(beginWord string, endWord string, wordList []string) int {\\n    if len(wordList) == 0 {\\n        return 0\\n    }\\n    \\n    mp := make(map[string]bool)\\n    \\n    for _, w := range wordList {\\n        mp[w] = true\\n    }\\n    \\n    \\n    findInMap := func(str string) bool {\\n        _, ok := mp[str]\\n        return ok\\n    }\\n    \\n    queue := make([]string, 0)\\n    \\n    queue = append(queue, beginWord)\\n    \\n    steps := 0\\n\\n    for len(queue) > 0 {\\n        for _, q := range queue {\\n            w := q\\n            if w == endWord {\\n                return steps + 1\\n            }\\n            for i:=0; i<len(w); i++ {\\n                for ch:=\\'a\\'; ch<=\\'z\\'; ch++ {\\n                    ww := w[:i] + string(ch) + w[i+1:]\\n                    if findInMap(ww) {\\n                        queue = append(queue, ww)\\n                        delete(mp, ww)\\n                    }\\n                }\\n            }\\n            queue = queue[1:]\\n        }\\n        steps++\\n    }\\n    \\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc ladderLength(beginWord string, endWord string, wordList []string) int {\\n    if len(wordList) == 0 {\\n        return 0\\n    }\\n    \\n    mp := make(map[string]bool)\\n    \\n    for _, w := range wordList {\\n        mp[w] = true\\n    }\\n    \\n    \\n    findInMap := func(str string) bool {\\n        _, ok := mp[str]\\n        return ok\\n    }\\n    \\n    queue := make([]string, 0)\\n    \\n    queue = append(queue, beginWord)\\n    \\n    steps := 0\\n\\n    for len(queue) > 0 {\\n        for _, q := range queue {\\n            w := q\\n            if w == endWord {\\n                return steps + 1\\n            }\\n            for i:=0; i<len(w); i++ {\\n                for ch:=\\'a\\'; ch<=\\'z\\'; ch++ {\\n                    ww := w[:i] + string(ch) + w[i+1:]\\n                    if findInMap(ww) {\\n                        queue = append(queue, ww)\\n                        delete(mp, ww)\\n                    }\\n                }\\n            }\\n            queue = queue[1:]\\n        }\\n        steps++\\n    }\\n    \\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767673,
                "title": "python-bfs-adjacency-mapping-thinking-process-diagram",
                "content": "First, create an adjacency mapping for each word in the `wordList`. What that means is, for each word, what are other words in the wordList that it can go just by swapping one character. If the word is \"dog\", \\nThere are three places where characters can be swapped\\n\\n1) First character -> (*)og\\n2) Second character -> d(*)g\\n3) Third character -> do(*)\\n\\nOur adjacency mapping maps these patterns to words in the `wordList`\\n\\nFor example, if we have, `beginWord` dig, `endWord` doc and `wordList` [dog, cat, dig, cot, hog, dot, doc, rat, bat, cap, car], the adjacency mapping will be:\\n       \\n       {\"*og\": [\\'dog\\', \\'hog\\'],\\n         \"d*g\": [\\'dog\\', \\'dig\\'],\\n         \"do*\": [\\'dog\\', \\'dot\\', \\'doc\\'],\\n         \"*at\": [\\'cat\\', \\'rat\\', \\'bat\\'],\\n         \"c*t\": [\\'cat\\', \\'cot\\'],          \\n         \"ca*\": [\\'cat\\', \\'cap\\', \\'car\\'],\\n         \"*ig\": [\\'dig\\'],\\n         \"di*\": [\\'dig\\'],\\n         \"*ot\": [\\'cot\\', \\'dot\\'],\\n         \"co*\": [\\'cot\\'],\\n         \"h*g\": [\\'hog\\'],\\n         \"ho*\": [\\'hog\\'],\\n         \"d*t\": [\\'dot\\'],\\n         \"*oc\": [\\'doc\\'],\\n         \"d*c\": [\\'doc\\'],\\n         \"r*t\": [\\'rat\\'],\\n         \"ra*\": [\\'rat\\'],\\n         \"b*t\": [\\'bat\\'],\\n         \"ba*\": [\\'bat\\'],\\n         \"*ap\": [\\'cap\\'],\\n         \"c*p\": [\\'cap\\'],\\n         \"*ar\": [\\'car\\'],\\n         \"c*r\": [\\'car\\']\\n        }\\n \\nHaving this mapping, we just need to check whether a character for the current word can be swapped to get to `endWord`. So, we try to swap every possible character position in the current word and look up the value in our adjacency mapping. We do that for each word in the adjacency mapping until we find the `endWord`. If we encounter `endWord` while checking for words in adjacency mapping, we can return the 1+level at which we are in. If we have exhausted everything, it is sure that we have not found the word and we can return 0.\\n\\nA visual progression of search using this adajacency mapping is as follows:\\n![image](https://assets.leetcode.com/users/images/35e2d76f-4d60-47aa-bca8-0562d411fe5d_1644740424.6723948.png)\\n\\n**It appears that the image is compressed and looks quite bad, look here for high res image https://github.com/ArkAung/code4fun/blob/main/assets/word_ladder/visual.png**\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        if endWord not in wordList:  # O(n)\\n            return 0\\n        if endWord == beginWord:\\n            return 1\\n\\n        L = len(beginWord)\\n\\n        # Build adjacency mapping\\n        all_combo_dict = defaultdict(list)\\n        for word in wordList:  # O(n)\\n            for i in range(L):  # O(m)\\n                all_combo_dict[word[:i] + \"*\" + word[i + 1 :]].append(\\n                    word\\n                )  # Substring operation O(m)\\n        # Overall runtime: O(m^2 * n)\\n\\n        level = 1\\n        # Push to BFS queue with beginWord so that we can start the ball rolling\\n        queue = deque([(beginWord, level)])\\n\\n        # Push words which we can encountered to hash set so that we don\\'t need to process\\n        # the word which we have already seen we can have this luxury since we are doing BFS \\n        # and if we are looking at the previouly looked word, we are sure that it cannot lead\\n        # to a shorter path than then path which we have taken before\\n        seen_words = set([beginWord])\\n\\n        while queue:  # This will be exhausted when we have completed our BFS tree\\n            currentWord, level = queue.popleft()\\n            for i in range(L): # O(m)\\n                # For each character index of the currentWord, we want to check\\n                # whether one of the adjacent words is the end word\\n                # So, we iterate through all adjacent words to check for that\\n                # If an adjacent word is not the end word, we will continue doing the same for\\n                # words mapped in adjacency mapping. Therefore, we push to the queue so they will\\n                # be processed afterwards\\n\\n                intermediate_word = currentWord[:i] + \"*\" + currentWord[i + 1 :] # O(m)\\n                for word in all_combo_dict[intermediate_word]: # O(n)\\n                    if word == endWord:\\n                        return level + 1\\n                    if word not in seen_words:\\n                        queue.append((word, level + 1))\\n                        seen_words.add(word)\\n\\n        return 0\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        if endWord not in wordList:  # O(n)\\n            return 0\\n        if endWord == beginWord:\\n            return 1\\n\\n        L = len(beginWord)\\n\\n        # Build adjacency mapping\\n        all_combo_dict = defaultdict(list)\\n        for word in wordList:  # O(n)\\n            for i in range(L):  # O(m)\\n                all_combo_dict[word[:i] + \"*\" + word[i + 1 :]].append(\\n                    word\\n                )  # Substring operation O(m)\\n        # Overall runtime: O(m^2 * n)\\n\\n        level = 1\\n        # Push to BFS queue with beginWord so that we can start the ball rolling\\n        queue = deque([(beginWord, level)])\\n\\n        # Push words which we can encountered to hash set so that we don\\'t need to process\\n        # the word which we have already seen we can have this luxury since we are doing BFS \\n        # and if we are looking at the previouly looked word, we are sure that it cannot lead\\n        # to a shorter path than then path which we have taken before\\n        seen_words = set([beginWord])\\n\\n        while queue:  # This will be exhausted when we have completed our BFS tree\\n            currentWord, level = queue.popleft()\\n            for i in range(L): # O(m)\\n                # For each character index of the currentWord, we want to check\\n                # whether one of the adjacent words is the end word\\n                # So, we iterate through all adjacent words to check for that\\n                # If an adjacent word is not the end word, we will continue doing the same for\\n                # words mapped in adjacency mapping. Therefore, we push to the queue so they will\\n                # be processed afterwards\\n\\n                intermediate_word = currentWord[:i] + \"*\" + currentWord[i + 1 :] # O(m)\\n                for word in all_combo_dict[intermediate_word]: # O(n)\\n                    if word == endWord:\\n                        return level + 1\\n                    if word not in seen_words:\\n                        queue.append((word, level + 1))\\n                        seen_words.add(word)\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765920,
                "title": "c-easy-to-understand-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint helper(string start,string end,unordered_set<string> &st){\\n\\t\\t\\t  queue<pair<string,int>> q;\\n\\t\\t\\t  q.push({start,1});  //current string and length \\n\\t\\t\\t  while(!q.empty()){\\n\\t\\t\\t\\t  int n=q.size();\\n\\t\\t\\t\\t  while(n--)\\n\\t\\t\\t\\t  {\\n\\t\\t\\t\\t\\t  string temp=q.front().first;\\n\\t\\t\\t\\t\\t  int len=q.front().second;\\n\\t\\t\\t\\t\\t  q.pop();\\n\\t\\t\\t\\t\\t  if(temp==end) return len; \\n\\t\\t\\t\\t\\t  for(int j=0;j<temp.length();j++){\\n\\t\\t\\t\\t\\t\\t\\tstring curr=temp;\\n\\t\\t\\t\\t\\t\\t  for(int i=0;i<26;i++){\\n\\t\\t\\t\\t\\t\\t\\t  curr[j]=i+\\'a\\';\\n\\t\\t\\t\\t\\t\\t\\t  // cout<<curr<<\" \";\\n\\t\\t\\t\\t\\t\\t\\t  if(curr!=temp && st.find(curr)!=st.end()){ \\n\\t\\t\\t\\t\\t\\t\\t\\t   q.push({curr,len+1});\\n\\t\\t\\t\\t\\t\\t\\t\\t  st.erase(curr);\\n\\t\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t  }\\n\\t\\t\\t  }\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint ladderLength(string start, string end, vector<string>& wordList) {\\n\\t\\t\\t unordered_set<string> st;\\n\\t\\t\\t for(auto &word: wordList) st.insert(word); //for making searching faster\\n\\t\\t\\t if(st.find(end)==st.end()) return 0;\\n\\n\\t\\t\\t return helper(start,end,st);\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint helper(string start,string end,unordered_set<string> &st){\\n\\t\\t\\t  queue<pair<string,int>> q;\\n\\t\\t\\t  q.push({start,1}",
                "codeTag": "Java"
            },
            {
                "id": 1765219,
                "title": "easy-c-solution-bfs-queue-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string begin, string end, vector<string>& words) {\\n        unordered_set <string> wordset;     //because it takes O(1) to find and erase\\n        bool present=false;            //to check whether end is present in words or not\\n        for(auto wo:words){\\n            if(end == wo)              //if found, make it true\\n                present=true;\\n            wordset.insert(wo);        //simultaneously adding words into wordset\\n        }\\n        if(!present)\\n            return 0;                  //if not present, return that no such sequence exists\\n        \\n        queue <string> q;              //to store the next word to be processed \\n        q.push(begin);                 //starting with begin\\n        int depth=0;\\n        while(!q.empty()){             //while queue is not empty\\n            depth++;                   //to get how many words did we move\\n            int level=q.size();        //to know that for how many next words - we can go on loop\\n            \\n            while(level--){\\n                string word = q.front();\\n                q.pop();\\n                for(int i=0; i<word.length(); i++){\\n                    string temp = word;     \\n                    for(char t=\\'a\\'; t<=\\'z\\'; t++){\\n                        temp[i]=t;      //substituting each letter in word with another letter\\n\\n                        if(temp == word)\\n                            continue;\\n                        \\n                        if(temp == end) //if end is found - return answer\\n                            return depth+1;\\n\\n                        if(wordset.find(temp)!=wordset.end()){  //if modified word is present in wordset, put it queue to be processed\\n                            q.push(temp);\\n                            wordset.erase(temp);                //removing from wordset\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string begin, string end, vector<string>& words) {\\n        unordered_set <string> wordset;     //because it takes O(1) to find and erase\\n        bool present=false;            //to check whether end is present in words or not\\n        for(auto wo:words){\\n            if(end == wo)              //if found, make it true\\n                present=true;\\n            wordset.insert(wo);        //simultaneously adding words into wordset\\n        }\\n        if(!present)\\n            return 0;                  //if not present, return that no such sequence exists\\n        \\n        queue <string> q;              //to store the next word to be processed \\n        q.push(begin);                 //starting with begin\\n        int depth=0;\\n        while(!q.empty()){             //while queue is not empty\\n            depth++;                   //to get how many words did we move\\n            int level=q.size();        //to know that for how many next words - we can go on loop\\n            \\n            while(level--){\\n                string word = q.front();\\n                q.pop();\\n                for(int i=0; i<word.length(); i++){\\n                    string temp = word;     \\n                    for(char t=\\'a\\'; t<=\\'z\\'; t++){\\n                        temp[i]=t;      //substituting each letter in word with another letter\\n\\n                        if(temp == word)\\n                            continue;\\n                        \\n                        if(temp == end) //if end is found - return answer\\n                            return depth+1;\\n\\n                        if(wordset.find(temp)!=wordset.end()){  //if modified word is present in wordset, put it queue to be processed\\n                            q.push(temp);\\n                            wordset.erase(temp);                //removing from wordset\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765037,
                "title": "js-set-queue",
                "content": "```\\n\\nconst ladderLength = function(beginWord, endWord, wordList) {\\n    let wordSet = new Set(wordList);\\n    let queue = [];\\n    queue.push({word: beginWord, pathLen: 1});\\n    while (queue.length > 0) {\\n        let {word, pathLen} = queue.shift();\\n        if (word === endWord) {  \\n            return pathLen;\\n        }\\n        for (let i = 0; i < word.length; i++) {  \\n            let prefix = word.substring(0,i);\\n            let suffix = word.substring(i+1);\\n            for (let i = 0; i < 26; i++) {\\n                let newStr = prefix + String.fromCharCode(97+i) + suffix;\\n                if (wordSet.has(newStr)) {  \\n                    queue.push({word: newStr, pathLen: pathLen+1});\\n                    wordSet.delete(newStr);  \\n                }\\n            }\\n        }\\n    }\\n    return 0;  \\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst ladderLength = function(beginWord, endWord, wordList) {\\n    let wordSet = new Set(wordList);\\n    let queue = [];\\n    queue.push({word: beginWord, pathLen: 1});\\n    while (queue.length > 0) {\\n        let {word, pathLen} = queue.shift();\\n        if (word === endWord) {  \\n            return pathLen;\\n        }\\n        for (let i = 0; i < word.length; i++) {  \\n            let prefix = word.substring(0,i);\\n            let suffix = word.substring(i+1);\\n            for (let i = 0; i < 26; i++) {\\n                let newStr = prefix + String.fromCharCode(97+i) + suffix;\\n                if (wordSet.has(newStr)) {  \\n                    queue.push({word: newStr, pathLen: pathLen+1});\\n                    wordSet.delete(newStr);  \\n                }\\n            }\\n        }\\n    }\\n    return 0;  \\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764726,
                "title": "java-easy-bfs-explained",
                "content": "**Idea:**\\n* The key idea here is to realize that by changing 1 letter of a word if you can get another word then they\\'re neighbors\\n* Using this you can enumerate all the possible neighbors of a word and check if any of them are in the provided list\\n\\t* If yes then make that word a neighbor of current word\\n* So this essentially reduces to finding the shortest distance from `start` to `end`, which is a trivial problem solvable using BFS\\n* If the end-word is not in the wordList then transformation isn\\'t possible so return 0\\n* Be sure not to visit a word twice. This can be done either by maintaining a visited set or removing the word from the adjacency list\\n\\n**Examples:**\\n1. hit \\u2192 hot \\u2192 lot \\u2192 log \\u2192 cog or hit \\u2192 hot \\u2192 dot \\u2192 dog \\u2192 cog\\n2. cog doesn\\'t exist in wordList, so ladder length = 0\\n\\n![image](https://assets.leetcode.com/users/images/0434d578-05f5-4021-a417-d3b5b202b219_1644661451.5558207.png)\\n\\n**T/S:** O(m\\xB2n)/O(m\\xB2n), where m = size(beginWord), n = size(wordList)\\n```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\tvar words = new HashSet<>(wordList);\\n\\tif (!words.contains(endWord))\\n\\t\\treturn 0;\\n\\t\\t\\n\\tvar adjList = getAdjList(beginWord, words);\\n\\tvar q = new ArrayDeque<>(List.of(beginWord));\\n\\tvar length = 0;\\n\\n\\twhile (!q.isEmpty()) {\\n\\t\\tlength++;\\n\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar word = q.poll();\\n\\n\\t\\t\\tfor (var neighbor : adjList.getOrDefault(word, List.of())) {\\n\\t\\t\\t\\tif (neighbor.equals(endWord))\\n\\t\\t\\t\\t\\treturn length + 1;\\n\\t\\t\\t\\tq.add(neighbor);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// remove the processed word to avoid circular loop\\n\\t\\t\\tadjList.remove(word);\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n/**\\n * Two words are neighbors if they differ by exactly 1 letter\\n *\\n * @param beginWord source word\\n * @param words set of words\\n * @return adjacency list of the graph representation of the words and their neighbors\\n */\\nprivate Map<String, List<String>> getAdjList(String beginWord, Set<String> words) {\\n\\tvar adjList = new HashMap<String, List<String>>();\\n\\tpopulateAdjList(words, adjList, beginWord);\\n\\tfor (var word : words)\\n\\t\\tpopulateAdjList(words, adjList, word);\\n\\treturn adjList;\\n}\\n\\n/**\\n * Populate the adjacency list with the neighbors of the current word\\n * \\n * @param words set of words\\n * @param adjList adjacency list of the graph\\n * @param word current node\\n */\\nprivate void populateAdjList(Set<String> words, Map<String, List<String>> adjList, String word) {\\n\\tvar wordArr = word.toCharArray();\\n\\n\\tfor (var i = 0; i < wordArr.length; i++) {\\n\\t\\tfor (var j = \\'a\\'; j <= \\'z\\'; j++) {\\n\\t\\t\\t// if letter is the same as original, skip it. e.g. don\\'t change hot to hot, when j = h\\n\\t\\t\\tif (word.charAt(i) == j)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n\\t\\t\\t// change one letter at a time\\n\\t\\t\\twordArr[i] = j;\\n\\t\\t\\t\\n\\t\\t\\tvar neighbor = new String(wordArr);\\n\\t\\t\\tif (words.contains(neighbor))\\n\\t\\t\\t\\tadjList.computeIfAbsent(word, k -> new ArrayList<>()).add(neighbor);\\n\\t\\t}\\n\\n\\t\\t// restore the original letter\\n\\t\\twordArr[i] = word.charAt(i);\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n\\tvar words = new HashSet<>(wordList);\\n\\tif (!words.contains(endWord))\\n\\t\\treturn 0;\\n\\t\\t\\n\\tvar adjList = getAdjList(beginWord, words);\\n\\tvar q = new ArrayDeque<>(List.of(beginWord));\\n\\tvar length = 0;\\n\\n\\twhile (!q.isEmpty()) {\\n\\t\\tlength++;\\n\\n\\t\\tfor (var i = q.size(); i > 0; i--) {\\n\\t\\t\\tvar word = q.poll();\\n\\n\\t\\t\\tfor (var neighbor : adjList.getOrDefault(word, List.of())) {\\n\\t\\t\\t\\tif (neighbor.equals(endWord))\\n\\t\\t\\t\\t\\treturn length + 1;\\n\\t\\t\\t\\tq.add(neighbor);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// remove the processed word to avoid circular loop\\n\\t\\t\\tadjList.remove(word);\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n/**\\n * Two words are neighbors if they differ by exactly 1 letter\\n *\\n * @param beginWord source word\\n * @param words set of words\\n * @return adjacency list of the graph representation of the words and their neighbors\\n */\\nprivate Map<String, List<String>> getAdjList(String beginWord, Set<String> words) {\\n\\tvar adjList = new HashMap<String, List<String>>();\\n\\tpopulateAdjList(words, adjList, beginWord);\\n\\tfor (var word : words)\\n\\t\\tpopulateAdjList(words, adjList, word);\\n\\treturn adjList;\\n}\\n\\n/**\\n * Populate the adjacency list with the neighbors of the current word\\n * \\n * @param words set of words\\n * @param adjList adjacency list of the graph\\n * @param word current node\\n */\\nprivate void populateAdjList(Set<String> words, Map<String, List<String>> adjList, String word) {\\n\\tvar wordArr = word.toCharArray();\\n\\n\\tfor (var i = 0; i < wordArr.length; i++) {\\n\\t\\tfor (var j = \\'a\\'; j <= \\'z\\'; j++) {\\n\\t\\t\\t// if letter is the same as original, skip it. e.g. don\\'t change hot to hot, when j = h\\n\\t\\t\\tif (word.charAt(i) == j)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\n\\t\\t\\t// change one letter at a time\\n\\t\\t\\twordArr[i] = j;\\n\\t\\t\\t\\n\\t\\t\\tvar neighbor = new String(wordArr);\\n\\t\\t\\tif (words.contains(neighbor))\\n\\t\\t\\t\\tadjList.computeIfAbsent(word, k -> new ArrayList<>()).add(neighbor);\\n\\t\\t}\\n\\n\\t\\t// restore the original letter\\n\\t\\twordArr[i] = word.charAt(i);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1512898,
                "title": "i-don-t-understand-this-test-case",
                "content": "```\\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n```\\nI keep getting expected output is 3. Shouldn\\'t is be 2?",
                "solutionTags": [],
                "code": "```\\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355091,
                "title": "easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/3d918ce1-fad6-4460-82b9-05cb0eebcdc0_1626962077.9850569.png)\\n\\n```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> word=new HashSet(wordList);//it will be easy to check if wordlist contains that word\\n        Queue<String> q=new LinkedList<>();\\n        Set<String> visited=new HashSet<>();//to keep track of visited words;\\n        q.add(beginWord);\\n        visited.add(beginWord);\\n        \\n        int level=0;\\n        while(!q.isEmpty())\\n        {\\n            for(int i=q.size();i>0;i--)\\n            {\\n                String curr_word=q.poll();\\n                if(curr_word.equals(endWord))\\n                    return level+1;\\n                \\n                char[] c=curr_word.toCharArray();\\n                for(int j=0;j<c.length;j++)//to replace every character of that word and check if it is present in wordlist\\n                {\\n                   char temp=c[j];\\n                   for(char ch=\\'a\\'; ch<=\\'z\\'; ch++)\\n                   {\\n                       c[j]=ch;\\n                       String word_formed=String.valueOf(c);//if this newly formed word isnt visited and also present in the wordlist add it to the queue\\n                       if(!visited.contains(word_formed) && word.contains(word_formed))\\n                       {\\n                           q.add(word_formed);\\n                           visited.add(word_formed);\\n                       }\\n                   }\\n                    c[j]=temp;\\n                }\\n            }\\n            \\n            level++;//moving to the next level\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Set<String> word=new HashSet(wordList);//it will be easy to check if wordlist contains that word\\n        Queue<String> q=new LinkedList<>();\\n        Set<String> visited=new HashSet<>();//to keep track of visited words;\\n        q.add(beginWord);\\n        visited.add(beginWord);\\n        \\n        int level=0;\\n        while(!q.isEmpty())\\n        {\\n            for(int i=q.size();i>0;i--)\\n            {\\n                String curr_word=q.poll();\\n                if(curr_word.equals(endWord))\\n                    return level+1;\\n                \\n                char[] c=curr_word.toCharArray();\\n                for(int j=0;j<c.length;j++)//to replace every character of that word and check if it is present in wordlist\\n                {\\n                   char temp=c[j];\\n                   for(char ch=\\'a\\'; ch<=\\'z\\'; ch++)\\n                   {\\n                       c[j]=ch;\\n                       String word_formed=String.valueOf(c);//if this newly formed word isnt visited and also present in the wordlist add it to the queue\\n                       if(!visited.contains(word_formed) && word.contains(word_formed))\\n                       {\\n                           q.add(word_formed);\\n                           visited.add(word_formed);\\n                       }\\n                   }\\n                    c[j]=temp;\\n                }\\n            }\\n            \\n            level++;//moving to the next level\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340754,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        Set<String> wordSet = new HashSet<>(wordList);\\n        if(!wordList.contains(endWord)) {\\n            return 0;\\n        }\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(beginWord);\\n       \\n        int depth = 0;\\n      \\n        while(!queue.isEmpty()) {\\n            depth ++;\\n            int size = queue.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                String currWord = queue.poll();\\n                char[] wordArr = currWord.toCharArray();\\n                \\n                //Generate all possibilites of the current word by replacing each letter\\n                for(int index = 0; index < wordArr.length; index ++) {\\n                    \\n                    for(char alpha = \\'a\\'; alpha <= \\'z\\'; alpha ++) {\\n                        \\n                        wordArr[index] = alpha;\\n                        String word = String.valueOf(wordArr);\\n                        \\n                        if(word.equals(currWord))\\n                            continue;\\n                        \\n                        // Since its BFS, we will arrive to the shortest path first\\n                        // Hence we can return\\n                        if(word.equals(endWord)) {\\n                            return depth+1;\\n                        }\\n                        \\n                        if(wordSet.contains(word)) {\\n                            wordSet.remove(word);\\n                            queue.offer(word);\\n                        }\\n                    }\\n                    \\n                    //Replace the character back to its original\\n                    wordArr[index] = currWord.charAt(index); \\n                }\\n            }\\n        } //End of while\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        Set<String> wordSet = new HashSet<>(wordList);\\n        if(!wordList.contains(endWord)) {\\n            return 0;\\n        }\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(beginWord);\\n       \\n        int depth = 0;\\n      \\n        while(!queue.isEmpty()) {\\n            depth ++;\\n            int size = queue.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                String currWord = queue.poll();\\n                char[] wordArr = currWord.toCharArray();\\n                \\n                //Generate all possibilites of the current word by replacing each letter\\n                for(int index = 0; index < wordArr.length; index ++) {\\n                    \\n                    for(char alpha = \\'a\\'; alpha <= \\'z\\'; alpha ++) {\\n                        \\n                        wordArr[index] = alpha;\\n                        String word = String.valueOf(wordArr);\\n                        \\n                        if(word.equals(currWord))\\n                            continue;\\n                        \\n                        // Since its BFS, we will arrive to the shortest path first\\n                        // Hence we can return\\n                        if(word.equals(endWord)) {\\n                            return depth+1;\\n                        }\\n                        \\n                        if(wordSet.contains(word)) {\\n                            wordSet.remove(word);\\n                            queue.offer(word);\\n                        }\\n                    }\\n                    \\n                    //Replace the character back to its original\\n                    wordArr[index] = currWord.charAt(index); \\n                }\\n            }\\n        } //End of while\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306452,
                "title": "c-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> hash(wordList.begin(), wordList.end());\\n        if(hash.find(endWord) == hash.end()) return 0;      //if the end word is not present int the wordlist return 0\\n        \\n        queue<string> q;\\n        q.push(beginWord);\\n        int shortest_transformation = 0;\\n        \\n        while(!q.empty()) {\\n           int size = q.size();\\n            \\n            for(int i = 0; i<size; i++) {\\n                string curr_word = q.front();\\n                q.pop();\\n\\n                //when we find the endword return the shortest transformation count\\n                if(curr_word == endWord) return shortest_transformation + 1;       \\n                \\n\\n                for(int i = 0; i<curr_word.size(); i++) {               // this loop will convert the word\\n                    string new_word = curr_word;\\n                    for(char letter = \\'a\\'; letter <= \\'z\\'; letter++) {\\n                        new_word[i] = letter;       \\n\\t\\t\\t\\t\\t\\t\\n                        /*\\n                        for every index, it will choose a new character & make a new word and if it is present in the hash set, then we \\n                        push it in the queue and erase it from the hashset\\n                        */\\n\\t\\t\\t\\t\\t\\t\\n                        if(hash.find(new_word) != hash.end() and curr_word != new_word )             \\n                            q.push(new_word);\\n                            hash.erase(new_word);\\n                    }\\n                } \\n                \\n            }\\n            \\n            ++shortest_transformation;\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        unordered_set<string> hash(wordList.begin(), wordList.end());\\n        if(hash.find(endWord) == hash.end()) return 0;      //if the end word is not present int the wordlist return 0\\n        \\n        queue<string> q;\\n        q.push(beginWord);\\n        int shortest_transformation = 0;\\n        \\n        while(!q.empty()) {\\n           int size = q.size();\\n            \\n            for(int i = 0; i<size; i++) {\\n                string curr_word = q.front();\\n                q.pop();\\n\\n                //when we find the endword return the shortest transformation count\\n                if(curr_word == endWord) return shortest_transformation + 1;       \\n                \\n\\n                for(int i = 0; i<curr_word.size(); i++) {               // this loop will convert the word\\n                    string new_word = curr_word;\\n                    for(char letter = \\'a\\'; letter <= \\'z\\'; letter++) {\\n                        new_word[i] = letter;       \\n\\t\\t\\t\\t\\t\\t\\n                        /*\\n                        for every index, it will choose a new character & make a new word and if it is present in the hash set, then we \\n                        push it in the queue and erase it from the hashset\\n                        */\\n\\t\\t\\t\\t\\t\\t\\n                        if(hash.find(new_word) != hash.end() and curr_word != new_word )             \\n                            q.push(new_word);\\n                            hash.erase(new_word);\\n                    }\\n                } \\n                \\n            }\\n            \\n            ++shortest_transformation;\\n            \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295826,
                "title": "java-bfs-easy-solution",
                "content": "**Do vote up if you like it :)**\\n\\nUsing HashMap\\n```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        if(!wordList.contains(endWord))\\n            return 0;\\n        \\n        HashMap<String, Boolean> visitedMap = new HashMap<String, Boolean>();\\n        for(String s : wordList){\\n            visitedMap.put(s, false);\\n        }\\n        \\n        Queue<String> queue = new LinkedList<String>();\\n        queue.offer(beginWord);\\n        visitedMap.put(beginWord, true);\\n        int level = 1;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                String currString = queue.poll();\\n                \\n                for(int i = 0; i < currString.length(); i++){\\n                    char[] word = currString.toCharArray();\\n                    for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                        word[i] = ch;\\n                        String neighString = String.valueOf(word);\\n                        if(neighString.equals(endWord)){\\n                            return level + 1;\\n                        }\\n                        if(visitedMap.containsKey(neighString) && !visitedMap.get(neighString)){\\n                            queue.offer(neighString);\\n                            visitedMap.put(neighString, true);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n------------------------------------------------------------------\\n//Using HashSet\\n```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        if(!wordList.contains(endWord))\\n            return 0;\\n        \\n        HashSet<String> unvisitedSet = new HashSet<String>(wordList);\\n        \\n        Queue<String> queue = new LinkedList<String>();\\n        queue.offer(beginWord);\\n        unvisitedSet.remove(beginWord);\\n        int level = 1;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                String currString = queue.poll();\\n                \\n                for(int i = 0; i < currString.length(); i++){\\n                    char[] word = currString.toCharArray();\\n                    for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                        word[i] = ch;\\n                        String neighString = String.valueOf(word);\\n                        if(neighString.equals(endWord)){\\n                            return level + 1;\\n                        }\\n                        if(unvisitedSet.contains(neighString) && wordList.contains(neighString)){\\n                            queue.offer(neighString);\\n                            unvisitedSet.remove(neighString);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n-------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        if(!wordList.contains(endWord))\\n            return 0;\\n        \\n        HashMap<String, Boolean> visitedMap = new HashMap<String, Boolean>();\\n        for(String s : wordList){\\n            visitedMap.put(s, false);\\n        }\\n        \\n        Queue<String> queue = new LinkedList<String>();\\n        queue.offer(beginWord);\\n        visitedMap.put(beginWord, true);\\n        int level = 1;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                String currString = queue.poll();\\n                \\n                for(int i = 0; i < currString.length(); i++){\\n                    char[] word = currString.toCharArray();\\n                    for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                        word[i] = ch;\\n                        String neighString = String.valueOf(word);\\n                        if(neighString.equals(endWord)){\\n                            return level + 1;\\n                        }\\n                        if(visitedMap.containsKey(neighString) && !visitedMap.get(neighString)){\\n                            queue.offer(neighString);\\n                            visitedMap.put(neighString, true);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        if(!wordList.contains(endWord))\\n            return 0;\\n        \\n        HashSet<String> unvisitedSet = new HashSet<String>(wordList);\\n        \\n        Queue<String> queue = new LinkedList<String>();\\n        queue.offer(beginWord);\\n        unvisitedSet.remove(beginWord);\\n        int level = 1;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                String currString = queue.poll();\\n                \\n                for(int i = 0; i < currString.length(); i++){\\n                    char[] word = currString.toCharArray();\\n                    for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n                        word[i] = ch;\\n                        String neighString = String.valueOf(word);\\n                        if(neighString.equals(endWord)){\\n                            return level + 1;\\n                        }\\n                        if(unvisitedSet.contains(neighString) && wordList.contains(neighString)){\\n                            queue.offer(neighString);\\n                            unvisitedSet.remove(neighString);\\n                        }\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291740,
                "title": "c-2-solutions-n-m-and-nm",
                "content": "O(N\\xB2M)\\n```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        int n = beginWord.size();\\n        int m = wordList.size();\\n        unordered_map<string, vector<string>> adj;\\n        \\n        for (const string& word: wordList) {\\n            int count = 0;\\n            \\n            for (int k = 0; k < n; ++k) {\\n                if (beginWord[k] == word[k])\\n                    ++count;\\n            }\\n            \\n            if (count == n-1) {\\n                adj[beginWord].push_back(word);\\n                adj[word].push_back(beginWord);\\n            }\\n        }\\n        \\n        for (int i = 0; i < m-1; ++i) {\\n            const string& word = wordList[i];\\n\\n            for (int j = i+1; j < m; ++j) {\\n                const string& word2 = wordList[j];\\n                int count = 0;\\n                \\n                for (int k = 0; k < n; ++k)\\n                    if (word[k] == word2[k])\\n                        ++count;\\n                \\n                if (count == n-1) {\\n                    adj[word].push_back(word2);\\n                    adj[word2].push_back(word);\\n                }\\n            }\\n        }\\n        \\n        deque<string> Q;\\n        unordered_map<string, int> distance;\\n        \\n        Q.push_back(beginWord);\\n        distance[beginWord] = 1;\\n        while (!Q.empty()) {\\n            const string u = Q.front();\\n            Q.pop_front();\\n            \\n            for (const string& v: adj[u])\\n                if (!distance[v]) {\\n                    distance[v] = distance[u] + 1;\\n                    Q.push_back(v);\\n                }\\n        }\\n        \\n        return distance[endWord];\\n    }\\n};\\n```\\n\\n\\nO(NM\\xB2)\\n```\\nclass Solution {\\nprivate:\\n    int foobar(deque<string>& Q, unordered_map<string, vector<string>>& dict, unordered_map<string, int>& distance, unordered_map<string, int>& otherDistance) {\\n        string u = Q.front();\\n        Q.pop_front();\\n        \\n        if (otherDistance[u])\\n            return distance[u] + otherDistance[u] - 1;\\n        \\n        for (int i = 0; i < u.size(); ++i) {\\n            string intermediate = u.substr(0, i) + \\'*\\' + u.substr(i+1);\\n            \\n            for (const string& v: dict[intermediate])\\n                if (!distance[v]) {\\n                    distance[v] = distance[u] + 1;\\n                    Q.push_back(v);\\n                }\\n        }\\n        \\n        return 0;\\n    }\\n    \\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        if (find(wordList.cbegin(), wordList.cend(), endWord) == wordList.cend())\\n            return 0;\\n\\n        int N = wordList.size();\\n        int M = beginWord.size();\\n        unordered_map<string, vector<string>> dict;\\n        \\n        for (int i = 0; i < M; ++i) {\\n            string intermediate = beginWord.substr(0, i) + \\'*\\' + beginWord.substr(i+1);\\n            dict[intermediate].push_back(beginWord);\\n        }\\n        \\n        for (const string& word: wordList)\\n            for (int i = 0; i < M; ++i) {\\n                string intermediate = word.substr(0, i) + \\'*\\' + word.substr(i+1);\\n                dict[intermediate].push_back(word);\\n            }\\n        \\n        deque<string> beginQ, endQ;\\n        unordered_map<string, int> beginDistance, endDistance;\\n        \\n        beginQ.push_back(beginWord);\\n        endQ.push_back(endWord);\\n        beginDistance[beginWord] = endDistance[endWord] = 1;\\n        while (!beginQ.empty() && !endQ.empty()) {\\n            int res = foobar(beginQ, dict, beginDistance, endDistance);\\n            \\n            if (res) return res;\\n\\n            res = foobar(endQ, dict, endDistance, beginDistance);\\n            \\n            if (res) return res;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        int n = beginWord.size();\\n        int m = wordList.size();\\n        unordered_map<string, vector<string>> adj;\\n        \\n        for (const string& word: wordList) {\\n            int count = 0;\\n            \\n            for (int k = 0; k < n; ++k) {\\n                if (beginWord[k] == word[k])\\n                    ++count;\\n            }\\n            \\n            if (count == n-1) {\\n                adj[beginWord].push_back(word);\\n                adj[word].push_back(beginWord);\\n            }\\n        }\\n        \\n        for (int i = 0; i < m-1; ++i) {\\n            const string& word = wordList[i];\\n\\n            for (int j = i+1; j < m; ++j) {\\n                const string& word2 = wordList[j];\\n                int count = 0;\\n                \\n                for (int k = 0; k < n; ++k)\\n                    if (word[k] == word2[k])\\n                        ++count;\\n                \\n                if (count == n-1) {\\n                    adj[word].push_back(word2);\\n                    adj[word2].push_back(word);\\n                }\\n            }\\n        }\\n        \\n        deque<string> Q;\\n        unordered_map<string, int> distance;\\n        \\n        Q.push_back(beginWord);\\n        distance[beginWord] = 1;\\n        while (!Q.empty()) {\\n            const string u = Q.front();\\n            Q.pop_front();\\n            \\n            for (const string& v: adj[u])\\n                if (!distance[v]) {\\n                    distance[v] = distance[u] + 1;\\n                    Q.push_back(v);\\n                }\\n        }\\n        \\n        return distance[endWord];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int foobar(deque<string>& Q, unordered_map<string, vector<string>>& dict, unordered_map<string, int>& distance, unordered_map<string, int>& otherDistance) {\\n        string u = Q.front();\\n        Q.pop_front();\\n        \\n        if (otherDistance[u])\\n            return distance[u] + otherDistance[u] - 1;\\n        \\n        for (int i = 0; i < u.size(); ++i) {\\n            string intermediate = u.substr(0, i) + \\'*\\' + u.substr(i+1);\\n            \\n            for (const string& v: dict[intermediate])\\n                if (!distance[v]) {\\n                    distance[v] = distance[u] + 1;\\n                    Q.push_back(v);\\n                }\\n        }\\n        \\n        return 0;\\n    }\\n    \\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        if (find(wordList.cbegin(), wordList.cend(), endWord) == wordList.cend())\\n            return 0;\\n\\n        int N = wordList.size();\\n        int M = beginWord.size();\\n        unordered_map<string, vector<string>> dict;\\n        \\n        for (int i = 0; i < M; ++i) {\\n            string intermediate = beginWord.substr(0, i) + \\'*\\' + beginWord.substr(i+1);\\n            dict[intermediate].push_back(beginWord);\\n        }\\n        \\n        for (const string& word: wordList)\\n            for (int i = 0; i < M; ++i) {\\n                string intermediate = word.substr(0, i) + \\'*\\' + word.substr(i+1);\\n                dict[intermediate].push_back(word);\\n            }\\n        \\n        deque<string> beginQ, endQ;\\n        unordered_map<string, int> beginDistance, endDistance;\\n        \\n        beginQ.push_back(beginWord);\\n        endQ.push_back(endWord);\\n        beginDistance[beginWord] = endDistance[endWord] = 1;\\n        while (!beginQ.empty() && !endQ.empty()) {\\n            int res = foobar(beginQ, dict, beginDistance, endDistance);\\n            \\n            if (res) return res;\\n\\n            res = foobar(endQ, dict, endDistance, beginDistance);\\n            \\n            if (res) return res;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265059,
                "title": "java-bi-directional-bfs-clean-with-comments",
                "content": "```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        //bi directional bfs to cut down on runtime\\n        \\n        Set<String> dict = new HashSet<>(wordList), start = new HashSet<>(), end = new HashSet<>();\\n        \\n        if(!dict.contains(endWord) || endWord.equals(beginWord)) return 0;\\n        \\n        int length = 1;\\n        \\n        start.add(beginWord); end.add(endWord);\\n        \\n        //remove begin and end from dict so we don\\'t attempt to include these in building towards the result\\n        \\n        dict.remove(endWord);\\n        \\n        if(dict.contains(beginWord))\\n            dict.remove(beginWord);\\n        \\n        //start will always be the smaller set which makes bfs faster\\n        while(!start.isEmpty()){\\n\\n            length++;\\n            \\n            //iterate all intermediary words from start, we won\\'t remove from the start set however we will not re-use it in later iterations therefore values are lost\\n            \\n            Set<String> neighbors = new HashSet<>(); //get all neighbors of all words in the start set\\n                \\n            for(String word : start){\\n                \\n                char[] chars = word.toCharArray();\\n                \\n                for(int idx = 0; idx < word.length(); idx++){\\n                    \\n                    //save the char for replacing it later\\n                    char charAtIdx = chars[idx];\\n                    \\n                    for(int c = \\'a\\'; c <= \\'z\\'; c++){\\n                        \\n                        chars[idx] = (char) c;\\n                        \\n                        String possibleNeighbor = String.valueOf(chars);\\n                        \\n                        if(end.contains(possibleNeighbor)) return length;\\n                        \\n                        if(dict.contains(possibleNeighbor)){\\n                            \\n                            neighbors.add(possibleNeighbor);\\n                            dict.remove(possibleNeighbor);\\n                        }\\n                    }\\n                    \\n                    //replace the char at the current idx\\n                    chars[idx] = charAtIdx;\\n                }\\n            }\\n            \\n            //make smart the smaller between neighbors and end\\n            start = neighbors.size() < end.size() ? neighbors : end;\\n            end = (start == end) ? neighbors : end;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        \\n        //bi directional bfs to cut down on runtime\\n        \\n        Set<String> dict = new HashSet<>(wordList), start = new HashSet<>(), end = new HashSet<>();\\n        \\n        if(!dict.contains(endWord) || endWord.equals(beginWord)) return 0;\\n        \\n        int length = 1;\\n        \\n        start.add(beginWord); end.add(endWord);\\n        \\n        //remove begin and end from dict so we don\\'t attempt to include these in building towards the result\\n        \\n        dict.remove(endWord);\\n        \\n        if(dict.contains(beginWord))\\n            dict.remove(beginWord);\\n        \\n        //start will always be the smaller set which makes bfs faster\\n        while(!start.isEmpty()){\\n\\n            length++;\\n            \\n            //iterate all intermediary words from start, we won\\'t remove from the start set however we will not re-use it in later iterations therefore values are lost\\n            \\n            Set<String> neighbors = new HashSet<>(); //get all neighbors of all words in the start set\\n                \\n            for(String word : start){\\n                \\n                char[] chars = word.toCharArray();\\n                \\n                for(int idx = 0; idx < word.length(); idx++){\\n                    \\n                    //save the char for replacing it later\\n                    char charAtIdx = chars[idx];\\n                    \\n                    for(int c = \\'a\\'; c <= \\'z\\'; c++){\\n                        \\n                        chars[idx] = (char) c;\\n                        \\n                        String possibleNeighbor = String.valueOf(chars);\\n                        \\n                        if(end.contains(possibleNeighbor)) return length;\\n                        \\n                        if(dict.contains(possibleNeighbor)){\\n                            \\n                            neighbors.add(possibleNeighbor);\\n                            dict.remove(possibleNeighbor);\\n                        }\\n                    }\\n                    \\n                    //replace the char at the current idx\\n                    chars[idx] = charAtIdx;\\n                }\\n            }\\n            \\n            //make smart the smaller between neighbors and end\\n            start = neighbors.size() < end.size() ? neighbors : end;\\n            end = (start == end) ? neighbors : end;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010216,
                "title": "simple-c-1-directional-bfs",
                "content": "```\\nclass Solution {\\n    typedef pair<string,int> psi;\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        unordered_set<string> dict;\\n        bool found = false;\\n        for( string& itr : wordList)\\n        {\\n            if( itr == endWord)\\n                found = true;\\n            dict.insert(itr);                \\n        }\\n        \\n        if( found == false)\\n            return 0;\\n        \\n        queue<psi> q;\\n        q.push({beginWord,1});\\n        \\n        while(!q.empty())\\n        {\\n            psi temp = q.front();\\n            q.pop();\\n            \\n            if( temp.first == endWord)\\n                return temp.second;\\n            \\n            string str = temp.first;\\n            for(int i = 0; i< str.length() ;i++)\\n            {\\n                for(char c = \\'a\\' ; c<= \\'z\\' ; c++)\\n                {\\n                    char x = str[i];\\n                    str[i] = c;\\n                    if( dict.count(str))\\n                    {\\n                        q.push({str , temp.second+1});\\n                        dict.erase(str);\\n                    }\\n                    str[i] = x;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef pair<string,int> psi;\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n        \\n        unordered_set<string> dict;\\n        bool found = false;\\n        for( string& itr : wordList)\\n        {\\n            if( itr == endWord)\\n                found = true;\\n            dict.insert(itr);                \\n        }\\n        \\n        if( found == false)\\n            return 0;\\n        \\n        queue<psi> q;\\n        q.push({beginWord,1});\\n        \\n        while(!q.empty())\\n        {\\n            psi temp = q.front();\\n            q.pop();\\n            \\n            if( temp.first == endWord)\\n                return temp.second;\\n            \\n            string str = temp.first;\\n            for(int i = 0; i< str.length() ;i++)\\n            {\\n                for(char c = \\'a\\' ; c<= \\'z\\' ; c++)\\n                {\\n                    char x = str[i];\\n                    str[i] = c;\\n                    if( dict.count(str))\\n                    {\\n                        q.push({str , temp.second+1});\\n                        dict.erase(str);\\n                    }\\n                    str[i] = x;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008595,
                "title": "python-bfs",
                "content": "Build the dictionary of `mask -> [words]`, then iterate the dictionary:\\n```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n\\tmasks = defaultdict(list)\\n\\tfor word in wordList:\\n\\t\\tfor i, ch in enumerate(word):\\n\\t\\t\\tmasks[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n\\n\\tsteps = 1\\n\\tqueue = [beginWord]\\n\\n\\twhile queue:\\n\\t\\tnext_queue = []\\n\\t\\twhile queue:\\n\\t\\t\\tcur_word = queue.pop()\\n\\t\\t\\tif cur_word == endWord:\\n\\t\\t\\t\\treturn steps\\n\\t\\t\\tfor i, ch in enumerate(cur_word):\\n\\t\\t\\t\\tmask = cur_word[:i] + \\'*\\' + cur_word[i+1:]\\n\\t\\t\\t\\tnext_queue.extend(masks[mask])\\n\\t\\t\\t\\tdel masks[mask]\\n\\t\\tsteps += 1\\n\\t\\tqueue = next_queue\\n\\n\\treturn 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n\\tmasks = defaultdict(list)\\n\\tfor word in wordList:\\n\\t\\tfor i, ch in enumerate(word):\\n\\t\\t\\tmasks[word[:i] + \\'*\\' + word[i+1:]].append(word)\\n\\n\\tsteps = 1\\n\\tqueue = [beginWord]\\n\\n\\twhile queue:\\n\\t\\tnext_queue = []\\n\\t\\twhile queue:\\n\\t\\t\\tcur_word = queue.pop()\\n\\t\\t\\tif cur_word == endWord:\\n\\t\\t\\t\\treturn steps\\n\\t\\t\\tfor i, ch in enumerate(cur_word):\\n\\t\\t\\t\\tmask = cur_word[:i] + \\'*\\' + cur_word[i+1:]\\n\\t\\t\\t\\tnext_queue.extend(masks[mask])\\n\\t\\t\\t\\tdel masks[mask]\\n\\t\\tsteps += 1\\n\\t\\tqueue = next_queue\\n\\n\\treturn 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 976087,
                "title": "clean-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string begin_word, string end_word, vector<string>& word_list) {\\n        std::unordered_map<string, vector<string>> word_map;\\n        for (const string &word : word_list) {\\n            for (size_t i = 0; i < word.size(); i++) {\\n                string word_key = word;\\n                word_key.at(i) = \\'_\\';\\n                word_map[word_key].push_back(std::move(word));\\n            }\\n        }\\n        \\n        std::unordered_set<string> seen;\\n        std::queue<std::pair<string, int>> word_queue;\\n        word_queue.emplace(begin_word, 1);\\n        while (not word_queue.empty()) {\\n            auto queue_front = word_queue.front();\\n            const string &popped_word = queue_front.first;\\n            word_queue.pop();\\n            if (popped_word == end_word)\\n                return queue_front.second;\\n            \\n            for (int i = 0; i < popped_word.size(); i++) {\\n                string word_key = popped_word;\\n                word_key.at(i) = \\'_\\';\\n                auto it = word_map.find(word_key);\\n                if (it == word_map.cend())\\n                    continue;\\n                \\n                for (const string &word : it->second) {\\n                    if (seen.count(word)) {\\n                        continue;\\n                    }\\n                    \\n                    word_queue.emplace(word, queue_front.second + 1);\\n                    seen.emplace(word);\\n                }\\n            }\\n        }\\n            \\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string begin_word, string end_word, vector<string>& word_list) {\\n        std::unordered_map<string, vector<string>> word_map;\\n        for (const string &word : word_list) {\\n            for (size_t i = 0; i < word.size(); i++) {\\n                string word_key = word;\\n                word_key.at(i) = \\'_\\';\\n                word_map[word_key].push_back(std::move(word));\\n            }\\n        }\\n        \\n        std::unordered_set<string> seen;\\n        std::queue<std::pair<string, int>> word_queue;\\n        word_queue.emplace(begin_word, 1);\\n        while (not word_queue.empty()) {\\n            auto queue_front = word_queue.front();\\n            const string &popped_word = queue_front.first;\\n            word_queue.pop();\\n            if (popped_word == end_word)\\n                return queue_front.second;\\n            \\n            for (int i = 0; i < popped_word.size(); i++) {\\n                string word_key = popped_word;\\n                word_key.at(i) = \\'_\\';\\n                auto it = word_map.find(word_key);\\n                if (it == word_map.cend())\\n                    continue;\\n                \\n                for (const string &word : it->second) {\\n                    if (seen.count(word)) {\\n                        continue;\\n                    }\\n                    \\n                    word_queue.emplace(word, queue_front.second + 1);\\n                    seen.emplace(word);\\n                }\\n            }\\n        }\\n            \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924548,
                "title": "can-we-use-dfs-here",
                "content": "Can We Use DFS, instead of BFS here? If not, please explains why we cannot.\\n\\n```\\n    public int ladderLength(String s, String e, List<String> wordList) {\\n        // BFS;\\n        int res = 0;\\n        Set<String> set = new HashSet<>(wordList);\\n        Queue<String> q = new LinkedList<>();\\n        q.add(s);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            res++;\\n            for (int i=0; i<size; i++) {\\n                char[] ch = q.poll().toCharArray();\\n                for (int j=0; j<ch.length; j++) {\\n                    char temp = ch[j];\\n                    for (char k = \\'a\\'; k <= \\'z\\'; k++) {\\n                        ch[j] = k;\\n                        String newString = new String(ch);\\n                        if (set.contains(newString)) {\\n                            //System.out.println(newString);\\n                            if (newString.equals(e)) {\\n                                return res + 1;\\n                            }\\n                            q.add(newString);\\n                            set.remove(newString);\\n                        }\\n                        \\n                    }\\n                    ch[j] = temp;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int ladderLength(String s, String e, List<String> wordList) {\\n        // BFS;\\n        int res = 0;\\n        Set<String> set = new HashSet<>(wordList);\\n        Queue<String> q = new LinkedList<>();\\n        q.add(s);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            res++;\\n            for (int i=0; i<size; i++) {\\n                char[] ch = q.poll().toCharArray();\\n                for (int j=0; j<ch.length; j++) {\\n                    char temp = ch[j];\\n                    for (char k = \\'a\\'; k <= \\'z\\'; k++) {\\n                        ch[j] = k;\\n                        String newString = new String(ch);\\n                        if (set.contains(newString)) {\\n                            //System.out.println(newString);\\n                            if (newString.equals(e)) {\\n                                return res + 1;\\n                            }\\n                            q.add(newString);\\n                            set.remove(newString);\\n                        }\\n                        \\n                    }\\n                    ch[j] = temp;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913716,
                "title": "python-60ms-beat-99-96-why",
                "content": "I found this answer in my own submissions, but I don\\'t remember how it works, anyone can add explanation to this fastest Python solution?\\n```\\nclass Solution:\\n    def ladderLength(self,bw,ew,wl):\\n        ws=set(wl)\\n        if ew not in ws:return 0\\n        bs={bw}\\n        es={ew}\\n        lv=1\\n        while bs:\\n            ws-=bs\\n            lv+=1\\n            t=set()\\n            for w in bs:\\n                for i in range(len(w)):\\n                    l=w[:i]\\n                    r=w[i+1:]\\n                    for c in string.ascii_lowercase:\\n                        n=l+c+r\\n                        if n in ws:\\n                            if n in es:return lv\\n                            else:t.add(n)\\n            bs=t\\n            if len(bs)>len(es):es,bs=bs,es\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ladderLength(self,bw,ew,wl):\\n        ws=set(wl)\\n        if ew not in ws:return 0\\n        bs={bw}\\n        es={ew}\\n        lv=1\\n        while bs:\\n            ws-=bs\\n            lv+=1\\n            t=set()\\n            for w in bs:\\n                for i in range(len(w)):\\n                    l=w[:i]\\n                    r=w[i+1:]\\n                    for c in string.ascii_lowercase:\\n                        n=l+c+r\\n                        if n in ws:\\n                            if n in es:return lv\\n                            else:t.add(n)\\n            bs=t\\n            if len(bs)>len(es):es,bs=bs,es\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876757,
                "title": "python-bfs-well-commented-for-understanding-it-better",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        # For a faster access turing it into a set\\n        words = set(wordList)\\n        \\n        # Edge case\\n        if endWord not in words: return 0\\n        \\n        # We will be doing a Breadth First search, so we begin with placing beginWord in the queue\\n        queue = collections.deque([beginWord])\\n        count = 1\\n        \\n        # To keep a track of what words we have visited already\\n        seen = set()\\n        \\n        while queue:\\n            # Picking up every word we put from the BFS neighbours\\n            \\n            for _ in range(len(queue)):\\n                \\n                # Taking one element at a time\\n                word = queue.popleft()\\n                \\n                # We will not come to this word again\\n                seen.add(word)\\n                \\n                # Bingo, we won\\n                if word == endWord:\\n                    return count\\n                \\n                # Find the current words neighbours\\n                for i in range(0, len(word)):\\n                    \\n                    # Try to create the possible new words\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        new_word = word[:i] + c + word[i+1:]\\n                        \\n                        # Never visited this word, the word is in words\\n                        if new_word in words and new_word not in seen:\\n                            queue.append(new_word)\\n                            seen.add(new_word)\\n            count+=1 \\n        return 0\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        \\n        # For a faster access turing it into a set\\n        words = set(wordList)\\n        \\n        # Edge case\\n        if endWord not in words: return 0\\n        \\n        # We will be doing a Breadth First search, so we begin with placing beginWord in the queue\\n        queue = collections.deque([beginWord])\\n        count = 1\\n        \\n        # To keep a track of what words we have visited already\\n        seen = set()\\n        \\n        while queue:\\n            # Picking up every word we put from the BFS neighbours\\n            \\n            for _ in range(len(queue)):\\n                \\n                # Taking one element at a time\\n                word = queue.popleft()\\n                \\n                # We will not come to this word again\\n                seen.add(word)\\n                \\n                # Bingo, we won\\n                if word == endWord:\\n                    return count\\n                \\n                # Find the current words neighbours\\n                for i in range(0, len(word)):\\n                    \\n                    # Try to create the possible new words\\n                    for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                        new_word = word[:i] + c + word[i+1:]\\n                        \\n                        # Never visited this word, the word is in words\\n                        if new_word in words and new_word not in seen:\\n                            queue.append(new_word)\\n                            seen.add(new_word)\\n            count+=1 \\n        return 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 874742,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        level = 1\\n        frontier = [beginWord]\\n        wl = set(wordList)\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        while frontier:\\n            next = []\\n            for cur in frontier:\\n                if cur==endWord:\\n                    return level\\n                for i in range(len(cur)):\\n                    for ch in alpha:\\n                        next_word = cur[:i]+ch+cur[i+1:]\\n                        if next_word in wl:\\n                            wl.remove(next_word)\\n                            next.append(next_word)\\n            frontier = next\\n            level+=1\\n        return 0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        level = 1\\n        frontier = [beginWord]\\n        wl = set(wordList)\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n        while frontier:\\n            next = []\\n            for cur in frontier:\\n                if cur==endWord:\\n                    return level\\n                for i in range(len(cur)):\\n                    for ch in alpha:\\n                        next_word = cur[:i]+ch+cur[i+1:]\\n                        if next_word in wl:\\n                            wl.remove(next_word)\\n                            next.append(next_word)\\n            frontier = next\\n            level+=1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838987,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        words_dict = self.construct_dict(wordList)\\n        return self.bfs(beginWord, endWord, words_dict)\\n    \\n    def construct_dict(self, wordList):\\n        words_dict = {}\\n        for word in wordList:\\n            for i in range(len(word)):\\n                s = word[:i] + \\'_\\' + word[i+1:]\\n                if s not in words_dict:\\n                    words_dict[s] = [word]\\n                else:\\n                    words_dict[s].append(word)\\n\\n        return words_dict\\n\\n    def bfs(self, beginWord, endWord, words_dict):\\n        queue, visited = collections.deque(), set()\\n        queue.append((beginWord, 1))\\n\\n        while queue:\\n            word, steps = queue.popleft()\\n\\n            if word == endWord:\\n                return steps\\n\\n            for i in range(len(word)):\\n                s = word[:i] + \\'_\\' + word[i+1:]\\n                neighbour_words = words_dict.get(s, [])\\n\\n                for nw in neighbour_words:\\n                    if nw not in visited:\\n                        visited.add(nw)\\n                        queue.append((nw, steps+1))\\n\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        words_dict = self.construct_dict(wordList)\\n        return self.bfs(beginWord, endWord, words_dict)\\n    \\n    def construct_dict(self, wordList):\\n        words_dict = {}\\n        for word in wordList:\\n            for i in range(len(word)):\\n                s = word[:i] + \\'_\\' + word[i+1:]\\n                if s not in words_dict:\\n                    words_dict[s] = [word]\\n                else:\\n                    words_dict[s].append(word)\\n\\n        return words_dict\\n\\n    def bfs(self, beginWord, endWord, words_dict):\\n        queue, visited = collections.deque(), set()\\n        queue.append((beginWord, 1))\\n\\n        while queue:\\n            word, steps = queue.popleft()\\n\\n            if word == endWord:\\n                return steps\\n\\n            for i in range(len(word)):\\n                s = word[:i] + \\'_\\' + word[i+1:]\\n                neighbour_words = words_dict.get(s, [])\\n\\n                for nw in neighbour_words:\\n                    if nw not in visited:\\n                        visited.add(nw)\\n                        queue.append((nw, steps+1))\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811058,
                "title": "c-288ms-bfs",
                "content": "```\\nstruct queObj {\\n    int level;\\n    char *str;\\n};\\n\\nint head = 0;\\nint tail = 0;\\nstruct queObj *queue = NULL;\\n\\nbool isNear(char *str1, char *str2) {\\n    int diffCnt = 0;\\n\\n    while (*str1) {\\n        if (*str1++ != *str2++) {\\n            diffCnt++;\\n            if (diffCnt > 1)\\n                return false;\\n        }\\n    }\\n\\n    if (1 == diffCnt)\\n        return true;\\n    \\n    return false;\\n}\\n\\nvoid addQueue(char *newStr, int level) {\\n    queue[tail].str = newStr;\\n    queue[tail].level = level;\\n    tail++;\\n}\\n\\nint ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize) { \\n    int level = 0;\\n    bool *visited = NULL;\\n    int i;\\n    int depth = 0;\\n\\n    head = 0;\\n    tail = 0;\\n    \\n    queue = malloc(sizeof(struct queObj) * (wordListSize + 2));\\n    visited = malloc(sizeof(bool) * wordListSize);\\n    memset(visited, 0, sizeof(bool) * wordListSize);\\n\\n    addQueue(beginWord, 1);\\n    while (head != tail) {\\n        for (i = 0; i < wordListSize; i++) {\\n            if (true == visited[i]) {\\n                continue;\\n            }\\n            if (isNear(queue[head].str, wordList[i])) {\\n                if (!strcmp(endWord, wordList[i]))\\n                    return queue[head].level + 1;\\n                addQueue(wordList[i], queue[head].level + 1);\\n                visited[i] = true;\\n            }\\n        }\\n        head++;\\n    }\\n\\n    return 0;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstruct queObj {\\n    int level;\\n    char *str;\\n};\\n\\nint head = 0;\\nint tail = 0;\\nstruct queObj *queue = NULL;\\n\\nbool isNear(char *str1, char *str2) {\\n    int diffCnt = 0;\\n\\n    while (*str1) {\\n        if (*str1++ != *str2++) {\\n            diffCnt++;\\n            if (diffCnt > 1)\\n                return false;\\n        }\\n    }\\n\\n    if (1 == diffCnt)\\n        return true;\\n    \\n    return false;\\n}\\n\\nvoid addQueue(char *newStr, int level) {\\n    queue[tail].str = newStr;\\n    queue[tail].level = level;\\n    tail++;\\n}\\n\\nint ladderLength(char * beginWord, char * endWord, char ** wordList, int wordListSize) { \\n    int level = 0;\\n    bool *visited = NULL;\\n    int i;\\n    int depth = 0;\\n\\n    head = 0;\\n    tail = 0;\\n    \\n    queue = malloc(sizeof(struct queObj) * (wordListSize + 2));\\n    visited = malloc(sizeof(bool) * wordListSize);\\n    memset(visited, 0, sizeof(bool) * wordListSize);\\n\\n    addQueue(beginWord, 1);\\n    while (head != tail) {\\n        for (i = 0; i < wordListSize; i++) {\\n            if (true == visited[i]) {\\n                continue;\\n            }\\n            if (isNear(queue[head].str, wordList[i])) {\\n                if (!strcmp(endWord, wordList[i]))\\n                    return queue[head].level + 1;\\n                addQueue(wordList[i], queue[head].level + 1);\\n                visited[i] = true;\\n            }\\n        }\\n        head++;\\n    }\\n\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804656,
                "title": "c-faster-than-95-75-less-than-40-89-mem",
                "content": "Runtime: 200 ms\\nMemory Usage: 32.2 MB\\n\\nIdea: If word is \"abc\" than\\nwe call FindNextStep for each of the following strings:\\n\".bc\", \"a.c\", \"ab.\" where \".\" means any char (= node) so we skip a node in the trie structure.\\nInstead of creating new strings, we pass the length of the prefix (before \".\") and the index where the postfix starts (after \".\");\\n\\n```\\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) \\n    {   \\n        HashSet<string> visited = new HashSet<string>();\\n        \\n        Queue<string> queue = new Queue<string>();\\n        queue.Enqueue(beginWord);\\n        \\n        Node root = BuildTrie(wordList);\\n        \\n        int size = 0;\\n        string word;\\n        int count = 0;\\n        bool found = false;\\n        \\n        while(queue.Count > 0 && !found)\\n        {\\n            count++;\\n            size = queue.Count;\\n            while(size > 0)\\n            {\\n                size--;\\n                word = queue.Dequeue();\\n                \\n                if (word == endWord) { found = true; break; }\\n                if (visited.Contains(word)) { continue; }\\n                \\n                visited.Add(word);\\n                \\n                for(int i=0; i< word.Length; i++)\\n                {\\n                    FindNextStep(root, word, i, i+1, visited, queue);\\n                }\\n            }\\n        }\\n        \\n        return (found)? count : 0;\\n    }\\n    \\n    private void FindNextStep(Node root, string word, int prefixLength, int postfixStartIdx, \\n                              HashSet<string> visited, Queue<string> queue)\\n    {\\n        \\n        Node node = root;\\n        int i = 0;\\n        while(i < prefixLength)\\n        {\\n            if (node.Child[word[i]-\\'a\\'] == null) { return; }\\n            node = node.Child[word[i]-\\'a\\'];\\n            i++;\\n        }        \\n        \\n        Node crnt;\\n        for(int j=0; j< node.Child.Length; j++)\\n        {\\n            if (node.Child[j] == null) { continue; }\\n                       \\n            crnt = node.Child[j];\\n\\n            for(int y=postfixStartIdx; y < word.Length; y++)\\n            {\\n                 if (crnt.Child[word[y]-\\'a\\'] == null) { crnt = null; break; }\\n                 crnt = crnt.Child[word[y]-\\'a\\'];\\n            }\\n\\n            if (crnt != null && crnt.IsEnd && !visited.Contains(crnt.Word))\\n            {\\n                queue.Enqueue(crnt.Word);\\n            }\\n        }\\n    }\\n    \\n    private Node BuildTrie(IList<string> wordList)\\n    {\\n        Node root = new Node();\\n        Node node = root;\\n        \\n        foreach(string word in wordList)\\n        {\\n            node = root;\\n            foreach(char c in word)\\n            {\\n                if (node.Child[c-\\'a\\'] == null)\\n                {\\n                    node.Child[c-\\'a\\'] = new Node();\\n                }\\n                node = node.Child[c-\\'a\\'];\\n            }\\n            node.Word = word;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private class Node\\n    {\\n        public Node[] Child = new Node[\\'z\\'-\\'a\\'+1];\\n        public bool IsEnd { get { return Word != null; } }\\n        public string Word;\\n    }",
                "solutionTags": [
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "Runtime: 200 ms\\nMemory Usage: 32.2 MB\\n\\nIdea: If word is \"abc\" than\\nwe call FindNextStep for each of the following strings:\\n\".bc\", \"a.c\", \"ab.\" where \".\" means any char (= node) so we skip a node in the trie structure.\\nInstead of creating new strings, we pass the length of the prefix (before \".\") and the index where the postfix starts (after \".\");\\n\\n```\\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) \\n    {   \\n        HashSet<string> visited = new HashSet<string>();\\n        \\n        Queue<string> queue = new Queue<string>();\\n        queue.Enqueue(beginWord);\\n        \\n        Node root = BuildTrie(wordList);\\n        \\n        int size = 0;\\n        string word;\\n        int count = 0;\\n        bool found = false;\\n        \\n        while(queue.Count > 0 && !found)\\n        {\\n            count++;\\n            size = queue.Count;\\n            while(size > 0)\\n            {\\n                size--;\\n                word = queue.Dequeue();\\n                \\n                if (word == endWord) { found = true; break; }\\n                if (visited.Contains(word)) { continue; }\\n                \\n                visited.Add(word);\\n                \\n                for(int i=0; i< word.Length; i++)\\n                {\\n                    FindNextStep(root, word, i, i+1, visited, queue);\\n                }\\n            }\\n        }\\n        \\n        return (found)? count : 0;\\n    }\\n    \\n    private void FindNextStep(Node root, string word, int prefixLength, int postfixStartIdx, \\n                              HashSet<string> visited, Queue<string> queue)\\n    {\\n        \\n        Node node = root;\\n        int i = 0;\\n        while(i < prefixLength)\\n        {\\n            if (node.Child[word[i]-\\'a\\'] == null) { return; }\\n            node = node.Child[word[i]-\\'a\\'];\\n            i++;\\n        }        \\n        \\n        Node crnt;\\n        for(int j=0; j< node.Child.Length; j++)\\n        {\\n            if (node.Child[j] == null) { continue; }\\n                       \\n            crnt = node.Child[j];\\n\\n            for(int y=postfixStartIdx; y < word.Length; y++)\\n            {\\n                 if (crnt.Child[word[y]-\\'a\\'] == null) { crnt = null; break; }\\n                 crnt = crnt.Child[word[y]-\\'a\\'];\\n            }\\n\\n            if (crnt != null && crnt.IsEnd && !visited.Contains(crnt.Word))\\n            {\\n                queue.Enqueue(crnt.Word);\\n            }\\n        }\\n    }\\n    \\n    private Node BuildTrie(IList<string> wordList)\\n    {\\n        Node root = new Node();\\n        Node node = root;\\n        \\n        foreach(string word in wordList)\\n        {\\n            node = root;\\n            foreach(char c in word)\\n            {\\n                if (node.Child[c-\\'a\\'] == null)\\n                {\\n                    node.Child[c-\\'a\\'] = new Node();\\n                }\\n                node = node.Child[c-\\'a\\'];\\n            }\\n            node.Word = word;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    private class Node\\n    {\\n        public Node[] Child = new Node[\\'z\\'-\\'a\\'+1];\\n        public bool IsEnd { get { return Word != null; } }\\n        public string Word;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 791449,
                "title": "c-easiest-solution-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n       unordered_set<string> s;\\n        for(string str:wordList)\\n            s.insert(str);\\n        \\n        if(s.find(endWord)==s.end())\\n            return 0;\\n        \\n        queue<string> q;\\n        q.push(beginWord);\\n        int level=0;\\n        \\n        while(!q.empty())\\n        {\\n            ++level;\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                string cur=q.front();\\n                q.pop();\\n                for(int i=0;i<cur.length();i++)\\n                {\\n                    char org=cur[i];\\n                    for(char c=\\'a\\';c<=\\'z\\';c++)\\n                    {\\n                        cur[i]=c;\\n                        if(cur==endWord)\\n                            return level+1;\\n                        if(s.find(cur)!=s.end())\\n                        {\\n                            q.push(cur);\\n                            s.erase(cur);\\n                        }\\n                    }\\n                    cur[i]=org;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n       unordered_set<string> s;\\n        for(string str:wordList)\\n            s.insert(str);\\n        \\n        if(s.find(endWord)==s.end())\\n            return 0;\\n        \\n        queue<string> q;\\n        q.push(beginWord);\\n        int level=0;\\n        \\n        while(!q.empty())\\n        {\\n            ++level;\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                string cur=q.front();\\n                q.pop();\\n                for(int i=0;i<cur.length();i++)\\n                {\\n                    char org=cur[i];\\n                    for(char c=\\'a\\';c<=\\'z\\';c++)\\n                    {\\n                        cur[i]=c;\\n                        if(cur==endWord)\\n                            return level+1;\\n                        if(s.find(cur)!=s.end())\\n                        {\\n                            q.push(cur);\\n                            s.erase(cur);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 756643,
                "title": "single-bfs-c-o-n-m-26",
                "content": "```\\ntypedef pair<string,int> psi;\\nclass Solution {\\npublic:\\n    int ladderLength(string start, string end, vector<string>& wordList) {\\n        unordered_set<string> D;// dict\\n        for(auto x: wordList)\\n            D.insert(x);\\n        \\n        queue<pair<string,int>> q;\\n        q.push({start, 1});\\n        D.erase(start); // visited = true\\n        \\n        while(!q.empty()){\\n            psi x = q.front();\\n            q.pop();\\n            \\n            string str = x.first;\\n            int len = x.second;\\n            \\n            if(str == end)\\n                return len;\\n            \\n            for(int i = 0; i < int(str.size()); i++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char prev = str[i];\\n                    str[i] = c;\\n                    if(D.find(str) != D.end()){\\n                        q.push({str, len + 1});\\n                        D.erase(str);\\n                    }\\n                    str[i] = prev;\\n                }\\n            }                        \\n        }\\n        \\n        return 0;// none found\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<string,int> psi;\\nclass Solution {\\npublic:\\n    int ladderLength(string start, string end, vector<string>& wordList) {\\n        unordered_set<string> D;// dict\\n        for(auto x: wordList)\\n            D.insert(x);\\n        \\n        queue<pair<string,int>> q;\\n        q.push({start, 1});\\n        D.erase(start); // visited = true\\n        \\n        while(!q.empty()){\\n            psi x = q.front();\\n            q.pop();\\n            \\n            string str = x.first;\\n            int len = x.second;\\n            \\n            if(str == end)\\n                return len;\\n            \\n            for(int i = 0; i < int(str.size()); i++){\\n                for(char c = \\'a\\'; c <= \\'z\\'; c++){\\n                    char prev = str[i];\\n                    str[i] = c;\\n                    if(D.find(str) != D.end()){\\n                        q.push({str, len + 1});\\n                        D.erase(str);\\n                    }\\n                    str[i] = prev;\\n                }\\n            }                        \\n        }\\n        \\n        return 0;// none found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742712,
                "title": "my-solution-returns-a-smaller-than-expected-result-but-looks-valid-any-thought",
                "content": "My solution seems to work for the test cases I ran, but fails on the following:\\n\\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nThe expected is 3, my result is 2. Which to me looks valid based on the problem statement. Any thoughts? \\n\\nMy solution :\\n\\n```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        /*Intuition : BFS traversal where each node is a word. \\n        Start with beginWord node, and goal is to end on endWord.\\n        I am using a queue for BFS traversal.\\n        \\n        In order to go from beingWord to endWord, we need a morphing strategy. \\n        We can either morph the beginWord with wordList as the reference, or\\n        we can use the english alphabets as guide/reference to explore all\\n        the different morphings. The latter performs well even in worst case,\\n        so I am adopting the latter foy my solution.\\n        \\n        Basically, we start with beginWord, explore all 1 transformation words,\\n        and if it matches the endWord we level up and return.\\n        Else, if any of the transformations exists in the wordList, we add it to \\n        the queue for subsequent exploration, and remove it from the wordList to\\n        avoid revisiting the same node twice.*/\\n        Queue<String> q = new LinkedList<>();\\n        int level = 0;\\n        q.offer(beginWord);\\n        while(!q.isEmpty()){//O(wordList.length())\\n            char[] word = q.poll().toCharArray();\\n            for(int i=0; i<word.length; i++){//O(word.length)\\n                for(char c=\\'a\\'; c<=\\'z\\'; c++){//O(25)\\n                    char[] w = Arrays.copyOf(word, word.length);\\n                    w[i] = c;\\n                    String str = new String(w);\\n                    if(str.equals(endWord) && wordList.contains(str)) return level;\\n                    if(wordList.contains(str)){\\n                        q.offer(str);\\n                        wordList.remove(str);\\n                        level +=1;\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "My solution seems to work for the test cases I ran, but fails on the following:\\n\\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nThe expected is 3, my result is 2. Which to me looks valid based on the problem statement. Any thoughts? \\n\\nMy solution :\\n\\n```\\npublic int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        /*Intuition : BFS traversal where each node is a word. \\n        Start with beginWord node, and goal is to end on endWord.\\n        I am using a queue for BFS traversal.\\n        \\n        In order to go from beingWord to endWord, we need a morphing strategy. \\n        We can either morph the beginWord with wordList as the reference, or\\n        we can use the english alphabets as guide/reference to explore all\\n        the different morphings. The latter performs well even in worst case,\\n        so I am adopting the latter foy my solution.\\n        \\n        Basically, we start with beginWord, explore all 1 transformation words,\\n        and if it matches the endWord we level up and return.\\n        Else, if any of the transformations exists in the wordList, we add it to \\n        the queue for subsequent exploration, and remove it from the wordList to\\n        avoid revisiting the same node twice.*/\\n        Queue<String> q = new LinkedList<>();\\n        int level = 0;\\n        q.offer(beginWord);\\n        while(!q.isEmpty()){//O(wordList.length())\\n            char[] word = q.poll().toCharArray();\\n            for(int i=0; i<word.length; i++){//O(word.length)\\n                for(char c=\\'a\\'; c<=\\'z\\'; c++){//O(25)\\n                    char[] w = Arrays.copyOf(word, word.length);\\n                    w[i] = c;\\n                    String str = new String(w);\\n                    if(str.equals(endWord) && wordList.contains(str)) return level;\\n                    if(wordList.contains(str)){\\n                        q.offer(str);\\n                        wordList.remove(str);\\n                        level +=1;\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 691849,
                "title": "python-very-clean-trie-bfs-solution-that-works-with-any-number-of-changes",
                "content": "\\n\\n```python\\nfrom collections import defaultdict, deque\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        def trie_factory():\\n            return defaultdict(trie_factory)\\n\\n        self.root = defaultdict(trie_factory)\\n\\n    def add(self, s):\\n        node = self.root\\n        for c in s:\\n            node = node[c]\\n\\n        node[\\'$\\'] = s\\n\\n    def findBy(self, s, total_changes=0):\\n        t = []\\n\\n        n = len(s)\\n\\n        def search(i, node, changes_left):\\n            if i == n:\\n                if \\'$\\' in node:\\n                    t.append(node[\\'$\\'])\\n\\n                return\\n\\n            if not changes_left:\\n                if s[i] in node:\\n                    search(i + 1, node[s[i]], 0)\\n            else:\\n                for c in string.ascii_lowercase:\\n                    if c in node:\\n                        search(i + 1, node[c], changes_left - (1 if c != s[i] else 0))\\n\\n        search(0, self.root, total_changes)\\n\\n        return t\\n\\n\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        trie = Trie()\\n\\n        for word in wordList:\\n            trie.add(word)\\n\\n        q = deque()\\n        seen = set()\\n\\n        q.append((beginWord, 1))\\n\\n        while q:\\n            word, k = q.popleft()\\n\\n            if word in seen:\\n                continue\\n\\n            if word == endWord:\\n                return k\\n\\n            seen.add(word)\\n\\n            for nextWord in trie.findBy(word, 1):\\n                if nextWord not in seen:\\n                    q.append((nextWord, k + 1))\\n\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict, deque\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        def trie_factory():\\n            return defaultdict(trie_factory)\\n\\n        self.root = defaultdict(trie_factory)\\n\\n    def add(self, s):\\n        node = self.root\\n        for c in s:\\n            node = node[c]\\n\\n        node[\\'$\\'] = s\\n\\n    def findBy(self, s, total_changes=0):\\n        t = []\\n\\n        n = len(s)\\n\\n        def search(i, node, changes_left):\\n            if i == n:\\n                if \\'$\\' in node:\\n                    t.append(node[\\'$\\'])\\n\\n                return\\n\\n            if not changes_left:\\n                if s[i] in node:\\n                    search(i + 1, node[s[i]], 0)\\n            else:\\n                for c in string.ascii_lowercase:\\n                    if c in node:\\n                        search(i + 1, node[c], changes_left - (1 if c != s[i] else 0))\\n\\n        search(0, self.root, total_changes)\\n\\n        return t\\n\\n\\nclass Solution:\\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\\n        trie = Trie()\\n\\n        for word in wordList:\\n            trie.add(word)\\n\\n        q = deque()\\n        seen = set()\\n\\n        q.append((beginWord, 1))\\n\\n        while q:\\n            word, k = q.popleft()\\n\\n            if word in seen:\\n                continue\\n\\n            if word == endWord:\\n                return k\\n\\n            seen.add(word)\\n\\n            for nextWord in trie.findBy(word, 1):\\n                if nextWord not in seen:\\n                    q.append((nextWord, k + 1))\\n\\n        return 0\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565525,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566075,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566288,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566314,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1565833,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566283,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566208,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1565524,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1570865,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566950,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1565525,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566075,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566288,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566314,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1565833,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566283,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566208,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1565524,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1570865,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1566950,
                "content": [
                    {
                        "username": "Margarita00",
                        "content": "I got the follow error. I believe the expected answer is wrong. \\nFrom \"a\" to \"c\", only one step is needed: \"a\"->\"c\". Did I misunderstand the problem?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2"
                    },
                    {
                        "username": "codeCarlos",
                        "content": "I thought this initially as well, but then realized the shortest transformation sequence of this is \"a\" -> \"c\" which is 2 words long. (i.e. the answer will always be the number of steps + 1 for the start word)"
                    },
                    {
                        "username": "dawei2",
                        "content": "Two key parts in the BFS algorithms must be taken care of, otherwise it will lead to TLE:\\n\\n 1. Instead of looping through the whole dict, change the testing word character by character will save a lot of time. This is a good trick;\\n\\n 2. Maintaining a hashset to check visited words will result in TLE. Remove the visited nodes from dict will save some running time. I do not like this part. If you did not make a copy of the dict, the algorithm will change the original dict, which make me feel bad. If you made a copy, you did not save any space compare to using a hash set."
                    },
                    {
                        "username": "cdeng0",
                        "content": "Why the result for the following test case is 2 instead of 1:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "The output should be the number of words in the sequence, not the number of changes.\\nFor a valid answer, $num words = num changes + 1$"
                    },
                    {
                        "username": "user2531u",
                        "content": "What is the intuition to use graph search (BFS) over a recursion/backtracking method?"
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "for me it\\'s the \\'shortest path from beginWord to endWord\\' that led to BFS"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "I guess whenever you see the word \"shortest\", the good hint is that its most likely a BFS based. With DFS its usually doable but needs a lot of code and handle edge case."
                    },
                    {
                        "username": "shirleyzlh2010",
                        "content": "Did I misunderstand the question? Why the expected output is 2? We can just change char 'a' to 'c' in one step. Shouldn't the output be 1?"
                    },
                    {
                        "username": "LC_Binod",
                        "content": "It\\'s not asking for steps it is asking for number of characters involved in total transformation including [beginWord...............endWord]."
                    },
                    {
                        "username": "bhoumick",
                        "content": "Getting a wrong answer for below input while submitting my solution. \\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow the expected 2 ?  Directly transform \"a\"->\"c\". so 1 level.\\n"
                    },
                    {
                        "username": "realitant",
                        "content": "where does it ask for the number of steps? It asks for the number of words"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/word-ladder/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search\n\n  \n**Approach 2:** Bidirectional Breadth First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "towhid",
                        "content": "I think there is a temporary glitch in the system. Anybody from the admin team could please look at the issue. Here is the screen shot of showing the wrong answer of the given example:![0_1487056716578_Screen Shot 2017-02-13 at 11.12.08 PM.png](/uploads/files/1487056720066-screen-shot-2017-02-13-at-11.12.08-pm.png)"
                    },
                    {
                        "username": "ajit_2828",
                        "content": "\"cog\" is not present in entire wordList so, there is no way to change \"hit\" into \"cog\"  that\\'s why answer is 0"
                    },
                    {
                        "username": "idham-",
                        "content": "This problem seems to be existing till now."
                    },
                    {
                        "username": "sijoxavier89",
                        "content": "\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nshould the output be 5 or 6?\\n\\nleet -> lest -> lose -> lode -> code\\n\\nleet -> lest -> lost -> lose -> lode -> code ?"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "Actually it appears the question is worded incorrectly or the test case answer is wrong. \"lest\" and \"lose\" only differ by 1 letter - t v. o, which satisfies the question. Reordering of the letters should be allowed."
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "For output 5, you are changing two words at a time in the step lest->lose (e->o and t->e) which is not allowed as per the question description"
                    },
                    {
                        "username": "subha-py",
                        "content": "**start_word**: \"a\"\\n**end_word**: \"c\"\\n**word_list**: [\"a\",\"b\",\"c\"]\\n\\nIn this example, start_word - \\'a\\', can be transformed to \\'c\\' by a single transformation, so output should be 1.\\nBut its failing, against this testcase as the output exepected is 2.\\n\\nCan anyone help me understand the problem better, why the output is 2 in this case?"
                    },
                    {
                        "username": "Gm_shuvo",
                        "content": "transformation be like a gose to a->c"
                    }
                ]
            },
            {
                "id": 1567414,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1566749,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1568663,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1567486,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1567874,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1567876,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1566479,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1570449,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1569896,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1567873,
                "content": [
                    {
                        "username": "nvaldiviezon",
                        "content": "In the test:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nmy code return 1, but the expected is 2...\\n\\nBased on the explanation this would be a fully connected graph a-b, b-c, a-c, the shortest path is the one edge...or am I misunderstanding the prompt?"
                    },
                    {
                        "username": "leiguo9107",
                        "content": "Input: \"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput: 1\\n\\nExpected: 2\\n\\nBut I think the right answer should be 1."
                    },
                    {
                        "username": "ayush9999",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nFor this test case expected output if 3 but actual solution should be 2\\n\\n\"hot\" -> \"dot\" -> \"dog\"\\n\\n![image](https://assets.leetcode.com/users/images/c4d1f5d6-e7d6-4688-8d00-424750ae5940_1633520857.7617679.png)\\n"
                    },
                    {
                        "username": "ak4046574",
                        "content": "hot->dot->dog, 3 transformation as expected!\\n\\n"
                    },
                    {
                        "username": "esters123",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\n\\nwhy is the ouput of this test case 2 why not 1 ?\\n\\nas we can directly make a transition from a to c which is just 1 word transition ??"
                    },
                    {
                        "username": "ingato",
                        "content": "it\\'s not explained well, but it isn\\'t asking for the number of change operations but the number of words in the list pf changes made from start to end. There can never be one because there is always at least two words in a valid list, beginWord an EndWord."
                    },
                    {
                        "username": "iwant6",
                        "content": "Run Code gives 0.\\n\\n\"hit\" \"cog\" [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nhow about this \\nhit hot dot dog log cog\\nand answer is 5?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "For input:\\n\\n    \"a\", \"c\", [\"a\", \"b\", \"c\"]\\n\\nmy solution gives answer 1, while expected answer is 2. Why is that? \"c\" is in the dictionary, so \"a\" can be switched directly to c in only one iteration.\\nOr am I missing something?"
                    },
                    {
                        "username": "MoonKnight",
                        "content": "I know the idea is to have the same variable names in different languages so people can understand other people's algorithm more easily.\\n\\nHowever, dict is a built-in class name in Python. So using dict as a variable name does not sound like a good idea to me in Python. I suggest changing it to \"dictionary\" here."
                    },
                    {
                        "username": "wilderfield",
                        "content": "I hate this question...\\n\\nThe only difficult part is determining the edge relationships between words.\\n\\nOtherwise its just BFS."
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody tell me why DFS won\\'t work for this problem? I have spent too much time implementing it in DFS but some of the test cases are failing."
                    },
                    {
                        "username": "joemillervi",
                        "content": "It can, i guess it just takes too long?"
                    },
                    {
                        "username": "mns",
                        "content": "Here we are interested to find shotest transformation sequence. DFS can give you whether transformation is possible or not, but need not be shortest alway. BFS gives the shortest path."
                    },
                    {
                        "username": "oldsui",
                        "content": "Any idea about the test case below? Why is the expected answer 0?\\n\\n20 / 39 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 0 minutes ago\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "dkochetov",
                        "content": "The endWord \"cog\" is must be in wordList, it\\'s not in this case"
                    }
                ]
            },
            {
                "id": 1567875,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1570349,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1570157,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1569922,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1569507,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1569317,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1569244,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1571905,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1568944,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1568945,
                "content": [
                    {
                        "username": "samparly",
                        "content": "![0_1478756091735_upload-1443832a-567d-4c42-91c3-e7df2c073cd3](/uploads/files/1478756092286-upload-1443832a-567d-4c42-91c3-e7df2c073cd3.png) \\n\\nFirstly, I don't know why OJ give back three results in a time. I mean if I got a wrong test case, shouldn't I just get a single test case as feedback?\\nSecondly, I think all of these three test cases should NOT return 0, as I can transform hot to dot by \"hot\"->\"dot\", and from hot to dog by \"hot\"->\"dot\"->\"dog\".\\nSo did anyone meet same situation? Please give me some clues, thx"
                    },
                    {
                        "username": "sdeep96396",
                        "content": "beginWord=\\'a\\'\\nendWord=\\'c\\'\\nwordList=[\\'a\\',\\'b\\',\\'c\\']\\nhow come the expected output is 2 when i can do it directly a->c in 1 step\\n"
                    },
                    {
                        "username": "sanketjoshi4",
                        "content": "My submission failed for the test case (beginWord=\"a\",endWord=\"c\",wordList=[\"a\",\"b\",\"c\"])\\nOutput : 1, Expected : 2\\n\\nI\\'m confused here. Shouldn\\'t we get \"c\" from \"a\" in a single step since its a single word change and present in the list?"
                    },
                    {
                        "username": "donniedarko123",
                        "content": "Please update the test cases, as many test cases contain incorrect target solutions, as multiple people posted below. It is not possible to pass the test cases in this way!"
                    },
                    {
                        "username": "banaren",
                        "content": "\\nWhat is the solution for this ?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nI expect one but the leetcode expects two\\n\\n"
                    },
                    {
                        "username": "shsharma05",
                        "content": "How is the answer for this 2 , should it not be 1 ?\\n\\nInput:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n0\\nExpected:\\n2"
                    },
                    {
                        "username": "apalvinski",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nI do not unsdersta why 2 transformatins are required to trasform \"a\"-> \"c\"? "
                    },
                    {
                        "username": "nk595",
                        "content": "I believe that there are some issues with the test cases. For example for single letter words it should take only 1 transformation to get the endWord. The correct answer should be 1 however the testcase expects 2.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/nk595/image_1523077291.png)\\n\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "Lucas_yang",
                        "content": "![alt text](![0_1513041880092_b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png](/assets/uploads/files/1513041884050-b6e59d9a-a88a-4623-be3c-9dd8169c8e47-image.png) image url)\\n\\nHi guys, I think this test case is not correct, someone help me check it?  thanks"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "adifire",
                        "content": "    Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n    Output:\\t1\\n    Expected:\\t2\\n\\nWhy should the expected output be 2 here?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1568947,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1568946,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1567570,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1917144,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1804536,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1742113,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1574903,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1574792,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1574788,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1574557,
                "content": [
                    {
                        "username": "xinyu5",
                        "content": "Input:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput:\\t1\\nExpected:\\t2\\n\\nAccording to the problem description, I could change \"a\" -> \"c\" and the length turns out to be 1.\\nI am confused by the expected answer... Did I miss something out?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "ycai77",
                        "content": "The problem statement is below.\\n\"Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: \\n1.Only one letter can be changed at a time\\n2.Each intermediate word must exist in the dictionary\\n...\"\\n\\nConditions 1 and 2 above do not require that the start and end words must be in the dictionary as confirmed by the given example, i.e., the words \"hit\" and \"cog\" are not in the given dict [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"].\\n\\nHowever, when testing my own solutions, I found that one of the solutions that is based on an assumption that both the start and end words MUST BE in the dictionary gets accepted, which means that this assumption holds in all the existing test cases for this problem. \\n\\nCould the admin check if this is true? If yes, could we get it fixed? It is easy to fix it by removing the start and end words from the dictionary before executing the submitted code."
                    },
                    {
                        "username": "zurendra9",
                        "content": "For test case beginword: \"a\", endword: \"c\" and wordList: [\"a\",\"b\",\"c\"]. The output should be 1 as for to convert `a` to `c` we need one letter change and it is a valid sequence too."
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "nithinpottackal",
                        "content": "Testcase:\\n\"hbo\"\\n\"qbx\"\\n[\"abo\",\"hco\",\"hbw\",\"ado\",\"abq\",\"hcd\",\"hcj\",\"hww\",\"qbq\",\"qby\",\"qbz\",\"qbx\",\"qbw\"]\\n\\nMy answer: 5\\nExpected answer: 4\\n\\nHow come you get 4?\\n\\nOnly one letter can be changed at a time.\\nEach transformed word must exist in the word list.\\n\\nIn this specific case, the problem can be interpreted as finding the shortest transformation sequence from \"hbo\" to \"qbx\" where all transformed words must be in the provided list.\\n\\nLet\\'s solve the problem:\\n\\nThe beginWord is \"hbo\".\\nThe possible transformations that exist in the wordList are [\"abo\", \"hco\", \"hbw\"].\\n\"abo\" can be transformed to \"ado\", and then \"ado\" can be transformed to \"abq\".\\n\"abq\" can finally be transformed to \"qbx\", which is our endWord.\\nSo the transformation sequence would be \"hbo\" -> \"abo\" -> \"ado\" -> \"abq\" -> \"qbx\". \\n\\nThe total number of steps including the beginWord and endWord is 5. If we were looking for the number of transformations, it would be 4."
                    },
                    {
                        "username": "mittalshreya",
                        "content": "I was also getting 5 as my answer, but after analyzing the vector string following transformations will take place:\nhbo->hbw->qbw->qbx\nhence the answer will be 4."
                    },
                    {
                        "username": "jethalol",
                        "content": "I got 50/50 test cases passed but still it is giving wrong answer"
                    },
                    {
                        "username": "tolanCode",
                        "content": "beginWord =\\n\"hot\"\\nendWord =\\n\"dog\"\\nwordList =\\n[\"hot\",\"dog\",\"dot\"]\\n\\n13 / 50 testcases passed\\n\\nOutput\\n0\\nExpected\\n3\\n\\nI\\'m confused about this due to the fact it\\'s saying the constraint is there is only one letter difference between adjacent words, but between \\'hot\\' and \\'dog\\' is 2 letters difference.  this doesn\\'t seem to fit the description that states:\\n\"Every adjacent pair of words differs by a single letter.\"\\nis this something wrong with the expected output? or are we supposed to allow changing of more than one letter?"
                    },
                    {
                        "username": "ankurg03",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nHow come expected output is 2, Shouldn\\'t it be 1, as the only single char is different between \\'a\\' and \\'c\\'.?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "anujjindal7",
                        "content": "\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nhot -> dot -> dog\\nAnswer should be 2 as far as I understood question, but expected 3.\\n![image](https://assets.leetcode.com/users/images/681688a2-40d7-442b-b681-8ca38c02cb2a_1610220667.2644837.png)\\n"
                    },
                    {
                        "username": "nvkleban",
                        "content": "I\\'m wondering why in this test case, expected answer is 2?\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nWe can directrly transform from `a` to `c` in only 1 transformation. And it will be a shortest path. What i\\'m doing wrong?\\n"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "shuvra7",
                        "content": "Can anyone please explain the following case:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nwhy does the result is 2 in this case?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    }
                ]
            },
            {
                "id": 1573787,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1573733,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1573236,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1572760,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1572650,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1572543,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1572345,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1572257,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1572162,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1572127,
                "content": [
                    {
                        "username": "__key_",
                        "content": "case 1:\\n\"leet\"\\n\"code\"\\n[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nOutput: leet->lest->lose->lode->code\\n4\\nExpected:\\n6\\n\\ncase 2: \\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nOutput: hit->hot->lot->log->cog\\n4\\nExpected:\\n5\\n\\ncase 3: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"cog\",\"pot\",\"dot\"]\\n\\nOutput:\\n2\\nExpected:\\n3\\n\\ncase 4: \\n\"hot\"\\n\"dog\"\\n[\"hot\",\"dog\",\"dot\"]\\n\\nOutput:\\n2\\nExpected: \\n3\\n\\ncase 5:\\n\"hot\"\\n\"dot\"\\n[\"hot\",\"dot\",\"dog\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\ncase 6:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nOutput:\\n1\\nExpected:\\n2\\n\\n\\nReference: https://leetcode.com/problems/word-ladder/discuss/638432/Please-update-the-test-cases-as-many-test-cases-contain-incorrect-target-solutions\\n"
                    },
                    {
                        "username": "dpjha84",
                        "content": "Can somebody prove why DFS can\\'t solve this problem?"
                    },
                    {
                        "username": "senseofgeek",
                        "content": "Input:\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput:\\n1\\nExpected:\\n2\\n\\nHow expected is 2 here, I think in 1 step we can reach \"c\""
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2."
                    },
                    {
                        "username": "snyder91",
                        "content": "The test case for a -> c with wordList as [a, b, c] should be 1 since we can change a directly to c. The test case expects the length to be 2. Is that correct ? Why is a -> b -> c correct answer for this ?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "wrenhh",
                        "content": "Since String.equals() is used in the first approach, should the time complexity be O(N * M * M)? In worst case N words are traversed in BFS, and each word has M possible variations, and inside the loop, String.equals() is used to compare with the endWord. Am I missing something here?"
                    },
                    {
                        "username": "zajun123",
                        "content": "When I first solve this problem, I use single BFS and it passed. But when I re-do this problem recently, it turns out that I used the same algorithn, but I got LTE, and when I look at other\\'s solution in the discussion, I use almost the same algorithm with them.\\nBut then, I found that the method\\'s signature was public int ladderLength(String start, String end, Set<String> dict), but now they changed to public int ladderLength(String start, String end, List<String> dict), which leads one of my check wordList.contains(nextString) become linear time complexity. So, I use HashSet instead of list for wordList, and it passed."
                    },
                    {
                        "username": "rq2144",
                        "content": "\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nwhy expected output is 2?"
                    },
                    {
                        "username": "programmervipul",
                        "content": "Please read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why answer is 2."
                    },
                    {
                        "username": "mrahman",
                        "content": "Why one earth the expected output is 3 for this input?\n\n\"hot\"\n\"dog\"\n[\"hot\",\"dog\",\"dot\"]\n\nSupposed to be 2.\n\"dot\"->\"dog\" \n"
                    },
                    {
                        "username": "bereshine",
                        "content": "I see many solutions in discussions changed the wordList from a list to a set at first. I know you will get a TLE if you do not change it to set. Is it just because the set spends less time to find a certain word in the wordList?\\n\\ndef ladderLength(self, beginWord, endWord, wordList):\\n        wordList = set(wordList)"
                    },
                    {
                        "username": "charleszhou327",
                        "content": "\"hit\"\\n\"hit\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\\n\\nShould return 0 since endWord (hit) is not in the wordList, but the sample return is 1"
                    }
                ]
            },
            {
                "id": 1571265,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1571266,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1571268,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1571270,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1571271,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1571274,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1570398,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1569912,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1571273,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1576372,
                "content": [
                    {
                        "username": "_durgaganesh_",
                        "content": "What's the rationale behind changing the wordList from a set to a vector/list?"
                    },
                    {
                        "username": "dragonhunter",
                        "content": "Something wrong with the following test case? From my understanding hit->hot->dot->dog->cog is a correct answer. So in this case, the ladder length should be 5. Am I missing something?\\n\\n\\nInput:\\n\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\nOutput:\\n5\\nExpected:\\n0"
                    },
                    {
                        "username": "ElderG",
                        "content": "\"hit\"\\n\"cog\"\\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\\n\\nfor above input\\n\\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\\n\\nshould be 5 instead of 0"
                    },
                    {
                        "username": "gg2529",
                        "content": "beginWord = \"hot\"\\nendWord = \"dog\"\\n\\ndict = [\"hot\", \"dog\"]"
                    },
                    {
                        "username": "nanomag0",
                        "content": "I saw the algorithm of two ends BFS. it enumerate all possible 26 char for each letter of one word. There are 26^k total possible branches for each word of length k.\\nFor English word, the average length is 8.2-letter long. For 8-letter word, there is about 2*10^11 possible variants. It doesn't look optimum to me."
                    },
                    {
                        "username": "abhay_11",
                        "content": "I was doing the problem : **http://oj.leetcode.com/problems/word-ladder/**, in which I applied BFS type approach on an undirected graph.. For the given test case (attached below) I think we can achieve the transformation in a single step, by going from **\"a\" - > \"c\"** , wherein both the said words exist in the dictionary , and the resulting transformation requires minimum steps. Why is the answer then **2**?\\n\\nInput:\\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\n\\nOutput:\\t1\\n\\nExpected:\\t2"
                    },
                    {
                        "username": "inspiro",
                        "content": "Endstring should always be in wordlist as mentioned in question."
                    },
                    {
                        "username": "Vi_ral95",
                        "content": "I see here everyone is doing a BFS. I tried doing a DFS and get a wrong solution for very large test cases but not sure why. Would a DFS work here?\\n\\nThanks"
                    },
                    {
                        "username": "ruparel",
                        "content": "Input: \\t\"a\", \"c\", [\"a\",\"b\",\"c\"]\\nOutput: \\t1\\nExpected: \\t2\\n\\n\"a\" can be changed to \"c\" by changing only one character. So minimum number of transformations must be 1."
                    },
                    {
                        "username": "Huds0n",
                        "content": "**The question might break my streak so far this month.** Really good question but tough to solve."
                    }
                ]
            },
            {
                "id": 1574275,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 1574052,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 1571267,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 2065019,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 2063501,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 2058958,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 2053840,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 2042855,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 2040320,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 2036603,
                "content": [
                    {
                        "username": "oizu",
                        "content": "Could somebody explain me why \"a\" to \"c\" requires 2 transformations?\\n\\nWrong Answer\\nDetails \\nInput\\n\"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\nOutput\\n1\\nExpected\\n2\\nTime Submitted\\nStatus\\nRuntime\\nMemory\\nLanguage\\n08/24/2020 23:02\\tWrong Answer\\tN/A\\tN/A\\tjava"
                    },
                    {
                        "username": "aj07",
                        "content": "Strongly feel diff level should have been hard"
                    },
                    {
                        "username": "stree13",
                        "content": "I am not sure why my result is wrong. Why the expected output is \"2\"? It should be 1.  \\n![0_1492219557887_Screen Shot 2017-04-14 at 9.25.22 PM.jpg](/uploads/files/1492219556953-screen-shot-2017-04-14-at-9.25.22-pm.jpg)"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "What is the TC for pattern creation and BFS approach for this problem?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "It is a complete copy of the problem 433. Minimum Genetic Mutation,\\nbut with a little bit stricter runtime requirements.\\n"
                    },
                    {
                        "username": "SouthernHumor",
                        "content": "I get an error in the following test case, saying it should return 6 and NOT 5:\\nbeginWord =\"leet\"\\nendWord =\"code\"\\nwordList =[\"lest\",\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\\n\\nThe main issue is moving from word \"lest\" to \"lose\", which is just 1 char different. I think Leetcode may have worded the problem wrong, OR the test case answer is wrong. \"lest\" and \"lose\" are ordered differently, but they only differ by 1 letter, and should be valid.\\n\\n\\n"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "Isn\\'t it more simpler than Minimum Genetic Mutation problem (https://leetcode.com/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)?"
                    },
                    {
                        "username": "soam_singh",
                        "content": "#18 Test-case not clear\\n\\nbeginWord = \"hot\"\\nendWord = \"dog\"\\n\\nwordList = [\"hot\",\"dog\",\"dot\"]\\n\\nExpected output is 3 but my solution and intuition says 2 is the right answer. \\n\\n\"hot\" -> \"dot\" -> \"dog\" would be the right order of transformation applied for this test-case. Can you point me in the right direction? \\n\\nThanks\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "This is to level order traveral, but very difficult to recognise"
                    },
                    {
                        "username": "sansshobhit",
                        "content": "Can someone please explain the test case \\n\\ns = \"hot\"\\ne = \"dog\"\\nwl=[\"hot\", \"dog\"]\\n\\nExpected output is 0. How?"
                    }
                ]
            },
            {
                "id": 2034573,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 2019634,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 2008895,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 2000613,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 1985791,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 1970096,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 1969943,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 1966934,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 1948209,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 1939807,
                "content": [
                    {
                        "username": "Nurbolatsnk",
                        "content": "Interesting, can we combine trie and dfs here"
                    },
                    {
                        "username": "lin25_",
                        "content": "\"differs by a single letter\"\\nwas not clear that order matters (i.e. lest and lose actually would not count)"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I got TLE error but showing passed 51/51 cases and error input, result is empty."
                    },
                    {
                        "username": "pengzuo",
                        "content": "[@EdChaparro](/EdChaparro) slightly will not work, must change to adjency list to map for(char ch = \\'a\\' ; ch <= \\'z\\' ; ch++)"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "I\\'ve gotten this on other test runs.  I assume LeetCode has an undocumented max aggregate time -- I don\\'t know for sure.  I\\'ve gotten around this problem by improving [slightly] the performance of my solution.  "
                    },
                    {
                        "username": "loser_complex",
                        "content": "I\\'ve written a code using set and queues, and on submitting it says 51/51 test cases passed but with a TLE message and the last executed input is empty. What is this supposed to mean?"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "Take a picture and frame it."
                    },
                    {
                        "username": "charant587",
                        "content": "didn\\'t understood the question button here.\\n\\n\\u2B07"
                    },
                    {
                        "username": "rraj09102002",
                        "content": "had a hard time understanding this question"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Just for curiosity, \nCan't we solve it like making an adjacency list and traversing like any other graph question\n\n\nUpdate : \nWe can solve by this way But it will give TLE"
                    },
                    {
                        "username": "prajapatimohit",
                        "content": "TLE on Test case 50. But it also says Test cases passed 50/50"
                    },
                    {
                        "username": "programmervipul",
                        "content": "For anyone, facing problem in following testcase: \"a\"\\n\"c\"\\n[\"a\",\"b\",\"c\"]\\n\\nPlease read the question carefully. We need to return the number of words in the shortest transformation sequence from beginWord to endWord. For example, the transformation sequence in your test case will be \"a\"->\"c\" and it contains two words(beginWord and endWord). That\\'s why the answer is 2.\\n\\n\\n\\n"
                    },
                    {
                        "username": "tangjm5",
                        "content": "Why is it that marking words as visited just before adding them to the queue is more efficient than marking words as visited after removing them them from the queue?"
                    }
                ]
            },
            {
                "id": 1939411,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1937444,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1935869,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1932120,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1913950,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1891231,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1876332,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1866891,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1836620,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1811578,
                "content": [
                    {
                        "username": "adj2908",
                        "content": "I am getting TLE on the below code, can someone please help me to debug this.\n`\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> visited=new HashSet<>();\n        HashSet<String> words=new HashSet<>();\n        for(String word:wordList){\n            words.add(word);\n        }\n        Queue<Node>qu=new LinkedList<>();\n        qu.add(new Node(beginWord,1));\n        visited.add(beginWord);\n        if(!words.contains(endWord)){\n            return 0;\n        }\n        while(!qu.isEmpty()){\n            Node temp=qu.remove();\n            String str=temp.word;\n            for(int i=0;i<str.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    String newWord=str.substring(0,i)+ch+\"\"+str.substring(i+1);\n                    if(visited.contains(newWord) || !wordList.contains(newWord)){\n                        continue;\n                    }\n                    visited.add(newWord);\n                    if(newWord.equals(endWord)){\n                        return temp.distance+1;\n                    }\n                    System.out.println(newWord);\n                    qu.add(new Node(newWord,temp.distance+1));\n                }\n            }\n        }\n        return 0;\n    }\n}\n`"
                    },
                    {
                        "username": "f20212839",
                        "content": "trying to get all the pairs of string which differ in one letter gives tle "
                    },
                    {
                        "username": "ramneet_17",
                        "content": "What is the 50th test case m unble to see it and it says TLE on 50th test case can anyone help??"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Tips to solve this one:\n1. `Think about the problem as a graph`: Each word in the `wordList` can be considered as a node in a graph, and two nodes are connected if their corresponding words differ by only one letter. The problem then becomes finding the shortest path between the `beginWord` and the `endWord` in this graph.\n\n2. Consider using `bidirectional BFS`: Instead of using regular BFS to search from the `beginWord` to the `endWord`, consider using bidirectional BFS to search from both ends simultaneously. This can reduce the search space and avoid unnecessary branching.\nClick here for a [cookie](https://leetcode.com/problems/word-ladder/solutions/3645819/python-simple-and-clean/) !🍪"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "Never would've thought to say that but this is not hard )))"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Literally the same problem:\\n[433. Minimum Genetic Mutation](https://leetcode.com/problems/minimum-genetic-mutation/description/)"
                    },
                    {
                        "username": "mishra-akash",
                        "content": "\\nclass Solution {\\n\\n    static class Pair{\\n        String word;\\n        int length;\\n        Pair(String word,int length){\\n            this.word=word;\\n            this.length=length;\\n        } \\n    }\\n\\n   public  boolean hasEdge(String s1,String s2){\\n       int diff=0;\\n       for(int i=0;i<s1.length();i++){\\n          \\n           while( s1.charAt(i) != s2.charAt(i) ){\\n               diff++;\\n           }\\n           \\n       }\\n       return (diff==1);\\n   }\\n\\n\\n    public int ladderLength(String src, String dest, List<String> dict) {\\n     \\n     Queue<Pair> q=new ArrayDeque<>();\\n     q.add(new Pair(src,0));\\n     \\n    HashMap<String,Integer> map=new HashMap<>();\\n\\n        while(q.size()>0){\\n\\n            Pair p=q.remove();\\n\\n            if(map.containsKey(p.word)==true)continue;\\n\\n            if( p.word.equals(dest))\\n                               return p.length;\\n             map.put(p.word,p.length);\\n\\n            for(String each:dict){\\n                if( hasEdge(p.word,each)==true){\\n                   // if(set.contains(each))continue;\\n                    q.add(new Pair(each,p.length+1));\\n                   \\n                }\\n            }\\n            \\n            \\n        }\\n         return -1;\\n        \\n    }\\n}\\n\\n\\nWHATS WRONG HERE??"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "BFS passed 50/50 on first try, but TLE. Can\\'t be bothered to optimize."
                    },
                    {
                        "username": "AlecLC",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "my first time reading this question and im hating it already"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Don\\'t be discouraged! After peeling the disguise away, it\\'s a very typical Breath-First Search problem. Give it a shot!"
                    }
                ]
            },
            {
                "id": 1799726,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1799456,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1792877,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1769137,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1768460,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1766325,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1756445,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1737422,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1722038,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            },
            {
                "id": 1718858,
                "content": [
                    {
                        "username": "EdChaparro",
                        "content": "`\"Every adjacent pair of words differs by a single letter.\"`\n\nWhat does that requirement mean -- precisely?\n\nFor example:\nGiven a word  list of [\"leet\",\"lose\",\"code\",\"lode\",\"robe\",\"lost\"]\n\nand a Begin Word of \"lest\"...\n\nMy code considered a transformation of  \"lest\" -> \"lose\" to be perfectly valid since there is only a SINGLE letter  difference  between the words (\"o\" instead of \"t\").   But, that yields a shorter transformation sequence count than what is expected by one of the test cases.  If I exclude \"lose\" and instead choose \"lost\" that yields the expected transformation sequence count.  FYI:  \"leet\" is another transformation candidate.\n\nAfter reviewing the examples closer, I'm wondering if the other [unspecified] valid transformation criteria is that the matching letters must be in the same relative position as the Begin Word.   This seems to be supported by the examples provided, but is not explicitly stated as a requirement.  FWIW, English is my native language.  Did I overlook something?  Can anyone confirm this is a requirement?\n"
                    },
                    {
                        "username": "EdChaparro",
                        "content": "Having solved the problem, I\\'m answering my own question in case others have the same -- a valid word transformation can only differ by single letter AND the unchanged letters must be in the same position as the source word.  E.g., \"lest\" -> \"lose\" is not valid because although the set of letters only differ by one, the unchanged letters don\\'t line up with the origin word.   In contrast, \"lest\" -> \"lost\" is a valid transformation.  There is only a single letter difference, and the remaining  unaltered letters are in the same relative position as the origin word."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "should be labeled medium"
                    },
                    {
                        "username": "its_oByes",
                        "content": "where i am wrong ?\\n\\n\\nclass Solution {\\npublic:\\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\\n      queue<pair<string ,int>>q;\\n       q.push({beginWord,1});\\n      unordered_set<string>st(wordList.begin(),wordList.end());\\n      st.erase(beginWord);\\n      while(!q.empty())\\n      {\\n          string str1=q.front().first;\\n          int cnt=q.front().second;\\n          q.pop();\\n          if(str1==endWord) return cnt;\\n          for( int i{0};i<str1.size();i++)\\n          { \\n              char ori=str1[i];\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n               str1[i]=ch;\\n            \\n            if(   st.find(str1)!=st.end() )\\n             {\\n                 \\n                  st.erase(str1);\\n                  cnt++;\\n\\n                  q.push({str1,cnt});\\n             }\\n    \\n            }\\n            str1[i]=ori;\\n         }\\n      }\\n      return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Ajay_jangid",
                        "content": "why getting TLE for DFS solution rather than BFS:-\\n\\n ```#define trav(A) for(auto x:A)\\nclass Solution {\\npublic:\\nint mini = INT_MAX;\\nvoid dfs(string s, string &eword, unordered_map<string, bool> &m, int len)\\n{\\n    m[s] = 0;\\n    if (s == eword)\\n    {\\n        m[s] = 1;\\n        mini = min(len, mini);\\n        return;\\n    }\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        char og = s[i];\\n        for (int j = 0; j < 26; j++)\\n        {\\n            char c = \\'a\\' + j;\\n            s[i] = c;\\n            if (c != og and m[s])\\n            {\\n                dfs(s, eword, m, len + 1);\\n            }\\n        }\\n        s[i] = og;\\n    }\\n    m[s] = 1;\\n}\\n    int ladderLength(string b, string e, vector<string>& list) {\\n            mini = INT_MAX;\\n           unordered_map<string, bool> m;\\n           trav(list) m[x] = 1;\\n           dfs(b, e, m, 1);\\n           if (mini == INT_MAX)\\n                  return 0;\\n    \\n           return mini;\\n     }\\n};```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "user5248P",
                        "content": "This problem was a bit silly. For my solution to work in time limit I had to do was use an adjacently list instead of matrix. All other optimizations weren\\'t necessary"
                    },
                    {
                        "username": "iscreamsandwitch",
                        "content": "The test cases are all over the place!!!"
                    },
                    {
                        "username": "cholanvijaya",
                        "content": "beginWord =\"a\" , endWord = \"c\" and wordList = [\"a\",\"b\",\"c\"] - for this input the expected output is 2 . \\nI am not able to understand the expected output of 2 where as we can replace a by c directly and  we can achieve this 1 iteration right . Can some one help me to understand why the answer is not 1 but 2."
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "Is `\"hot\"` and `\"tod\"` not words with one letter difference ?\\ncan anyone also tell me how the expected output for ```[\"hot\",\"tod\",\"dog\",\"log\",\"cog\"]``` is 0"
                    },
                    {
                        "username": "kiethuynh",
                        "content": "Hi all,\\n\\nProbably a stupid question but would appreciate if someone could help me understand.  For this problem, what makes BFS better than DFS with memoization in terms of Time Complexity ? \\nWith memoization, it\\'s pretty much guaranteed that a node is not calculated more than once. To me, we traverse the same number of edges (can be N*N) with the two approaches?\\n\\nRegards,\\n\\nKiet"
                    }
                ]
            }
        ]
    }
]