[
    {
        "title": "Number of Times a Driver Was a Passenger",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Closest Node to Path in Tree",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1987557,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "It would only be hard if O(N^2) were not be an option,imo"
                    },
                    {
                        "username": "as9vd2",
                        "content": "Agree, the only difficult part of it IMO is the length of the final solution."
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@unordered_set](/unordered_set) Harder than a typical medium but there is no fancy algorithm.If you know bfs and dfs in depth,it is straight-forward.Binary lifting solution is hard"
                    },
                    {
                        "username": "unordered_set",
                        "content": "[@stefan](/stefan1096) So according to you it should be marked as Medium??"
                    }
                ]
            }
        ]
    },
    {
        "title": "Design a Text Editor",
        "question_content": "<p>Design a text editor with a cursor that can do the following:</p>\n\n<ul>\n\t<li><strong>Add</strong> text to where the cursor is.</li>\n\t<li><strong>Delete</strong> text from where the cursor is (simulating the backspace key).</li>\n\t<li><strong>Move</strong> the cursor either left or right.</li>\n</ul>\n\n<p>When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that <code>0 &lt;= cursor.position &lt;= currentText.length</code> always holds.</p>\n\n<p>Implement the <code>TextEditor</code> class:</p>\n\n<ul>\n\t<li><code>TextEditor()</code> Initializes the object with empty text.</li>\n\t<li><code>void addText(string text)</code> Appends <code>text</code> to where the cursor is. The cursor ends to the right of <code>text</code>.</li>\n\t<li><code>int deleteText(int k)</code> Deletes <code>k</code> characters to the left of the cursor. Returns the number of characters actually deleted.</li>\n\t<li><code>string cursorLeft(int k)</code> Moves the cursor to the left <code>k</code> times. Returns the last <code>min(10, len)</code> characters to the left of the cursor, where <code>len</code> is the number of characters to the left of the cursor.</li>\n\t<li><code>string cursorRight(int k)</code> Moves the cursor to the right <code>k</code> times. Returns the last <code>min(10, len)</code> characters to the left of the cursor, where <code>len</code> is the number of characters to the left of the cursor.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;TextEditor&quot;, &quot;addText&quot;, &quot;deleteText&quot;, &quot;addText&quot;, &quot;cursorRight&quot;, &quot;cursorLeft&quot;, &quot;deleteText&quot;, &quot;cursorLeft&quot;, &quot;cursorRight&quot;]\n[[], [&quot;leetcode&quot;], [4], [&quot;practice&quot;], [3], [8], [10], [2], [6]]\n<strong>Output</strong>\n[null, null, 4, null, &quot;etpractice&quot;, &quot;leet&quot;, 4, &quot;&quot;, &quot;practi&quot;]\n\n<strong>Explanation</strong>\nTextEditor textEditor = new TextEditor(); // The current text is &quot;|&quot;. (The &#39;|&#39; character represents the cursor)\ntextEditor.addText(&quot;leetcode&quot;); // The current text is &quot;leetcode|&quot;.\ntextEditor.deleteText(4); // return 4\n                          // The current text is &quot;leet|&quot;. \n                          // 4 characters were deleted.\ntextEditor.addText(&quot;practice&quot;); // The current text is &quot;leetpractice|&quot;. \ntextEditor.cursorRight(3); // return &quot;etpractice&quot;\n                           // The current text is &quot;leetpractice|&quot;. \n                           // The cursor cannot be moved beyond the actual text and thus did not move.\n                           // &quot;etpractice&quot; is the last 10 characters to the left of the cursor.\ntextEditor.cursorLeft(8); // return &quot;leet&quot;\n                          // The current text is &quot;leet|practice&quot;.\n                          // &quot;leet&quot; is the last min(10, 4) = 4 characters to the left of the cursor.\ntextEditor.deleteText(10); // return 4\n                           // The current text is &quot;|practice&quot;.\n                           // Only 4 characters were deleted.\ntextEditor.cursorLeft(2); // return &quot;&quot;\n                          // The current text is &quot;|practice&quot;.\n                          // The cursor cannot be moved beyond the actual text and thus did not move. \n                          // &quot;&quot; is the last min(10, 0) = 0 characters to the left of the cursor.\ntextEditor.cursorRight(6); // return &quot;practi&quot;\n                           // The current text is &quot;practi|ce&quot;.\n                           // &quot;practi&quot; is the last min(10, 6) = 6 characters to the left of the cursor.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= text.length, k &lt;= 40</code></li>\n\t<li><code>text</code> consists of lowercase English letters.</li>\n\t<li>At most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>addText</code>, <code>deleteText</code>, <code>cursorLeft</code> and <code>cursorRight</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Could you find a solution with time complexity of <code>O(k)</code> per call?</p>\n",
        "solutions": [
            {
                "id": 2111861,
                "title": "using-two-stacks-c",
                "content": "**Always maintain the left part of string in left stack and right part of the string in right stack which are divided  by the cursor**\\n\\n**1)** **Add operation:** Push string character by character to the left stack.\\n**2)** **Deletion operation:** Pop characters from the left stack and return the number of characters popped.\\n**3)** **Cursor movement to left:** Pop elements from left stack and push in right stack.\\n**4)** **Cursor movement to right:** Pop elements from right stack and push in left stack. \\n\\n```\\nclass TextEditor {\\n    stack<char> left;\\n    stack<char> right;\\npublic:\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        for(auto &c : text){\\n            left.push(c);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt=0;\\n        while(!left.empty() and k>0){\\n            left.pop();\\n            cnt++;\\n            k--;\\n        }\\n        return cnt;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(!left.empty() and k>0){\\n            char c = left.top();left.pop();\\n            right.push(c);\\n            k--;\\n        }\\n\\t\\t// returning the last min(10, len) characters to the left of the cursor\\n        return cursorShiftString();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(!right.empty() and k>0){\\n            char c = right.top();right.pop();\\n            left.push(c);\\n            k--;\\n        }\\n\\t\\t// returning the last min(10, len) characters to the left of the cursor\\n        return cursorShiftString();\\n    }\\n    \\n\\t// function to return the last min(10, len) characters to the left of the cursor\\n    string cursorShiftString(){\\n        string rtn = \"\";\\n        int cnt=10;\\n        while(!left.empty() and cnt>0){\\n            char c = left.top();left.pop();\\n            rtn += c;\\n            cnt--;\\n        }\\n        reverse(rtn.begin(),rtn.end());\\n        for(int i=0;i<rtn.size();i++){\\n            left.push(rtn[i]);\\n        }\\n        return rtn;\\n    }\\n};\\n```\\n\\n**Time Complexity of each operation:**\\n```addText(string text) : O(n) {where n == length of text}```\\n```deleteText(int k) : O(k)```\\n```cursorLeft(int k) : O(k)```\\n```cursorRight(int k) : O(k)```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor {\\n    stack<char> left;\\n    stack<char> right;\\npublic:\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        for(auto &c : text){\\n            left.push(c);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt=0;\\n        while(!left.empty() and k>0){\\n            left.pop();\\n            cnt++;\\n            k--;\\n        }\\n        return cnt;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(!left.empty() and k>0){\\n            char c = left.top();left.pop();\\n            right.push(c);\\n            k--;\\n        }\\n\\t\\t// returning the last min(10, len) characters to the left of the cursor\\n        return cursorShiftString();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(!right.empty() and k>0){\\n            char c = right.top();right.pop();\\n            left.push(c);\\n            k--;\\n        }\\n\\t\\t// returning the last min(10, len) characters to the left of the cursor\\n        return cursorShiftString();\\n    }\\n    \\n\\t// function to return the last min(10, len) characters to the left of the cursor\\n    string cursorShiftString(){\\n        string rtn = \"\";\\n        int cnt=10;\\n        while(!left.empty() and cnt>0){\\n            char c = left.top();left.pop();\\n            rtn += c;\\n            cnt--;\\n        }\\n        reverse(rtn.begin(),rtn.end());\\n        for(int i=0;i<rtn.size();i++){\\n            left.push(rtn[i]);\\n        }\\n        return rtn;\\n    }\\n};\\n```\n```addText(string text) : O(n) {where n == length of text}```\n```deleteText(int k) : O(k)```\n```cursorLeft(int k) : O(k)```\n```cursorRight(int k) : O(k)```",
                "codeTag": "Java"
            },
            {
                "id": 2112623,
                "title": "two-strings",
                "content": "I originally solved it using a list, which was hard to debug. Then, I realized that two-string solution is much easier, and faster.\\n\\nThe complexity of `deleteText` is O(1), while other methods require `n` operations.\\n\\n> I am assuming that the resize operation is O(1) when decreasing the size. The actual implementation could be O(n).\\n> In principle, the `deleteText` operation can be O(1) - see the second solution with the custom memory management.\\n\\n**C++**\\n```cpp\\nstring before, after;\\nvoid addText(string text) {\\n    before.insert(end(before), begin(text), end(text));\\n}\\nint deleteText(int k) {\\n    k = min(k, (int)before.size());\\n    before.resize(before.size() - k);\\n    return k;\\n}\\nstring cursorLeft(int k) {\\n    while(k-- && !before.empty()) {\\n        after.push_back(before.back());\\n        before.pop_back();\\n    }\\n    return before.substr(before.size() - min((int)before.size(), 10));\\n}\\nstring cursorRight(int k) {\\n    while(k-- && !after.empty()) {\\n        before.push_back(after.back());\\n        after.pop_back();\\n    }\\n    return before.substr(before.size() - min((int)before.size(), 10));\\n}\\n```\\n#### O(1) deleteText \\nThis is just to demonstrate that this operation can be O(1), if we manage memory ourselves.\\n\\nThis solution is accepted with 350 ms runtime, which is the fastest of C++ solutions I checked so far (contest and disscuss posts).\\n\\n**C++**\\n```cpp\\nchar before[800000], after[800000];\\nclass TextEditor {\\npublic:\\nint sz_before = 0, sz_after = 0;\\nvoid addText(string text) {\\n    copy(begin(text), end(text), begin(before) + sz_before);\\n    sz_before += text.size();\\n}\\nint deleteText(int k) {\\n    k = min(k, sz_before);\\n    sz_before -= k;\\n    return k;\\n}\\nstring cursorLeft(int k) {\\n    for (k = min(k, sz_before); k > 0; --k)\\n        after[sz_after++] = before[--sz_before];\\n    return string(before + sz_before - min(sz_before, 10), before + sz_before);\\n}\\nstring cursorRight(int k) {\\n    for (k = min(k, sz_after); k > 0; --k)\\n        before[sz_before++] = after[--sz_after];\\n    return string(before + sz_before - min(sz_before, 10), before + sz_before);\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring before, after;\\nvoid addText(string text) {\\n    before.insert(end(before), begin(text), end(text));\\n}\\nint deleteText(int k) {\\n    k = min(k, (int)before.size());\\n    before.resize(before.size() - k);\\n    return k;\\n}\\nstring cursorLeft(int k) {\\n    while(k-- && !before.empty()) {\\n        after.push_back(before.back());\\n        before.pop_back();\\n    }\\n    return before.substr(before.size() - min((int)before.size(), 10));\\n}\\nstring cursorRight(int k) {\\n    while(k-- && !after.empty()) {\\n        before.push_back(after.back());\\n        after.pop_back();\\n    }\\n    return before.substr(before.size() - min((int)before.size(), 10));\\n}\\n```\n```cpp\\nchar before[800000], after[800000];\\nclass TextEditor {\\npublic:\\nint sz_before = 0, sz_after = 0;\\nvoid addText(string text) {\\n    copy(begin(text), end(text), begin(before) + sz_before);\\n    sz_before += text.size();\\n}\\nint deleteText(int k) {\\n    k = min(k, sz_before);\\n    sz_before -= k;\\n    return k;\\n}\\nstring cursorLeft(int k) {\\n    for (k = min(k, sz_before); k > 0; --k)\\n        after[sz_after++] = before[--sz_before];\\n    return string(before + sz_before - min(sz_before, 10), before + sz_before);\\n}\\nstring cursorRight(int k) {\\n    for (k = min(k, sz_after); k > 0; --k)\\n        before[sz_before++] = after[--sz_after];\\n    return string(before + sz_before - min(sz_before, 10), before + sz_before);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111909,
                "title": "java-my-simple-solution",
                "content": "```\\nclass TextEditor {\\n    StringBuilder res;\\n    int pos=0;\\n    \\n    public TextEditor() {\\n        res = new StringBuilder();\\n    }\\n    \\n    public void addText(String text) {\\n        res.insert(pos,text);\\n        pos += text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int tmp = pos;\\n        pos -= k;\\n        if(pos<0) pos=0;\\n        res.delete(pos,tmp);\\n        return tmp-pos;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        pos-=k;\\n        if(pos<0) pos = 0;\\n        if(pos<10) return res.substring(0,pos);\\n        return res.substring(pos-10,pos);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        pos+=k;\\n        if(pos>res.length()) pos = res.length();\\n        if(pos<10) return res.substring(0,pos);\\n        return res.substring(pos-10,pos);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n    StringBuilder res;\\n    int pos=0;\\n    \\n    public TextEditor() {\\n        res = new StringBuilder();\\n    }\\n    \\n    public void addText(String text) {\\n        res.insert(pos,text);\\n        pos += text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int tmp = pos;\\n        pos -= k;\\n        if(pos<0) pos=0;\\n        res.delete(pos,tmp);\\n        return tmp-pos;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        pos-=k;\\n        if(pos<0) pos = 0;\\n        if(pos<10) return res.substring(0,pos);\\n        return res.substring(pos-10,pos);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        pos+=k;\\n        if(pos>res.length()) pos = res.length();\\n        if(pos<10) return res.substring(0,pos);\\n        return res.substring(pos-10,pos);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045030,
                "title": "solution",
                "content": "```C++ []\\nclass TextEditor {\\npublic:\\n    string ltext = \"\", rtext=\"\";\\n    TextEditor() {}\\n    \\n    void addText(string text) {\\n        ltext += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        k = min(k, (int) ltext.size());\\n        ltext.resize(ltext.size() - k);\\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        for(;k > 0 && !ltext.empty(); ltext.pop_back(), k--)\\n            rtext.push_back(ltext.back());\\n            \\n        return ltext.size() >= 10 ? ltext.substr(ltext.size()-10, 10): ltext;\\n    }\\n    \\n    string cursorRight(int k) {\\n        for(;k > 0 && !rtext.empty(); rtext.pop_back(), k--)\\n            ltext.push_back(rtext.back());\\n        \\n        return ltext.size() >= 10 ? ltext.substr(ltext.size()-10, 10): ltext;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        self.left.append(text)\\n        \\n    def deleteText(self, k: int) -> int:\\n        total = 0\\n        while k:\\n            if not self.left:\\n                break\\n            s = self.left.pop()\\n            if len(s) > k:\\n                s = s[:-k]\\n                self.left.append(s)\\n                total +=k\\n                break\\n            k -= len(s)\\n            total += len(s)\\n        return total\\n\\n    def cursorLeft(self, k: int) -> str:\\n        total = 0\\n        while k:\\n            if not self.left:\\n                break\\n            s = self.left.pop()\\n            if len(s) > k:\\n                self.left.append(s[:-k])\\n                self.right.appendleft(s[-k:])\\n                break\\n            self.right.appendleft(s)\\n            k -= len(s)\\n        return self.get()\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        total = 0\\n        while k:\\n            if not self.right:\\n                break\\n            s = self.right.popleft()\\n            if len(s) > k:\\n                self.left.append(s[:k])\\n                self.right.appendleft(s[k:])\\n                break\\n            self.left.append(s)\\n            k -= len(s)\\n        return self.get()\\n    \\n    def get(self):\\n        ans = \\'\\'\\n        i = len(self.left) - 1\\n        while i >= 0 and len(ans) < 10:\\n            ans = self.left[i] + ans\\n            i -= 1\\n        return ans[-10:]\\n```\\n\\n```Java []\\nclass TextEditor {\\n    char buffer[];\\n    int left;\\n    int right;\\n    public TextEditor() {\\n        buffer = new char[800000];\\n        left = 0;\\n        right = buffer.length-1;\\n    }\\n    \\n    public void addText(String text) {\\n        for(char c : text.toCharArray()){\\n            buffer[left] = c;\\n            left++;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        if(k>left)k=left;\\n        left-=k;\\n        return k;\\n    }\\n    \\n    public String cursorLeft(int k) {                \\n        k = Math.min(k,left);\\n        while(k>0){\\n            left--;k--;\\n            buffer[right] = buffer[left];\\n            right--;\\n        }\\n        int len = Math.min(10,left);\\n        StringBuilder sb = new StringBuilder();\\n        int i = left;\\n        while(len!=0){\\n            len--;i--;\\n            sb.append(buffer[i]);\\n        }\\n        return sb.reverse().toString();        \\n    }\\n    \\n    public String cursorRight(int k) {\\n        int charOnRight = buffer.length - right -1;\\n        k = Math.min(k,charOnRight);\\n        while(k>0){\\n            k--;\\n            right++;            \\n            buffer[left] = buffer[right];\\n            left++;\\n        }\\n        int len = Math.min(10,left);\\n        int i = left;\\n        StringBuilder sb = new StringBuilder();\\n        while(len!=0){\\n            len--;i--;\\n            sb.append(buffer[i]);\\n        }\\n        return sb.reverse().toString();\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass TextEditor {\\npublic:\\n    string ltext = \"\", rtext=\"\";\\n    TextEditor() {}\\n    \\n    void addText(string text) {\\n        ltext += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        k = min(k, (int) ltext.size());\\n        ltext.resize(ltext.size() - k);\\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        for(;k > 0 && !ltext.empty(); ltext.pop_back(), k--)\\n            rtext.push_back(ltext.back());\\n            \\n        return ltext.size() >= 10 ? ltext.substr(ltext.size()-10, 10): ltext;\\n    }\\n    \\n    string cursorRight(int k) {\\n        for(;k > 0 && !rtext.empty(); rtext.pop_back(), k--)\\n            ltext.push_back(rtext.back());\\n        \\n        return ltext.size() >= 10 ? ltext.substr(ltext.size()-10, 10): ltext;\\n    }\\n};\\n```\n```Python3 []\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        self.left.append(text)\\n        \\n    def deleteText(self, k: int) -> int:\\n        total = 0\\n        while k:\\n            if not self.left:\\n                break\\n            s = self.left.pop()\\n            if len(s) > k:\\n                s = s[:-k]\\n                self.left.append(s)\\n                total +=k\\n                break\\n            k -= len(s)\\n            total += len(s)\\n        return total\\n\\n    def cursorLeft(self, k: int) -> str:\\n        total = 0\\n        while k:\\n            if not self.left:\\n                break\\n            s = self.left.pop()\\n            if len(s) > k:\\n                self.left.append(s[:-k])\\n                self.right.appendleft(s[-k:])\\n                break\\n            self.right.appendleft(s)\\n            k -= len(s)\\n        return self.get()\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        total = 0\\n        while k:\\n            if not self.right:\\n                break\\n            s = self.right.popleft()\\n            if len(s) > k:\\n                self.left.append(s[:k])\\n                self.right.appendleft(s[k:])\\n                break\\n            self.left.append(s)\\n            k -= len(s)\\n        return self.get()\\n    \\n    def get(self):\\n        ans = \\'\\'\\n        i = len(self.left) - 1\\n        while i >= 0 and len(ans) < 10:\\n            ans = self.left[i] + ans\\n            i -= 1\\n        return ans[-10:]\\n```\n```Java []\\nclass TextEditor {\\n    char buffer[];\\n    int left;\\n    int right;\\n    public TextEditor() {\\n        buffer = new char[800000];\\n        left = 0;\\n        right = buffer.length-1;\\n    }\\n    \\n    public void addText(String text) {\\n        for(char c : text.toCharArray()){\\n            buffer[left] = c;\\n            left++;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        if(k>left)k=left;\\n        left-=k;\\n        return k;\\n    }\\n    \\n    public String cursorLeft(int k) {                \\n        k = Math.min(k,left);\\n        while(k>0){\\n            left--;k--;\\n            buffer[right] = buffer[left];\\n            right--;\\n        }\\n        int len = Math.min(10,left);\\n        StringBuilder sb = new StringBuilder();\\n        int i = left;\\n        while(len!=0){\\n            len--;i--;\\n            sb.append(buffer[i]);\\n        }\\n        return sb.reverse().toString();        \\n    }\\n    \\n    public String cursorRight(int k) {\\n        int charOnRight = buffer.length - right -1;\\n        k = Math.min(k,charOnRight);\\n        while(k>0){\\n            k--;\\n            right++;            \\n            buffer[left] = buffer[right];\\n            left++;\\n        }\\n        int len = Math.min(10,left);\\n        int i = left;\\n        StringBuilder sb = new StringBuilder();\\n        while(len!=0){\\n            len--;i--;\\n            sb.append(buffer[i]);\\n        }\\n        return sb.reverse().toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111918,
                "title": "c-stl-list-char",
                "content": "```\\nclass TextEditor {\\nprivate:\\n    list<char>a;\\n    // If delete, will delete position cur - 1, not position cur.\\n    list<char>::iterator cur;\\npublic:\\n    TextEditor() {\\n        a.clear();\\n        // For convenience.\\n        a.push_back(\\'A\\');\\n        cur = a.end();\\n    }\\n    \\n    void addText(string text) {\\n        a.insert(cur, text.begin(), text.end());\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt = 0;\\n        // Move to the position that will be deleted.\\n        cur--;\\n        while(k--){\\n            if(cur==a.begin())break;\\n            cnt++;\\n            a.erase(cur--);\\n        }\\n        // Adjust the position of the cursor.\\n        cur++;\\n        return cnt;\\n    }\\n    \\n    // Left 10 chars.\\n    string solve() {\\n        auto tt = cur;\\n        tt--;\\n        string ret;\\n        int k = 10;\\n        while(k--){\\n            if(tt==a.begin())break;\\n            ret += (*(tt--));\\n        }\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k--){\\n            auto nxt = cur;\\n            nxt--;\\n            // Never move the cursor to the first position.\\n            if(nxt==a.begin())break;\\n            cur = nxt;\\n        }\\n        return solve();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k--){\\n            if(cur==a.end())break;\\n            cur++;\\n        }\\n        return solve();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TextEditor {\\nprivate:\\n    list<char>a;\\n    // If delete, will delete position cur - 1, not position cur.\\n    list<char>::iterator cur;\\npublic:\\n    TextEditor() {\\n        a.clear();\\n        // For convenience.\\n        a.push_back(\\'A\\');\\n        cur = a.end();\\n    }\\n    \\n    void addText(string text) {\\n        a.insert(cur, text.begin(), text.end());\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt = 0;\\n        // Move to the position that will be deleted.\\n        cur--;\\n        while(k--){\\n            if(cur==a.begin())break;\\n            cnt++;\\n            a.erase(cur--);\\n        }\\n        // Adjust the position of the cursor.\\n        cur++;\\n        return cnt;\\n    }\\n    \\n    // Left 10 chars.\\n    string solve() {\\n        auto tt = cur;\\n        tt--;\\n        string ret;\\n        int k = 10;\\n        while(k--){\\n            if(tt==a.begin())break;\\n            ret += (*(tt--));\\n        }\\n        reverse(ret.begin(), ret.end());\\n        return ret;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k--){\\n            auto nxt = cur;\\n            nxt--;\\n            // Never move the cursor to the first position.\\n            if(nxt==a.begin())break;\\n            cur = nxt;\\n        }\\n        return solve();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k--){\\n            if(cur==a.end())break;\\n            cur++;\\n        }\\n        return solve();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112501,
                "title": "tle-with-contest-winner-s-solution",
                "content": "I am not sure why he get AC but I get TLE by just copying his codes.\\n\\nCopied from ranked 1 (`__declspec`)\\nhttps://leetcode.com/contest/weekly-contest-296/ranking/\\n\\nThis is my submission\\nhttps://leetcode.com/submissions/detail/714697648/\\n\\nAnd his submission\\nhttps://leetcode.com/contest/weekly-contest-296/submissions/detail/714590990/\\n\\nThis is not fair because some can get AC from slower algo but some cannot.\\n\\n```\\nclass TextEditor {\\n    string s;\\n    int pos ;\\npublic:\\n    TextEditor() {\\n        pos = 0;\\n    }\\n    \\n    void addText(string text) {\\n        s.insert(pos, text);\\n        pos += text.size();\\n        // cout << \"add\" << endl;\\n    }\\n    \\n    int deleteText(int k) {\\n        int ans = 0;\\n        while (pos != 0 && ans < k) {\\n            s.erase(pos-1, 1);\\n            --pos;\\n            ++ans;\\n        }\\n        // cout << \"delet\" << endl;\\n        return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        // cout << \"r\" << endl;\\n        pos = max(pos-k, 0);\\n        string res;\\n        for (int i = pos-10; i < pos; ++i) if (i >= 0) res += s[i];\\n        return res;\\n    }\\n    \\n    string cursorRight(int k) {\\n        // cout << \"R\" << endl;\\n        pos = min(pos+k, int(s.size()));\\n        string res;\\n        for (int i = pos-10; i < pos; ++i) if (i >= 0) res += s[i];\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass TextEditor {\\n    string s;\\n    int pos ;\\npublic:\\n    TextEditor() {\\n        pos = 0;\\n    }\\n    \\n    void addText(string text) {\\n        s.insert(pos, text);\\n        pos += text.size();\\n        // cout << \"add\" << endl;\\n    }\\n    \\n    int deleteText(int k) {\\n        int ans = 0;\\n        while (pos != 0 && ans < k) {\\n            s.erase(pos-1, 1);\\n            --pos;\\n            ++ans;\\n        }\\n        // cout << \"delet\" << endl;\\n        return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        // cout << \"r\" << endl;\\n        pos = max(pos-k, 0);\\n        string res;\\n        for (int i = pos-10; i < pos; ++i) if (i >= 0) res += s[i];\\n        return res;\\n    }\\n    \\n    string cursorRight(int k) {\\n        // cout << \"R\" << endl;\\n        pos = min(pos+k, int(s.size()));\\n        string res;\\n        for (int i = pos-10; i < pos; ++i) if (i >= 0) res += s[i];\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 2112018,
                "title": "python-simple-solution",
                "content": "The approach that I am using is string slicing. So that would end up with `O(n)` time for all the operations. The following implementation seems to pass without any TLE.  I will update this post once I find a more optimized solution.\\n\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.s = \\'\\'\\n        self.cursor = 0\\n\\n    def addText(self, text: str) -> None:\\n        self.s = self.s[:self.cursor] + text + self.s[self.cursor:]\\n        self.cursor += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        new_cursor = max(0, self.cursor - k)\\n        noOfChars = k if self.cursor - k >= 0 else self.cursor\\n        self.s = self.s[:new_cursor] + self.s[self.cursor:]\\n        self.cursor = new_cursor\\n        return noOfChars\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor = max(0, self.cursor - k)\\n        start = max(0, self.cursor-10)\\n        return self.s[start:self.cursor]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor = min(len(self.s), self.cursor + k)\\n        start = max(0, self.cursor - 10)\\n        return self.s[start:self.cursor]\\n```\\n\\n**Time - O(n)** - for all operations\\n**Space - O(n)** - store the string\\n\\n\\n---\\n\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.s = \\'\\'\\n        self.cursor = 0\\n\\n    def addText(self, text: str) -> None:\\n        self.s = self.s[:self.cursor] + text + self.s[self.cursor:]\\n        self.cursor += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        new_cursor = max(0, self.cursor - k)\\n        noOfChars = k if self.cursor - k >= 0 else self.cursor\\n        self.s = self.s[:new_cursor] + self.s[self.cursor:]\\n        self.cursor = new_cursor\\n        return noOfChars\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor = max(0, self.cursor - k)\\n        start = max(0, self.cursor-10)\\n        return self.s[start:self.cursor]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor = min(len(self.s), self.cursor + k)\\n        start = max(0, self.cursor - 10)\\n        return self.s[start:self.cursor]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112082,
                "title": "simple-strings",
                "content": "Just keep two strings one which represent the text before the cursor and one which represent the text after(in reverse order for the after string) the cursor.\\n```\\nclass TextEditor {\\npublic:\\n    string bef, aft;\\n    TextEditor() {\\n        bef = \"\";\\n        aft = \"\";\\n    }\\n    \\n    void addText(string text) {\\n        bef += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        int mn = min(int(bef.length()), k);\\n        \\n        for(int i = 0; i < mn; ++i) bef.pop_back();\\n        \\n        return mn;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int mn = min(k, int(bef.length()));\\n        for(int i = 0; i < mn; ++i) {\\n            aft.push_back(bef.back());\\n            bef.pop_back();\\n        }\\n        \\n        int mxlen = min(10, int(bef.length()));\\n        \\n        return bef.substr(bef.length() - mxlen);\\n    }\\n    \\n    string cursorRight(int k) {\\n        int mn = min(k, int(aft.length()));\\n        for(int i = 0; i < mn; ++i) {\\n            bef.push_back(aft.back());\\n            aft.pop_back();\\n        }\\n        \\n        int mxlen = min(10, int(bef.length()));\\n        \\n        return bef.substr(bef.length() - mxlen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string bef, aft;\\n    TextEditor() {\\n        bef = \"\";\\n        aft = \"\";\\n    }\\n    \\n    void addText(string text) {\\n        bef += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        int mn = min(int(bef.length()), k);\\n        \\n        for(int i = 0; i < mn; ++i) bef.pop_back();\\n        \\n        return mn;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int mn = min(k, int(bef.length()));\\n        for(int i = 0; i < mn; ++i) {\\n            aft.push_back(bef.back());\\n            bef.pop_back();\\n        }\\n        \\n        int mxlen = min(10, int(bef.length()));\\n        \\n        return bef.substr(bef.length() - mxlen);\\n    }\\n    \\n    string cursorRight(int k) {\\n        int mn = min(k, int(aft.length()));\\n        for(int i = 0; i < mn; ++i) {\\n            bef.push_back(aft.back());\\n            aft.pop_back();\\n        }\\n        \\n        int mxlen = min(10, int(bef.length()));\\n        \\n        return bef.substr(bef.length() - mxlen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111867,
                "title": "java-stringbuilder-easy-to-understand",
                "content": "```\\nclass TextEditor\\n{\\n    StringBuilder sb; // Stores text\\n    int cur; // Current pointer location\\n    public TextEditor()\\n    {\\n        sb = new StringBuilder();\\n        cur = 0;\\n    }\\n    \\n    public void addText(String text)\\n    {\\n        sb.insert(cur,text);\\n        cur+= text.length(); // Shift pointer to the right of added text\\n    }\\n    \\n    public int deleteText(int k)\\n    {\\n        int l = Math.max(0,cur-k);\\n        int r = cur;\\n        sb.delete(l,r);\\n        cur = l; // Shift pointer to the left of deleted text\\n        return r-l;\\n    }\\n    \\n    public String cursorLeft(int k)\\n    {\\n        int start = Math.max(0,cur-k); // Maximum text present on the left\\n        cur = start; // Updates pointer\\n        int l = Math.max(0,cur-10);\\n        return sb.substring(l,cur);\\n    }\\n    \\n    public String cursorRight(int k)\\n    {\\n        int start = Math.min(sb.length(),cur+k); // Maximum text present on the right\\n        cur = start; // Updates pointer\\n        int r = Math.max(0,cur-10);\\n        return sb.substring(r,cur);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor\\n{\\n    StringBuilder sb; // Stores text\\n    int cur; // Current pointer location\\n    public TextEditor()\\n    {\\n        sb = new StringBuilder();\\n        cur = 0;\\n    }\\n    \\n    public void addText(String text)\\n    {\\n        sb.insert(cur,text);\\n        cur+= text.length(); // Shift pointer to the right of added text\\n    }\\n    \\n    public int deleteText(int k)\\n    {\\n        int l = Math.max(0,cur-k);\\n        int r = cur;\\n        sb.delete(l,r);\\n        cur = l; // Shift pointer to the left of deleted text\\n        return r-l;\\n    }\\n    \\n    public String cursorLeft(int k)\\n    {\\n        int start = Math.max(0,cur-k); // Maximum text present on the left\\n        cur = start; // Updates pointer\\n        int l = Math.max(0,cur-10);\\n        return sb.substring(l,cur);\\n    }\\n    \\n    public String cursorRight(int k)\\n    {\\n        int start = Math.min(sb.length(),cur+k); // Maximum text present on the right\\n        cur = start; // Updates pointer\\n        int r = Math.max(0,cur-10);\\n        return sb.substring(r,cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111988,
                "title": "c-with-explanation-implementation-doubly-ended-linked-list-o-k",
                "content": "**Observations**\\n1. Value of `k` <= 40. Hence, the solution need not be optimised.\\n2. Movement of cursor can be in both directions. Hence, something like Deque should work. \\n3. We can use doubly linkedlist to easily traverse in left/right direction.\\n\\n**Algorithm**\\n1. Consider \\'|\\' as the base address of the linkedlist. We will only store the position of this base address and modify characters against its position.\\n2. **addText(string):** Append characters one by one behind \\'|\\'. \\n3. **deleteText(int k):** Delete characters, if present, one by one behind \\'|\\'.\\n4. **cursorLeft(int k):** Store `k` elements present behind \\'|\\' in a queue and delete them. Add these `k` elements ahead of \\'|\\'. Now, to print `min(10, len)` characters behind \\'|\\',   iterate behind \\'|\\' (As we would do for a linkedlist)\\n5. **cursorLeft(int k):** Store `k` elements present after \\'|\\' in a queue and delete them. Add these `k` elements before \\'|\\'. Now, to print `min(10, len)` characters behind \\'|\\',   iterate behind \\'|\\' (As we would do for a linkedlist)\\n\\n**Code:**\\n```\\nclass Node {\\n    public:\\n        char data;\\n        Node* next;\\n        Node* prev;\\n    \\n    Node(char data) {\\n        this->data = data;\\n        this->next = NULL;\\n        this->prev = NULL;\\n    }\\n};\\nclass TextEditor {\\n    Node* head;\\npublic:\\n    TextEditor() {\\n        head = new Node(\\'|\\');\\n    }\\n    \\n    void addText(string text) {\\n        \\n        for(auto x:text) {\\n            Node* newNode = new Node(x);\\n            \\n            Node* previousNode = head->prev;\\n            if(previousNode) {\\n                previousNode->next = newNode;\\n            }\\n            newNode->prev = previousNode;\\n            newNode->next = head;\\n            head->prev = newNode;\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int count = 0;\\n        while(count < k && head->prev != NULL) {\\n            Node* previousNode = head->prev->prev;\\n            delete head->prev;\\n            \\n            if(previousNode)\\n                previousNode->next = head;\\n            head->prev = previousNode;\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int count = 0;\\n        queue<char> traversed;\\n        while(count < k && head->prev != NULL) {\\n            Node* previousNode = head->prev->prev;\\n            traversed.push(head->prev->data);\\n            delete head->prev;\\n            \\n            if(previousNode) {\\n                previousNode->next = head;   \\n            }\\n            head->prev = previousNode;\\n            \\n            count++;\\n        }\\n        \\n        while(!traversed.empty()) {\\n            Node* newNode = new Node(traversed.front());\\n            traversed.pop();\\n            \\n            Node* nextNode = head->next;\\n            newNode->next = nextNode;\\n            \\n            if(nextNode)\\n                nextNode->prev = newNode;\\n            \\n            head->next = newNode;\\n            newNode->prev = head;\\n        }\\n        \\n        Node* temp = head->prev;\\n        count = 0;\\n        \\n        string ans;\\n        while(count < 10 && temp != NULL) {\\n            ans.push_back(temp->data);\\n            count++;\\n            \\n            temp = temp->prev;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int count = 0;\\n        queue<char> traversed;\\n        while(count < k && head->next != NULL) {\\n            Node* nextNode = head->next->next;\\n            traversed.push(head->next->data);\\n            delete head->next;\\n            \\n            if(nextNode)\\n                nextNode->prev = head;\\n            head->next = nextNode;\\n            \\n            count++;\\n        }\\n        \\n        while(!traversed.empty()) {\\n            Node* newNode = new Node(traversed.front());\\n            traversed.pop();\\n            \\n            Node* prevNode = head->prev;\\n            newNode->prev = prevNode;\\n            if(prevNode)\\n                prevNode->next = newNode;\\n            \\n            head->prev = newNode;\\n            newNode->next = head;\\n        }\\n        \\n        Node* temp = head->prev;\\n        count = 0;\\n        \\n        string ans;\\n        while(count < 10 && temp != NULL) {\\n            ans.push_back(temp->data);\\n            count++;\\n            \\n            temp = temp->prev;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** \\n`addText(String s): O(s.len)`\\n`deleteText(int k): O(k)`\\n`cursorLeft(int k): O(k)`\\n`cursorRight(int k): O(k)`\\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Queue"
                ],
                "code": "```\\nclass Node {\\n    public:\\n        char data;\\n        Node* next;\\n        Node* prev;\\n    \\n    Node(char data) {\\n        this->data = data;\\n        this->next = NULL;\\n        this->prev = NULL;\\n    }\\n};\\nclass TextEditor {\\n    Node* head;\\npublic:\\n    TextEditor() {\\n        head = new Node(\\'|\\');\\n    }\\n    \\n    void addText(string text) {\\n        \\n        for(auto x:text) {\\n            Node* newNode = new Node(x);\\n            \\n            Node* previousNode = head->prev;\\n            if(previousNode) {\\n                previousNode->next = newNode;\\n            }\\n            newNode->prev = previousNode;\\n            newNode->next = head;\\n            head->prev = newNode;\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int count = 0;\\n        while(count < k && head->prev != NULL) {\\n            Node* previousNode = head->prev->prev;\\n            delete head->prev;\\n            \\n            if(previousNode)\\n                previousNode->next = head;\\n            head->prev = previousNode;\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int count = 0;\\n        queue<char> traversed;\\n        while(count < k && head->prev != NULL) {\\n            Node* previousNode = head->prev->prev;\\n            traversed.push(head->prev->data);\\n            delete head->prev;\\n            \\n            if(previousNode) {\\n                previousNode->next = head;   \\n            }\\n            head->prev = previousNode;\\n            \\n            count++;\\n        }\\n        \\n        while(!traversed.empty()) {\\n            Node* newNode = new Node(traversed.front());\\n            traversed.pop();\\n            \\n            Node* nextNode = head->next;\\n            newNode->next = nextNode;\\n            \\n            if(nextNode)\\n                nextNode->prev = newNode;\\n            \\n            head->next = newNode;\\n            newNode->prev = head;\\n        }\\n        \\n        Node* temp = head->prev;\\n        count = 0;\\n        \\n        string ans;\\n        while(count < 10 && temp != NULL) {\\n            ans.push_back(temp->data);\\n            count++;\\n            \\n            temp = temp->prev;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int count = 0;\\n        queue<char> traversed;\\n        while(count < k && head->next != NULL) {\\n            Node* nextNode = head->next->next;\\n            traversed.push(head->next->data);\\n            delete head->next;\\n            \\n            if(nextNode)\\n                nextNode->prev = head;\\n            head->next = nextNode;\\n            \\n            count++;\\n        }\\n        \\n        while(!traversed.empty()) {\\n            Node* newNode = new Node(traversed.front());\\n            traversed.pop();\\n            \\n            Node* prevNode = head->prev;\\n            newNode->prev = prevNode;\\n            if(prevNode)\\n                prevNode->next = newNode;\\n            \\n            head->prev = newNode;\\n            newNode->next = head;\\n        }\\n        \\n        Node* temp = head->prev;\\n        count = 0;\\n        \\n        string ans;\\n        while(count < 10 && temp != NULL) {\\n            ans.push_back(temp->data);\\n            count++;\\n            \\n            temp = temp->prev;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114754,
                "title": "simple-python-solution-2-stacks-o-k-time-where-k-n-o-n-space-complexity",
                "content": "Basic idea:\\n=====\\n1. Create two stacks, left and right. The \"left\" stack is left of cursor, while the \"right\" stack is right of cursor.\\n2. addText - we append characters to the \"left\" stack.\\n3. deleteText - we delete text by popping characters from the \"left\" stack.\\n4. cursorLeft - we move the cursor to the left by popping characters from the \"left\" stack, and pushing it to the \"right\" stack\\n5. cursorRight - we move the cursor to the right by popping characters from the \"right\" stack and pushing it to the \"left\" stack\\n\\nTime complexity is O(K) - where K is the length of the affected operations, e.g. number of characters of text to add / delete, number of times to move cursor left / right\\nSpace complexity is O(N)\\n\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.left.append(c)\\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        while len(self.left) > 0 and count < k:\\n            self.left.pop()\\n            count += 1\\n        return count\\n\\n    def cursorLeft(self, k: int) -> str:\\n        count = 0\\n        while len(self.left) > 0 and count < k:\\n            self.right.append(self.left.pop())\\n            count += 1\\n        return \\'\\'.join(self.left[max(0, len(self.left) - 10):])\\n\\n    def cursorRight(self, k: int) -> str:\\n        count = 0\\n        while len(self.right) > 0 and count < k:\\n            self.left.append(self.right.pop())\\n            count += 1\\n        return \\'\\'.join(self.left[max(0, len(self.left) - 10):])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.left.append(c)\\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        while len(self.left) > 0 and count < k:\\n            self.left.pop()\\n            count += 1\\n        return count\\n\\n    def cursorLeft(self, k: int) -> str:\\n        count = 0\\n        while len(self.left) > 0 and count < k:\\n            self.right.append(self.left.pop())\\n            count += 1\\n        return \\'\\'.join(self.left[max(0, len(self.left) - 10):])\\n\\n    def cursorRight(self, k: int) -> str:\\n        count = 0\\n        while len(self.right) > 0 and count < k:\\n            self.left.append(self.right.pop())\\n            count += 1\\n        return \\'\\'.join(self.left[max(0, len(self.left) - 10):])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112489,
                "title": "java-two-stacks-with-explanation",
                "content": "### Steps\\nKeep `left` and `right` stacks which are divided by cursor.\\n\\n- AddText(): push characters into `left` stack\\n- deleteText(): pop characters from `left` stack\\n- cursorRight(): pop characters from `right` stack, then push them to `left` stack \\n- cursorLeft(): pop characters from `left` stack, then push them to `right` stack \\n\\n\\n### How to return the left min(10, len) characters?\\n1. first pop the min(10, len) elements from left stack\\n2. then push it back so that the left stack remains the same state\\n3. return the elements as string in reverse order\\n\\nRefer to `getLeftString()` method\\n### Complexity\\n\\nTime Complexity:\\n- AddText(): `O(n)` where n is text length\\n- deleteText(): `O(k)`\\n- cursorRight(): `O(k)`\\n- cursorLeft(): `O(k)`\\n\\nSpace Complexity: \\n- `O(m)` where m is total text\\n---\\n### Java\\n```java\\nStack<Character> left = new Stack<>();\\nStack<Character> right = new Stack<>();\\n\\npublic void addText(String text) {\\n\\tfor (int i = 0; i < text.length(); i++) {\\n\\t\\tleft.push(text.charAt(i));\\n\\t}\\n}\\n\\npublic int deleteText(int k) {\\n\\tint cnt = 0;\\n\\twhile (!left.isEmpty() && k-- > 0) {\\n\\t\\tleft.pop();\\n\\t\\tcnt++;\\n\\t}\\n\\treturn cnt;\\n}\\n\\npublic String cursorLeft(int k) {\\n\\twhile (!left.isEmpty() && k-- > 0) {\\n\\t\\tright.push(left.pop());\\n\\t}\\n\\treturn getLeftString();\\n}\\n\\npublic String cursorRight(int k) {\\n\\twhile (!right.isEmpty() && k-- > 0) {\\n\\t\\tleft.push(right.pop());\\n\\t}\\n\\treturn getLeftString();\\n}\\n\\nString getLeftString() {\\n\\tint cnt = 10;\\n\\tStringBuilder sb = new StringBuilder();\\n\\twhile (!left.isEmpty() && cnt-- > 0) {\\n\\t\\tsb.append(left.pop());\\n\\t}\\n\\n\\tfor (int i = sb.length() - 1; i >= 0; i--) {\\n\\t\\tleft.push(sb.charAt(i));\\n\\t}\\n\\treturn sb.reverse().toString();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nStack<Character> left = new Stack<>();\\nStack<Character> right = new Stack<>();\\n\\npublic void addText(String text) {\\n\\tfor (int i = 0; i < text.length(); i++) {\\n\\t\\tleft.push(text.charAt(i));\\n\\t}\\n}\\n\\npublic int deleteText(int k) {\\n\\tint cnt = 0;\\n\\twhile (!left.isEmpty() && k-- > 0) {\\n\\t\\tleft.pop();\\n\\t\\tcnt++;\\n\\t}\\n\\treturn cnt;\\n}\\n\\npublic String cursorLeft(int k) {\\n\\twhile (!left.isEmpty() && k-- > 0) {\\n\\t\\tright.push(left.pop());\\n\\t}\\n\\treturn getLeftString();\\n}\\n\\npublic String cursorRight(int k) {\\n\\twhile (!right.isEmpty() && k-- > 0) {\\n\\t\\tleft.push(right.pop());\\n\\t}\\n\\treturn getLeftString();\\n}\\n\\nString getLeftString() {\\n\\tint cnt = 10;\\n\\tStringBuilder sb = new StringBuilder();\\n\\twhile (!left.isEmpty() && cnt-- > 0) {\\n\\t\\tsb.append(left.pop());\\n\\t}\\n\\n\\tfor (int i = sb.length() - 1; i >= 0; i--) {\\n\\t\\tleft.push(sb.charAt(i));\\n\\t}\\n\\treturn sb.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112167,
                "title": "memory-limit-exceeded-for-hidden-test-cases",
                "content": "Basic simple string manipulation techniques, with an ans string and a temporary string variable. cur is used to store the index of the cursor. \\n70/75 test cases passed.\\n\\nCan anyone tell how can I improve the space complexity in this approach, if it is possible?\\nAlso the text length was supposed to be <= 40.\\n```\\nclass TextEditor {\\npublic:\\n    int cur;\\n    string str, temp;\\n    TextEditor() {\\n        str = \"\";\\n        cur = 0;\\n    }\\n    \\n    void addText(string text) {\\n        int len = str.length();\\n        temp = str.substr(0,cur)+text+str.substr(cur,len-cur);\\n        str = temp;\\n        cur = cur+text.length();\\n    }\\n    \\n    int deleteText(int k) {\\n        int len = str.length();\\n        if(k>=cur){\\n            str = str.substr(cur,len-cur);\\n            int val = cur;\\n            cur = 0;\\n            return val;\\n        }   \\n        else\\n            temp = str.substr(0,cur-k)+str.substr(cur,len-cur);\\n        str = temp;\\n        cur -= k;\\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        if(cur-k >= 0)\\n            cur -= k;\\n        else\\n            cur = 0;\\n        temp = str.substr(0,cur);\\n        if(temp.length() < 10)\\n            return temp;\\n        else\\n            temp = temp.substr(temp.length()-10,10);\\n        return temp;\\n    }\\n    \\n    string cursorRight(int k) {\\n        if(cur+k < str.length())\\n            cur += k;\\n        else\\n            cur = str.length();\\n        temp = str.substr(0,cur);\\n        if(temp.length() < 10)\\n            return temp;\\n        else\\n            temp = temp.substr(temp.length()-10,10);\\n        return temp;\\n    }\\n};\\n```\\n\\n**Update** I found that using normal insert() and erase() functions alone could have got the work done. And using substr is using some extra space, so I guess that is why it led to MLE.\\nThank you !",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    int cur;\\n    string str, temp;\\n    TextEditor() {\\n        str = \"\";\\n        cur = 0;\\n    }\\n    \\n    void addText(string text) {\\n        int len = str.length();\\n        temp = str.substr(0,cur)+text+str.substr(cur,len-cur);\\n        str = temp;\\n        cur = cur+text.length();\\n    }\\n    \\n    int deleteText(int k) {\\n        int len = str.length();\\n        if(k>=cur){\\n            str = str.substr(cur,len-cur);\\n            int val = cur;\\n            cur = 0;\\n            return val;\\n        }   \\n        else\\n            temp = str.substr(0,cur-k)+str.substr(cur,len-cur);\\n        str = temp;\\n        cur -= k;\\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        if(cur-k >= 0)\\n            cur -= k;\\n        else\\n            cur = 0;\\n        temp = str.substr(0,cur);\\n        if(temp.length() < 10)\\n            return temp;\\n        else\\n            temp = temp.substr(temp.length()-10,10);\\n        return temp;\\n    }\\n    \\n    string cursorRight(int k) {\\n        if(cur+k < str.length())\\n            cur += k;\\n        else\\n            cur = str.length();\\n        temp = str.substr(0,cur);\\n        if(temp.length() < 10)\\n            return temp;\\n        else\\n            temp = temp.substr(temp.length()-10,10);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915730,
                "title": "python-3-solution-beat-95-using-stack-and-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\naddText: O(n)\\ndeleteText: O(k)\\ncursorLeft: O(k)\\ncursorRight: O(k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.stack = []\\n        self.q = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.stack.append(c)\\n\\n        #return \"\".join(self.stack)\\n        \\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while self.stack and i < k:\\n            self.stack.pop()\\n            i += 1\\n        return i\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while self.stack and i < k:\\n            self.q.appendleft(self.stack.pop())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while self.q and i < k:\\n            self.stack.append(self.q.popleft())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \\n            \\n\\n\\n\\n       \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.stack = []\\n        self.q = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.stack.append(c)\\n\\n        #return \"\".join(self.stack)\\n        \\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while self.stack and i < k:\\n            self.stack.pop()\\n            i += 1\\n        return i\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while self.stack and i < k:\\n            self.q.appendleft(self.stack.pop())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while self.q and i < k:\\n            self.stack.append(self.q.popleft())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \\n            \\n\\n\\n\\n       \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113901,
                "title": "using-stl-list",
                "content": "Using Basic STL List inbuilt functions and list::iterator arithmetics.\\n\\n```\\n// Ishwar Govind\\nclass TextEditor {\\npublic:\\n    list<char> txt;  // The data storage\\n    list<char>::iterator cur;  // Current position of cursor\\n    \\n    TextEditor() {\\n        txt.push_back(\\'|\\');   // Initial State of Text editor\\n        cur = txt.begin(); \\n    }\\n    \\n    void addText(string text) {\\n        for(auto x:text){\\n            txt.insert(cur,x);      // insert using STL inbuilt insert function\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        auto it = cur;\\n        it--;\\n        int ans = 0 ;\\n        while(k>0 && it!=txt.end()){            // Use erase function until text beginning or till number of backspaces \\n            it = txt.erase(it);\\n            ans++;\\n            k--;\\n            it--;\\n        }\\n        return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        string ans = \"\";\\n        auto it = cur;it--;\\n        if(it==txt.end()) return ans;           // nothing behind cursor\\n        \\n        it = txt.erase(cur);\\n        while(k>0){                             // go left till last element or till number of <- keypress\\n            auto it2 = it; it2--;\\n            if(it2==txt.end()) break;\\n            else it--;\\n            k--;\\n        }\\n        cur = txt.insert(it,\\'|\\');\\n        \\n        int n = 10;                            // get last min(10,len) string\\n        it = cur;it--;\\n        for(;it!=txt.end()&&n>0;it--){\\n            ans += *it;\\n            n--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        string ans = \"\";\\n        auto it = txt.erase(cur);              // drop cursor move right k times or till end then insert cursor\\n        while(it!=txt.end() && k>0){\\n            it++;\\n            k--;\\n        }\\n        cur = txt.insert(it,\\'|\\');\\n        \\n        int n = 10;                         // get last min(10,len) string\\n        it = cur; it--;\\n        for( ; it!=txt.end() && n>0 ;it--){\\n            ans += *it;\\n            n--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Ishwar Govind\\nclass TextEditor {\\npublic:\\n    list<char> txt;  // The data storage\\n    list<char>::iterator cur;  // Current position of cursor\\n    \\n    TextEditor() {\\n        txt.push_back(\\'|\\');   // Initial State of Text editor\\n        cur = txt.begin(); \\n    }\\n    \\n    void addText(string text) {\\n        for(auto x:text){\\n            txt.insert(cur,x);      // insert using STL inbuilt insert function\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        auto it = cur;\\n        it--;\\n        int ans = 0 ;\\n        while(k>0 && it!=txt.end()){            // Use erase function until text beginning or till number of backspaces \\n            it = txt.erase(it);\\n            ans++;\\n            k--;\\n            it--;\\n        }\\n        return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        string ans = \"\";\\n        auto it = cur;it--;\\n        if(it==txt.end()) return ans;           // nothing behind cursor\\n        \\n        it = txt.erase(cur);\\n        while(k>0){                             // go left till last element or till number of <- keypress\\n            auto it2 = it; it2--;\\n            if(it2==txt.end()) break;\\n            else it--;\\n            k--;\\n        }\\n        cur = txt.insert(it,\\'|\\');\\n        \\n        int n = 10;                            // get last min(10,len) string\\n        it = cur;it--;\\n        for(;it!=txt.end()&&n>0;it--){\\n            ans += *it;\\n            n--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        string ans = \"\";\\n        auto it = txt.erase(cur);              // drop cursor move right k times or till end then insert cursor\\n        while(it!=txt.end() && k>0){\\n            it++;\\n            k--;\\n        }\\n        cur = txt.insert(it,\\'|\\');\\n        \\n        int n = 10;                         // get last min(10,len) string\\n        it = cur; it--;\\n        for( ; it!=txt.end() && n>0 ;it--){\\n            ans += *it;\\n            n--;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112689,
                "title": "python-2-solutions-doubly-linked-list-2-queues",
                "content": "## Doubly linked list\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.cursor = Node(-1)\\n        \\n    def addText(self, text: str) -> None:\\n        curr = self.cursor\\n        last = curr.right\\n        for c in text:\\n            curr.right = Node(c)\\n            curr.right.left = curr\\n            curr = curr.right\\n        curr.right = last\\n        if last:\\n            last.left = curr\\n        self.cursor = curr\\n        \\n    def deleteText(self, k: int) -> int:\\n        curr = self.cursor\\n        last = curr.right\\n        tot = 0\\n        while k and curr.val != -1:\\n            curr = curr.left\\n            k -= 1\\n            tot += 1\\n        if last:\\n            last.left = curr\\n        curr.right = last\\n        self.cursor = curr\\n        return tot\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.cursor.val != -1:\\n            self.cursor = self.cursor.left\\n            k -= 1\\n        return self.getvals(self.cursor)\\n    \\n    def cursorRight(self, k: int) -> str:\\n        while k and self.cursor.right:\\n            self.cursor = self.cursor.right\\n            k -= 1\\n        return self.getvals(self.cursor)\\n    \\n    def getvals(self, curr):\\n        vals = deque()\\n        k = 10\\n        while k and curr.val != -1:\\n            vals.appendleft(curr.val)\\n            curr = curr.left\\n            k -= 1\\n        return \"\".join(vals)\\n```\\n\\n\\n## 2 queues\\n```\\nclass TextEditor:\\n    def __init__(self):\\n        self.left = deque()\\n        self.right = deque()\\n        \\n    def addText(self, text: str) -> None:\\n        self.left.extend(list(text))\\n\\n    def deleteText(self, k: int) -> int:\\n        tot = 0\\n        while k and self.left:\\n            self.left.pop()\\n            k -= 1\\n            tot +=1\\n        return tot\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.left:\\n            self.right.appendleft(self.left.pop())\\n            k -= 1\\n        return self.getvals()\\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.right:\\n            self.left.append(self.right.popleft())\\n            k -= 1\\n        return self.getvals()\\n        \\n    def getvals(self):\\n        N = len(self.left) \\n        return \"\".join(self.left[i] for i in range(max(N-10, 0), N))\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.cursor = Node(-1)\\n        \\n    def addText(self, text: str) -> None:\\n        curr = self.cursor\\n        last = curr.right\\n        for c in text:\\n            curr.right = Node(c)\\n            curr.right.left = curr\\n            curr = curr.right\\n        curr.right = last\\n        if last:\\n            last.left = curr\\n        self.cursor = curr\\n        \\n    def deleteText(self, k: int) -> int:\\n        curr = self.cursor\\n        last = curr.right\\n        tot = 0\\n        while k and curr.val != -1:\\n            curr = curr.left\\n            k -= 1\\n            tot += 1\\n        if last:\\n            last.left = curr\\n        curr.right = last\\n        self.cursor = curr\\n        return tot\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.cursor.val != -1:\\n            self.cursor = self.cursor.left\\n            k -= 1\\n        return self.getvals(self.cursor)\\n    \\n    def cursorRight(self, k: int) -> str:\\n        while k and self.cursor.right:\\n            self.cursor = self.cursor.right\\n            k -= 1\\n        return self.getvals(self.cursor)\\n    \\n    def getvals(self, curr):\\n        vals = deque()\\n        k = 10\\n        while k and curr.val != -1:\\n            vals.appendleft(curr.val)\\n            curr = curr.left\\n            k -= 1\\n        return \"\".join(vals)\\n```\n```\\nclass TextEditor:\\n    def __init__(self):\\n        self.left = deque()\\n        self.right = deque()\\n        \\n    def addText(self, text: str) -> None:\\n        self.left.extend(list(text))\\n\\n    def deleteText(self, k: int) -> int:\\n        tot = 0\\n        while k and self.left:\\n            self.left.pop()\\n            k -= 1\\n            tot +=1\\n        return tot\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.left:\\n            self.right.appendleft(self.left.pop())\\n            k -= 1\\n        return self.getvals()\\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.right:\\n            self.left.append(self.right.popleft())\\n            k -= 1\\n        return self.getvals()\\n        \\n    def getvals(self):\\n        N = len(self.left) \\n        return \"\".join(self.left[i] for i in range(max(N-10, 0), N))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112166,
                "title": "simple-java-solution-using-stringbuffer",
                "content": "```\\nclass TextEditor {\\n    StringBuffer sb = new StringBuffer();\\n    int cursor = 0;\\n    public TextEditor() {\\n        sb = new StringBuffer();\\n        cursor = 0;\\n    }\\n    \\n    public void addText(String text) {\\n        sb.insert(cursor, text);\\n        cursor=cursor+text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int old = cursor;\\n        sb.delete(Math.max(0,cursor-k),cursor);\\n        cursor = Math.max(0,cursor-k);\\n        return old-cursor;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor = Math.max(0,cursor-k);\\n        return getLast10Characters();\\n    }\\n    \\n    public String cursorRight(int k) {\\n\\n        cursor = Math.min(sb.length(), cursor+k);\\n        return getLast10Characters();\\n    }\\n    String getLast10Characters(){\\n        int start = Math.max(0, cursor-10);\\n        return sb.substring(start, cursor);\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass TextEditor {\\n    StringBuffer sb = new StringBuffer();\\n    int cursor = 0;\\n    public TextEditor() {\\n        sb = new StringBuffer();\\n        cursor = 0;\\n    }\\n    \\n    public void addText(String text) {\\n        sb.insert(cursor, text);\\n        cursor=cursor+text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int old = cursor;\\n        sb.delete(Math.max(0,cursor-k),cursor);\\n        cursor = Math.max(0,cursor-k);\\n        return old-cursor;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor = Math.max(0,cursor-k);\\n        return getLast10Characters();\\n    }\\n    \\n    public String cursorRight(int k) {\\n\\n        cursor = Math.min(sb.length(), cursor+k);\\n        return getLast10Characters();\\n    }\\n    String getLast10Characters(){\\n        int start = Math.max(0, cursor-10);\\n        return sb.substring(start, cursor);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2484331,
                "title": "python-clean-and-easy-solution-2-stacks-solution",
                "content": "The idea is very simple: divide the text into two parts: left (text before the cursor) and right(text after the cursor)\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        self.left.extend(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        for i in range(k):\\n            if self.left:\\n                self.left.pop()\\n            else:\\n                return i\\n        return k\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for i in range(k):\\n            if self.left:\\n                self.right.append(self.left.pop())\\n            else:\\n                break\\n        return \\'\\'.join(self.left[-10:])\\n\\n    def cursorRight(self, k: int) -> str:\\n        for i in range(k):\\n            if self.right:\\n                self.left.append(self.right.pop())\\n            else:\\n                break\\n        return \\'\\'.join(self.left[-10:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        self.left.extend(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        for i in range(k):\\n            if self.left:\\n                self.left.pop()\\n            else:\\n                return i\\n        return k\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for i in range(k):\\n            if self.left:\\n                self.right.append(self.left.pop())\\n            else:\\n                break\\n        return \\'\\'.join(self.left[-10:])\\n\\n    def cursorRight(self, k: int) -> str:\\n        for i in range(k):\\n            if self.right:\\n                self.left.append(self.right.pop())\\n            else:\\n                break\\n        return \\'\\'.join(self.left[-10:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113021,
                "title": "easy-to-understand-c-solution-using-doubly-linkedlist-from-scratch",
                "content": "**Time Complexties of each function and their explaination**\\n*addText(string text):*  **O(text.length)** since we loop through each char and add it before the cursor, inserting a node in doubly linkedlist takes O(1) time since we just modify the links\\n\\n*deleteText(int k):* **O(k)** since k chars needs to be deleted and deletion of a node in doubly linkedlist also takes O(1) time\\n\\n*cursorLeft(int k):* **O(k)** \\n\\n*cursorRight(int k):* **O(k)** \\n\\n\\n```\\n// Using doubly linkedlist allows us to move the cursor back and front\\n\\n// Each letter in the text editor gets mapped to a Char node\\nclass Char{\\npublic:\\n    char c;\\n    Char *next,*prev;\\n    Char(char ch){\\n        c=ch;\\n        next=NULL;\\n        prev=NULL;\\n    }\\n    \\n};\\n\\nclass TextEditor {\\nprivate:\\n    // cursor indicates the \"|\" char and start is a dummy node to indicate start of text\\n    Char *cursor,*start;\\n    \\n    // the position \"|\" is currently at\\n    int pos;\\npublic:\\n    TextEditor() {\\n        // Initialize the linked list\\n        start=new Char(\\'S\\');\\n        cursor=new Char(\\'|\\');\\n        start->next=cursor;\\n        cursor->prev=start;\\n        //set the cursor position to 0\\n        pos=0;\\n    }\\n    \\n    void addText(string text) {\\n        // Increase the cursor position when adding text\\n        pos+=text.size();\\n        \\n        // for each char in the text, insert the char between the cursor and cursor\\'s previous node\\n        for(int i=0;i<text.size();i++){\\n            Char *c=new Char(text[i]);\\n            Char *p=cursor->prev;\\n            p->next=c;\\n            c->prev=p;\\n            c->next=cursor;\\n            cursor->prev=c;\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        // find the no. of chars which can be deleted \\n        int charsDeleted=min(pos,k);\\n        // move the cursor after deleting chars from editor\\n        pos-=charsDeleted;\\n        \\n        // each char should be deleted between the cursor and char\\'s previous node\\n        for(int i=1;i<=charsDeleted;i++){\\n            Char *c=cursor->prev;\\n            c->prev->next=c->next;\\n            c->next->prev=c->prev;\\n            delete c;\\n        }\\n        return charsDeleted;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        // find the number of moves  the cursor can move to left and update the cursor\\'s position\\n        int move=min(pos,k);\\n        pos-=move;\\n        \\n        // while moving to left the link should be modifed between cursor, cursor\\'s prev character and cursor\\'s prev and cursor\\'s prev\\'s prev chars\\n        for(int i=1;i<=move;i++){\\n            Char *one=cursor->prev->prev,*two=one->next;\\n            one->next=cursor;\\n            cursor->prev=one;\\n            two->next=cursor->next;\\n            two->prev=cursor;\\n            cursor->next=two;\\n        }\\n \\n        return lastTenChars();\\n    }\\n    \\n    // returns the last 10 chars in the editor if length of text in editor>10\\n    string lastTenChars(){\\n        string s=\"\";\\n        \\n        int move=min(10,pos);\\n        Char *ch=cursor;\\n        for(int i=1;i<=move;i++){\\n            ch=ch->prev;\\n            s=s+ch->c;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    \\n    \\n    string cursorRight(int k) {\\n        // move cursor by k chars to right\\n        for(int i=1;i<=k;i++){\\n            // if cursor reaches the end, don\\'t move any further\\n            if(cursor->next==NULL)\\n                break;\\n            \\n            // update position of cursor when moving to right\\n            pos+=1;\\n            Char *p=cursor->prev,*n=cursor->next;\\n\\n            p->next=cursor->next;\\n            n->prev=cursor->prev;\\n            cursor->next=n->next;\\n            n->next=cursor;\\n            cursor->prev=n;\\n        }\\n        return lastTenChars();\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Using doubly linkedlist allows us to move the cursor back and front\\n\\n// Each letter in the text editor gets mapped to a Char node\\nclass Char{\\npublic:\\n    char c;\\n    Char *next,*prev;\\n    Char(char ch){\\n        c=ch;\\n        next=NULL;\\n        prev=NULL;\\n    }\\n    \\n};\\n\\nclass TextEditor {\\nprivate:\\n    // cursor indicates the \"|\" char and start is a dummy node to indicate start of text\\n    Char *cursor,*start;\\n    \\n    // the position \"|\" is currently at\\n    int pos;\\npublic:\\n    TextEditor() {\\n        // Initialize the linked list\\n        start=new Char(\\'S\\');\\n        cursor=new Char(\\'|\\');\\n        start->next=cursor;\\n        cursor->prev=start;\\n        //set the cursor position to 0\\n        pos=0;\\n    }\\n    \\n    void addText(string text) {\\n        // Increase the cursor position when adding text\\n        pos+=text.size();\\n        \\n        // for each char in the text, insert the char between the cursor and cursor\\'s previous node\\n        for(int i=0;i<text.size();i++){\\n            Char *c=new Char(text[i]);\\n            Char *p=cursor->prev;\\n            p->next=c;\\n            c->prev=p;\\n            c->next=cursor;\\n            cursor->prev=c;\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        // find the no. of chars which can be deleted \\n        int charsDeleted=min(pos,k);\\n        // move the cursor after deleting chars from editor\\n        pos-=charsDeleted;\\n        \\n        // each char should be deleted between the cursor and char\\'s previous node\\n        for(int i=1;i<=charsDeleted;i++){\\n            Char *c=cursor->prev;\\n            c->prev->next=c->next;\\n            c->next->prev=c->prev;\\n            delete c;\\n        }\\n        return charsDeleted;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        // find the number of moves  the cursor can move to left and update the cursor\\'s position\\n        int move=min(pos,k);\\n        pos-=move;\\n        \\n        // while moving to left the link should be modifed between cursor, cursor\\'s prev character and cursor\\'s prev and cursor\\'s prev\\'s prev chars\\n        for(int i=1;i<=move;i++){\\n            Char *one=cursor->prev->prev,*two=one->next;\\n            one->next=cursor;\\n            cursor->prev=one;\\n            two->next=cursor->next;\\n            two->prev=cursor;\\n            cursor->next=two;\\n        }\\n \\n        return lastTenChars();\\n    }\\n    \\n    // returns the last 10 chars in the editor if length of text in editor>10\\n    string lastTenChars(){\\n        string s=\"\";\\n        \\n        int move=min(10,pos);\\n        Char *ch=cursor;\\n        for(int i=1;i<=move;i++){\\n            ch=ch->prev;\\n            s=s+ch->c;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    \\n    \\n    string cursorRight(int k) {\\n        // move cursor by k chars to right\\n        for(int i=1;i<=k;i++){\\n            // if cursor reaches the end, don\\'t move any further\\n            if(cursor->next==NULL)\\n                break;\\n            \\n            // update position of cursor when moving to right\\n            pos+=1;\\n            Char *p=cursor->prev,*n=cursor->next;\\n\\n            p->next=cursor->next;\\n            n->prev=cursor->prev;\\n            cursor->next=n->next;\\n            n->next=cursor;\\n            cursor->prev=n;\\n        }\\n        return lastTenChars();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112628,
                "title": "python-easy-to-understand-solution-string-operation",
                "content": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.txt = \\'\\'  \\n        self.ptr = 0  \\n\\n    def addText(self, text: str) -> None:\\n        self.txt = self.txt[:self.ptr] + text + self.txt[self.ptr:]\\n        self.ptr += len(text)  \\n\\n    def deleteText(self, k: int) -> int:\\n        org = len(self.txt)  \\n        self.txt = self.txt[:max(self.ptr - k, 0)] + self.txt[self.ptr:]\\n        self.ptr = max(self.ptr - k, 0)  \\n        return org - len(self.txt)\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.ptr = max(self.ptr - k, 0)  \\n        return self.txt[max(0, self.ptr - 10):self.ptr]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.ptr = min(self.ptr + k, len(self.txt))  \\n        return self.txt[max(0, self.ptr - 10):self.ptr]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.txt = \\'\\'  \\n        self.ptr = 0  \\n\\n    def addText(self, text: str) -> None:\\n        self.txt = self.txt[:self.ptr] + text + self.txt[self.ptr:]\\n        self.ptr += len(text)  \\n\\n    def deleteText(self, k: int) -> int:\\n        org = len(self.txt)  \\n        self.txt = self.txt[:max(self.ptr - k, 0)] + self.txt[self.ptr:]\\n        self.ptr = max(self.ptr - k, 0)  \\n        return org - len(self.txt)\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.ptr = max(self.ptr - k, 0)  \\n        return self.txt[max(0, self.ptr - 10):self.ptr]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.ptr = min(self.ptr + k, len(self.txt))  \\n        return self.txt[max(0, self.ptr - 10):self.ptr]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112441,
                "title": "clean-code-easy-to-understand-c-string-methods-simulation-well-commented",
                "content": "```\\nclass TextEditor {\\n    \\n    string s;\\n    int idx;\\n    int len;\\npublic:\\n    TextEditor() {\\n        s=\"\";\\n        idx=-1;\\n        len=0;\\n    }\\n    \\n    void addText(string text) {\\n        \\n        \\n        s.insert(idx+1,text);\\n        \\n        //moving the cursor to the desired position \\n        idx+=text.length();\\n        \\n        //incrementing the lenght\\n        len+=text.length();\\n        \\n        \\n    }\\n    \\n    int deleteText(int k) {\\n        \\n        //we can delete minimum of k characters \\n        int toDel=min(k,idx+1);\\n        \\n        //the erase function in c++ takes two params from (from which idx to delete ,how many chars to delete)\\n        s.erase(idx-toDel+1,toDel);\\n        \\n        //now move our cursor behind by  number of chars deleted \\n        idx=idx-toDel;\\n        \\n        //update the length\\n        len-=toDel;\\n        \\n        return toDel;\\n        \\n        \\n        \\n    }\\n    \\n    string cursorLeft(int k) {\\n        \\n        if(len==0) return \"\";\\n        \\n        \\n        //go left \\n        while(idx>=0 && k){\\n            idx--;\\n            k--;\\n        }\\n        \\n        \\n        //count chars to return \\n        int chars=min(10,idx+1);\\n        \\n        \\n        //fiding the start index \\n        int stIdx=idx-chars+1;\\n        \\n        return s.substr(stIdx,chars);\\n        \\n        return \"\";\\n        \\n        \\n        \\n    }\\n    \\n    string cursorRight(int k) {\\n        \\n        \\n        if(len==0) return \"\";\\n        \\n        while(idx<len-1 && k){\\n            idx++;\\n            k--;\\n        }\\n        \\n      \\n        \\n        \\n        int chars=min(10,idx+1);\\n        \\n        int stIdx=idx-chars+1;\\n        \\n        \\n        \\n        return s.substr(stIdx,chars);\\n        \\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```\\n\\n![image](https://assets.leetcode.com/users/images/204118e9-da3c-489e-b235-009fb3684be1_1654499206.749174.png)\\n**Sry guys its TLE ,I uploaded before it started giving TLE**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\n    \\n    string s;\\n    int idx;\\n    int len;\\npublic:\\n    TextEditor() {\\n        s=\"\";\\n        idx=-1;\\n        len=0;\\n    }\\n    \\n    void addText(string text) {\\n        \\n        \\n        s.insert(idx+1,text);\\n        \\n        //moving the cursor to the desired position \\n        idx+=text.length();\\n        \\n        //incrementing the lenght\\n        len+=text.length();\\n        \\n        \\n    }\\n    \\n    int deleteText(int k) {\\n        \\n        //we can delete minimum of k characters \\n        int toDel=min(k,idx+1);\\n        \\n        //the erase function in c++ takes two params from (from which idx to delete ,how many chars to delete)\\n        s.erase(idx-toDel+1,toDel);\\n        \\n        //now move our cursor behind by  number of chars deleted \\n        idx=idx-toDel;\\n        \\n        //update the length\\n        len-=toDel;\\n        \\n        return toDel;\\n        \\n        \\n        \\n    }\\n    \\n    string cursorLeft(int k) {\\n        \\n        if(len==0) return \"\";\\n        \\n        \\n        //go left \\n        while(idx>=0 && k){\\n            idx--;\\n            k--;\\n        }\\n        \\n        \\n        //count chars to return \\n        int chars=min(10,idx+1);\\n        \\n        \\n        //fiding the start index \\n        int stIdx=idx-chars+1;\\n        \\n        return s.substr(stIdx,chars);\\n        \\n        return \"\";\\n        \\n        \\n        \\n    }\\n    \\n    string cursorRight(int k) {\\n        \\n        \\n        if(len==0) return \"\";\\n        \\n        while(idx<len-1 && k){\\n            idx++;\\n            k--;\\n        }\\n        \\n      \\n        \\n        \\n        int chars=min(10,idx+1);\\n        \\n        int stIdx=idx-chars+1;\\n        \\n        \\n        \\n        return s.substr(stIdx,chars);\\n        \\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113264,
                "title": "java-simple-solution-stringbuilder",
                "content": "Starting the cursor from -1 position\\n```\\nclass TextEditor {\\n    \\n    private StringBuilder sb;\\n    private int cursor=-1;\\n    \\n    public TextEditor() {\\n        sb = new StringBuilder();\\n    }\\n    \\n    public void addText(String text) {\\n        sb.insert(cursor+1,text);\\n        cursor+=text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int count=0;\\n        while(cursor>=0&&k-->0){\\n            sb.deleteCharAt(cursor);\\n            count++;\\n            cursor--;\\n        }\\n        return count;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor = Math.max(-1,cursor-k);\\n        if(cursor==-1)\\n            return \"\";\\n        return sb.substring(cursor-Math.min(cursor,9),cursor+1);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        int n = sb.length();\\n        cursor = Math.min(cursor+k,n-1);\\n        if(cursor==-1)\\n            return \"\";\\n        return sb.substring(cursor-Math.min(cursor,9),cursor+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\n    \\n    private StringBuilder sb;\\n    private int cursor=-1;\\n    \\n    public TextEditor() {\\n        sb = new StringBuilder();\\n    }\\n    \\n    public void addText(String text) {\\n        sb.insert(cursor+1,text);\\n        cursor+=text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int count=0;\\n        while(cursor>=0&&k-->0){\\n            sb.deleteCharAt(cursor);\\n            count++;\\n            cursor--;\\n        }\\n        return count;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor = Math.max(-1,cursor-k);\\n        if(cursor==-1)\\n            return \"\";\\n        return sb.substring(cursor-Math.min(cursor,9),cursor+1);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        int n = sb.length();\\n        cursor = Math.min(cursor+k,n-1);\\n        if(cursor==-1)\\n            return \"\";\\n        return sb.substring(cursor-Math.min(cursor,9),cursor+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112267,
                "title": "c-implementation-using-two-deque-easy-to-understand",
                "content": "```\\nclass TextEditor {\\n    deque<char> l,r;\\npublic:\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        for(char ch:text)l.push_back(ch);\\n    }\\n    \\n    int deleteText(int k) {\\n        int ret=0;\\n        while(!l.empty()&&k--){\\n            l.pop_back();\\n            ++ret;\\n        }\\n        return ret;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k--&&!l.empty()){\\n            r.push_front(l.back());           \\n            l.pop_back();\\n        }\\n        return last_10();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k--&&r.size()){\\n            l.push_back(r.front());\\n            r.pop_front();\\n        }\\n        return last_10();\\n    }\\n    string last_10(){\\n        string tmp=\"\";\\n        int st=max(0,(int)l.size()-10);\\n        for(int i =st;i<st+10&&i<l.size();++i)tmp+=l[i];\\n        return tmp;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass TextEditor {\\n    deque<char> l,r;\\npublic:\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        for(char ch:text)l.push_back(ch);\\n    }\\n    \\n    int deleteText(int k) {\\n        int ret=0;\\n        while(!l.empty()&&k--){\\n            l.pop_back();\\n            ++ret;\\n        }\\n        return ret;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k--&&!l.empty()){\\n            r.push_front(l.back());           \\n            l.pop_back();\\n        }\\n        return last_10();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k--&&r.size()){\\n            l.push_back(r.front());\\n            r.pop_front();\\n        }\\n        return last_10();\\n    }\\n    string last_10(){\\n        string tmp=\"\";\\n        int st=max(0,(int)l.size()-10);\\n        for(int i =st;i<st+10&&i<l.size();++i)tmp+=l[i];\\n        return tmp;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2112153,
                "title": "c-linkedlist",
                "content": "**Explaination**: \\nFrom problem statement it\\'s clear that it can be implemented using any linear data structure, but using continious data structure like array or vector in c++ will be costly because of delete operation.\\nDeleting from in between of continious data structure requires average of O(n) time complexity because of allocation of new space.\\n\\nTo avoid this extra operation we can use linked list which can perform delete operation without allocating new space, and to move in both the direction we need to have double linked list.\\n\\nAlso to avoid checking multiple null conditions, add an extra dummy head ( here \\'#\\' ).\\n\\n**C++ code:**\\n```c++\\nclass TextEditor {\\npublic:\\n\\t// linked list node structure\\n    struct Node\\n    {\\n\\t\\tchar data;\\n        Node *prev, *next;\\n        Node(){ prev = next = NULL;}\\n        Node(char ch){ prev = next = NULL; data = ch; }\\n    };\\n    \\n    Node *head, *curr;\\n    int len;\\n\\t\\n    TextEditor(){\\n\\t\\t// initializing dummy node\\n        head = new Node(\\'#\\');\\n        curr = head;\\n\\t\\tlen = 0;\\n    }\\n\\n    \\n    void addText(string text) {\\n        Node *next = curr->next;\\n        for(char ch : text)\\n        {\\n            curr->next = new Node(ch);\\n            curr->next->prev = curr;\\n            curr = curr->next;\\n            len++;\\n        }\\n        curr->next = next;\\n        if(next) next->prev = curr;\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt = 0;\\n        while(k && (curr != NULL) && (curr->data != \\'#\\'))\\n        {\\n            k--;\\n            Node *prev = curr->prev;\\n            prev->next = curr->next;\\n            if(curr->next)\\n                curr->next->prev = prev;\\n            curr = prev;\\n            cnt++; len--;\\n        }\\n        return cnt;\\n    }\\n    \\n    string getVal()\\n    {\\n        string s;\\n        int k = min(len, 10);\\n        Node *temp = curr;\\n        while(k && (temp != NULL) && (temp->data != \\'#\\')){\\n            k--;\\n            s.push_back(temp->data);\\n            temp = temp->prev;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    string cursorLeft(int k)\\n    {\\n  \\n        while(k && (curr != NULL) && (curr->data != \\'#\\')){\\n            k--;\\n            curr = curr->prev;\\n        }\\n        return getVal();\\n    }\\n    \\n    string cursorRight(int k)\\n    {\\n        while(k && (curr != NULL) ){\\n            k--;\\n            if(curr->next) curr = curr->next;\\n            else break;\\n        }\\n        return getVal();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```c++\\nclass TextEditor {\\npublic:\\n\\t// linked list node structure\\n    struct Node\\n    {\\n\\t\\tchar data;\\n        Node *prev, *next;\\n        Node(){ prev = next = NULL;}\\n        Node(char ch){ prev = next = NULL; data = ch; }\\n    };\\n    \\n    Node *head, *curr;\\n    int len;\\n\\t\\n    TextEditor(){\\n\\t\\t// initializing dummy node\\n        head = new Node(\\'#\\');\\n        curr = head;\\n\\t\\tlen = 0;\\n    }\\n\\n    \\n    void addText(string text) {\\n        Node *next = curr->next;\\n        for(char ch : text)\\n        {\\n            curr->next = new Node(ch);\\n            curr->next->prev = curr;\\n            curr = curr->next;\\n            len++;\\n        }\\n        curr->next = next;\\n        if(next) next->prev = curr;\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt = 0;\\n        while(k && (curr != NULL) && (curr->data != \\'#\\'))\\n        {\\n            k--;\\n            Node *prev = curr->prev;\\n            prev->next = curr->next;\\n            if(curr->next)\\n                curr->next->prev = prev;\\n            curr = prev;\\n            cnt++; len--;\\n        }\\n        return cnt;\\n    }\\n    \\n    string getVal()\\n    {\\n        string s;\\n        int k = min(len, 10);\\n        Node *temp = curr;\\n        while(k && (temp != NULL) && (temp->data != \\'#\\')){\\n            k--;\\n            s.push_back(temp->data);\\n            temp = temp->prev;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n    string cursorLeft(int k)\\n    {\\n  \\n        while(k && (curr != NULL) && (curr->data != \\'#\\')){\\n            k--;\\n            curr = curr->prev;\\n        }\\n        return getVal();\\n    }\\n    \\n    string cursorRight(int k)\\n    {\\n        while(k && (curr != NULL) ){\\n            k--;\\n            if(curr->next) curr = curr->next;\\n            else break;\\n        }\\n        return getVal();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111859,
                "title": "simple-string-slicing",
                "content": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.s = \"\"\\n        self.c = 0\\n\\n    def addText(self, text: str) -> None:\\n        self.s = self.s[:self.c] + text + self.s[self.c:]\\n        self.c += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        k = min(k, self.c)\\n        self.s = self.s[:self.c - k] + self.s[self.c:]\\n        self.c -= k\\n        return k\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.c  = max(self.c - k, 0)\\n        k = min(self.c, 10)\\n        return self.s[self.c - k : self.c]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.c  = min(self.c + k, len(self.s))\\n        k = min(self.c, 10)\\n        return self.s[self.c - k : self.c]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.s = \"\"\\n        self.c = 0\\n\\n    def addText(self, text: str) -> None:\\n        self.s = self.s[:self.c] + text + self.s[self.c:]\\n        self.c += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        k = min(k, self.c)\\n        self.s = self.s[:self.c - k] + self.s[self.c:]\\n        self.c -= k\\n        return k\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.c  = max(self.c - k, 0)\\n        k = min(self.c, 10)\\n        return self.s[self.c - k : self.c]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.c  = min(self.c + k, len(self.s))\\n        k = min(self.c, 10)\\n        return self.s[self.c - k : self.c]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931516,
                "title": "java-based-on-linkedlist-simple-solution",
                "content": "# Code\\n```\\nclass TextEditor {\\n\\n        private final Node head = new Node(null);\\n\\n        private final Node tail = new Node(null);\\n\\n        private Node cursor = new Node(\\'|\\');\\n\\n        public TextEditor() {\\n            this.head.next = this.cursor;\\n            this.cursor.previous = this.head;\\n            this.tail.previous = this.cursor;\\n            this.cursor.next = this.tail;\\n        }\\n\\n        public void addText(String text) {\\n            final char[] symbols = Objects.requireNonNull(text).toCharArray();\\n\\n            for (char symbol : symbols) {\\n                final Node newNode = new Node(symbol, this.cursor.previous, this.cursor);\\n                this.cursor.previous.next = newNode;\\n                this.cursor.previous = newNode;\\n            }\\n        }\\n\\n        public int deleteText(int k) {\\n            int deleted = 0;\\n            Node current = this.cursor.previous;\\n\\n            while(deleted < k && current.previous != null && current.value != null) {\\n                current = current.previous;\\n                deleted++;\\n            }\\n\\n            current.next = this.cursor;\\n            this.cursor.previous = current;\\n\\n            return deleted;\\n        }\\n\\n        public String cursorLeft(int k) {\\n            int leftSteps = 0;\\n            Node current = this.cursor.previous;\\n\\n            while(leftSteps < k && current.previous != null && current.value != null) {\\n                current = current.previous;\\n                leftSteps++;\\n            }\\n\\n            this.cursor.previous.next = this.cursor.next;\\n            this.cursor.next.previous = this.cursor.previous;\\n            this.cursor.previous = current;\\n            this.cursor.next = current.next;\\n            current.next = this.cursor;\\n\\n            return this.getLeftText();\\n        }\\n\\n        public String cursorRight(int k) {\\n            int rightSteps = 0;\\n            Node current = this.cursor.next;\\n\\n            while(rightSteps < k && current.next != null && current.value != null) {\\n                current = current.next;\\n                rightSteps++;\\n            }\\n\\n            this.cursor.previous.next = this.cursor.next;\\n            this.cursor.next.previous = this.cursor.previous;\\n            this.cursor.previous = current.previous;\\n            this.cursor.next = current;\\n            current.previous.next = this.cursor;\\n\\n            return this.getLeftText();\\n        }\\n\\n        private String getLeftText() {\\n            StringBuilder leftText = new StringBuilder();\\n\\n            int moveToLeft = 0;\\n            Node current = this.cursor.previous;\\n\\n            while(moveToLeft < 10 && current.value != null) {\\n                leftText.insert(0, current.value);\\n                current = current.previous;\\n                moveToLeft++;\\n            }\\n\\n            return leftText.toString();\\n        }\\n\\n        @Override\\n        public String toString() {\\n            StringBuilder text = new StringBuilder();\\n\\n            Node current = this.head.next;\\n            int i = 0;\\n            while(current.value != null) {\\n               text.append(current.value);\\n               current = current.next;\\n            }\\n\\n            return text.toString();\\n        }\\n\\n        static class Node {\\n            private final Character value;\\n\\n            private Node next;\\n\\n            private Node previous;\\n\\n            private Node(Character value) {\\n                this(value, null, null);\\n            }\\n\\n            private Node(Character value, Node previous, Node next) {\\n                this.value = value;\\n                this.previous = previous;\\n                this.next = next;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n\\n        private final Node head = new Node(null);\\n\\n        private final Node tail = new Node(null);\\n\\n        private Node cursor = new Node(\\'|\\');\\n\\n        public TextEditor() {\\n            this.head.next = this.cursor;\\n            this.cursor.previous = this.head;\\n            this.tail.previous = this.cursor;\\n            this.cursor.next = this.tail;\\n        }\\n\\n        public void addText(String text) {\\n            final char[] symbols = Objects.requireNonNull(text).toCharArray();\\n\\n            for (char symbol : symbols) {\\n                final Node newNode = new Node(symbol, this.cursor.previous, this.cursor);\\n                this.cursor.previous.next = newNode;\\n                this.cursor.previous = newNode;\\n            }\\n        }\\n\\n        public int deleteText(int k) {\\n            int deleted = 0;\\n            Node current = this.cursor.previous;\\n\\n            while(deleted < k && current.previous != null && current.value != null) {\\n                current = current.previous;\\n                deleted++;\\n            }\\n\\n            current.next = this.cursor;\\n            this.cursor.previous = current;\\n\\n            return deleted;\\n        }\\n\\n        public String cursorLeft(int k) {\\n            int leftSteps = 0;\\n            Node current = this.cursor.previous;\\n\\n            while(leftSteps < k && current.previous != null && current.value != null) {\\n                current = current.previous;\\n                leftSteps++;\\n            }\\n\\n            this.cursor.previous.next = this.cursor.next;\\n            this.cursor.next.previous = this.cursor.previous;\\n            this.cursor.previous = current;\\n            this.cursor.next = current.next;\\n            current.next = this.cursor;\\n\\n            return this.getLeftText();\\n        }\\n\\n        public String cursorRight(int k) {\\n            int rightSteps = 0;\\n            Node current = this.cursor.next;\\n\\n            while(rightSteps < k && current.next != null && current.value != null) {\\n                current = current.next;\\n                rightSteps++;\\n            }\\n\\n            this.cursor.previous.next = this.cursor.next;\\n            this.cursor.next.previous = this.cursor.previous;\\n            this.cursor.previous = current.previous;\\n            this.cursor.next = current;\\n            current.previous.next = this.cursor;\\n\\n            return this.getLeftText();\\n        }\\n\\n        private String getLeftText() {\\n            StringBuilder leftText = new StringBuilder();\\n\\n            int moveToLeft = 0;\\n            Node current = this.cursor.previous;\\n\\n            while(moveToLeft < 10 && current.value != null) {\\n                leftText.insert(0, current.value);\\n                current = current.previous;\\n                moveToLeft++;\\n            }\\n\\n            return leftText.toString();\\n        }\\n\\n        @Override\\n        public String toString() {\\n            StringBuilder text = new StringBuilder();\\n\\n            Node current = this.head.next;\\n            int i = 0;\\n            while(current.value != null) {\\n               text.append(current.value);\\n               current = current.next;\\n            }\\n\\n            return text.toString();\\n        }\\n\\n        static class Node {\\n            private final Character value;\\n\\n            private Node next;\\n\\n            private Node previous;\\n\\n            private Node(Character value) {\\n                this(value, null, null);\\n            }\\n\\n            private Node(Character value, Node previous, Node next) {\\n                this.value = value;\\n                this.previous = previous;\\n                this.next = next;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553473,
                "title": "doubly-linked-list-cpp-solution",
                "content": "```\\nclass List{\\n  public:\\n    char val;\\n    List* next,*prev;\\n    \\n    List(char v){\\n        val=v;\\n        next=prev=NULL;\\n    }\\n    \\n    List(char v,List* a,List* b){\\n        val=v;\\n        next=a;\\n        prev=b;\\n    }\\n};\\n\\nclass TextEditor {\\npublic:\\n    List* head,* pointer;\\n    \\n    TextEditor() {\\n        head=new List(\\'0\\');\\n        pointer=head;\\n    }\\n    \\n    void addText(string text) {\\n        \\n        List* p=pointer->next;\\n        int n=text.size();\\n        \\n        for(int i=0;i<n;i++){\\n            auto e=new List(text[i],NULL,pointer);\\n            pointer->next=e;\\n            pointer=pointer->next;\\n        }\\n        \\n        pointer->next=p;\\n        if(p)p->prev=pointer;\\n    }\\n    \\n    int deleteText(int k) {\\n        List* p=pointer->next;\\n        \\n        \\n        int a=0;\\n        while(a!=k && pointer!=head){\\n            pointer=pointer->prev;\\n            pointer->next=NULL;\\n            a++;\\n        }\\n                \\n        pointer->next=p;\\n        if(p)p->prev=pointer;\\n        \\n        return a;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int a=0;\\n        while(a!=k && pointer!=head){\\n            pointer=pointer->prev;\\n            a++;\\n        }\\n    \\n        auto t=pointer;\\n        int len=10;\\n        string ans=\"\";\\n        \\n        while(t!=head && len!=0){\\n            ans+=t->val;\\n            t=t->prev;\\n            len--;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int a=0;\\n        while(a!=k && pointer->next!=NULL){\\n            pointer=pointer->next;\\n            a++;\\n        }\\n        \\n        auto t=pointer;\\n        int len=10;\\n        string ans=\"\";\\n        \\n        while(t!=head && len!=0){\\n            ans+=t->val;\\n            t=t->prev;\\n            len--;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass List{\\n  public:\\n    char val;\\n    List* next,*prev;\\n    \\n    List(char v){\\n        val=v;\\n        next=prev=NULL;\\n    }\\n    \\n    List(char v,List* a,List* b){\\n        val=v;\\n        next=a;\\n        prev=b;\\n    }\\n};\\n\\nclass TextEditor {\\npublic:\\n    List* head,* pointer;\\n    \\n    TextEditor() {\\n        head=new List(\\'0\\');\\n        pointer=head;\\n    }\\n    \\n    void addText(string text) {\\n        \\n        List* p=pointer->next;\\n        int n=text.size();\\n        \\n        for(int i=0;i<n;i++){\\n            auto e=new List(text[i],NULL,pointer);\\n            pointer->next=e;\\n            pointer=pointer->next;\\n        }\\n        \\n        pointer->next=p;\\n        if(p)p->prev=pointer;\\n    }\\n    \\n    int deleteText(int k) {\\n        List* p=pointer->next;\\n        \\n        \\n        int a=0;\\n        while(a!=k && pointer!=head){\\n            pointer=pointer->prev;\\n            pointer->next=NULL;\\n            a++;\\n        }\\n                \\n        pointer->next=p;\\n        if(p)p->prev=pointer;\\n        \\n        return a;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int a=0;\\n        while(a!=k && pointer!=head){\\n            pointer=pointer->prev;\\n            a++;\\n        }\\n    \\n        auto t=pointer;\\n        int len=10;\\n        string ans=\"\";\\n        \\n        while(t!=head && len!=0){\\n            ans+=t->val;\\n            t=t->prev;\\n            len--;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int a=0;\\n        while(a!=k && pointer->next!=NULL){\\n            pointer=pointer->next;\\n            a++;\\n        }\\n        \\n        auto t=pointer;\\n        int len=10;\\n        string ans=\"\";\\n        \\n        while(t!=head && len!=0){\\n            ans+=t->val;\\n            t=t->prev;\\n            len--;\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2192337,
                "title": "python-o-k-implementation-with-the-built-in-doubly-linked-list-deque-faster-than-96",
                "content": "The O(k) solution can be made by using doubly linked-list. \\nWe do not need to implement the complex doubly linked-list by ourself since the built-in container ```collections.deque``` is actually an implemention of the doubly linked-list. \\nThus, we can solve this problem with ```deque``` in a short and fast way.\\nUnlike a regular doubly linked-list, we cannot direct trace a node in a deque for simulating the cursor moving. \\nInstead, the key is to handle the cursor as the first element of the deque, and rotate the deque for moving the cursor. \\nThe complexity of ```addText()``` is O(|text|), and ```cursorLeft()```, ```cursorRight()```, and ```deleteText()``` are O(k).\\n\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.q = deque([\"\\\\n\"])\\n\\n    def addText(self, text: str) -> None:\\n        self.q.extendleft(reversed(list(text)))\\n        self.q.rotate(-len(text))\\n        \\n    def deleteText(self, k: int) -> int:\\n        c = 0\\n        for _ in range(k):\\n            if self.q[-1] == \"\\\\n\":\\n                break\\n            self.q.rotate(1)\\n            self.q.popleft()\\n            c += 1\\n        return c\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.q[-1] == \"\\\\n\":\\n                break\\n            self.q.rotate(1)\\n        return self.left10()\\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.q[0] == \"\\\\n\":\\n                break\\n            self.q.rotate(-1)\\n        return self.left10()\\n\\n    def left10(self) -> str:\\n        r = \"\"\\n        for i in range(10):\\n            if self.q[-i-1] == \"\\\\n\":\\n                break\\n            r = self.q[-i-1] + r\\n        return r",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```collections.deque```\n```deque```\n```addText()```\n```cursorLeft()```\n```cursorRight()```\n```deleteText()```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130457,
                "title": "ridiculously-simple-solution-with-2-stacks-o-k",
                "content": "You don\\'t need a deque! \\nYou don\\'t need a linked list.\\nJust a stack. \\nPure and simple stack.\\nAnd the simple dynamic array, **[]**  could easily be your stack.\\n\\n- The cursor is always on the top of the **forward** stack.\\n- We delete and add letters directly to and from the **forward** stack.\\n- While we move cursor left, we push last letter of the **forward** stack, to our **backward** stack, where we store all the letters in reverse.\\n- While we move the cursor right, we push last letter of the **backward** stack to our **forward** stack.\\n```javascript\\n\\n\\nvar TextEditor = function() {\\n    this.forward = [];\\n    this.backward = [];\\n};\\n\\n/** \\n * @param {string} text\\n * @return {void}\\n */\\nTextEditor.prototype.addText = function(text) {\\n    for (let letter of text) {\\n        this.forward.push(letter);\\n    }\\n};\\n\\n/** \\n * @param {number} k\\n * @return {number}\\n */\\nTextEditor.prototype.deleteText = function(k) {\\n    let deleted = 0;\\n    while (this.forward.length && deleted < k) {\\n        this.forward.pop();\\n        deleted++;\\n    }\\n    return deleted;\\n};\\n\\n/** \\n * @param {number} k\\n * @return {string}\\n */\\nTextEditor.prototype.cursorLeft = function(k) {\\n    let moved = 0;\\n    while (this.forward.length && moved < k) {\\n        this.backward.push(this.forward.pop());\\n        moved++;\\n    }\\n    return toTheLeft(this.forward);\\n};\\n\\n/** \\n * @param {number} k\\n * @return {string}\\n */\\nTextEditor.prototype.cursorRight = function(k) {\\n    let moved = 0;\\n    while (moved < k && this.backward.length) {\\n        this.forward.push(this.backward.pop());\\n        moved++;\\n    }\\n    return toTheLeft(this.forward);\\n};\\n\\n\\nfunction toTheLeft (arr) {\\n    let letters = [];\\n    for (let i = Math.max(0, arr.length - 10); i < arr.length; i++) {\\n        letters.push(arr[i]);\\n    }\\n    let res = letters.join(\"\");\\n    return res; \\n}\\n\\n```\\n\\nAll operations are O(k) cause push and pop are O(1) for the dynamic array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n\\n\\nvar TextEditor = function() {\\n    this.forward = [];\\n    this.backward = [];\\n};\\n\\n/** \\n * @param {string} text\\n * @return {void}\\n */\\nTextEditor.prototype.addText = function(text) {\\n    for (let letter of text) {\\n        this.forward.push(letter);\\n    }\\n};\\n\\n/** \\n * @param {number} k\\n * @return {number}\\n */\\nTextEditor.prototype.deleteText = function(k) {\\n    let deleted = 0;\\n    while (this.forward.length && deleted < k) {\\n        this.forward.pop();\\n        deleted++;\\n    }\\n    return deleted;\\n};\\n\\n/** \\n * @param {number} k\\n * @return {string}\\n */\\nTextEditor.prototype.cursorLeft = function(k) {\\n    let moved = 0;\\n    while (this.forward.length && moved < k) {\\n        this.backward.push(this.forward.pop());\\n        moved++;\\n    }\\n    return toTheLeft(this.forward);\\n};\\n\\n/** \\n * @param {number} k\\n * @return {string}\\n */\\nTextEditor.prototype.cursorRight = function(k) {\\n    let moved = 0;\\n    while (moved < k && this.backward.length) {\\n        this.forward.push(this.backward.pop());\\n        moved++;\\n    }\\n    return toTheLeft(this.forward);\\n};\\n\\n\\nfunction toTheLeft (arr) {\\n    let letters = [];\\n    for (let i = Math.max(0, arr.length - 10); i < arr.length; i++) {\\n        letters.push(arr[i]);\\n    }\\n    let res = letters.join(\"\");\\n    return res; \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113276,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Two Strings***\\n\\n* ***Time Complexity : O(n) for add and O(k) for all other***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass TextEditor {\\npublic:\\n    \\n    string left = \"\";\\n    \\n    string right = \"\";\\n    \\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        \\n        left += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        \\n        int size = left.size();\\n        \\n        int count = min({k, size});\\n        \\n        for(int i = 0; i < count; i++)\\n        {\\n            left.pop_back();\\n        }\\n        \\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        \\n        while(k && left.size() > 0)\\n        {\\n            char ch = left.back();\\n            \\n            left.pop_back();\\n            \\n            right += ch;\\n            \\n            k--;\\n        }\\n        \\n        int size = left.size();\\n        \\n        int length = min(10, size);\\n        \\n        return left.substr(size - length);\\n    }\\n    \\n    string cursorRight(int k) {\\n        \\n        while(k && right.size())\\n        {\\n            char ch = right.back();\\n            \\n            left += ch;\\n            \\n            right.pop_back();\\n            \\n            k--;\\n        }\\n        \\n        int size = left.size();\\n        \\n        int length = min(10, size);\\n        \\n        return left.substr(size - length);\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    \\n    string left = \"\";\\n    \\n    string right = \"\";\\n    \\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        \\n        left += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        \\n        int size = left.size();\\n        \\n        int count = min({k, size});\\n        \\n        for(int i = 0; i < count; i++)\\n        {\\n            left.pop_back();\\n        }\\n        \\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        \\n        while(k && left.size() > 0)\\n        {\\n            char ch = left.back();\\n            \\n            left.pop_back();\\n            \\n            right += ch;\\n            \\n            k--;\\n        }\\n        \\n        int size = left.size();\\n        \\n        int length = min(10, size);\\n        \\n        return left.substr(size - length);\\n    }\\n    \\n    string cursorRight(int k) {\\n        \\n        while(k && right.size())\\n        {\\n            char ch = right.back();\\n            \\n            left += ch;\\n            \\n            right.pop_back();\\n            \\n            k--;\\n        }\\n        \\n        int size = left.size();\\n        \\n        int length = min(10, size);\\n        \\n        return left.substr(size - length);\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113170,
                "title": "python-doubly-linked-list-vs-two-stacks",
                "content": "Doubly-linked list:\\n```\\nclass Node:\\n    def __init__(self, char, left=None, right=None):\\n        self.char, self.left, self.right = char, left, right\\n\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.cursor = Node(\\'|\\')\\n\\n    def addText(self, text: str) -> None:\\n        left = self.cursor.left\\n        head = self.cursor\\n        for char in reversed(text):\\n            new_head = Node(char, None, head)\\n            head.left = new_head\\n            head = new_head\\n        head.left = left\\n        if left:\\n            left.right = head\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        while k and self.cursor.left:\\n            new_left = self.cursor.left.left\\n            self.cursor.left = new_left\\n            if new_left:\\n                new_left.right = self.cursor\\n            k -= 1\\n            ans += 1\\n        return ans\\n\\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.cursor.left:\\n            left = self.cursor.left\\n            left.char, self.cursor.char = self.cursor.char, left.char\\n            self.cursor = left\\n            k -= 1\\n        return self.toLeft()        \\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.cursor.right:\\n            right = self.cursor.right\\n            right.char, self.cursor.char = self.cursor.char, right.char\\n            self.cursor = right\\n            k -= 1\\n        return self.toLeft()\\n        \\n    def toLeft(self):\\n        left = self.cursor.left\\n        l = []\\n        while left and len(l) < 10:\\n            l.append(left.char)\\n            left = left.left\\n        return \\'\\'.join(reversed(l))\\n```\\nTwo stacks:\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.r = []\\n\\n    def addText(self, text: str) -> None:\\n        self.l.extend(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        while k and self.l:\\n            self.l.pop()\\n            k -= 1\\n            ans += 1\\n        return ans\\n\\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.l:\\n            self.r.append(self.l.pop())\\n            k -= 1\\n        return \\'\\'.join(self.l[-10:])      \\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.r:\\n            self.l.append(self.r.pop())\\n            k -= 1\\n        return \\'\\'.join(self.l[-10:])\\n```\\nIn both cases\\nTime complexity for each operation: `O(k)` or `O(len(text))`\\nSpace complexity: `O(n)`, `n` is length of the current text in the editor.\\n\\nHowever, the two stacks solution is ~9 times as fast.\\n![image](https://assets.leetcode.com/users/images/aa73afd2-d540-41ff-8d98-9b1ec7600cbc_1654411960.6368103.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, char, left=None, right=None):\\n        self.char, self.left, self.right = char, left, right\\n\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.cursor = Node(\\'|\\')\\n\\n    def addText(self, text: str) -> None:\\n        left = self.cursor.left\\n        head = self.cursor\\n        for char in reversed(text):\\n            new_head = Node(char, None, head)\\n            head.left = new_head\\n            head = new_head\\n        head.left = left\\n        if left:\\n            left.right = head\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        while k and self.cursor.left:\\n            new_left = self.cursor.left.left\\n            self.cursor.left = new_left\\n            if new_left:\\n                new_left.right = self.cursor\\n            k -= 1\\n            ans += 1\\n        return ans\\n\\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.cursor.left:\\n            left = self.cursor.left\\n            left.char, self.cursor.char = self.cursor.char, left.char\\n            self.cursor = left\\n            k -= 1\\n        return self.toLeft()        \\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.cursor.right:\\n            right = self.cursor.right\\n            right.char, self.cursor.char = self.cursor.char, right.char\\n            self.cursor = right\\n            k -= 1\\n        return self.toLeft()\\n        \\n    def toLeft(self):\\n        left = self.cursor.left\\n        l = []\\n        while left and len(l) < 10:\\n            l.append(left.char)\\n            left = left.left\\n        return \\'\\'.join(reversed(l))\\n```\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.r = []\\n\\n    def addText(self, text: str) -> None:\\n        self.l.extend(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        while k and self.l:\\n            self.l.pop()\\n            k -= 1\\n            ans += 1\\n        return ans\\n\\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.l:\\n            self.r.append(self.l.pop())\\n            k -= 1\\n        return \\'\\'.join(self.l[-10:])      \\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.r:\\n            self.l.append(self.r.pop())\\n            k -= 1\\n        return \\'\\'.join(self.l[-10:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112423,
                "title": "double-linked-list-o-n",
                "content": "```\\nclass Node:\\n    def __init__(self, c, pre=None, next=None):\\n        self.c = c\\n        self.pre = pre\\n        self.next = next\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.head = Node(0)\\n        self.tail = Node(1)\\n        self.head.next = self.tail\\n        self.tail.pre = self.head\\n        self.curr = self.tail\\n        \\n    def addText(self, text: str) -> None:\\n        pre = self.curr.pre\\n        post = self.curr\\n        for c in text:\\n            curr = Node(c)\\n            pre.next = curr\\n            curr.pre = pre\\n            pre = curr\\n        \\n        pre.next = post\\n        post.pre = pre\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        curr = self.curr\\n        pre = curr.pre\\n        for _ in range(k):\\n            if pre.c == 0:\\n                break\\n            ans += 1\\n            pre = pre.pre\\n            pre.next = curr\\n            curr.pre = pre\\n            \\n        return ans\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        curr = self.curr\\n        pre = curr.pre\\n        for _ in range(k):\\n            if pre.c == 0:\\n                break\\n            self.curr = pre\\n            pre = pre.pre\\n        \\n        return self.rt_txt()\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.curr.c == 1:\\n                break\\n            post = self.curr.next\\n            self.curr = post\\n        \\n        return self.rt_txt()\\n        \\n    \\n    def rt_txt(self,):\\n        s = \"\"\\n        pre = self.curr.pre\\n        for _ in range(10):\\n            if pre.c == 0:\\n                break\\n            s = pre.c + s\\n            pre = pre.pre\\n\\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, c, pre=None, next=None):\\n        self.c = c\\n        self.pre = pre\\n        self.next = next\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.head = Node(0)\\n        self.tail = Node(1)\\n        self.head.next = self.tail\\n        self.tail.pre = self.head\\n        self.curr = self.tail\\n        \\n    def addText(self, text: str) -> None:\\n        pre = self.curr.pre\\n        post = self.curr\\n        for c in text:\\n            curr = Node(c)\\n            pre.next = curr\\n            curr.pre = pre\\n            pre = curr\\n        \\n        pre.next = post\\n        post.pre = pre\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        curr = self.curr\\n        pre = curr.pre\\n        for _ in range(k):\\n            if pre.c == 0:\\n                break\\n            ans += 1\\n            pre = pre.pre\\n            pre.next = curr\\n            curr.pre = pre\\n            \\n        return ans\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        curr = self.curr\\n        pre = curr.pre\\n        for _ in range(k):\\n            if pre.c == 0:\\n                break\\n            self.curr = pre\\n            pre = pre.pre\\n        \\n        return self.rt_txt()\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.curr.c == 1:\\n                break\\n            post = self.curr.next\\n            self.curr = post\\n        \\n        return self.rt_txt()\\n        \\n    \\n    def rt_txt(self,):\\n        s = \"\"\\n        pre = self.curr.pre\\n        for _ in range(10):\\n            if pre.c == 0:\\n                break\\n            s = pre.c + s\\n            pre = pre.pre\\n\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112389,
                "title": "javascript-doubly-linked-list",
                "content": "```js\\nclass Node{\\n    public val: string;\\n    public next: Node | null = null;\\n    public prev: Node | null = null;\\n\\n    constructor(val:string){\\n        this.val = val\\n    }\\n}\\n\\nclass TextEditor {\\n    public dummy: Node = new Node(\"\");\\n    public node: Node;\\n    \\n    constructor(){\\n        this.node = this.dummy\\n    }\\n\\n    addText(text: string): void {\\n        let node = null\\n        let prev = this.node\\n        let next = prev.next\\n        \\n        for (const c of text){\\n            node = new Node(c)\\n            node.prev = prev\\n            prev.next = node\\n            prev = node\\n        }\\n        \\n        \\n        node.next = next\\n        if (next){\\n            next.prev = node\\n        }\\n        \\n        this.node = node\\n\\n    }\\n\\n    deleteText(k: number): number {\\n        let i = 0;\\n        let next = this.node.next;\\n        \\n        while (i< k && this.node!=this.dummy){\\n            this.node = this.node.prev\\n            i+=1\\n        }\\n        \\n        \\n        this.node.next = next;\\n        if (next){\\n            next.prev = this.node\\n        }\\n        \\n        return i\\n    }\\n\\n    cursorLeft(k: number): string {\\n        let i = 0;\\n        while (i < k && this.node.prev!=null && this.node!=this.dummy ){\\n            this.node = this.node.prev\\n            i+=1\\n        }\\n            \\n        \\n        let node = this.node\\n        let t = \"\"\\n        i = 0\\n        \\n        while(i < 10 && node != null) {\\n            i+=1\\n            t = node.val + t\\n            node = node.prev\\n        }\\n        // console.log(t)\\n        return t\\n    }\\n\\n    cursorRight(k: number): string {\\n        let i = 0;\\n        while (i < k && this.node.next!=null){\\n            this.node = this.node.next\\n            i+=1\\n        }\\n        \\n        let node = this.node\\n        let t = \"\"\\n        i = 0\\n        \\n        while(i < 10 && node != null) {\\n            i+=1\\n            t = node.val + t\\n            node = node.prev\\n        }\\n        // console.log(t)\\n        return t\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass Node{\\n    public val: string;\\n    public next: Node | null = null;\\n    public prev: Node | null = null;\\n\\n    constructor(val:string){\\n        this.val = val\\n    }\\n}\\n\\nclass TextEditor {\\n    public dummy: Node = new Node(\"\");\\n    public node: Node;\\n    \\n    constructor(){\\n        this.node = this.dummy\\n    }\\n\\n    addText(text: string): void {\\n        let node = null\\n        let prev = this.node\\n        let next = prev.next\\n        \\n        for (const c of text){\\n            node = new Node(c)\\n            node.prev = prev\\n            prev.next = node\\n            prev = node\\n        }\\n        \\n        \\n        node.next = next\\n        if (next){\\n            next.prev = node\\n        }\\n        \\n        this.node = node\\n\\n    }\\n\\n    deleteText(k: number): number {\\n        let i = 0;\\n        let next = this.node.next;\\n        \\n        while (i< k && this.node!=this.dummy){\\n            this.node = this.node.prev\\n            i+=1\\n        }\\n        \\n        \\n        this.node.next = next;\\n        if (next){\\n            next.prev = this.node\\n        }\\n        \\n        return i\\n    }\\n\\n    cursorLeft(k: number): string {\\n        let i = 0;\\n        while (i < k && this.node.prev!=null && this.node!=this.dummy ){\\n            this.node = this.node.prev\\n            i+=1\\n        }\\n            \\n        \\n        let node = this.node\\n        let t = \"\"\\n        i = 0\\n        \\n        while(i < 10 && node != null) {\\n            i+=1\\n            t = node.val + t\\n            node = node.prev\\n        }\\n        // console.log(t)\\n        return t\\n    }\\n\\n    cursorRight(k: number): string {\\n        let i = 0;\\n        while (i < k && this.node.next!=null){\\n            this.node = this.node.next\\n            i+=1\\n        }\\n        \\n        let node = this.node\\n        let t = \"\"\\n        i = 0\\n        \\n        while(i < 10 && node != null) {\\n            i+=1\\n            t = node.val + t\\n            node = node.prev\\n        }\\n        // console.log(t)\\n        return t\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112283,
                "title": "using-1-string-and-1-stack-very-easy-implementation",
                "content": "Think of the Text Editor as a stack as a whole. \\nI divided my text editor into two parts.\\nLeft (left of cursor) (string)\\nRight (right of cursor) (stack)\\n\\nWhen we go right, we move a letter from stack to string. \\nand when we go left, we move a letter from the string to the stack.\\nas simple as that.\\n\\nI used string for the left for the sole reason of using **substring** which i can\\'t use in stack data structure.\\n\\nBut overall, think of the string as a **stack with substring feature.**\\n\\n\\n```\\nclass TextEditor {\\npublic:\\n    string left;\\n    stack<char> right;\\n    \\n    \\n    TextEditor() {\\n        left=\"\";\\n       \\n    }\\n    \\n    void addText(string text) {\\n        left.append(text);\\n    }\\n    \\n    int deleteText(int k) {\\n        int s=left.size();\\n        for(int i=0;i<min(k,s);i++)\\n        {\\n            left.pop_back();\\n        }\\n        return min(k,s);\\n    }\\n    \\n    \\n    string cursorLeft(int k) {\\n     int s=left.size();\\n        for(int i=0;i<min(k,s);i++)\\n        {\\n            char temp=left.back();\\n            left.pop_back();\\n            right.push(temp);\\n        }\\n        \\n        if(left.length()<10)\\n            return left;\\n        return left.substr(left.size()-10,10); //returns 10 letters from the end of the string, or the whole string if size(left) < 10\\n    }\\n    \\n    string cursorRight(int k) {\\n      int s=right.size();\\n        for(int i=0;i<min(k,s);i++)\\n        {\\n            char temp=right.top();\\n            right.pop();\\n            left.push_back(temp);\\n        }\\n        \\n        if(left.length()<10)\\n            return left;\\n        return left.substr(left.size()-10,10); //returns 10 letters from the end of the string, or the whole string if size(left) < 10\\n    }\\n\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string left;\\n    stack<char> right;\\n    \\n    \\n    TextEditor() {\\n        left=\"\";\\n       \\n    }\\n    \\n    void addText(string text) {\\n        left.append(text);\\n    }\\n    \\n    int deleteText(int k) {\\n        int s=left.size();\\n        for(int i=0;i<min(k,s);i++)\\n        {\\n            left.pop_back();\\n        }\\n        return min(k,s);\\n    }\\n    \\n    \\n    string cursorLeft(int k) {\\n     int s=left.size();\\n        for(int i=0;i<min(k,s);i++)\\n        {\\n            char temp=left.back();\\n            left.pop_back();\\n            right.push(temp);\\n        }\\n        \\n        if(left.length()<10)\\n            return left;\\n        return left.substr(left.size()-10,10); //returns 10 letters from the end of the string, or the whole string if size(left) < 10\\n    }\\n    \\n    string cursorRight(int k) {\\n      int s=right.size();\\n        for(int i=0;i<min(k,s);i++)\\n        {\\n            char temp=right.top();\\n            right.pop();\\n            left.push_back(temp);\\n        }\\n        \\n        if(left.length()<10)\\n            return left;\\n        return left.substr(left.size()-10,10); //returns 10 letters from the end of the string, or the whole string if size(left) < 10\\n    }\\n\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112124,
                "title": "c-easy-understanding",
                "content": "```\\nclass TextEditor {\\npublic:\\n    string b=\"\", a=\"\";\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        b += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        int mn = min(int(b.length()), k);\\n        \\n        for(int i = 0; i < mn; ++i) b.pop_back();\\n        \\n        return mn;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int mn = min(k, int(b.length()));\\n        for(int i = 0; i < mn; ++i) {\\n            a.push_back(b.back());\\n            b.pop_back();\\n        }\\n        \\n        int mxlen = min(10, int(b.length()));\\n        \\n        return b.substr(b.length() - mxlen);\\n    }\\n    \\n    string cursorRight(int k) {\\n        int mn = min(k, int(a.length()));\\n        for(int i = 0; i < mn; ++i) {\\n            b.push_back(a.back());\\n            a.pop_back();\\n        }\\n        \\n        int mxlen = min(10, int(b.length()));\\n        \\n        return b.substr(b.length() - mxlen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string b=\"\", a=\"\";\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        b += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        int mn = min(int(b.length()), k);\\n        \\n        for(int i = 0; i < mn; ++i) b.pop_back();\\n        \\n        return mn;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int mn = min(k, int(b.length()));\\n        for(int i = 0; i < mn; ++i) {\\n            a.push_back(b.back());\\n            b.pop_back();\\n        }\\n        \\n        int mxlen = min(10, int(b.length()));\\n        \\n        return b.substr(b.length() - mxlen);\\n    }\\n    \\n    string cursorRight(int k) {\\n        int mn = min(k, int(a.length()));\\n        for(int i = 0; i < mn; ++i) {\\n            b.push_back(a.back());\\n            a.pop_back();\\n        }\\n        \\n        int mxlen = min(10, int(b.length()));\\n        \\n        return b.substr(b.length() - mxlen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886271,
                "title": "c-o-n-solution-with-explanation-fun-with-linked-list-iterators",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to design a text editor where every function call is O(n), for addition, deletion and cursor shifting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt a first glance, one might be tempted to use strings as the underlying data structure to hold the data. However, strings won\\'t work because:\\n- Like vectors, they are O(n) insertion and deletion.\\n- So if you insert/delete n characters, that\\'s O(n^2), which isn\\'t good.\\n\\nA data structure which gives constant time insertion and deletion is of course, the linked list.\\n\\nThe idea is that we use a linked list of characters (char) to keep track of the total text so far, and keep track of an iterator to this same linked list to keep track of the **cursor position**.\\n\\nFor addText():\\n- We simply insert k characters just before cursor position. The linked list.insert() method does this perfectly. O(1) * k times = O(k), meeting specifications :)\\n\\nFor deleteText():\\n- Similar to addText, delete k characters just before the cursor position. This is also O(1) * k times = O(k).\\n\\nFor cursor left and right shifts:\\n- The time complexity of moving elements in a linked list is O(k) (i.e. O(1) to delete, O(k) to shift the iterator k times, then another O(1) to re-add).\\n- With regards to printing the characters before the cursor, we are capped at 10 characters. So in the grand scheme of things, this is basically constant time O(1) (even if your total text is millions of lines long, only return the previous 10 characters).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) for every method call, as requested by the problem.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - we store the total text as a single linked list, plus a single iterator to track cursor position.\\n\\nHope this helps! :)\\n\\n# Code\\n```\\nclass TextEditor {\\nprivate:\\n    list<char> currText;\\n    list<char>::iterator cursorIter;\\n\\n#define MAXLEFT (10)\\n\\n    string getCharsLeftOfCursor()\\n    {\\n        string ret = \"\";\\n        int currShifted = 0;\\n\\n        list<char>::iterator myIt = cursorIter;\\n\\n        while (currShifted < MAXLEFT && myIt != currText.begin())\\n        {\\n            myIt--;\\n            ret += *myIt;\\n            currShifted++;\\n        }\\n\\n        reverse(ret.begin(), ret.end());\\n\\n        return ret;\\n    }\\n\\npublic:\\n    TextEditor() {\\n        // initialize the cursor\\n        currText.push_back(\\'|\\');\\n        cursorIter = currText.begin();\\n    }\\n    \\n    void addText(string text) {\\n\\n        for (const auto& ch : text)\\n        {\\n            // O(1) insertion k times == O(k)\\n            currText.insert(cursorIter, ch);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int chars_deleted = 0;\\n\\n        while (chars_deleted < k && cursorIter != currText.begin())\\n        {\\n            currText.erase(prev(cursorIter));\\n            chars_deleted++;\\n        }\\n\\n        return chars_deleted;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int chars_moved = 0;\\n        \\n        list<char>::iterator startPos = cursorIter;\\n\\n        while (chars_moved < k && cursorIter != currText.begin())\\n        {\\n            cursorIter--;\\n            chars_moved++;\\n        }\\n\\n        // insert \\'|\\' at new position and delete old \\'|\\'\\n        currText.insert(cursorIter, \\'|\\');\\n        cursorIter--; // point to proper cursor position\\n        currText.erase(startPos);\\n\\n        // get up to 10 characters to the left of cursor\\n        string ret = getCharsLeftOfCursor();\\n\\n        return ret;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int chars_moved = 0;\\n\\n        list<char>::iterator startPos = cursorIter;\\n\\n        while (chars_moved < k && cursorIter != --currText.end())\\n        {\\n            cursorIter++;\\n            chars_moved++;\\n        }\\n\\n        // insert \\'|\\' at end\\n        cursorIter++;\\n        currText.insert(cursorIter, \\'|\\');\\n        cursorIter--;\\n        currText.erase(startPos);\\n\\n        // get up to 10 characters to the left of cursor\\n        string ret = getCharsLeftOfCursor();\\n\\n        return ret;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TextEditor {\\nprivate:\\n    list<char> currText;\\n    list<char>::iterator cursorIter;\\n\\n#define MAXLEFT (10)\\n\\n    string getCharsLeftOfCursor()\\n    {\\n        string ret = \"\";\\n        int currShifted = 0;\\n\\n        list<char>::iterator myIt = cursorIter;\\n\\n        while (currShifted < MAXLEFT && myIt != currText.begin())\\n        {\\n            myIt--;\\n            ret += *myIt;\\n            currShifted++;\\n        }\\n\\n        reverse(ret.begin(), ret.end());\\n\\n        return ret;\\n    }\\n\\npublic:\\n    TextEditor() {\\n        // initialize the cursor\\n        currText.push_back(\\'|\\');\\n        cursorIter = currText.begin();\\n    }\\n    \\n    void addText(string text) {\\n\\n        for (const auto& ch : text)\\n        {\\n            // O(1) insertion k times == O(k)\\n            currText.insert(cursorIter, ch);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int chars_deleted = 0;\\n\\n        while (chars_deleted < k && cursorIter != currText.begin())\\n        {\\n            currText.erase(prev(cursorIter));\\n            chars_deleted++;\\n        }\\n\\n        return chars_deleted;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int chars_moved = 0;\\n        \\n        list<char>::iterator startPos = cursorIter;\\n\\n        while (chars_moved < k && cursorIter != currText.begin())\\n        {\\n            cursorIter--;\\n            chars_moved++;\\n        }\\n\\n        // insert \\'|\\' at new position and delete old \\'|\\'\\n        currText.insert(cursorIter, \\'|\\');\\n        cursorIter--; // point to proper cursor position\\n        currText.erase(startPos);\\n\\n        // get up to 10 characters to the left of cursor\\n        string ret = getCharsLeftOfCursor();\\n\\n        return ret;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int chars_moved = 0;\\n\\n        list<char>::iterator startPos = cursorIter;\\n\\n        while (chars_moved < k && cursorIter != --currText.end())\\n        {\\n            cursorIter++;\\n            chars_moved++;\\n        }\\n\\n        // insert \\'|\\' at end\\n        cursorIter++;\\n        currText.insert(cursorIter, \\'|\\');\\n        cursorIter--;\\n        currText.erase(startPos);\\n\\n        // get up to 10 characters to the left of cursor\\n        string ret = getCharsLeftOfCursor();\\n\\n        return ret;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744283,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass TextEditor {\\n  stack<char> left;\\n    stack<char> right;\\npublic:\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        for(auto &c : text){\\n            left.push(c);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt=0;\\n        while(!left.empty() and k>0){\\n            left.pop();\\n            cnt++;\\n            k--;\\n        }\\n        return cnt;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(!left.empty() and k>0){\\n            char c = left.top();left.pop();\\n            right.push(c);\\n            k--;\\n        }\\n        return cursorShiftString();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(!right.empty() and k>0){\\n            char c = right.top();right.pop();\\n            left.push(c);\\n            k--;\\n        }\\n        return cursorShiftString();\\n    }\\n    \\n    string cursorShiftString(){\\n        string rtn = \"\";\\n        int cnt=10;\\n        while(!left.empty() and cnt>0){\\n            char c = left.top();left.pop();\\n            rtn += c;\\n            cnt--;\\n        }\\n        reverse(rtn.begin(),rtn.end());\\n        for(int i=0;i<rtn.size();i++){\\n            left.push(rtn[i]);\\n        }\\n        return rtn;\\n    }\\n};\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TextEditor {\\n  stack<char> left;\\n    stack<char> right;\\npublic:\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        for(auto &c : text){\\n            left.push(c);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt=0;\\n        while(!left.empty() and k>0){\\n            left.pop();\\n            cnt++;\\n            k--;\\n        }\\n        return cnt;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(!left.empty() and k>0){\\n            char c = left.top();left.pop();\\n            right.push(c);\\n            k--;\\n        }\\n        return cursorShiftString();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(!right.empty() and k>0){\\n            char c = right.top();right.pop();\\n            left.push(c);\\n            k--;\\n        }\\n        return cursorShiftString();\\n    }\\n    \\n    string cursorShiftString(){\\n        string rtn = \"\";\\n        int cnt=10;\\n        while(!left.empty() and cnt>0){\\n            char c = left.top();left.pop();\\n            rtn += c;\\n            cnt--;\\n        }\\n        reverse(rtn.begin(),rtn.end());\\n        for(int i=0;i<rtn.size();i++){\\n            left.push(rtn[i]);\\n        }\\n        return rtn;\\n    }\\n};\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676977,
                "title": "c-two-strings-time-o-k-space-o-n",
                "content": "# Intuition\\nWe have a string `leetc|ode`, the cursor is in between `c` and `o`\\na string `left` = `leetc`, `left.front` is `l`, `left.back` is `c`\\na string `right` = `ode`, `right.front` is `e`, `right.back` is `o`\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n`addText()` always appends the new text to `left`.\\n\\n`deleteText()` pops at most `k` letters from `left`.\\nReturn the number of popped letters.\\n\\n`cursorLeft()` pops at most `k` letters from `left` to `right`.\\nReturn the substring of the last min(10, len) letters of `left`.\\n\\n`cursorRight()` pops at most `k` letters from `right` to `left`.\\nReturn the substring of the last min(10, len) letters of `left`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor {\\npublic:\\n  TextEditor() {\\n    \\n  }\\n  \\n  void addText(string text) {\\n    left += text;\\n  }\\n  \\n  int deleteText(int k) {\\n    int count = 0;\\n    while (k-- and left.size()) {\\n      left.pop_back();\\n      count++;\\n    }\\n    return count;\\n  }\\n  \\n  string cursorLeft(int k) {\\n    while (k-- and left.size()) {\\n      char c = left.back();\\n      left.pop_back();\\n      right += c;\\n    }\\n    int n = left.size();\\n    return left.substr(max(0, n - 10));\\n  }\\n  \\n  string cursorRight(int k) {\\n    while (k-- and right.size()) {\\n      char c = right.back();\\n      right.pop_back();\\n      left += c;\\n    }\\n    int n = left.size();\\n    return left.substr(max(0, n - 10));\\n  }\\n\\nprivate:\\n  string left, right;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n  TextEditor() {\\n    \\n  }\\n  \\n  void addText(string text) {\\n    left += text;\\n  }\\n  \\n  int deleteText(int k) {\\n    int count = 0;\\n    while (k-- and left.size()) {\\n      left.pop_back();\\n      count++;\\n    }\\n    return count;\\n  }\\n  \\n  string cursorLeft(int k) {\\n    while (k-- and left.size()) {\\n      char c = left.back();\\n      left.pop_back();\\n      right += c;\\n    }\\n    int n = left.size();\\n    return left.substr(max(0, n - 10));\\n  }\\n  \\n  string cursorRight(int k) {\\n    while (k-- and right.size()) {\\n      char c = right.back();\\n      right.pop_back();\\n      left += c;\\n    }\\n    int n = left.size();\\n    return left.substr(max(0, n - 10));\\n  }\\n\\nprivate:\\n  string left, right;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186584,
                "title": "sringbuilder-java",
                "content": "```\\nclass TextEditor {\\n    StringBuilder sb;\\n    int cursor;\\n\\n    public TextEditor() {\\n        sb = new StringBuilder();\\n        cursor = 0;\\n    }\\n\\n    public void addText(String text) {\\n        sb.insert(cursor, text);\\n        incrementBy(text.length());\\n    }\\n\\n    public int deleteText(int k) {\\n        int currentCursor = cursor;\\n        decrementBy(k);\\n        sb.delete(cursor, currentCursor);\\n        return currentCursor - cursor;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        decrementBy(k);\\n        int startPoint = getStartPoint();\\n        return sb.substring(startPoint, cursor);    \\n    }\\n\\n    public String cursorRight(int k) {\\n        incrementBy(k);\\n        int startPoint = getStartPoint();\\n        return sb.substring(startPoint, cursor);\\n    }\\n     \\n    private void decrementBy(int k) {\\n        cursor = Math.max(0, cursor - k);\\n    }\\n    \\n    private void incrementBy(int k) {\\n        cursor = Math.min(cursor + k, sb.length());\\n    }\\n    \\n    private int getStartPoint() {\\n        return (cursor < 10) ? 0 : cursor - 10;\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\n    StringBuilder sb;\\n    int cursor;\\n\\n    public TextEditor() {\\n        sb = new StringBuilder();\\n        cursor = 0;\\n    }\\n\\n    public void addText(String text) {\\n        sb.insert(cursor, text);\\n        incrementBy(text.length());\\n    }\\n\\n    public int deleteText(int k) {\\n        int currentCursor = cursor;\\n        decrementBy(k);\\n        sb.delete(cursor, currentCursor);\\n        return currentCursor - cursor;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        decrementBy(k);\\n        int startPoint = getStartPoint();\\n        return sb.substring(startPoint, cursor);    \\n    }\\n\\n    public String cursorRight(int k) {\\n        incrementBy(k);\\n        int startPoint = getStartPoint();\\n        return sb.substring(startPoint, cursor);\\n    }\\n     \\n    private void decrementBy(int k) {\\n        cursor = Math.max(0, cursor - k);\\n    }\\n    \\n    private void incrementBy(int k) {\\n        cursor = Math.min(cursor + k, sb.length());\\n    }\\n    \\n    private int getStartPoint() {\\n        return (cursor < 10) ? 0 : cursor - 10;\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147232,
                "title": "simple-java-solution",
                "content": "class TextEditor {\\n    \\n    StringBuilder sbString;\\n    int cursor;\\n\\n    public TextEditor() {\\n        sbString = new StringBuilder();\\n        cursor = 0;\\n    }\\n    \\n    public void addText(String text) {\\n        sbString.insert(cursor, text);\\n        cursor += text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int temp = cursor;\\n        cursor -= k;\\n        if(cursor < 0)\\n            cursor = 0;\\n        \\n        sbString.delete(cursor, temp);\\n        return temp - cursor;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor -= k;\\n        \\n        if(cursor < 0)\\n            cursor = 0;\\n        \\n        \\n        if(cursor < 10)\\n            return sbString.substring(0, cursor);\\n        \\n        return sbString.substring(cursor - 10, cursor);    \\n    }\\n    \\n    public String cursorRight(int k) {\\n        cursor += k;\\n        \\n        if(cursor > sbString.length())\\n            cursor = sbString.length();\\n        \\n        if(cursor < 10)\\n            return sbString.substring(0, cursor);\\n        \\n        return sbString.substring(cursor - 10, cursor);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class TextEditor {\\n    \\n    StringBuilder sbString;\\n    int cursor;\\n\\n    public TextEditor() {\\n        sbString = new StringBuilder();\\n        cursor = 0;\\n    }\\n    \\n    public void addText(String text) {\\n        sbString.insert(cursor, text);\\n        cursor += text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int temp = cursor;\\n        cursor -= k;\\n        if(cursor < 0)\\n            cursor = 0;\\n        \\n        sbString.delete(cursor, temp);\\n        return temp - cursor;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor -= k;\\n        \\n        if(cursor < 0)\\n            cursor = 0;\\n        \\n        \\n        if(cursor < 10)\\n            return sbString.substring(0, cursor);\\n        \\n        return sbString.substring(cursor - 10, cursor);    \\n    }\\n    \\n    public String cursorRight(int k) {\\n        cursor += k;\\n        \\n        if(cursor > sbString.length())\\n            cursor = sbString.length();\\n        \\n        if(cursor < 10)\\n            return sbString.substring(0, cursor);\\n        \\n        return sbString.substring(cursor - 10, cursor);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2131988,
                "title": "python-simple-solution-two-stack-only-o-k",
                "content": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        self.left.extend(list(text))\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        while self.left and k:\\n            k -= 1\\n            self.left.pop()\\n            ans += 1\\n        return ans\\n\\n    def cursorLeft(self, k: int) -> str:\\n        while self.left and k:\\n            k -= 1\\n            self.right.append(self.left.pop())\\n        return \"\".join(self.left[-10:])\\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.right:\\n            k -= 1\\n            self.left.append(self.right.pop())\\n        return \"\".join(self.left[-10:])\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        self.left.extend(list(text))\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        while self.left and k:\\n            k -= 1\\n            self.left.pop()\\n            ans += 1\\n        return ans\\n\\n    def cursorLeft(self, k: int) -> str:\\n        while self.left and k:\\n            k -= 1\\n            self.right.append(self.left.pop())\\n        return \"\".join(self.left[-10:])\\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.right:\\n            k -= 1\\n            self.left.append(self.right.pop())\\n        return \"\".join(self.left[-10:])\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127728,
                "title": "doubly-linked-list-solution-object-oriented-code-with-dedicated-functions",
                "content": "```\\nclass TextEditor {\\npublic:\\n    class node{\\n        public:\\n        char val;\\n        node *next, *prev;\\n        \\n        node(char c, node* p, node* n){\\n            val=c;\\n            next = n;\\n            prev = p;\\n        }\\n    };\\n    \\n    node *head, *tail, *ptr;\\n    \\n    TextEditor() {\\n        head = new node(\\'.\\',NULL,NULL);\\n        tail = new node(\\'.\\',NULL,NULL);\\n        ptr = head;\\n        \\n        head->next = tail;\\n        head->prev = NULL;\\n        tail->next = NULL;\\n        tail->prev = head;\\n    }\\n    \\n    node* addNode(node* curr, char c){\\n        node *temp = new node(c,curr, curr->next);\\n        curr->next = temp;\\n        temp->next->prev=temp;\\n        \\n        return temp;\\n    }\\n    \\n    node* delNode(node* curr){\\n        node* temp = curr->prev;\\n        curr->prev->next = curr->next;\\n        curr->next->prev = curr->prev;\\n        delete curr;\\n        return temp;\\n    }\\n    \\n    void addText(string text) {\\n        for(auto i : text){\\n            ptr = addNode(ptr, i);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int res = 0;\\n        while(ptr!=head && res<k){\\n            ptr = delNode(ptr);\\n            res++;\\n        }\\n        return res;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int res=0; string ans=\"\";\\n        while(ptr!=head && res<k){\\n            ptr = ptr->prev;\\n            res++;\\n        }\\n        node *temp = ptr;\\n        res=0;\\n        while(temp!=head && res<10){\\n            ans+=temp->val;\\n            temp = temp->prev;\\n            res++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int res=0; string ans=\"\";\\n        while(ptr->next!=tail && res<k){\\n            ptr = ptr->next;\\n            res++;\\n        }\\n        node *temp = ptr;\\n        res=0;\\n        while(temp!=head && res<10){\\n            ans+=temp->val;\\n            temp = temp->prev;\\n            res++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    class node{\\n        public:\\n        char val;\\n        node *next, *prev;\\n        \\n        node(char c, node* p, node* n){\\n            val=c;\\n            next = n;\\n            prev = p;\\n        }\\n    };\\n    \\n    node *head, *tail, *ptr;\\n    \\n    TextEditor() {\\n        head = new node(\\'.\\',NULL,NULL);\\n        tail = new node(\\'.\\',NULL,NULL);\\n        ptr = head;\\n        \\n        head->next = tail;\\n        head->prev = NULL;\\n        tail->next = NULL;\\n        tail->prev = head;\\n    }\\n    \\n    node* addNode(node* curr, char c){\\n        node *temp = new node(c,curr, curr->next);\\n        curr->next = temp;\\n        temp->next->prev=temp;\\n        \\n        return temp;\\n    }\\n    \\n    node* delNode(node* curr){\\n        node* temp = curr->prev;\\n        curr->prev->next = curr->next;\\n        curr->next->prev = curr->prev;\\n        delete curr;\\n        return temp;\\n    }\\n    \\n    void addText(string text) {\\n        for(auto i : text){\\n            ptr = addNode(ptr, i);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int res = 0;\\n        while(ptr!=head && res<k){\\n            ptr = delNode(ptr);\\n            res++;\\n        }\\n        return res;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int res=0; string ans=\"\";\\n        while(ptr!=head && res<k){\\n            ptr = ptr->prev;\\n            res++;\\n        }\\n        node *temp = ptr;\\n        res=0;\\n        while(temp!=head && res<10){\\n            ans+=temp->val;\\n            temp = temp->prev;\\n            res++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int res=0; string ans=\"\";\\n        while(ptr->next!=tail && res<k){\\n            ptr = ptr->next;\\n            res++;\\n        }\\n        node *temp = ptr;\\n        res=0;\\n        while(temp!=head && res<10){\\n            ans+=temp->val;\\n            temp = temp->prev;\\n            res++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120932,
                "title": "c-simple-two-string-approach-clean-and-concise",
                "content": "```\\nclass TextEditor {\\npublic:\\n    string ltext = \"\", rtext=\"\";\\n    TextEditor() {}\\n    \\n    void addText(string text) {\\n        ltext += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        k = min(k, (int) ltext.size());\\n        ltext.resize(ltext.size() - k);\\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        for(;k > 0 && !ltext.empty(); ltext.pop_back(), k--)\\n            rtext.push_back(ltext.back());\\n            \\n        return ltext.size() >= 10 ? ltext.substr(ltext.size()-10, 10): ltext;\\n    }\\n    \\n    string cursorRight(int k) {\\n        for(;k > 0 && !rtext.empty(); rtext.pop_back(), k--)\\n            ltext.push_back(rtext.back());\\n        \\n        return ltext.size() >= 10 ? ltext.substr(ltext.size()-10, 10): ltext;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string ltext = \"\", rtext=\"\";\\n    TextEditor() {}\\n    \\n    void addText(string text) {\\n        ltext += text;\\n    }\\n    \\n    int deleteText(int k) {\\n        k = min(k, (int) ltext.size());\\n        ltext.resize(ltext.size() - k);\\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        for(;k > 0 && !ltext.empty(); ltext.pop_back(), k--)\\n            rtext.push_back(ltext.back());\\n            \\n        return ltext.size() >= 10 ? ltext.substr(ltext.size()-10, 10): ltext;\\n    }\\n    \\n    string cursorRight(int k) {\\n        for(;k > 0 && !rtext.empty(); rtext.pop_back(), k--)\\n            ltext.push_back(rtext.back());\\n        \\n        return ltext.size() >= 10 ? ltext.substr(ltext.size()-10, 10): ltext;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120229,
                "title": "simple-fast-java-solution-faster-than-100",
                "content": "Java code:\\n```\\nclass TextEditor {\\n    StringBuilder str = new StringBuilder();\\n    int cursorIndex = 0;\\n\\n    public void addText(String text) {\\n        str.insert(cursorIndex, text);\\n        cursorIndex +=text.length();\\n    }\\n\\n    public int deleteText(int k) {\\n        var index = cursorIndex;\\n        if (cursorIndex>k) {\\n            str.delete(cursorIndex - k, cursorIndex);\\n            cursorIndex -= k;\\n            return k;\\n        }\\n        else {\\n            str.delete(0, cursorIndex);\\n            cursorIndex = 0;\\n        }\\n        return index;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        if (cursorIndex>=k) cursorIndex-=k;\\n        else cursorIndex = 0;\\n        var min = Math.min(10, cursorIndex);\\n        return str.substring(cursorIndex-min, cursorIndex);\\n    }\\n\\n    public String cursorRight(int k) {\\n        if (str.length()-cursorIndex>=k) cursorIndex+=k;\\n        else cursorIndex = str.length();\\n        var min = Math.min(10, cursorIndex);\\n        return str.substring(cursorIndex-min, cursorIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\n    StringBuilder str = new StringBuilder();\\n    int cursorIndex = 0;\\n\\n    public void addText(String text) {\\n        str.insert(cursorIndex, text);\\n        cursorIndex +=text.length();\\n    }\\n\\n    public int deleteText(int k) {\\n        var index = cursorIndex;\\n        if (cursorIndex>k) {\\n            str.delete(cursorIndex - k, cursorIndex);\\n            cursorIndex -= k;\\n            return k;\\n        }\\n        else {\\n            str.delete(0, cursorIndex);\\n            cursorIndex = 0;\\n        }\\n        return index;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        if (cursorIndex>=k) cursorIndex-=k;\\n        else cursorIndex = 0;\\n        var min = Math.min(10, cursorIndex);\\n        return str.substring(cursorIndex-min, cursorIndex);\\n    }\\n\\n    public String cursorRight(int k) {\\n        if (str.length()-cursorIndex>=k) cursorIndex+=k;\\n        else cursorIndex = str.length();\\n        var min = Math.min(10, cursorIndex);\\n        return str.substring(cursorIndex-min, cursorIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114003,
                "title": "java-stringbuilder",
                "content": "```\\nclass TextEditor {\\n\\n    StringBuilder sb;\\n    int cursor;\\n    \\n    public TextEditor() {\\n        sb = new StringBuilder();\\n        cursor = 0;\\n    }\\n    \\n    public void addText(String text) {\\n        sb = sb.insert(cursor, text);\\n        cursor += text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int prevPos = cursor;\\n        if(cursor - k >= 0) {\\n            cursor -= k;\\n            sb.delete(cursor, cursor + k);\\n        }else{\\n            sb.delete(0, cursor);\\n            cursor = 0;\\n        }\\n        \\n        return prevPos - cursor;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor = cursor - k >= 0? cursor - k : 0;\\n        return sb.substring(Math.max(cursor - 10, 0), cursor);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        cursor = cursor + k > sb.length()? sb.length() : cursor + k;\\n        return sb.substring(Math.max(cursor - 10, 0), cursor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    StringBuilder sb;\\n    int cursor;\\n    \\n    public TextEditor() {\\n        sb = new StringBuilder();\\n        cursor = 0;\\n    }\\n    \\n    public void addText(String text) {\\n        sb = sb.insert(cursor, text);\\n        cursor += text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int prevPos = cursor;\\n        if(cursor - k >= 0) {\\n            cursor -= k;\\n            sb.delete(cursor, cursor + k);\\n        }else{\\n            sb.delete(0, cursor);\\n            cursor = 0;\\n        }\\n        \\n        return prevPos - cursor;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor = cursor - k >= 0? cursor - k : 0;\\n        return sb.substring(Math.max(cursor - 10, 0), cursor);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        cursor = cursor + k > sb.length()? sb.length() : cursor + k;\\n        return sb.substring(Math.max(cursor - 10, 0), cursor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112584,
                "title": "python-easy-solution",
                "content": "Here we take self.x as an empty string on which we apply our operations and self.p is the pointer which we iterate and move as per the functions say. \\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.x=\"\"\\n        self.p=0\\n\\n    def addText(self, text: str) -> None:\\n        self.x = self.x[:self.p]+text+self.x[self.p:]\\n        self.p += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        y = len(self.x[:self.p])\\n        if k>=y:\\n            self.x=self.x[self.p:]\\n            self.p=0\\n            return y\\n        else:\\n            self.x = self.x[:self.p-k] + self.x[self.p:]\\n            self.p -= k\\n            return k\\n\\n    def cursorLeft(self, k: int) -> str:\\n        if k>=self.p:\\n            self.p = 0\\n            return \"\"\\n        \\n        else:\\n            self.p -= k\\n            y = min(10,self.p)\\n            if y==10:\\n                return self.x[self.p-10:self.p]\\n            else:\\n                return self.x[:self.p]\\n            \\n\\n    def cursorRight(self, k: int) -> str:\\n        z=len(self.x)\\n        if self.p+k >= z:\\n            self.p = z\\n            y = min(10,self.p)\\n            if y==10:\\n                return self.x[self.p-10:self.p]\\n            else:\\n                return self.x[:self.p] \\n        \\n        else:\\n            self.p += k\\n            y = min(10,self.p)\\n            if y==10:\\n                return self.x[self.p-10:self.p]\\n            else:\\n                return self.x[:self.p]\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```\\n\\nIf u understood the code then plz....UPVOTE.....Thnx in adv\\n\\nIf u have some more doubts feel free to write in comment section, would be happy to explain.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.x=\"\"\\n        self.p=0\\n\\n    def addText(self, text: str) -> None:\\n        self.x = self.x[:self.p]+text+self.x[self.p:]\\n        self.p += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        y = len(self.x[:self.p])\\n        if k>=y:\\n            self.x=self.x[self.p:]\\n            self.p=0\\n            return y\\n        else:\\n            self.x = self.x[:self.p-k] + self.x[self.p:]\\n            self.p -= k\\n            return k\\n\\n    def cursorLeft(self, k: int) -> str:\\n        if k>=self.p:\\n            self.p = 0\\n            return \"\"\\n        \\n        else:\\n            self.p -= k\\n            y = min(10,self.p)\\n            if y==10:\\n                return self.x[self.p-10:self.p]\\n            else:\\n                return self.x[:self.p]\\n            \\n\\n    def cursorRight(self, k: int) -> str:\\n        z=len(self.x)\\n        if self.p+k >= z:\\n            self.p = z\\n            y = min(10,self.p)\\n            if y==10:\\n                return self.x[self.p-10:self.p]\\n            else:\\n                return self.x[:self.p] \\n        \\n        else:\\n            self.p += k\\n            y = min(10,self.p)\\n            if y==10:\\n                return self.x[self.p-10:self.p]\\n            else:\\n                return self.x[:self.p]\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112557,
                "title": "java-doubly-linkedlist-easy-contest-imo",
                "content": "I feel like this contest is one of the easiest. Regretted that I wasn\\'t able to participate. Solved the whole contest in 25 minutes with 1 WA on the first problem (yes, the first problem ...).\\n\\nDoubly LinkedList allows us to move the cursor in both directions and support deletion and insertion in O(1).\\n\\nThe only catch is that the cursor can never be tail. \\n```Java\\nclass TextEditor {\\n\\n    private Item head;\\n    private Item tail;\\n    private Item cur;\\n\\n    public TextEditor() {\\n        head = new Item();\\n        tail = new Item();\\n        cur = head;\\n        tail.prev = head;\\n        head.next = tail;\\n    }\\n\\n    public void addText(String text) {\\n        for (char ch : text.toCharArray()){\\n            Item item = new Item(ch);\\n            item.prev = cur;\\n            item.next = cur.next;\\n            cur.next.prev = item;\\n            cur.next = item;\\n            cur = cur.next;\\n        }\\n    }\\n\\n    public int deleteText(int k) {\\n        int sz = k;\\n        while(--k >= 0 && cur != head){\\n            Item next = cur.prev;\\n            cur.next.prev = cur.prev;\\n            cur.prev.next = cur.next;\\n            cur = next;\\n        }\\n        return sz - k - 1;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        while(--k >= 0 && cur != head){\\n            cur = cur.prev;\\n        }\\n        return getText(cur);\\n    }\\n\\n    public String cursorRight(int k) {\\n        while(--k >= 0 && cur.next != tail){\\n            cur = cur.next;\\n        }\\n        return getText(cur);\\n    }\\n\\n    private String getText(Item st){\\n        int k = 10;\\n        StringBuilder sb = new StringBuilder();\\n        while(--k >= 0 && st != head){\\n            sb.append(st.ch);\\n            st = st.prev;\\n        }\\n        return sb.reverse().toString();\\n    }\\n\\n    private class Item {\\n        char ch;\\n        Item next;\\n        Item prev;\\n        Item (){}\\n        Item (char ch){\\n            this.ch = ch;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```Java\\nclass TextEditor {\\n\\n    private Item head;\\n    private Item tail;\\n    private Item cur;\\n\\n    public TextEditor() {\\n        head = new Item();\\n        tail = new Item();\\n        cur = head;\\n        tail.prev = head;\\n        head.next = tail;\\n    }\\n\\n    public void addText(String text) {\\n        for (char ch : text.toCharArray()){\\n            Item item = new Item(ch);\\n            item.prev = cur;\\n            item.next = cur.next;\\n            cur.next.prev = item;\\n            cur.next = item;\\n            cur = cur.next;\\n        }\\n    }\\n\\n    public int deleteText(int k) {\\n        int sz = k;\\n        while(--k >= 0 && cur != head){\\n            Item next = cur.prev;\\n            cur.next.prev = cur.prev;\\n            cur.prev.next = cur.next;\\n            cur = next;\\n        }\\n        return sz - k - 1;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        while(--k >= 0 && cur != head){\\n            cur = cur.prev;\\n        }\\n        return getText(cur);\\n    }\\n\\n    public String cursorRight(int k) {\\n        while(--k >= 0 && cur.next != tail){\\n            cur = cur.next;\\n        }\\n        return getText(cur);\\n    }\\n\\n    private String getText(Item st){\\n        int k = 10;\\n        StringBuilder sb = new StringBuilder();\\n        while(--k >= 0 && st != head){\\n            sb.append(st.ch);\\n            st = st.prev;\\n        }\\n        return sb.reverse().toString();\\n    }\\n\\n    private class Item {\\n        char ch;\\n        Item next;\\n        Item prev;\\n        Item (){}\\n        Item (char ch){\\n            this.ch = ch;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112529,
                "title": "done-using-two-deque-s",
                "content": "to simulate the text editor, i\\'ve done the following:\\ndeque<char> before -> for the part of the text that\\'s currently to the left of the cursor\\ndeque<char> after -> for the part of the text that\\'s currently to the right of the cursor\\n\\nthen to move the cursor to the right do this for example:\\nchar ch = after.front();\\nbefore.push_back(ch);\\nafter.pop_front();\\n\\ni\\'ve used seperate fillString function to get the string of length min(before.size(), 10) \\nrest of the code is easy to understand, hope you liked the approach\\n\\n```\\nclass TextEditor {\\n    deque<char> before;\\n    deque<char> after;\\n    \\n    void fillString(deque<char>& before, string& s) {\\n        int maxLen = 10;\\n        while (before.size() && maxLen --) {\\n            s.push_back(before.back());\\n            before.pop_back();\\n        }\\n        reverse(s.begin(), s.end());\\n        for (auto &ch: s) {\\n            before.push_back(ch);\\n        }\\n    }\\n    \\npublic:\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        for (auto &ch: text) {\\n            before.push_back(ch);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int deleted = 0;\\n        while(before.size() && k --) {\\n            before.pop_back();\\n            deleted ++;\\n        }\\n        return deleted;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while (before.size() && k --) {\\n            char ch = before.back();\\n            after.push_front(ch);\\n            before.pop_back();\\n        }\\n        string s;\\n        fillString(before, s);\\n        return s;\\n    }\\n    \\n    string cursorRight(int k) {\\n        while (after.size() && k --) {\\n            char ch = after.front();\\n            before.push_back(ch);\\n            after.pop_front();\\n        }\\n        string s;\\n        fillString(before, s);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Queue"
                ],
                "code": "```\\nclass TextEditor {\\n    deque<char> before;\\n    deque<char> after;\\n    \\n    void fillString(deque<char>& before, string& s) {\\n        int maxLen = 10;\\n        while (before.size() && maxLen --) {\\n            s.push_back(before.back());\\n            before.pop_back();\\n        }\\n        reverse(s.begin(), s.end());\\n        for (auto &ch: s) {\\n            before.push_back(ch);\\n        }\\n    }\\n    \\npublic:\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        for (auto &ch: text) {\\n            before.push_back(ch);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int deleted = 0;\\n        while(before.size() && k --) {\\n            before.pop_back();\\n            deleted ++;\\n        }\\n        return deleted;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while (before.size() && k --) {\\n            char ch = before.back();\\n            after.push_front(ch);\\n            before.pop_back();\\n        }\\n        string s;\\n        fillString(before, s);\\n        return s;\\n    }\\n    \\n    string cursorRight(int k) {\\n        while (after.size() && k --) {\\n            char ch = after.front();\\n            before.push_back(ch);\\n            after.pop_front();\\n        }\\n        string s;\\n        fillString(before, s);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112221,
                "title": "explained-easy-python-solution-using-string-slicing",
                "content": "# [Explained] Easy Python Solution using String slicing\\n\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        \"\"\"\\n\\t\\tstring storage\\n\\t\\t\"\"\"\\n\\t\\tself.txt = \\'\\'  \\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tcursor/pointer location storage\\n\\t\\t\"\"\"\\n        self.ptr = 0  \\n        \\n\\n    def addText(self, text: str) -> None:\\n\\t\\t\"\"\"\\n\\t\\tslicing the previously added text and \\n\\t\\tadding the new text after pointer location\\n\\t\\t\"\"\"\\n        self.txt = self.txt[:self.ptr] + text + self.txt[self.ptr:]\\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tincrementing the pointer/cursor \\n\\t\\tlocation by the length of the added text\\n\\t\\t\"\"\"\\n        self.ptr += len(text)  \\n        \\n\\n    def deleteText(self, k: int) -> int:\\n\\t\\t\"\"\"\\n\\t\\toriginal length of the string before deletion\\n\\t\\t\"\"\"\\n\\t\\torg = len(self.txt)  \\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tdeleting the text to the left of pointer, \\n\\t\\twhile checking that the pointer value stays above or equal to 0\\n\\t\\t\"\"\"\\n        self.txt = self.txt[:max(self.ptr - k, 0)] + self.txt[self.ptr:]\\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tupdating the pointer/cursor to the current value\\n\\t\\t\"\"\"\\n        self.ptr = max(self.ptr - k, 0)  \\n        \\n\\t\\t\"\"\"\\n\\t\\treturning the difference in lengths of original and new string\\n\\t\\t\"\"\"\\n        return org - len(self.txt)\\n\\n    \\n    def cursorLeft(self, k: int) -> str:\\n        \"\"\"\\n\\t\\tgetting the new value of pointer/cursor\\n\\t\\t\"\"\"\\n\\t\\tself.ptr = max(self.ptr - k, 0)  \\n        \\n\\t\\t\"\"\"\\n\\t\\tbased on the new value returning \\n\\t\\tthe string of minimum length to the left of pointer/cursor\\n\\t\\t\"\"\"\\n        return self.txt[max(0, self.ptr - 10):self.ptr]\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        \"\"\"\\n\\t\\tgetting the new value of pointer/cursor\\n\\t\\t\"\"\"\\n\\t\\tself.ptr = min(self.ptr + k, len(self.txt))  \\n\\n\\t\\t\"\"\"\\n\\t\\tbased on the new value returning\\n\\t\\tthe string of minimum length to the left of pointer/cursor\\n\\t\\t\"\"\"\\n        return self.txt[max(0, self.ptr - 10):self.ptr]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        \"\"\"\\n\\t\\tstring storage\\n\\t\\t\"\"\"\\n\\t\\tself.txt = \\'\\'  \\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tcursor/pointer location storage\\n\\t\\t\"\"\"\\n        self.ptr = 0  \\n        \\n\\n    def addText(self, text: str) -> None:\\n\\t\\t\"\"\"\\n\\t\\tslicing the previously added text and \\n\\t\\tadding the new text after pointer location\\n\\t\\t\"\"\"\\n        self.txt = self.txt[:self.ptr] + text + self.txt[self.ptr:]\\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tincrementing the pointer/cursor \\n\\t\\tlocation by the length of the added text\\n\\t\\t\"\"\"\\n        self.ptr += len(text)  \\n        \\n\\n    def deleteText(self, k: int) -> int:\\n\\t\\t\"\"\"\\n\\t\\toriginal length of the string before deletion\\n\\t\\t\"\"\"\\n\\t\\torg = len(self.txt)  \\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tdeleting the text to the left of pointer, \\n\\t\\twhile checking that the pointer value stays above or equal to 0\\n\\t\\t\"\"\"\\n        self.txt = self.txt[:max(self.ptr - k, 0)] + self.txt[self.ptr:]\\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\tupdating the pointer/cursor to the current value\\n\\t\\t\"\"\"\\n        self.ptr = max(self.ptr - k, 0)  \\n        \\n\\t\\t\"\"\"\\n\\t\\treturning the difference in lengths of original and new string\\n\\t\\t\"\"\"\\n        return org - len(self.txt)\\n\\n    \\n    def cursorLeft(self, k: int) -> str:\\n        \"\"\"\\n\\t\\tgetting the new value of pointer/cursor\\n\\t\\t\"\"\"\\n\\t\\tself.ptr = max(self.ptr - k, 0)  \\n        \\n\\t\\t\"\"\"\\n\\t\\tbased on the new value returning \\n\\t\\tthe string of minimum length to the left of pointer/cursor\\n\\t\\t\"\"\"\\n        return self.txt[max(0, self.ptr - 10):self.ptr]\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        \"\"\"\\n\\t\\tgetting the new value of pointer/cursor\\n\\t\\t\"\"\"\\n\\t\\tself.ptr = min(self.ptr + k, len(self.txt))  \\n\\n\\t\\t\"\"\"\\n\\t\\tbased on the new value returning\\n\\t\\tthe string of minimum length to the left of pointer/cursor\\n\\t\\t\"\"\"\\n        return self.txt[max(0, self.ptr - 10):self.ptr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112148,
                "title": "solved-hard-one-in-contest-for-the-first-time-python",
                "content": "class TextEditor:\\n\\n    def __init__(self):\\n        self.word = \"\"\\n        self.cursor = 0\\n        \\n\\n    def addText(self, text: str) -> None:\\n        self.word = self.word[:self.cursor] + text + self.word[self.cursor:] \\n        self.cursor += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        if self.cursor-k <0: res = self.cursor \\n        else: res = k\\n        self.word = self.word[:max(0,self.cursor-k)] + self.word[self.cursor:]\\n        self.cursor -= k\\n        self.cursor = max(0,self.cursor)\\n        return res\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor -= k\\n        self.cursor = max(0,self.cursor)\\n        return self.word[max(0,self.cursor-10):self.cursor]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor = min(len(self.word),self.cursor + k) \\n        return self.word[max(0,self.cursor-10):self.cursor]\\n        \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class TextEditor:\\n\\n    def __init__(self):\\n        self.word = \"\"\\n        self.cursor = 0\\n        \\n\\n    def addText(self, text: str) -> None:\\n        self.word = self.word[:self.cursor] + text + self.word[self.cursor:] \\n        self.cursor += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        if self.cursor-k <0: res = self.cursor \\n        else: res = k\\n        self.word = self.word[:max(0,self.cursor-k)] + self.word[self.cursor:]\\n        self.cursor -= k\\n        self.cursor = max(0,self.cursor)\\n        return res\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor -= k\\n        self.cursor = max(0,self.cursor)\\n        return self.word[max(0,self.cursor-10):self.cursor]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor = min(len(self.word),self.cursor + k) \\n        return self.word[max(0,self.cursor-10):self.cursor]\\n        \\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2112115,
                "title": "easy-c-solution-using-strings-accepted",
                "content": "Here is the intitutive solution which got accepted though i missed this by 1 min in contest...........\\n```\\nclass TextEditor {\\npublic:\\n    string all_text;\\n    int cur_pos;\\n    TextEditor() {\\n        cur_pos=0;\\n        all_text=\"\";\\n    }\\n    \\n    void addText(string text) {\\n        all_text.insert(cur_pos, text);\\n        int k=text.size();\\n        cur_pos+=k;\\n    }\\n    \\n    int deleteText(int k) {\\n        if(cur_pos<k)\\n        {\\n            all_text=all_text.substr(cur_pos);\\n            int ans=cur_pos;\\n            cur_pos=0;\\n            return ans;\\n        }\\n        else\\n        {\\n            all_text.erase(cur_pos-k,k);\\n            cur_pos-=k;\\n            return k;\\n        }\\n    }\\n    \\n    string cursorLeft(int k) {\\n        cur_pos-=k;\\n        if(cur_pos<0)\\n            cur_pos=0;\\n        if(cur_pos<10)\\n            return all_text.substr(0,cur_pos);\\n        return all_text.substr(cur_pos-10,10);\\n            \\n    }\\n    \\n    string cursorRight(int k) {\\n        cur_pos+=k;\\n        if(cur_pos>all_text.size())\\n            cur_pos=all_text.size();\\n        if(cur_pos<10)\\n            return all_text.substr(0,cur_pos);\\n        return all_text.substr(cur_pos-10,10);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string all_text;\\n    int cur_pos;\\n    TextEditor() {\\n        cur_pos=0;\\n        all_text=\"\";\\n    }\\n    \\n    void addText(string text) {\\n        all_text.insert(cur_pos, text);\\n        int k=text.size();\\n        cur_pos+=k;\\n    }\\n    \\n    int deleteText(int k) {\\n        if(cur_pos<k)\\n        {\\n            all_text=all_text.substr(cur_pos);\\n            int ans=cur_pos;\\n            cur_pos=0;\\n            return ans;\\n        }\\n        else\\n        {\\n            all_text.erase(cur_pos-k,k);\\n            cur_pos-=k;\\n            return k;\\n        }\\n    }\\n    \\n    string cursorLeft(int k) {\\n        cur_pos-=k;\\n        if(cur_pos<0)\\n            cur_pos=0;\\n        if(cur_pos<10)\\n            return all_text.substr(0,cur_pos);\\n        return all_text.substr(cur_pos-10,10);\\n            \\n    }\\n    \\n    string cursorRight(int k) {\\n        cur_pos+=k;\\n        if(cur_pos>all_text.size())\\n            cur_pos=all_text.size();\\n        if(cur_pos<10)\\n            return all_text.substr(0,cur_pos);\\n        return all_text.substr(cur_pos-10,10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111888,
                "title": "python-doubly-linked-list",
                "content": "```\\nclass Node:\\n    def __init__(self, val = None, prev = None, next = None):\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n        \\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.dummy = Node()\\n        self.cursor = self.dummy\\n\\n    def addText(self, text: str) -> None:\\n        _next = self.cursor.next\\n        for c in text:\\n            self.cursor.next = Node(val = c)\\n            self.cursor.next.prev = self.cursor\\n            self.cursor = self.cursor.next\\n        self.cursor.next = _next\\n        if _next:\\n            _next.prev = self.cursor\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        _next = self.cursor.next\\n        while ans < k and self.cursor.val:\\n            self.cursor = self.cursor.prev\\n            ans += 1\\n        self.cursor.next = _next\\n        if _next:\\n            _next.prev = self.cursor\\n        return ans      \\n\\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while i < k and self.cursor.prev:\\n            self.cursor = self.cursor.prev\\n            i += 1\\n        ans = []\\n        temp = self.cursor\\n        j = 0\\n        while j < 10 and temp.val:\\n            ans.append(temp.val)\\n            temp = temp.prev\\n            j += 1\\n        return \\'\\'.join(ans[::-1])\\n\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while i < k and self.cursor.next:\\n            self.cursor = self.cursor.next\\n            i += 1\\n        ans = []\\n        temp = self.cursor\\n        j = 0\\n        while j < 10 and temp.val:\\n            ans.append(temp.val)\\n            temp = temp.prev\\n            j += 1\\n        return \\'\\'.join(ans[::-1])\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val = None, prev = None, next = None):\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n        \\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.dummy = Node()\\n        self.cursor = self.dummy\\n\\n    def addText(self, text: str) -> None:\\n        _next = self.cursor.next\\n        for c in text:\\n            self.cursor.next = Node(val = c)\\n            self.cursor.next.prev = self.cursor\\n            self.cursor = self.cursor.next\\n        self.cursor.next = _next\\n        if _next:\\n            _next.prev = self.cursor\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0\\n        _next = self.cursor.next\\n        while ans < k and self.cursor.val:\\n            self.cursor = self.cursor.prev\\n            ans += 1\\n        self.cursor.next = _next\\n        if _next:\\n            _next.prev = self.cursor\\n        return ans      \\n\\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while i < k and self.cursor.prev:\\n            self.cursor = self.cursor.prev\\n            i += 1\\n        ans = []\\n        temp = self.cursor\\n        j = 0\\n        while j < 10 and temp.val:\\n            ans.append(temp.val)\\n            temp = temp.prev\\n            j += 1\\n        return \\'\\'.join(ans[::-1])\\n\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while i < k and self.cursor.next:\\n            self.cursor = self.cursor.next\\n            i += 1\\n        ans = []\\n        temp = self.cursor\\n        j = 0\\n        while j < 10 and temp.val:\\n            ans.append(temp.val)\\n            temp = temp.prev\\n            j += 1\\n        return \\'\\'.join(ans[::-1])\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111869,
                "title": "c-string-manipulation-substr-function",
                "content": "UPD : This solution got AC in contest , now showing TLE.\\n```\\nclass TextEditor {\\npublic:\\n    string s = \"\";\\n    int cursor = 0;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        s = s.insert(cursor,text);\\n        cursor = cursor + text.size();\\n    }\\n    \\n    int deleteText(int k) {\\n        int ans = min(cursor,k);\\n        s.erase(cursor-ans,ans);\\n        cursor = cursor - ans;\\n        return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int maxCursorLeft = min(k,cursor);\\n        cursor = cursor - maxCursorLeft;\\n        int leftChars = min(10,cursor);\\n        string ans = s.substr(cursor-leftChars,leftChars);\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int maxCursorRight = min(k,int(s.size())-cursor);\\n        cursor = cursor + maxCursorRight;\\n        int leftChars = min(10,cursor);\\n        string ans = s.substr(cursor-leftChars,leftChars);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n \\n ```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string s = \"\";\\n    int cursor = 0;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        s = s.insert(cursor,text);\\n        cursor = cursor + text.size();\\n    }\\n    \\n    int deleteText(int k) {\\n        int ans = min(cursor,k);\\n        s.erase(cursor-ans,ans);\\n        cursor = cursor - ans;\\n        return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int maxCursorLeft = min(k,cursor);\\n        cursor = cursor - maxCursorLeft;\\n        int leftChars = min(10,cursor);\\n        string ans = s.substr(cursor-leftChars,leftChars);\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int maxCursorRight = min(k,int(s.size())-cursor);\\n        cursor = cursor + maxCursorRight;\\n        int leftChars = min(10,cursor);\\n        string ans = s.substr(cursor-leftChars,leftChars);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 4031600,
                "title": "simple-o-k-python-solution-in-11-lines-of-code-beats-89-84",
                "content": "# Complexity\\n- Time complexities: $$\\\\begin{matrix}\\n\\\\textrm{\\\\_\\\\_init\\\\_\\\\_} & \\\\mathcal O(1) \\\\\\\\\\n\\\\textrm{addText} & \\\\mathcal O(len(text)) \\\\\\\\\\n\\\\textrm{deleteText} & \\\\mathcal O(k) \\\\\\\\\\n\\\\textrm{cursorLeft} & \\\\mathcal O(k) \\\\\\\\\\n\\\\textrm{cursorRight} & \\\\mathcal O(k)\\n\\\\end{matrix}$$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $\\\\mathcal O(max(len(currentText)))$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        # Two stacks that are relative to the cursor, r is in reverse\\n        self.l, self.r = [], []\\n\\n    def addText(self, text: str) -> None:\\n        self.l.extend(list(text))\\n\\n    def deleteText(self, k: int) -> int:\\n        for _ in range((d := min(k, len(self.l)))):\\n            self.l.pop()\\n        return d\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(min(k, len(self.l))):\\n            self.r.append(self.l.pop())\\n        return \\'\\'.join(self.l[-10:])\\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(min(k, len(self.r))):\\n            self.l.append(self.r.pop())\\n        return \\'\\'.join(self.l[-10:])\\n        \\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        # Two stacks that are relative to the cursor, r is in reverse\\n        self.l, self.r = [], []\\n\\n    def addText(self, text: str) -> None:\\n        self.l.extend(list(text))\\n\\n    def deleteText(self, k: int) -> int:\\n        for _ in range((d := min(k, len(self.l)))):\\n            self.l.pop()\\n        return d\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(min(k, len(self.l))):\\n            self.r.append(self.l.pop())\\n        return \\'\\'.join(self.l[-10:])\\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(min(k, len(self.r))):\\n            self.l.append(self.r.pop())\\n        return \\'\\'.join(self.l[-10:])\\n        \\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986050,
                "title": "python-easy-problem-just-do-what-asked",
                "content": "```python\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.data = \\'\\'\\n        self.cursor = 0\\n\\n    def addText(self, text: str) -> None:\\n        before, after = self.data[:self.cursor], self.data[self.cursor:]\\n        self.data = before + text + after\\n        self.cursor += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        before, after = self.data[:self.cursor], self.data[self.cursor:]\\n\\n        deleted = len(before)\\n        before = before[:-k]\\n        deleted -= len(before)\\n\\n        self.data = before + after\\n        self.cursor -= deleted\\n        return deleted\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor -= min(self.cursor, k)\\n        return self.data[self.cursor - min(10, self.cursor):self.cursor]\\n\\n    def cursorRight(self, k: int) -> str:\\n        _max = len(self.data) - self.cursor\\n        self.cursor += min(k, _max)\\n        return self.data[self.cursor - min(10, self.cursor):self.cursor]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.data = \\'\\'\\n        self.cursor = 0\\n\\n    def addText(self, text: str) -> None:\\n        before, after = self.data[:self.cursor], self.data[self.cursor:]\\n        self.data = before + text + after\\n        self.cursor += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        before, after = self.data[:self.cursor], self.data[self.cursor:]\\n\\n        deleted = len(before)\\n        before = before[:-k]\\n        deleted -= len(before)\\n\\n        self.data = before + after\\n        self.cursor -= deleted\\n        return deleted\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor -= min(self.cursor, k)\\n        return self.data[self.cursor - min(10, self.cursor):self.cursor]\\n\\n    def cursorRight(self, k: int) -> str:\\n        _max = len(self.data) - self.cursor\\n        self.cursor += min(k, _max)\\n        return self.data[self.cursor - min(10, self.cursor):self.cursor]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687886,
                "title": "python-easy-logical-starightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse python functions to manipulate strings\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe tricky part is to figure which index location is our cursor present..\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.tex=\"\"\\n        self.pos=0\\n\\n    def addText(self, text: str) -> None:\\n        self.tex=self.tex[:self.pos]+text+self.tex[self.pos:]\\n        self.pos+=len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        de=max(self.pos-k,0)\\n        d=min(self.pos,k)\\n        self.tex=self.tex[:de]+self.tex[self.pos:]\\n        self.pos=de\\n        return d\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.pos=max(0,self.pos-k)\\n        return self.tex[max(0,self.pos-10):self.pos]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.pos=min(len(self.tex),self.pos+k)\\n        return self.tex[max(0,self.pos-10):self.pos]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.tex=\"\"\\n        self.pos=0\\n\\n    def addText(self, text: str) -> None:\\n        self.tex=self.tex[:self.pos]+text+self.tex[self.pos:]\\n        self.pos+=len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        de=max(self.pos-k,0)\\n        d=min(self.pos,k)\\n        self.tex=self.tex[:de]+self.tex[self.pos:]\\n        self.pos=de\\n        return d\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.pos=max(0,self.pos-k)\\n        return self.tex[max(0,self.pos-10):self.pos]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.pos=min(len(self.tex),self.pos+k)\\n        return self.tex[max(0,self.pos-10):self.pos]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674175,
                "title": "java-using-stringbuilder-count",
                "content": "# Code\\n```\\nclass TextEditor {\\n\\n    StringBuilder sb;\\n    int cursor;\\n    public TextEditor() {\\n        sb = new StringBuilder();\\n        cursor = 0;\\n    }\\n\\n    public void addText(String text) {\\n        sb.replace(cursor, cursor, text);\\n        cursor += text.length();\\n    }\\n\\n    public int deleteText(int k) {\\n        if (k >= cursor) {\\n            sb.replace(0, cursor, \"\");\\n            int temp = cursor;\\n            cursor = 0;\\n            return temp;\\n        } else {\\n            sb.replace(cursor - k, cursor, \"\");\\n            cursor -= k;\\n            return k;\\n        }\\n    }\\n\\n    public String cursorLeft(int k) {\\n        cursor = Math.max(0, cursor - k);\\n        int len = Math.min(10, cursor);\\n        return sb.substring(cursor - len, cursor);\\n    }\\n\\n    public String cursorRight(int k) {\\n        cursor = Math.min(cursor + k, sb.length());\\n        int len = Math.min(10, cursor);\\n        return sb.substring(cursor - len, cursor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    StringBuilder sb;\\n    int cursor;\\n    public TextEditor() {\\n        sb = new StringBuilder();\\n        cursor = 0;\\n    }\\n\\n    public void addText(String text) {\\n        sb.replace(cursor, cursor, text);\\n        cursor += text.length();\\n    }\\n\\n    public int deleteText(int k) {\\n        if (k >= cursor) {\\n            sb.replace(0, cursor, \"\");\\n            int temp = cursor;\\n            cursor = 0;\\n            return temp;\\n        } else {\\n            sb.replace(cursor - k, cursor, \"\");\\n            cursor -= k;\\n            return k;\\n        }\\n    }\\n\\n    public String cursorLeft(int k) {\\n        cursor = Math.max(0, cursor - k);\\n        int len = Math.min(10, cursor);\\n        return sb.substring(cursor - len, cursor);\\n    }\\n\\n    public String cursorRight(int k) {\\n        cursor = Math.min(cursor + k, sb.length());\\n        int len = Math.min(10, cursor);\\n        return sb.substring(cursor - len, cursor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502757,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class TextEditor {\\n    private StringBuilder text;\\n    private int cursorPosition;\\n\\n    public TextEditor() {\\n        text = new StringBuilder();\\n        cursorPosition = 0;\\n    }\\n\\n    public void addText(String textToAdd) {\\n        text.insert(cursorPosition, textToAdd);\\n        cursorPosition += textToAdd.length();\\n    }\\n\\n    public int deleteText(int k) {\\n        int numCharsToDelete = Math.min(k, cursorPosition);\\n        text.delete(cursorPosition - numCharsToDelete, cursorPosition);\\n        cursorPosition -= numCharsToDelete;\\n        return numCharsToDelete;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        cursorPosition = Math.max(0, cursorPosition - k);\\n        int start = Math.max(0, cursorPosition - 10);\\n        return text.substring(start, cursorPosition);\\n    }\\n\\n    public String cursorRight(int k) {\\n        cursorPosition = Math.min(text.length(), cursorPosition + k);\\n        int start = Math.max(0, cursorPosition - 10);\\n        return text.substring(start, cursorPosition);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class TextEditor {\\n    private StringBuilder text;\\n    private int cursorPosition;\\n\\n    public TextEditor() {\\n        text = new StringBuilder();\\n        cursorPosition = 0;\\n    }\\n\\n    public void addText(String textToAdd) {\\n        text.insert(cursorPosition, textToAdd);\\n        cursorPosition += textToAdd.length();\\n    }\\n\\n    public int deleteText(int k) {\\n        int numCharsToDelete = Math.min(k, cursorPosition);\\n        text.delete(cursorPosition - numCharsToDelete, cursorPosition);\\n        cursorPosition -= numCharsToDelete;\\n        return numCharsToDelete;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        cursorPosition = Math.max(0, cursorPosition - k);\\n        int start = Math.max(0, cursorPosition - 10);\\n        return text.substring(start, cursorPosition);\\n    }\\n\\n    public String cursorRight(int k) {\\n        cursorPosition = Math.min(text.length(), cursorPosition + k);\\n        int start = Math.max(0, cursorPosition - 10);\\n        return text.substring(start, cursorPosition);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411922,
                "title": "java-97-faster-doubly-linked-list-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass TextEditor {\\n\\n    class Node {\\n        char chr;\\n        Node next, prev;\\n        Node(char _chr, Node _next, Node _prev) {\\n            this.chr = _chr;\\n            this.next = _next;\\n            this.prev = _prev;\\n        }\\n    }\\n    Node fakeHead, fakeTail, cursor;\\n\\n    public TextEditor() {\\n        this.fakeHead = new Node(\\'1\\', null, null);\\n        this.fakeTail = new Node(\\'9\\', null, null);\\n\\n        this.fakeHead.next = this.fakeTail;\\n        this.fakeTail.prev = this.fakeHead;\\n\\n        this.cursor = this.fakeHead;\\n    }\\n    \\n    public void addText(String text) {\\n        for(char c : text.toCharArray()) {\\n            Node node = new Node(c, cursor.next, cursor);\\n            cursor.next.prev = node;\\n            cursor.next = node;\\n            cursor = node;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int x = k;\\n        while(x > 0 && cursor != fakeHead) {\\n            cursor.prev.next = cursor.next;\\n            cursor.next.prev = cursor.prev;\\n            cursor = cursor.prev;\\n            x--;\\n        }\\n        return k-x;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while(k > 0 && cursor != fakeHead) {\\n            cursor = cursor.prev;\\n            k--;\\n        }\\n        return printLeftString(cursor);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while(k > 0 && cursor != fakeTail) {\\n            cursor = cursor.next;\\n            k--;\\n        }\\n        if(cursor == fakeTail) {\\n            cursor = fakeTail.prev;\\n        }\\n        return printLeftString(cursor);\\n    }\\n\\n    private String printLeftString(Node temp) {\\n        int i = 0;\\n        StringBuffer sb = new StringBuffer();\\n\\n        while(i < 10 && temp != fakeHead) {\\n            sb.append(Character.toString(temp.chr));\\n            temp = temp.prev;\\n            i++;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    class Node {\\n        char chr;\\n        Node next, prev;\\n        Node(char _chr, Node _next, Node _prev) {\\n            this.chr = _chr;\\n            this.next = _next;\\n            this.prev = _prev;\\n        }\\n    }\\n    Node fakeHead, fakeTail, cursor;\\n\\n    public TextEditor() {\\n        this.fakeHead = new Node(\\'1\\', null, null);\\n        this.fakeTail = new Node(\\'9\\', null, null);\\n\\n        this.fakeHead.next = this.fakeTail;\\n        this.fakeTail.prev = this.fakeHead;\\n\\n        this.cursor = this.fakeHead;\\n    }\\n    \\n    public void addText(String text) {\\n        for(char c : text.toCharArray()) {\\n            Node node = new Node(c, cursor.next, cursor);\\n            cursor.next.prev = node;\\n            cursor.next = node;\\n            cursor = node;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int x = k;\\n        while(x > 0 && cursor != fakeHead) {\\n            cursor.prev.next = cursor.next;\\n            cursor.next.prev = cursor.prev;\\n            cursor = cursor.prev;\\n            x--;\\n        }\\n        return k-x;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while(k > 0 && cursor != fakeHead) {\\n            cursor = cursor.prev;\\n            k--;\\n        }\\n        return printLeftString(cursor);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while(k > 0 && cursor != fakeTail) {\\n            cursor = cursor.next;\\n            k--;\\n        }\\n        if(cursor == fakeTail) {\\n            cursor = fakeTail.prev;\\n        }\\n        return printLeftString(cursor);\\n    }\\n\\n    private String printLeftString(Node temp) {\\n        int i = 0;\\n        StringBuffer sb = new StringBuffer();\\n\\n        while(i < 10 && temp != fakeHead) {\\n            sb.append(Character.toString(temp.chr));\\n            temp = temp.prev;\\n            i++;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895645,
                "title": "c-stringbuilder",
                "content": "The first intuitive solution was to use two Stacks but I didn\\'t like the idea of extra allocation to get stack data and push it back afterwards\\n# Code\\n```\\n    public class TextEditor\\n    {\\n        StringBuilder sb;\\n        int cursorPosition = 0;\\n\\n        public TextEditor()\\n        {\\n            sb = new();\\n        }\\n\\n        public void AddText(string text)\\n        {\\n            sb.Insert(cursorPosition, text);\\n            cursorPosition += text.Length;\\n        }\\n\\n        public int DeleteText(int k)\\n        {\\n            int deletedAmount = k;\\n\\n            if (cursorPosition < k)\\n            {\\n                deletedAmount = cursorPosition;\\n                cursorPosition = 0;\\n            }\\n            else\\n            {\\n                cursorPosition -= k;\\n            }\\n\\n            sb.Remove(cursorPosition, deletedAmount);\\n\\n            return deletedAmount;\\n        }\\n\\n        public string CursorLeft(int k)\\n        {\\n            cursorPosition = Math.Max(0, cursorPosition - k);\\n\\n            if (cursorPosition < 10)\\n            {\\n                return sb.ToString(0, cursorPosition);\\n            }\\n\\n            return sb.ToString(cursorPosition - 10, 10);\\n        }\\n\\n        public string CursorRight(int k)\\n        {\\n            cursorPosition = Math.Min(sb.Length, cursorPosition + k);\\n\\n            if (cursorPosition < 10)\\n            {\\n                return sb.ToString(0, cursorPosition);\\n            }\\n\\n            return sb.ToString(cursorPosition - 10, 10);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    public class TextEditor\\n    {\\n        StringBuilder sb;\\n        int cursorPosition = 0;\\n\\n        public TextEditor()\\n        {\\n            sb = new();\\n        }\\n\\n        public void AddText(string text)\\n        {\\n            sb.Insert(cursorPosition, text);\\n            cursorPosition += text.Length;\\n        }\\n\\n        public int DeleteText(int k)\\n        {\\n            int deletedAmount = k;\\n\\n            if (cursorPosition < k)\\n            {\\n                deletedAmount = cursorPosition;\\n                cursorPosition = 0;\\n            }\\n            else\\n            {\\n                cursorPosition -= k;\\n            }\\n\\n            sb.Remove(cursorPosition, deletedAmount);\\n\\n            return deletedAmount;\\n        }\\n\\n        public string CursorLeft(int k)\\n        {\\n            cursorPosition = Math.Max(0, cursorPosition - k);\\n\\n            if (cursorPosition < 10)\\n            {\\n                return sb.ToString(0, cursorPosition);\\n            }\\n\\n            return sb.ToString(cursorPosition - 10, 10);\\n        }\\n\\n        public string CursorRight(int k)\\n        {\\n            cursorPosition = Math.Min(sb.Length, cursorPosition + k);\\n\\n            if (cursorPosition < 10)\\n            {\\n                return sb.ToString(0, cursorPosition);\\n            }\\n\\n            return sb.ToString(cursorPosition - 10, 10);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598216,
                "title": "easy-solution",
                "content": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.st=\"\"\\n        self.cur=0\\n\\n    def addText(self, text: str) -> None:\\n        self.st=self.st[:self.cur]+text+self.st[self.cur:]\\n        self.cur+=len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        if(self.cur>k):\\n            self.st=self.st[:self.cur-k]+self.st[self.cur:]\\n            self.cur-=k\\n            return(k)\\n        else:\\n            self.st=self.st[self.cur:]\\n            z=self.cur\\n            self.cur=0\\n            return(z)\\n    def cursorLeft(self, k: int) -> str:\\n        if(self.cur>k):\\n            self.cur-=k\\n        else:\\n            self.cur=0\\n        z=self.st[:self.cur][-10:]\\n        return(z)\\n\\n    def cursorRight(self, k: int) -> str:\\n        if(len(self.st)-self.cur>k):\\n            z=self.st[self.cur:self.cur+k]\\n            self.cur+=k\\n        else:\\n            self.cur=len(self.st)\\n        z=self.st[:self.cur][-10:]\\n        return(z)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.st=\"\"\\n        self.cur=0\\n\\n    def addText(self, text: str) -> None:\\n        self.st=self.st[:self.cur]+text+self.st[self.cur:]\\n        self.cur+=len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        if(self.cur>k):\\n            self.st=self.st[:self.cur-k]+self.st[self.cur:]\\n            self.cur-=k\\n            return(k)\\n        else:\\n            self.st=self.st[self.cur:]\\n            z=self.cur\\n            self.cur=0\\n            return(z)\\n    def cursorLeft(self, k: int) -> str:\\n        if(self.cur>k):\\n            self.cur-=k\\n        else:\\n            self.cur=0\\n        z=self.st[:self.cur][-10:]\\n        return(z)\\n\\n    def cursorRight(self, k: int) -> str:\\n        if(len(self.st)-self.cur>k):\\n            z=self.st[self.cur:self.cur+k]\\n            self.cur+=k\\n        else:\\n            self.cur=len(self.st)\\n        z=self.st[:self.cur][-10:]\\n        return(z)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404510,
                "title": "python-double-linked-list-solution",
                "content": "Clean, readable solution using Double Linked list.\\n\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nclass TextEditor:\\n    \\n    def _addNode(self, prevNode, nxtNode, curNode):\\n        prevNode.next = curNode\\n        curNode.prev = prevNode\\n        curNode.next = nxtNode\\n        nxtNode.prev = curNode        \\n    \\n    def _removeNode(self, node):\\n        prev = node.prev\\n        nxt = node.next\\n        \\n        if prev:\\n            prev.next = nxt\\n        if nxt:\\n            nxt.prev = prev\\n\\n    def __init__(self):\\n        self.head = Node(\"\")\\n        self.tail = Node(\"\")\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n        self.cursor = self.head\\n        \\n\\n    def addText(self, text: str) -> None:\\n        for char in text:\\n            newNode = Node(char)\\n            self._addNode(self.cursor, self.cursor.next, newNode)\\n            self.cursor = newNode\\n\\n    def deleteText(self, k: int) -> int:\\n        beenDeleted = 0\\n        for _ in range(k):\\n            if self.cursor.prev:\\n                prev = self.cursor.prev\\n                self._removeNode(self.cursor)\\n                self.cursor = prev\\n                beenDeleted += 1\\n                \\n        return beenDeleted\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.cursor.prev:\\n                self.cursor = self.cursor.prev\\n                \\n        return self._buildString(self.cursor)\\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.cursor.next.next:\\n                self.cursor = self.cursor.next\\n                \\n        return self._buildString(self.cursor)\\n    \\n    def _buildLeftString(self, cursor):\\n        temp = self.cursor\\n        count = 0\\n        res = \"\"\\n        while temp != self.head and count != 10:\\n            res = temp.val + res\\n            temp = temp.prev\\n            count += 1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n\\nclass TextEditor:\\n    \\n    def _addNode(self, prevNode, nxtNode, curNode):\\n        prevNode.next = curNode\\n        curNode.prev = prevNode\\n        curNode.next = nxtNode\\n        nxtNode.prev = curNode        \\n    \\n    def _removeNode(self, node):\\n        prev = node.prev\\n        nxt = node.next\\n        \\n        if prev:\\n            prev.next = nxt\\n        if nxt:\\n            nxt.prev = prev\\n\\n    def __init__(self):\\n        self.head = Node(\"\")\\n        self.tail = Node(\"\")\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        \\n        self.cursor = self.head\\n        \\n\\n    def addText(self, text: str) -> None:\\n        for char in text:\\n            newNode = Node(char)\\n            self._addNode(self.cursor, self.cursor.next, newNode)\\n            self.cursor = newNode\\n\\n    def deleteText(self, k: int) -> int:\\n        beenDeleted = 0\\n        for _ in range(k):\\n            if self.cursor.prev:\\n                prev = self.cursor.prev\\n                self._removeNode(self.cursor)\\n                self.cursor = prev\\n                beenDeleted += 1\\n                \\n        return beenDeleted\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.cursor.prev:\\n                self.cursor = self.cursor.prev\\n                \\n        return self._buildString(self.cursor)\\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.cursor.next.next:\\n                self.cursor = self.cursor.next\\n                \\n        return self._buildString(self.cursor)\\n    \\n    def _buildLeftString(self, cursor):\\n        temp = self.cursor\\n        count = 0\\n        res = \"\"\\n        while temp != self.head and count != 10:\\n            res = temp.val + res\\n            temp = temp.prev\\n            count += 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362594,
                "title": "python-3-sucess-faster-than-99-70",
                "content": "![image](https://assets.leetcode.com/users/images/25adb851-c1fb-4bf8-91f4-732ce39fa715_1659327580.377505.png)\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = deque([])\\n        \\n\\n    def addText(self, text: str) -> None:\\n        self.left.append(text)\\n        \\n\\n    def deleteText(self, k: int) -> int:\\n        total = 0\\n        while k:\\n            if not self.left:\\n                break\\n            s = self.left.pop()\\n            if len(s) > k:\\n                s = s[:-k]\\n                self.left.append(s)\\n                total +=k\\n                break\\n            k -= len(s)\\n            total += len(s)\\n        return total\\n\\n    def cursorLeft(self, k: int) -> str:\\n        total = 0\\n        while k:\\n            if not self.left:\\n                break\\n            s = self.left.pop()\\n            if len(s) > k:\\n                self.left.append(s[:-k])\\n                self.right.appendleft(s[-k:])\\n                break\\n            self.right.appendleft(s)\\n            k -= len(s)\\n        return self.get()\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        total = 0\\n        while k:\\n            if not self.right:\\n                break\\n            s = self.right.popleft()\\n            if len(s) > k:\\n                self.left.append(s[:k])\\n                self.right.appendleft(s[k:])\\n                break\\n            self.left.append(s)\\n            k -= len(s)\\n        return self.get()\\n    \\n    def get(self):\\n        ans = \\'\\'\\n        i = len(self.left) - 1\\n        while i >= 0 and len(ans) < 10:\\n            ans = self.left[i] + ans\\n            i -= 1\\n        return ans[-10:]\\n                \\n            \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = deque([])\\n        \\n\\n    def addText(self, text: str) -> None:\\n        self.left.append(text)\\n        \\n\\n    def deleteText(self, k: int) -> int:\\n        total = 0\\n        while k:\\n            if not self.left:\\n                break\\n            s = self.left.pop()\\n            if len(s) > k:\\n                s = s[:-k]\\n                self.left.append(s)\\n                total +=k\\n                break\\n            k -= len(s)\\n            total += len(s)\\n        return total\\n\\n    def cursorLeft(self, k: int) -> str:\\n        total = 0\\n        while k:\\n            if not self.left:\\n                break\\n            s = self.left.pop()\\n            if len(s) > k:\\n                self.left.append(s[:-k])\\n                self.right.appendleft(s[-k:])\\n                break\\n            self.right.appendleft(s)\\n            k -= len(s)\\n        return self.get()\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        total = 0\\n        while k:\\n            if not self.right:\\n                break\\n            s = self.right.popleft()\\n            if len(s) > k:\\n                self.left.append(s[:k])\\n                self.right.appendleft(s[k:])\\n                break\\n            self.left.append(s)\\n            k -= len(s)\\n        return self.get()\\n    \\n    def get(self):\\n        ans = \\'\\'\\n        i = len(self.left) - 1\\n        while i >= 0 and len(ans) < 10:\\n            ans = self.left[i] + ans\\n            i -= 1\\n        return ans[-10:]\\n                \\n            \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333487,
                "title": "java-doubly-linked-list",
                "content": "**Doubly Linked List:**\\n    \\n\\t// our linked list node\\n    class Node{\\n        char ch;\\n        Node prev, next;\\n        \\n        Node() {}\\n        Node(char ch, Node p){\\n            this.ch = ch;\\n            this.prev = p;\\n        }\\n    }\\n\\t\\n\\t// root: dummy node for start of list\\n\\t// curr: current node where cursor is\\n    Node root = new Node();\\n    Node curr = root;\\n\\t\\n\\t\\n\\t// Make a new List for the new Text and then insert it into our main list.\\n    public void addText(String text) {\\n        \\n\\t\\t// head: dummy head for new list,\\n\\t\\t// temp: used for adding next nodes.\\n        Node head = new Node(), temp = head;\\n        for(char ch : text.toCharArray()){\\n            temp.next = new Node(ch, temp);\\n            temp = temp.next;\\n        }\\n        \\n\\t\\t// move dummy head to our actual head\\n        head = head.next;\\n\\t\\t\\n\\t\\t// insert new list into our main list\\n        Node next = curr.next;\\n        curr.next = head;\\n        head.prev = curr;\\n        temp.next = next;\\n        if(next!=null)\\n            next.prev = temp;\\n        \\n\\t\\t// our cursor will now be at the last node of new list\\n        curr = temp;  \\n    }\\n    \\n    public int deleteText(int k) {\\n        int i=0;\\n        Node next = curr.next;\\n        while(k!=0 && curr!=root){\\n            curr = curr.prev;\\n            i++; k--;\\n        }\\n        curr.next = next;\\n        if(next!=null)\\n            next.prev = curr;\\n        return i;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while(k!=0 && curr!=root){\\n            curr = curr.prev;\\n            k--;\\n        }\\n        return getLast();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        Node prev = null;\\n        while(k!=0 && curr!=null){\\n            prev = curr;\\n            curr = curr.next;\\n            k--;\\n        }\\n        if(curr==null)\\n            curr = prev;\\n        return getLast();\\n    }\\n    \\n\\t\\n\\t// return last min(10, len) length string\\n    public String getLast(){\\n\\t\\n        Node temp = curr;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<10 && temp!=root; i++){\\n            sb.append(temp.ch);\\n            temp = temp.prev;\\n        }\\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "**Doubly Linked List:**\\n    \\n\\t// our linked list node\\n    class Node{\\n        char ch;\\n        Node prev, next;\\n        \\n        Node() {}\\n        Node(char ch, Node p){\\n            this.ch = ch;\\n            this.prev = p;\\n        }\\n    }\\n\\t\\n\\t// root: dummy node for start of list\\n\\t// curr: current node where cursor is\\n    Node root = new Node();\\n    Node curr = root;\\n\\t\\n\\t\\n\\t// Make a new List for the new Text and then insert it into our main list.\\n    public void addText(String text) {\\n        \\n\\t\\t// head: dummy head for new list,\\n\\t\\t// temp: used for adding next nodes.\\n        Node head = new Node(), temp = head;\\n        for(char ch : text.toCharArray()){\\n            temp.next = new Node(ch, temp);\\n            temp = temp.next;\\n        }\\n        \\n\\t\\t// move dummy head to our actual head\\n        head = head.next;\\n\\t\\t\\n\\t\\t// insert new list into our main list\\n        Node next = curr.next;\\n        curr.next = head;\\n        head.prev = curr;\\n        temp.next = next;\\n        if(next!=null)\\n            next.prev = temp;\\n        \\n\\t\\t// our cursor will now be at the last node of new list\\n        curr = temp;  \\n    }\\n    \\n    public int deleteText(int k) {\\n        int i=0;\\n        Node next = curr.next;\\n        while(k!=0 && curr!=root){\\n            curr = curr.prev;\\n            i++; k--;\\n        }\\n        curr.next = next;\\n        if(next!=null)\\n            next.prev = curr;\\n        return i;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while(k!=0 && curr!=root){\\n            curr = curr.prev;\\n            k--;\\n        }\\n        return getLast();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        Node prev = null;\\n        while(k!=0 && curr!=null){\\n            prev = curr;\\n            curr = curr.next;\\n            k--;\\n        }\\n        if(curr==null)\\n            curr = prev;\\n        return getLast();\\n    }\\n    \\n\\t\\n\\t// return last min(10, len) length string\\n    public String getLast(){\\n\\t\\n        Node temp = curr;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<10 && temp!=root; i++){\\n            sb.append(temp.ch);\\n            temp = temp.prev;\\n        }\\n        return sb.reverse().toString();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2301239,
                "title": "python3-2-stacks",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/ce9cc71c30ea3ded8cf33d737816708a41588ddd) for solutions of weekly 296. \\n\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        for ch in text: self.left.append(ch)\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0 \\n        while self.left and k: \\n            k -= 1\\n            self.left.pop()\\n            ans += 1\\n        return ans \\n\\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.left: \\n            k -= 1\\n            self.right.append(self.left.pop())\\n        return \\'\\'.join(self.left[-min(10, len(self.left)):])\\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.right: \\n            k -= 1\\n            self.left.append(self.right.pop())\\n        return \\'\\'.join(self.left[-min(10, len(self.left)):])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        for ch in text: self.left.append(ch)\\n\\n    def deleteText(self, k: int) -> int:\\n        ans = 0 \\n        while self.left and k: \\n            k -= 1\\n            self.left.pop()\\n            ans += 1\\n        return ans \\n\\n    def cursorLeft(self, k: int) -> str:\\n        while k and self.left: \\n            k -= 1\\n            self.right.append(self.left.pop())\\n        return \\'\\'.join(self.left[-min(10, len(self.left)):])\\n\\n    def cursorRight(self, k: int) -> str:\\n        while k and self.right: \\n            k -= 1\\n            self.left.append(self.right.pop())\\n        return \\'\\'.join(self.left[-min(10, len(self.left)):])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170539,
                "title": "c-string",
                "content": "```\\nclass TextEditor {\\npublic:\\n    string left,right;\\n    int p;\\n    TextEditor() {\\n        left=right=\"\";\\n        p=0;\\n    }\\n    string get()\\n    {\\n        string s=\"\";\\n        int n=left.size();\\n        for(int i=n-1;i>=max(0,n-10);i--)\\n            s+=left[i];\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    void addText(string text) {\\n        left+=text;\\n    }\\n    \\n    int deleteText(int k) {\\n        int x=min(k,(int)left.size());\\n        for(int i=0;i<x;i++)\\n            left.pop_back();\\n        return x;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int x=min(k,(int)left.size());\\n        for(int i=0;i<x;i++)\\n        {\\n            right+=left.back();\\n            left.pop_back();\\n        }\\n        return get();\\n    }\\n    \\n    string cursorRight(int k) \\n    {\\n        int x=min(k,(int)right.size());\\n        for(int i=0;i<x;i++)\\n        {\\n            left+=right.back();\\n            right.pop_back();\\n        }\\n        return get();\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string left,right;\\n    int p;\\n    TextEditor() {\\n        left=right=\"\";\\n        p=0;\\n    }\\n    string get()\\n    {\\n        string s=\"\";\\n        int n=left.size();\\n        for(int i=n-1;i>=max(0,n-10);i--)\\n            s+=left[i];\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    void addText(string text) {\\n        left+=text;\\n    }\\n    \\n    int deleteText(int k) {\\n        int x=min(k,(int)left.size());\\n        for(int i=0;i<x;i++)\\n            left.pop_back();\\n        return x;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int x=min(k,(int)left.size());\\n        for(int i=0;i<x;i++)\\n        {\\n            right+=left.back();\\n            left.pop_back();\\n        }\\n        return get();\\n    }\\n    \\n    string cursorRight(int k) \\n    {\\n        int x=min(k,(int)right.size());\\n        for(int i=0;i<x;i++)\\n        {\\n            left+=right.back();\\n            right.pop_back();\\n        }\\n        return get();\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136788,
                "title": "easy-understanding-solution",
                "content": "```\\n\\nclass TextEditor{\\n    constructor(){\\n        this.texts = \\'\\';\\n      this.index = 0;\\n      this.left = \\'\\';\\n      this.right = \\'\\';\\n    \\n    }\\n  };\\n  \\n  \\n  TextEditor.prototype.addText = function(text) {\\n    if(!this.texts.length){ \\n      this.left = text;\\n       this.index = text.length;\\n    } \\n    else{\\n       this.left = this.left + text\\n       this.right = this.right;\\n        this.index = this.index+text.length;\\n    }\\n  \\n    return this.texts=this.left+this.right;\\n  };\\n  \\n  \\n  TextEditor.prototype.deleteText = function(k) {\\n      if(this.texts.length===0) return \\'\\'\\n    var deleteLen = Math.min(k,this.index);\\n   this.left = this.left.slice(0, this.left.length-deleteLen);\\n   this.right = this.right;\\n   this.texts = this.left + this.right;\\n   this.index = this.left.length; \\n    return deleteLen\\n  };\\n  \\n  \\n  TextEditor.prototype.cursorLeft = function(k) {\\n      if(!this.texts) return \\'\\';\\n        \\n       this.index = Math.max(0, this.index-k) \\n       this.left = this.texts.slice(0,this.index) \\n       this.right = this.texts.slice(this.index)\\n        this.texts = this.left + this.right;\\n      var min = Math.min(10, this.index);\\n    return this.left.slice(-min)  \\n  };\\n  \\n  \\n  TextEditor.prototype.cursorRight = function(k) {\\n      if(this.texts.length===0) return \\'\\';\\n       this.index = Math.min(this.texts.length, this.index+k);\\n       this.left = this.texts.slice(0,this.index)\\n       this.right = this.texts.slice(this.index);\\n       this.texts = this.left+this.right;\\n      var min = Math.min(10,this.index)  \\n   return this.left.slice(-min) \\n  };\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nclass TextEditor{\\n    constructor(){\\n        this.texts = \\'\\';\\n      this.index = 0;\\n      this.left = \\'\\';\\n      this.right = \\'\\';\\n    \\n    }\\n  };\\n  \\n  \\n  TextEditor.prototype.addText = function(text) {\\n    if(!this.texts.length){ \\n      this.left = text;\\n       this.index = text.length;\\n    } \\n    else{\\n       this.left = this.left + text\\n       this.right = this.right;\\n        this.index = this.index+text.length;\\n    }\\n  \\n    return this.texts=this.left+this.right;\\n  };\\n  \\n  \\n  TextEditor.prototype.deleteText = function(k) {\\n      if(this.texts.length===0) return \\'\\'\\n    var deleteLen = Math.min(k,this.index);\\n   this.left = this.left.slice(0, this.left.length-deleteLen);\\n   this.right = this.right;\\n   this.texts = this.left + this.right;\\n   this.index = this.left.length; \\n    return deleteLen\\n  };\\n  \\n  \\n  TextEditor.prototype.cursorLeft = function(k) {\\n      if(!this.texts) return \\'\\';\\n        \\n       this.index = Math.max(0, this.index-k) \\n       this.left = this.texts.slice(0,this.index) \\n       this.right = this.texts.slice(this.index)\\n        this.texts = this.left + this.right;\\n      var min = Math.min(10, this.index);\\n    return this.left.slice(-min)  \\n  };\\n  \\n  \\n  TextEditor.prototype.cursorRight = function(k) {\\n      if(this.texts.length===0) return \\'\\';\\n       this.index = Math.min(this.texts.length, this.index+k);\\n       this.left = this.texts.slice(0,this.index)\\n       this.right = this.texts.slice(this.index);\\n       this.texts = this.left+this.right;\\n      var min = Math.min(10,this.index)  \\n   return this.left.slice(-min) \\n  };\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129417,
                "title": "c-stack",
                "content": "```\\nclass TextEditor {\\npublic:\\n    stack<char> left,right;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        for(int i=0;i<text.length();i++)\\n            left.push(text[i]);\\n    }\\n    \\n    int deleteText(int k) {\\n        int i=0;\\n        for(int j=0;j<k;j++)\\n        {\\n            if(left.empty())\\n                break;\\n            left.pop();\\n            i++;\\n        }\\n        return i;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        for(int i=0;i<k;i++)\\n        {\\n            if(left.empty())\\n                break;\\n            char c=left.top();\\n            left.pop();\\n            right.push(c);\\n        }        \\n        stack<char> t;\\n        string x=\"\";\\n        for(int i=0;i<10;i++)\\n        {\\n            if(left.empty())\\n                break;\\n            char c=left.top();\\n            left.pop();\\n            x+=c;\\n            t.push(c);\\n        }\\n        while(!t.empty())\\n        {\\n            left.push(t.top());\\n            t.pop();\\n        }\\n        reverse(x.begin(),x.end());\\n        return x;\\n    }\\n    \\n    string cursorRight(int k) {\\n       for(int i=0;i<k;i++)\\n        {\\n            if(right.empty())\\n                break;\\n            char c=right.top();\\n            right.pop();\\n            left.push(c);\\n        }        \\n        stack<char> t;\\n        string x=\"\";\\n        for(int i=0;i<10;i++)\\n        {\\n            if(left.empty())\\n                break;\\n            char c=left.top();\\n            left.pop();\\n            x+=c;\\n            t.push(c);\\n        }\\n        while(!t.empty())\\n        {\\n            left.push(t.top());\\n            t.pop();\\n        }\\n        reverse(x.begin(),x.end());\\n        return x;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    stack<char> left,right;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        for(int i=0;i<text.length();i++)\\n            left.push(text[i]);\\n    }\\n    \\n    int deleteText(int k) {\\n        int i=0;\\n        for(int j=0;j<k;j++)\\n        {\\n            if(left.empty())\\n                break;\\n            left.pop();\\n            i++;\\n        }\\n        return i;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        for(int i=0;i<k;i++)\\n        {\\n            if(left.empty())\\n                break;\\n            char c=left.top();\\n            left.pop();\\n            right.push(c);\\n        }        \\n        stack<char> t;\\n        string x=\"\";\\n        for(int i=0;i<10;i++)\\n        {\\n            if(left.empty())\\n                break;\\n            char c=left.top();\\n            left.pop();\\n            x+=c;\\n            t.push(c);\\n        }\\n        while(!t.empty())\\n        {\\n            left.push(t.top());\\n            t.pop();\\n        }\\n        reverse(x.begin(),x.end());\\n        return x;\\n    }\\n    \\n    string cursorRight(int k) {\\n       for(int i=0;i<k;i++)\\n        {\\n            if(right.empty())\\n                break;\\n            char c=right.top();\\n            right.pop();\\n            left.push(c);\\n        }        \\n        stack<char> t;\\n        string x=\"\";\\n        for(int i=0;i<10;i++)\\n        {\\n            if(left.empty())\\n                break;\\n            char c=left.top();\\n            left.pop();\\n            x+=c;\\n            t.push(c);\\n        }\\n        while(!t.empty())\\n        {\\n            left.push(t.top());\\n            t.pop();\\n        }\\n        reverse(x.begin(),x.end());\\n        return x;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123461,
                "title": "python3-two-stacks",
                "content": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        # two stacks\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        for letter in text:\\n            self.left.append(letter)\\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        while (k>0) & (len(self.left)>0):\\n            self.left.pop()\\n            k -= 1\\n            count += 1\\n        return count\\n        \\n\\n    def cursorLeft(self, k: int) -> str:\\n        while (k>0) & (len(self.left)>0):\\n            self.right.append(self.left.pop())\\n            k -= 1\\n        return self.listToStr(self.left[max(0, len(self.left)-10):len(self.left)])\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        while (k>0) & (len(self.right)>0):\\n            self.left.append(self.right.pop())\\n            k -= 1\\n        return self.listToStr(self.left[max(0, len(self.left)-10):len(self.left)])\\n        \\n            \\n    def listToStr(self, arr: List[str]) -> str:\\n        ans = \"\"\\n        for letter in arr:\\n            ans += (letter)\\n        return ans\\n",
                "solutionTags": [],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        # two stacks\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        for letter in text:\\n            self.left.append(letter)\\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        while (k>0) & (len(self.left)>0):\\n            self.left.pop()\\n            k -= 1\\n            count += 1\\n        return count\\n        \\n\\n    def cursorLeft(self, k: int) -> str:\\n        while (k>0) & (len(self.left)>0):\\n            self.right.append(self.left.pop())\\n            k -= 1\\n        return self.listToStr(self.left[max(0, len(self.left)-10):len(self.left)])\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        while (k>0) & (len(self.right)>0):\\n            self.left.append(self.right.pop())\\n            k -= 1\\n        return self.listToStr(self.left[max(0, len(self.left)-10):len(self.left)])\\n        \\n            \\n    def listToStr(self, arr: List[str]) -> str:\\n        ans = \"\"\\n        for letter in arr:\\n            ans += (letter)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2118372,
                "title": "simple-linkedlist-solution-using-c",
                "content": "**CPP approach**\\n\\n\\tclass node{\\n\\t\\tpublic:\\n\\t\\tchar c;\\n\\t\\tnode *next;\\n\\t\\tnode *prev;\\n\\t\\tnode(char t){\\n\\t\\t\\tc = t;\\n\\t\\t\\tnext = NULL;\\n\\t\\t\\tprev = NULL;\\n\\t\\t}\\n\\t};\\n\\n\\n\\tclass TextEditor {\\n\\tpublic:\\n\\t\\tnode *crs;\\n\\t\\tint size;\\n\\t\\tTextEditor() {\\n\\t\\t\\tcrs = new node(\\' \\');\\n\\t\\t\\tsize = 0;\\n\\t\\t}\\n\\n\\t\\tvoid addText(string text) {\\n\\t\\t\\tnode *tmp = crs->next;\\n\\t\\t\\tfor(char c : text){\\n\\t\\t\\t\\tcrs->next = new node(c);\\n\\t\\t\\t\\tcrs->next->prev = crs;\\n\\t\\t\\t\\tcrs = crs->next;\\n\\t\\t\\t}\\n\\t\\t\\tcrs->next = tmp;\\n\\t\\t\\tif(tmp){\\n\\t\\t\\t\\ttmp->prev = crs;\\n\\t\\t\\t}\\n\\t\\t\\tsize += text.size();\\n\\t\\t}\\n\\n\\t\\tint deleteText(int k) {\\n\\t\\t\\tnode *cur = crs->next;\\n\\t\\t\\tint n = 0;\\n\\t\\t\\twhile(crs->c != \\' \\' && n < k){\\n\\t\\t\\t\\tcrs = crs->prev;\\n\\t\\t\\t\\tn++;\\n\\t\\t\\t}\\n\\t\\t\\tcrs->next = cur;\\n\\t\\t\\tif(cur)  cur->prev = crs;\\n\\t\\t\\treturn n;\\n\\t\\t}\\n\\n\\t\\tstring cursorLeft(int k) {\\n\\t\\t\\tnode *cur = crs;\\n\\t\\t\\tstring tmp = \"\";\\n\\t\\t\\tint n = k;\\n\\t\\t\\twhile(cur->c != \\' \\' && n--){\\n\\t\\t\\t\\tcur = cur->prev;\\n\\t\\t\\t}\\n\\t\\t\\tn = 10;\\n\\t\\t\\tcrs = cur;\\n\\t\\t\\twhile(cur->c != \\' \\' && n--){\\n\\t\\t\\t\\ttmp.push_back(cur->c);\\n\\t\\t\\t\\tcur = cur->prev;\\n\\t\\t\\t}\\n\\t\\t\\treverse(tmp.begin(),tmp.end());\\n\\t\\t\\treturn tmp;\\n\\t\\t}\\n\\n\\t\\tstring cursorRight(int k) {\\n\\t\\t\\tnode *cur = crs;\\n\\t\\t\\tstring tmp = \"\";\\n\\t\\t\\tint n = k;\\n\\t\\t\\twhile(cur->next && n--){\\n\\t\\t\\t\\tcur = cur->next;\\n\\t\\t\\t}\\n\\t\\t\\tn = 10;\\n\\t\\t\\tcrs = cur;\\n\\t\\t\\twhile(cur->c != \\' \\' && n--){\\n\\t\\t\\t\\ttmp.push_back(cur->c);\\n\\t\\t\\t\\tcur = cur->prev;\\n\\t\\t\\t}\\n\\t\\t\\treverse(tmp.begin(),tmp.end());\\n\\t\\t\\treturn tmp;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your TextEditor object will be instantiated and called as such:\\n\\t * TextEditor* obj = new TextEditor();\\n\\t * obj->addText(text);\\n\\t * int param_2 = obj->deleteText(k);\\n\\t * string param_3 = obj->cursorLeft(k);\\n\\t * string param_4 = obj->cursorRight(k);\\n\\t */\\n",
                "solutionTags": [
                    "Linked List",
                    "Simulation"
                ],
                "code": "**CPP approach**\\n\\n\\tclass node{\\n\\t\\tpublic:\\n\\t\\tchar c;\\n\\t\\tnode *next;\\n\\t\\tnode *prev;\\n\\t\\tnode(char t){\\n\\t\\t\\tc = t;\\n\\t\\t\\tnext = NULL;\\n\\t\\t\\tprev = NULL;\\n\\t\\t}\\n\\t};\\n\\n\\n\\tclass TextEditor {\\n\\tpublic:\\n\\t\\tnode *crs;\\n\\t\\tint size;\\n\\t\\tTextEditor() {\\n\\t\\t\\tcrs = new node(\\' \\');\\n\\t\\t\\tsize = 0;\\n\\t\\t}\\n\\n\\t\\tvoid addText(string text) {\\n\\t\\t\\tnode *tmp = crs->next;\\n\\t\\t\\tfor(char c : text){\\n\\t\\t\\t\\tcrs->next = new node(c);\\n\\t\\t\\t\\tcrs->next->prev = crs;\\n\\t\\t\\t\\tcrs = crs->next;\\n\\t\\t\\t}\\n\\t\\t\\tcrs->next = tmp;\\n\\t\\t\\tif(tmp){\\n\\t\\t\\t\\ttmp->prev = crs;\\n\\t\\t\\t}\\n\\t\\t\\tsize += text.size();\\n\\t\\t}\\n\\n\\t\\tint deleteText(int k) {\\n\\t\\t\\tnode *cur = crs->next;\\n\\t\\t\\tint n = 0;\\n\\t\\t\\twhile(crs->c != \\' \\' && n < k){\\n\\t\\t\\t\\tcrs = crs->prev;\\n\\t\\t\\t\\tn++;\\n\\t\\t\\t}\\n\\t\\t\\tcrs->next = cur;\\n\\t\\t\\tif(cur)  cur->prev = crs;\\n\\t\\t\\treturn n;\\n\\t\\t}\\n\\n\\t\\tstring cursorLeft(int k) {\\n\\t\\t\\tnode *cur = crs;\\n\\t\\t\\tstring tmp = \"\";\\n\\t\\t\\tint n = k;\\n\\t\\t\\twhile(cur->c != \\' \\' && n--){\\n\\t\\t\\t\\tcur = cur->prev;\\n\\t\\t\\t}\\n\\t\\t\\tn = 10;\\n\\t\\t\\tcrs = cur;\\n\\t\\t\\twhile(cur->c != \\' \\' && n--){\\n\\t\\t\\t\\ttmp.push_back(cur->c);\\n\\t\\t\\t\\tcur = cur->prev;\\n\\t\\t\\t}\\n\\t\\t\\treverse(tmp.begin(),tmp.end());\\n\\t\\t\\treturn tmp;\\n\\t\\t}\\n\\n\\t\\tstring cursorRight(int k) {\\n\\t\\t\\tnode *cur = crs;\\n\\t\\t\\tstring tmp = \"\";\\n\\t\\t\\tint n = k;\\n\\t\\t\\twhile(cur->next && n--){\\n\\t\\t\\t\\tcur = cur->next;\\n\\t\\t\\t}\\n\\t\\t\\tn = 10;\\n\\t\\t\\tcrs = cur;\\n\\t\\t\\twhile(cur->c != \\' \\' && n--){\\n\\t\\t\\t\\ttmp.push_back(cur->c);\\n\\t\\t\\t\\tcur = cur->prev;\\n\\t\\t\\t}\\n\\t\\t\\treverse(tmp.begin(),tmp.end());\\n\\t\\t\\treturn tmp;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your TextEditor object will be instantiated and called as such:\\n\\t * TextEditor* obj = new TextEditor();\\n\\t * obj->addText(text);\\n\\t * int param_2 = obj->deleteText(k);\\n\\t * string param_3 = obj->cursorLeft(k);\\n\\t * string param_4 = obj->cursorRight(k);\\n\\t */\\n",
                "codeTag": "Java"
            },
            {
                "id": 2118369,
                "title": "c-linked-list-stl-short",
                "content": "**Idea-**\\n* Use c++ stl `list` to maintain our `text` and `cursor`\\n* Insert each character at position of cursor.\\n* Always keep the iterator `curr` at position of cursor. While inserting, deleting or moving - update `curr` to position of cursor.\\n**Note-**\\n* Using `lst.insert()`, character is inserted before the cursor. So, basically, our list is always reversed of `original text` i.e `lst.begin()` is the end of `original text`. \\nWe can handle that easily by - `curr++` to move the cursor `left` and `curr--` to move cursor `right`.\\n\\n```\\nclass TextEditor {\\npublic:\\n\\n    list<char> lst;\\n    list<char>::iterator curr;\\n\\n    TextEditor() {\\n        curr = lst.begin();\\n    }\\n    \\n    void addText(string text) {\\n        for(char c: text)\\n            curr = lst.insert(curr, c);\\n    }\\n    \\n    int deleteText(int k) {\\n        int c = 0;\\n        for(; curr != lst.end() && k; k--, c++)  \\n            curr = lst.erase(curr);\\n\\n        return c;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        string res = \"\";\\n        for(; curr != lst.end() && k; k--, curr++);   // note the semicolon\\n\\n        auto it = curr;\\n        while(size(res) < 10 && it != lst.end())\\n            res.push_back(*it), it++;\\n\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    string cursorRight(int k) {\\n        string res = \"\";\\n        for(; curr != lst.begin() && k; k--, curr--);  // note the semicolon\\n\\n        auto it = curr;\\n        while(size(res) < 10 && it != lst.end())\\n            res.push_back(*it), it++;\\n\\n        reverse(res.begin(), res.end());\\n        return res;\\n        \\n    }\\n};\\n```\\n\\nPlease **upvote** if you liked the idea \\uD83D\\uDE0A.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n\\n    list<char> lst;\\n    list<char>::iterator curr;\\n\\n    TextEditor() {\\n        curr = lst.begin();\\n    }\\n    \\n    void addText(string text) {\\n        for(char c: text)\\n            curr = lst.insert(curr, c);\\n    }\\n    \\n    int deleteText(int k) {\\n        int c = 0;\\n        for(; curr != lst.end() && k; k--, c++)  \\n            curr = lst.erase(curr);\\n\\n        return c;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        string res = \"\";\\n        for(; curr != lst.end() && k; k--, curr++);   // note the semicolon\\n\\n        auto it = curr;\\n        while(size(res) < 10 && it != lst.end())\\n            res.push_back(*it), it++;\\n\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    string cursorRight(int k) {\\n        string res = \"\";\\n        for(; curr != lst.begin() && k; k--, curr--);  // note the semicolon\\n\\n        auto it = curr;\\n        while(size(res) < 10 && it != lst.end())\\n            res.push_back(*it), it++;\\n\\n        reverse(res.begin(), res.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118244,
                "title": "c-using-two-stacks",
                "content": "We will use two stacks, **front stack** for maintaining the left part of the cursor and **back stack** for the right part of the cursor.\\nBasically the cursor acts as a bridge between the two stacks.\\naddText() func simply adds the string char by char in the front stack.\\ndeleteText() func deletes the string char by char from the front stack.\\ncursorLeft() func takes the char from the front stack and puts it in the back stack and vice versa for the cursorRight() func.\\nhelper() func helps in returning the string on the left side of the cursor. \\n\\n```\\nclass TextEditor {\\npublic:\\n    stack<char> front, back;\\n\\t\\n    TextEditor() { \\n    }\\n    \\n    string helper() {\\n        string res;\\n        int count = 10;\\n        while(front.size() and count--) {\\n            res = front.top() + res;\\n            front.pop();\\n        }\\n        for(auto &ch : res) front.push(ch);   // for putting the string back again\\n        return res;\\n    }\\n    \\n    void addText(string text) {\\n        for(auto &ch : text) front.push(ch);\\n    }\\n    \\n    int deleteText(int k) {\\n        int count = 0;   // for returning the actual count of chars deleted\\n        while(front.size() and k--) {\\n            front.pop();\\n            count += 1;\\n        }\\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(front.size() and k--) {\\n            back.push(front.top());\\n            front.pop();\\n        }\\n        return helper();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(back.size() and k--) {\\n            front.push(back.top());\\n            back.pop();\\n        }\\n        return helper();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    stack<char> front, back;\\n\\t\\n    TextEditor() { \\n    }\\n    \\n    string helper() {\\n        string res;\\n        int count = 10;\\n        while(front.size() and count--) {\\n            res = front.top() + res;\\n            front.pop();\\n        }\\n        for(auto &ch : res) front.push(ch);   // for putting the string back again\\n        return res;\\n    }\\n    \\n    void addText(string text) {\\n        for(auto &ch : text) front.push(ch);\\n    }\\n    \\n    int deleteText(int k) {\\n        int count = 0;   // for returning the actual count of chars deleted\\n        while(front.size() and k--) {\\n            front.pop();\\n            count += 1;\\n        }\\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(front.size() and k--) {\\n            back.push(front.top());\\n            front.pop();\\n        }\\n        return helper();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(back.size() and k--) {\\n            front.push(back.top());\\n            back.pop();\\n        }\\n        return helper();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114987,
                "title": "c-double-linked-list-solution",
                "content": "```\\nclass Node {\\npublic:\\n    char key;\\n    Node* next;\\n    Node* prev;\\n    Node(): key(\\'0\\'), next(nullptr), prev(nullptr) {};\\n    Node(char k): key(k), next(nullptr), prev(nullptr) {};\\n    ~Node() {\\n        next = nullptr;\\n        prev = nullptr;\\n    }\\n};\\n\\nclass TextEditor {\\npublic:\\n    TextEditor() {\\n        head = new Node();\\n        tail = new Node();\\n        head->next = tail;\\n        tail->prev = head;\\n        ptr = head;\\n    }\\n    \\n    void addText(string text) {\\n        Node* cur = ptr;\\n        for (char c: text)\\n        {\\n            Node* temp = cur->next;\\n            cur->next = new Node(c);\\n            cur->next->prev = cur;\\n            cur = cur->next;\\n            cur->next = temp;\\n            temp->prev = cur;\\n        }\\n        ptr = cur;\\n        // cout<<ptr->key<<endl;\\n    }\\n    \\n    int deleteText(int k) {\\n        Node* cur = ptr;\\n        int res = 0;\\n        while (cur != head && k > 0)\\n        {\\n            cur = cur->prev;\\n            k--;\\n            res++;\\n        }\\n        Node* del = cur->next;\\n        cur->next = ptr->next;\\n        ptr->next->prev = cur;\\n        ptr = cur;\\n        for (int i=0; i<res; i++)\\n        {\\n            Node* temp = del->next;\\n            delete(del);\\n            del = temp;\\n        }\\n        // cout<<\"after deletion: \"<<ptr->key<<endl;\\n        return res;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        Node* cur = ptr;\\n        while (cur != head && k > 0)\\n        {\\n            cur = cur->prev;\\n            k--;\\n        }\\n        ptr = cur;\\n        string res = \"\";\\n        int len = 10;\\n        while (cur != head && len > 0)\\n        {\\n            res.push_back(cur->key);\\n            cur = cur->prev;\\n            len--;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    string cursorRight(int k) {\\n        Node* cur = ptr;\\n        while (cur->next != tail && k > 0)\\n        {\\n            cur = cur->next;\\n            k--;\\n        }\\n        ptr = cur;\\n        string res = \"\";\\n        int len = 10;\\n        while (cur != head && len > 0)\\n        {\\n            res.push_back(cur->key);\\n            cur = cur->prev;\\n            len--;\\n        }\\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\nprivate:\\n    Node* head;\\n    Node* tail;\\n    Node* ptr;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Node {\\npublic:\\n    char key;\\n    Node* next;\\n    Node* prev;\\n    Node(): key(\\'0\\'), next(nullptr), prev(nullptr) {};\\n    Node(char k): key(k), next(nullptr), prev(nullptr) {};\\n    ~Node() {\\n        next = nullptr;\\n        prev = nullptr;\\n    }\\n};\\n\\nclass TextEditor {\\npublic:\\n    TextEditor() {\\n        head = new Node();\\n        tail = new Node();\\n        head->next = tail;\\n        tail->prev = head;\\n        ptr = head;\\n    }\\n    \\n    void addText(string text) {\\n        Node* cur = ptr;\\n        for (char c: text)\\n        {\\n            Node* temp = cur->next;\\n            cur->next = new Node(c);\\n            cur->next->prev = cur;\\n            cur = cur->next;\\n            cur->next = temp;\\n            temp->prev = cur;\\n        }\\n        ptr = cur;\\n        // cout<<ptr->key<<endl;\\n    }\\n    \\n    int deleteText(int k) {\\n        Node* cur = ptr;\\n        int res = 0;\\n        while (cur != head && k > 0)\\n        {\\n            cur = cur->prev;\\n            k--;\\n            res++;\\n        }\\n        Node* del = cur->next;\\n        cur->next = ptr->next;\\n        ptr->next->prev = cur;\\n        ptr = cur;\\n        for (int i=0; i<res; i++)\\n        {\\n            Node* temp = del->next;\\n            delete(del);\\n            del = temp;\\n        }\\n        // cout<<\"after deletion: \"<<ptr->key<<endl;\\n        return res;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        Node* cur = ptr;\\n        while (cur != head && k > 0)\\n        {\\n            cur = cur->prev;\\n            k--;\\n        }\\n        ptr = cur;\\n        string res = \"\";\\n        int len = 10;\\n        while (cur != head && len > 0)\\n        {\\n            res.push_back(cur->key);\\n            cur = cur->prev;\\n            len--;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    string cursorRight(int k) {\\n        Node* cur = ptr;\\n        while (cur->next != tail && k > 0)\\n        {\\n            cur = cur->next;\\n            k--;\\n        }\\n        ptr = cur;\\n        string res = \"\";\\n        int len = 10;\\n        while (cur != head && len > 0)\\n        {\\n            res.push_back(cur->key);\\n            cur = cur->prev;\\n            len--;\\n        }\\n        reverse(res.begin(), res.end());\\n        \\n        return res;\\n    }\\nprivate:\\n    Node* head;\\n    Node* tail;\\n    Node* ptr;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2114886,
                "title": "c-easy-and-clean-code",
                "content": "```\\nclass TextEditor {\\npublic:\\n    string s;\\n    int idx=0;\\n    TextEditor() {\\n        s=\"\";\\n    }\\n    \\n    void addText(string text) {\\n        s.insert(idx,text);\\n        idx+=text.size();\\n    }\\n    \\n    int deleteText(int k) {\\n        int len=min(k,idx);\\n            s.erase(idx-len,len);\\n        idx-=len;\\n        return len;\\n    }\\n    \\n    string cursorLeft(int k) {\\n       \\n       int l=min(idx,k);\\n        idx-=l;\\n        if(idx>10)\\n            return s.substr(idx-10,10);\\n        else \\n            return s.substr(0,idx);\\n    }\\n\\t\\n    string cursorRight(int k) {\\n        int r=min(k,(int)s.size()-idx);\\n        idx+=r;\\n        if(idx>10)\\n            return s.substr(idx-10,10);\\n        else \\n            return s.substr(0,idx);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string s;\\n    int idx=0;\\n    TextEditor() {\\n        s=\"\";\\n    }\\n    \\n    void addText(string text) {\\n        s.insert(idx,text);\\n        idx+=text.size();\\n    }\\n    \\n    int deleteText(int k) {\\n        int len=min(k,idx);\\n            s.erase(idx-len,len);\\n        idx-=len;\\n        return len;\\n    }\\n    \\n    string cursorLeft(int k) {\\n       \\n       int l=min(idx,k);\\n        idx-=l;\\n        if(idx>10)\\n            return s.substr(idx-10,10);\\n        else \\n            return s.substr(0,idx);\\n    }\\n\\t\\n    string cursorRight(int k) {\\n        int r=min(k,(int)s.size()-idx);\\n        idx+=r;\\n        if(idx>10)\\n            return s.substr(idx-10,10);\\n        else \\n            return s.substr(0,idx);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114289,
                "title": "using-two-stack",
                "content": "```\\n// Here Cursor Will Be Btw left and right stacks \\n// left stack denote the left part of the cursor and right  stack as right part of the stack\\n// print() func is just for debugging \\n// Time complexity will be O(n*k) \\n// solving with single string got tle  in the contest. \\n// Get the idea of using two stack from the discuss section \\n\\nclass TextEditor\\n{\\n    stack<char> left, right;\\n    public:\\n        TextEditor() {}\\n\\n    void addText(string text)\\n    {\\n        for (int i = 0; i < text.size(); i++)\\n        {\\n            left.push(text[i]);\\n        }\\n        // print();\\n    }\\n\\n    int deleteText(int k)\\n    {\\n        int tmp = k;\\n        while (!left.empty() && tmp)\\n        {\\n            left.pop();\\n            tmp--;\\n        }\\n        // print();\\n        return k - tmp;\\n    }\\n\\n    string cursorLeft(int k)\\n    {\\n        string s;\\n        int tmp = k;\\n        while (!left.empty() && tmp)\\n        {\\n            right.push(left.top());\\n            left.pop();\\n            tmp--;\\n        }\\n        tmp=0;\\n        while(!left.empty()&&s.size()<10)\\n        {\\n            s=left.top()+s;\\n            right.push(left.top());\\n            left.pop();\\n            tmp++;\\n        }\\n        while(tmp>0)\\n        {\\n            left.push(right.top());\\n            right.pop();\\n            tmp--;\\n        }\\n        return s;\\n    }\\n\\n    string cursorRight(int k)\\n    {\\n        string s;\\n        int tmp = k;\\n        while (!right.empty() && tmp)\\n        {\\n            left.push(right.top());\\n            right.pop();\\n            tmp--;\\n        }\\n        tmp=0;\\n        while(!left.empty()&&s.size()<10)\\n        {\\n            s=left.top()+s;\\n            right.push(left.top());\\n            left.pop();\\n            tmp++;\\n        }\\n        while(tmp>0)\\n        {\\n            left.push(right.top());\\n            right.pop();\\n            tmp--;\\n        }\\n        return s;\\n    }\\n    void print()\\n    {\\n        stack<char>t1=left,t2=right;\\n        while(!t1.empty())\\n        {\\n            t2.push(t1.top());\\n            t1.pop();\\n        }\\n        while(!t2.empty())\\n        {\\n            cout<<t2.top();\\n            t2.pop();\\n        }\\n        cout<<\"\\\\n\";\\n    }\\n};\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n// Here Cursor Will Be Btw left and right stacks \\n// left stack denote the left part of the cursor and right  stack as right part of the stack\\n// print() func is just for debugging \\n// Time complexity will be O(n*k) \\n// solving with single string got tle  in the contest. \\n// Get the idea of using two stack from the discuss section \\n\\nclass TextEditor\\n{\\n    stack<char> left, right;\\n    public:\\n        TextEditor() {}\\n\\n    void addText(string text)\\n    {\\n        for (int i = 0; i < text.size(); i++)\\n        {\\n            left.push(text[i]);\\n        }\\n        // print();\\n    }\\n\\n    int deleteText(int k)\\n    {\\n        int tmp = k;\\n        while (!left.empty() && tmp)\\n        {\\n            left.pop();\\n            tmp--;\\n        }\\n        // print();\\n        return k - tmp;\\n    }\\n\\n    string cursorLeft(int k)\\n    {\\n        string s;\\n        int tmp = k;\\n        while (!left.empty() && tmp)\\n        {\\n            right.push(left.top());\\n            left.pop();\\n            tmp--;\\n        }\\n        tmp=0;\\n        while(!left.empty()&&s.size()<10)\\n        {\\n            s=left.top()+s;\\n            right.push(left.top());\\n            left.pop();\\n            tmp++;\\n        }\\n        while(tmp>0)\\n        {\\n            left.push(right.top());\\n            right.pop();\\n            tmp--;\\n        }\\n        return s;\\n    }\\n\\n    string cursorRight(int k)\\n    {\\n        string s;\\n        int tmp = k;\\n        while (!right.empty() && tmp)\\n        {\\n            left.push(right.top());\\n            right.pop();\\n            tmp--;\\n        }\\n        tmp=0;\\n        while(!left.empty()&&s.size()<10)\\n        {\\n            s=left.top()+s;\\n            right.push(left.top());\\n            left.pop();\\n            tmp++;\\n        }\\n        while(tmp>0)\\n        {\\n            left.push(right.top());\\n            right.pop();\\n            tmp--;\\n        }\\n        return s;\\n    }\\n    void print()\\n    {\\n        stack<char>t1=left,t2=right;\\n        while(!t1.empty())\\n        {\\n            t2.push(t1.top());\\n            t1.pop();\\n        }\\n        while(!t2.empty())\\n        {\\n            cout<<t2.top();\\n            t2.pop();\\n        }\\n        cout<<\"\\\\n\";\\n    }\\n};\\n",
                "codeTag": "C++"
            },
            {
                "id": 2114117,
                "title": "c-easy-solution-with-two-strings",
                "content": "```\\nclass TextEditor {\\npublic:\\n    int cursor=0;\\n    string left=\"\", right=\"\";\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        left.insert(end(left),begin(text),end(text));\\n        // cursor+=text.size();\\n    }\\n    \\n    int deleteText(int k) {\\n        int size = left.size();\\n        int ds = min(size,k);\\n        left.resize(size-ds);\\n        // cursor-=ds;\\n        return ds;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k-- && !left.empty()) {\\n            right.push_back(left.back());\\n            left.pop_back();\\n        }\\n        return left.substr(left.size() - min((int)left.size(), 10));\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k-- && !right.empty()){\\n            left.push_back(right.back());\\n            right.pop_back();\\n        } \\n        return left.substr(left.size()-min(10,(int)left.size()));\\n\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */",
                "solutionTags": [],
                "code": "```\\nclass TextEditor {\\npublic:\\n    int cursor=0;\\n    string left=\"\", right=\"\";\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        left.insert(end(left),begin(text),end(text));\\n        // cursor+=text.size();\\n    }\\n    \\n    int deleteText(int k) {\\n        int size = left.size();\\n        int ds = min(size,k);\\n        left.resize(size-ds);\\n        // cursor-=ds;\\n        return ds;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k-- && !left.empty()) {\\n            right.push_back(left.back());\\n            left.pop_back();\\n        }\\n        return left.substr(left.size() - min((int)left.size(), 10));\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k-- && !right.empty()){\\n            left.push_back(right.back());\\n            right.pop_back();\\n        } \\n        return left.substr(left.size()-min(10,(int)left.size()));\\n\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2114096,
                "title": "double-linked-list",
                "content": "```\\nclass Node{\\n    public:\\n    char data;\\n    Node *prev=0,*next=0;\\n    Node (char x)\\n    {\\n        data=x;\\n    }\\n        \\n};\\n\\nclass TextEditor {\\n     Node *first=0,*position=0,*last=0,*head=0;\\npublic:\\n    string count()\\n    {\\n        string ans;\\n        Node *p=position;\\n        while(p!=first&&ans.size()<10)\\n        {\\n            ans.push_back(p->data);\\n            p=p->prev;\\n        }\\n       reverse(ans.begin(),ans.end());\\n            return ans;\\n    }\\n    \\n    TextEditor() {\\n            first=new Node(\\'-\\');\\n            position=first;\\n            last=new Node(\\'-\\');\\n            first->next=last;\\n            last->prev=first;\\n    }\\n    \\n    void addText(string text) {\\n        head=position->next;\\n        for(auto x:text)\\n        {\\n            position->next=new Node(x);\\n            position->next->prev=position;\\n            position=position->next;\\n        }\\n        //linking again\\n        head->prev=position;\\n        position->next=head;\\n    }\\n    \\n    int deleteText(int k) {\\n        int ans=0;\\n        Node *head=position->next;\\n        while(position!=first&&k--)\\n        {\\n            position=position->prev;\\n            ans++;\\n        }\\n        //linking again\\n           head->prev=position;\\n           position->next=head;\\n            return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(position!=first&&k--)\\n            position=position->prev;\\n        return count();\\n    }\\n    \\n    string cursorRight(int k) {\\n      \\n        while(position->next!=last&&k--)\\n            position=position->next;\\n        return count();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Node{\\n    public:\\n    char data;\\n    Node *prev=0,*next=0;\\n    Node (char x)\\n    {\\n        data=x;\\n    }\\n        \\n};\\n\\nclass TextEditor {\\n     Node *first=0,*position=0,*last=0,*head=0;\\npublic:\\n    string count()\\n    {\\n        string ans;\\n        Node *p=position;\\n        while(p!=first&&ans.size()<10)\\n        {\\n            ans.push_back(p->data);\\n            p=p->prev;\\n        }\\n       reverse(ans.begin(),ans.end());\\n            return ans;\\n    }\\n    \\n    TextEditor() {\\n            first=new Node(\\'-\\');\\n            position=first;\\n            last=new Node(\\'-\\');\\n            first->next=last;\\n            last->prev=first;\\n    }\\n    \\n    void addText(string text) {\\n        head=position->next;\\n        for(auto x:text)\\n        {\\n            position->next=new Node(x);\\n            position->next->prev=position;\\n            position=position->next;\\n        }\\n        //linking again\\n        head->prev=position;\\n        position->next=head;\\n    }\\n    \\n    int deleteText(int k) {\\n        int ans=0;\\n        Node *head=position->next;\\n        while(position!=first&&k--)\\n        {\\n            position=position->prev;\\n            ans++;\\n        }\\n        //linking again\\n           head->prev=position;\\n           position->next=head;\\n            return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(position!=first&&k--)\\n            position=position->prev;\\n        return count();\\n    }\\n    \\n    string cursorRight(int k) {\\n      \\n        while(position->next!=last&&k--)\\n            position=position->next;\\n        return count();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113877,
                "title": "clean-code-c",
                "content": "```\\n``` class TextEditor\\n{\\npublic:\\n    string s;\\n    int pos;\\n    TextEditor()\\n    {\\n        pos = 0;\\n    }\\n\\n    void addText(string text)\\n    {\\n\\n        s.insert(pos, text);\\n        pos += text.size();\\n    }\\n\\n    int deleteText(int k)\\n    {\\n        int count = 0;\\n        // deleting k character from current cursor pos\\n        while (pos != 0 && k > 0)\\n        {\\n            s.erase(pos - 1, 1);\\n            pos--;\\n            count++;\\n            k--;\\n        }\\n        return count;\\n    }\\n\\n    string cursorLeft(int k)\\n    {\\n        //  set curosr to 0 if pos-k less than 0\\n        pos = pos - k < 0 ? 0 : pos - k;\\n        string t = \"\";\\n        // add character in range cursor position-min(10,pos) to before cursor position  in answer string\\n        for (int i = pos - 10; i < pos; i++)\\n        {\\n            if (i >= 0)\\n                t += s[i];\\n        }\\n        return t;\\n    }\\n\\n    string cursorRight(int k)\\n    {\\n        int n = s.size();\\n        //  set curosr to n if pos+k>=n\\n        pos = pos + k >= n ? n : pos + k;\\n        string t = \"\";\\n        // add character in range cursor position-min(10,pos) to before cursor position  in answer string\\n        for (int i = pos - 10; i < pos; i++)\\n        {\\n            if (i >= 0)\\n                t += s[i];\\n        }\\n        return t;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113500,
                "title": "using-two-deque",
                "content": "```\\ndeque<char>ba,front;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        \\n        for(auto it : text)ba.push_back(it);\\n        \\n    }\\n    \\n    int deleteText(int k) {\\n        int ans=0;\\n        while(k-- and !ba.empty()){\\n            ba.pop_back();ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    string cursorLeft(int k) {\\n        for(int i=0;i<k and ba.empty()==false;i++){\\n            front.push_front(ba.back());\\n            ba.pop_back();\\n        }\\n                    \\n        return shift_left();\\n    }\\n    \\n    string cursorRight(int k) {\\n        for(int i=0;i<k and front.empty()==false;i++){\\n            ba.push_back(front.front());\\n            front.pop_front();\\n        }\\n        \\n        return shift_left();\\n    }\\n    \\n    string shift_left(){\\n        int i=0;\\n        deque<char> v;\\n        string ans=\"\";\\n        while(!ba.empty() and i<10 ){\\n            v.push_front(ba.back());\\n            ba.pop_back();\\n            i++;\\n        }\\n        while(!v.empty()){\\n            ans+=v.front();\\n            ba.push_back(v.front());\\n            v.pop_front();\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\ndeque<char>ba,front;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        \\n        for(auto it : text)ba.push_back(it);\\n        \\n    }\\n    \\n    int deleteText(int k) {\\n        int ans=0;\\n        while(k-- and !ba.empty()){\\n            ba.pop_back();ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    string cursorLeft(int k) {\\n        for(int i=0;i<k and ba.empty()==false;i++){\\n            front.push_front(ba.back());\\n            ba.pop_back();\\n        }\\n                    \\n        return shift_left();\\n    }\\n    \\n    string cursorRight(int k) {\\n        for(int i=0;i<k and front.empty()==false;i++){\\n            ba.push_back(front.front());\\n            front.pop_front();\\n        }\\n        \\n        return shift_left();\\n    }\\n    \\n    string shift_left(){\\n        int i=0;\\n        deque<char> v;\\n        string ans=\"\";\\n        while(!ba.empty() and i<10 ){\\n            v.push_front(ba.back());\\n            ba.pop_back();\\n            i++;\\n        }\\n        while(!v.empty()){\\n            ans+=v.front();\\n            ba.push_back(v.front());\\n            v.pop_front();\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2113469,
                "title": "javascript-lr-string-tracking-653ms",
                "content": "```\\nfunction TextEditor() {\\n    let L = \\'\\', R = \\'\\';\\n    return { addText, deleteText, cursorLeft, cursorRight }\\n    function addText(text) {\\n       L += text;\\n    }\\n    function deleteText(k) {\\n        let remove = Math.min(k, L.length);\\n        L = L.slice(0, L.length - remove);\\n        return remove;\\n    }\\n    function cursorLeft(k) {\\n        let leftmove = Math.min(L.length, k);\\n        R = L.slice(L.length - leftmove) + R;\\n        L = L.slice(0, L.length - leftmove);\\n        let t = Math.min(10, L.length);\\n        return L.slice(L.length - t);\\n    }\\n    function cursorRight(k) {\\n        let leftmove = Math.min(R.length, k);\\n        L += R.slice(0, leftmove);\\n        R = R.slice(leftmove);\\n        let t = Math.min(10, L.length);\\n        return L.slice(L.length - t);\\n    }\\n}\\n```\\nSolution 2:  2521ms\\nuse Deque instead of string to track L R, don\\'t use JS Array, will TLE for shift() and unshift()\\n```\\n/////////////////////////////////////////////////// Template ///////////////////////////////////////////////////////////////////\\nfunction Deque () {\\n    let m = {}, first = 0, last = -1;\\n    return { unshift, shift, push, pop, front, back, size, show }\\n    function push(...args) {\\n        let i = 0\\n        if (size() == 0) {\\n            first = last = 0;\\n            m[first] = args[i++];\\n        }\\n        for (; i < args.length; i++) m[++last] = args[i];\\n    }\\n    function unshift(...args) {\\n        let i = 0\\n        if (size() == 0) {\\n            first = last = 0;\\n            m[first] = args[i++];\\n        }\\n        for (; i < args.length; i++) m[--first] = args[i];\\n    }\\n    function pop() {\\n        let res = m[last];\\n        delete m[last];\\n        last--;\\n        return res;\\n    }\\n    function shift() {\\n        let res = m[first];\\n        delete m[first]\\n        first++;\\n        return res;\\n    }\\n    function front() {\\n        return m[first];\\n    }\\n    function back() {\\n        return m[last];\\n    }\\n    function size() {\\n        if (first > last) return 0;\\n        return last - first + 1;\\n    }\\n    function show() {\\n        return m;\\n    }\\n}\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfunction TextEditor() {\\n    let L = new Deque(), R = new Deque();\\n    return { addText, deleteText, cursorLeft, cursorRight }\\n    function addText(text) {\\n        for (const c of text) L.push(c);\\n    }\\n    function deleteText(k) {\\n        let remove = Math.min(k, L.size());\\n        for (let i = 0; i < remove; i++) L.pop();\\n        return remove;\\n    }\\n    function cursorLeft(k) {\\n        let leftmove = Math.min(L.size(), k);\\n        while (leftmove--) {\\n            let c = L.pop();\\n            R.unshift(c);\\n        }\\n        let t = Math.min(10, L.size());\\n        let res = \\'\\';\\n        for (let i = 0; i < t; i++) res = L.pop() + res;\\n        for (let i = 0; i < t; i++) L.push(res[i]);\\n        return res;\\n    }\\n    function cursorRight(k) {\\n        let leftmove = Math.min(R.size(), k);\\n        while (leftmove--) {\\n            let c = R.shift();\\n            L.push(c);\\n        }\\n        let t = Math.min(10, L.size());\\n        let res = \\'\\';\\n        for (let i = 0; i < t; i++) res = L.pop() + res;\\n        for (let i = 0; i < t; i++) L.push(res[i]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nfunction TextEditor() {\\n    let L = \\'\\', R = \\'\\';\\n    return { addText, deleteText, cursorLeft, cursorRight }\\n    function addText(text) {\\n       L += text;\\n    }\\n    function deleteText(k) {\\n        let remove = Math.min(k, L.length);\\n        L = L.slice(0, L.length - remove);\\n        return remove;\\n    }\\n    function cursorLeft(k) {\\n        let leftmove = Math.min(L.length, k);\\n        R = L.slice(L.length - leftmove) + R;\\n        L = L.slice(0, L.length - leftmove);\\n        let t = Math.min(10, L.length);\\n        return L.slice(L.length - t);\\n    }\\n    function cursorRight(k) {\\n        let leftmove = Math.min(R.length, k);\\n        L += R.slice(0, leftmove);\\n        R = R.slice(leftmove);\\n        let t = Math.min(10, L.length);\\n        return L.slice(L.length - t);\\n    }\\n}\\n```\n```\\n/////////////////////////////////////////////////// Template ///////////////////////////////////////////////////////////////////\\nfunction Deque () {\\n    let m = {}, first = 0, last = -1;\\n    return { unshift, shift, push, pop, front, back, size, show }\\n    function push(...args) {\\n        let i = 0\\n        if (size() == 0) {\\n            first = last = 0;\\n            m[first] = args[i++];\\n        }\\n        for (; i < args.length; i++) m[++last] = args[i];\\n    }\\n    function unshift(...args) {\\n        let i = 0\\n        if (size() == 0) {\\n            first = last = 0;\\n            m[first] = args[i++];\\n        }\\n        for (; i < args.length; i++) m[--first] = args[i];\\n    }\\n    function pop() {\\n        let res = m[last];\\n        delete m[last];\\n        last--;\\n        return res;\\n    }\\n    function shift() {\\n        let res = m[first];\\n        delete m[first]\\n        first++;\\n        return res;\\n    }\\n    function front() {\\n        return m[first];\\n    }\\n    function back() {\\n        return m[last];\\n    }\\n    function size() {\\n        if (first > last) return 0;\\n        return last - first + 1;\\n    }\\n    function show() {\\n        return m;\\n    }\\n}\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfunction TextEditor() {\\n    let L = new Deque(), R = new Deque();\\n    return { addText, deleteText, cursorLeft, cursorRight }\\n    function addText(text) {\\n        for (const c of text) L.push(c);\\n    }\\n    function deleteText(k) {\\n        let remove = Math.min(k, L.size());\\n        for (let i = 0; i < remove; i++) L.pop();\\n        return remove;\\n    }\\n    function cursorLeft(k) {\\n        let leftmove = Math.min(L.size(), k);\\n        while (leftmove--) {\\n            let c = L.pop();\\n            R.unshift(c);\\n        }\\n        let t = Math.min(10, L.size());\\n        let res = \\'\\';\\n        for (let i = 0; i < t; i++) res = L.pop() + res;\\n        for (let i = 0; i < t; i++) L.push(res[i]);\\n        return res;\\n    }\\n    function cursorRight(k) {\\n        let leftmove = Math.min(R.size(), k);\\n        while (leftmove--) {\\n            let c = R.shift();\\n            L.push(c);\\n        }\\n        let t = Math.min(10, L.size());\\n        let res = \\'\\';\\n        for (let i = 0; i < t; i++) res = L.pop() + res;\\n        for (let i = 0; i < t; i++) L.push(res[i]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113314,
                "title": "c-two-stringbuilders",
                "content": "```\\npublic class TextEditor {\\n    \\n    private StringBuilder left = new StringBuilder();\\n    private StringBuilder right = new StringBuilder();\\n    \\n    public TextEditor() {\\n    }\\n    \\n    public void AddText(string text) {\\n        left.Append(text);\\n    }\\n    \\n    public int DeleteText(int k) {\\n        if(left.Length <= k)\\n        {\\n            k = left.Length;\\n            left.Length = 0;\\n        }\\n        else\\n        {\\n            left.Length = left.Length - k;\\n        }\\n        return k;\\n    }\\n    \\n    public string CursorLeft(int k) {\\n        if(left.Length > k)\\n        {\\n            right.Insert(0,left.ToString(left.Length-k, k));\\n            left.Length = left.Length-k;\\n        }\\n        else\\n        {\\n            right = left.Append(right);\\n            left = new StringBuilder();\\n        }\\n        return left.ToString(left.Length-Math.Min(10,left.Length), Math.Min(10,left.Length));\\n    }\\n    \\n    public string CursorRight(int k) {\\n        if(right.Length > k)\\n        {\\n            left.Append(right.ToString(0, k));\\n            right.Remove(0, k);\\n        }\\n        else\\n        {\\n            left.Append(right);\\n            right.Length = 0;\\n        }\\n        return left.ToString(left.Length-Math.Min(10,left.Length), Math.Min(10,left.Length));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class TextEditor {\\n    \\n    private StringBuilder left = new StringBuilder();\\n    private StringBuilder right = new StringBuilder();\\n    \\n    public TextEditor() {\\n    }\\n    \\n    public void AddText(string text) {\\n        left.Append(text);\\n    }\\n    \\n    public int DeleteText(int k) {\\n        if(left.Length <= k)\\n        {\\n            k = left.Length;\\n            left.Length = 0;\\n        }\\n        else\\n        {\\n            left.Length = left.Length - k;\\n        }\\n        return k;\\n    }\\n    \\n    public string CursorLeft(int k) {\\n        if(left.Length > k)\\n        {\\n            right.Insert(0,left.ToString(left.Length-k, k));\\n            left.Length = left.Length-k;\\n        }\\n        else\\n        {\\n            right = left.Append(right);\\n            left = new StringBuilder();\\n        }\\n        return left.ToString(left.Length-Math.Min(10,left.Length), Math.Min(10,left.Length));\\n    }\\n    \\n    public string CursorRight(int k) {\\n        if(right.Length > k)\\n        {\\n            left.Append(right.ToString(0, k));\\n            right.Remove(0, k);\\n        }\\n        else\\n        {\\n            left.Append(right);\\n            right.Length = 0;\\n        }\\n        return left.ToString(left.Length-Math.Min(10,left.Length), Math.Min(10,left.Length));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113300,
                "title": "python-simple-python-solution-using-two-list",
                "content": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\n\\tclass TextEditor:\\n\\n\\n\\t\\tdef __init__(self):\\n\\n\\t\\t\\tself.string_one = []\\n\\n\\t\\t\\tself.string_second = []\\n\\n\\t\\tdef addText(self, text: str) -> None:\\n\\n\\t\\t\\tself.string_one += list(text)\\n\\n\\t\\tdef deleteText(self, k: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor i in range(min(len(self.string_one), k)):\\n\\n\\t\\t\\t\\tdel self.string_one[-1]\\n\\n\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result\\n\\n\\t\\tdef cursorLeft(self, k: int) -> str:\\n\\n\\t\\t\\tfor _ in range(k):\\n\\n\\t\\t\\t\\tif not self.string_one:\\n\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tself.string_second.append(self.string_one.pop())\\n\\n\\t\\t\\treturn \"\".join(self.string_one[-10:])\\n\\n\\t\\tdef cursorRight(self, k: int) -> str:\\n\\n\\t\\t\\tfor _ in range(k):\\n\\n\\t\\t\\t\\tif not self.string_second:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tself.string_one.append(self.string_second.pop())\\n\\n\\t\\t\\treturn \"\".join(self.string_one[-10:])\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You Like My Solution Please UpVote Me \\uD83D\\uDE4F\\n\\tclass TextEditor:\\n\\n\\n\\t\\tdef __init__(self):\\n\\n\\t\\t\\tself.string_one = []\\n\\n\\t\\t\\tself.string_second = []\\n\\n\\t\\tdef addText(self, text: str) -> None:\\n\\n\\t\\t\\tself.string_one += list(text)\\n\\n\\t\\tdef deleteText(self, k: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor i in range(min(len(self.string_one), k)):\\n\\n\\t\\t\\t\\tdel self.string_one[-1]\\n\\n\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result\\n\\n\\t\\tdef cursorLeft(self, k: int) -> str:\\n\\n\\t\\t\\tfor _ in range(k):\\n\\n\\t\\t\\t\\tif not self.string_one:\\n\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tself.string_second.append(self.string_one.pop())\\n\\n\\t\\t\\treturn \"\".join(self.string_one[-10:])\\n\\n\\t\\tdef cursorRight(self, k: int) -> str:\\n\\n\\t\\t\\tfor _ in range(k):\\n\\n\\t\\t\\t\\tif not self.string_second:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tself.string_one.append(self.string_second.pop())\\n\\n\\t\\t\\treturn \"\".join(self.string_one[-10:])\\n",
                "codeTag": "Java"
            },
            {
                "id": 2112985,
                "title": "string-reversed-string-iterator-manipulation-pretty-fast-and-simple",
                "content": "keep the text after cursor in a second string in reversed order.  Use reverse iterators to quickly copy text from one string to the other and resize accordingly.\\n```\\nclass TextEditor {\\nprivate:\\n    string p,s;   // p - before cursor, s- after cursor (reversed)\\n    \\npublic:\\n    TextEditor() {        \\n        s=\"\"; p=\"\";    \\n    }\\n    \\n    void addText(string text) {\\n        p+=text;    \\n    }\\n    \\n    int deleteText(int k) {\\n        int pos=p.size();\\n        if (k>=p.size()) {\\n            k=p.size();\\n            p.erase();            \\n        }\\n        else \\n            p.resize(pos-k);                    \\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        if (k>=p.size()) {\\n            s+={p.rbegin(),p.rend()}; // reversed!\\n            p.erase();\\n            return \"\";\\n        } else {\\n            s+={p.rbegin(),p.rbegin()+k};\\n            p.resize(p.size()-k);\\n        }\\n        int pos=p.size();\\n        return p.substr(max(pos-10,0), min(10,pos));        \\n    }\\n    \\n    string cursorRight(int k) {\\n        if (k>=s.size()) {\\n            p+={s.rbegin(),s.rend()};\\n            s.erase();             \\n        } else { \\n            p+={s.rbegin(),s.rbegin()+k};\\n            s.resize(s.size()-k);\\n        }\\n        int pos=p.size();\\n        return p.substr(max(pos-10,0), min(10,pos));       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass TextEditor {\\nprivate:\\n    string p,s;   // p - before cursor, s- after cursor (reversed)\\n    \\npublic:\\n    TextEditor() {        \\n        s=\"\"; p=\"\";    \\n    }\\n    \\n    void addText(string text) {\\n        p+=text;    \\n    }\\n    \\n    int deleteText(int k) {\\n        int pos=p.size();\\n        if (k>=p.size()) {\\n            k=p.size();\\n            p.erase();            \\n        }\\n        else \\n            p.resize(pos-k);                    \\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        if (k>=p.size()) {\\n            s+={p.rbegin(),p.rend()}; // reversed!\\n            p.erase();\\n            return \"\";\\n        } else {\\n            s+={p.rbegin(),p.rbegin()+k};\\n            p.resize(p.size()-k);\\n        }\\n        int pos=p.size();\\n        return p.substr(max(pos-10,0), min(10,pos));        \\n    }\\n    \\n    string cursorRight(int k) {\\n        if (k>=s.size()) {\\n            p+={s.rbegin(),s.rend()};\\n            s.erase();             \\n        } else { \\n            p+={s.rbegin(),s.rbegin()+k};\\n            s.resize(s.size()-k);\\n        }\\n        int pos=p.size();\\n        return p.substr(max(pos-10,0), min(10,pos));       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112965,
                "title": "easy-doubly-linked-list-c",
                "content": "Maitain the current pointer using a doubly linked list\\n\\n```\\nclass DLLNode {\\npublic:\\n    char val;\\n    DLLNode *prev, *next;\\n    DLLNode(char v) : val(v), prev(nullptr), next(nullptr) {}\\n};\\n\\nclass TextEditor {\\npublic:\\n    DLLNode *head, *curr;\\n    TextEditor() {\\n        head = new DLLNode(\\'#\\');\\n        curr = head;\\n    }\\n    \\n    void addText(string text) {\\n        DLLNode *other = curr->next;\\n        for(char &c: text) {\\n            DLLNode *node = new DLLNode(c);\\n            curr->next = node;\\n            node->prev = curr;\\n            curr = curr->next;\\n        }\\n        curr->next = other;\\n        if(other) other->prev = curr;\\n    }\\n    \\n    int deleteText(int k) {\\n        DLLNode *right = curr->next;\\n        int cnt = 0;\\n        while(k-- && curr != head) {\\n            curr = curr->prev;\\n            cnt++;\\n        }\\n        curr->next = right;\\n        if(right) right->prev = curr;\\n        return cnt;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k-- && curr != head) {\\n            curr = curr->prev;\\n        }\\n        string ans;\\n        DLLNode *ptr = curr;\\n        for(int i = 0; i < 10 && ptr != head; i++, ptr = ptr->prev) {\\n            ans.push_back(ptr->val);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k-- && curr->next) {\\n            curr = curr->next;\\n        }\\n        string ans;\\n        DLLNode *ptr = curr;\\n        for(int i = 0; i < 10 && ptr != head; i++, ptr = ptr->prev) {\\n            ans.push_back(ptr->val);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass DLLNode {\\npublic:\\n    char val;\\n    DLLNode *prev, *next;\\n    DLLNode(char v) : val(v), prev(nullptr), next(nullptr) {}\\n};\\n\\nclass TextEditor {\\npublic:\\n    DLLNode *head, *curr;\\n    TextEditor() {\\n        head = new DLLNode(\\'#\\');\\n        curr = head;\\n    }\\n    \\n    void addText(string text) {\\n        DLLNode *other = curr->next;\\n        for(char &c: text) {\\n            DLLNode *node = new DLLNode(c);\\n            curr->next = node;\\n            node->prev = curr;\\n            curr = curr->next;\\n        }\\n        curr->next = other;\\n        if(other) other->prev = curr;\\n    }\\n    \\n    int deleteText(int k) {\\n        DLLNode *right = curr->next;\\n        int cnt = 0;\\n        while(k-- && curr != head) {\\n            curr = curr->prev;\\n            cnt++;\\n        }\\n        curr->next = right;\\n        if(right) right->prev = curr;\\n        return cnt;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k-- && curr != head) {\\n            curr = curr->prev;\\n        }\\n        string ans;\\n        DLLNode *ptr = curr;\\n        for(int i = 0; i < 10 && ptr != head; i++, ptr = ptr->prev) {\\n            ans.push_back(ptr->val);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k-- && curr->next) {\\n            curr = curr->next;\\n        }\\n        string ans;\\n        DLLNode *ptr = curr;\\n        for(int i = 0; i < 10 && ptr != head; i++, ptr = ptr->prev) {\\n            ans.push_back(ptr->val);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2112799,
                "title": "using-linked-list-simple-implementation",
                "content": "\\n\\n```\\nclass link{\\npublic:\\n    char val;\\n    link *pre;\\n    link *next;\\n    link(char ch)\\n    {\\n        val = ch;\\n        next=NULL;\\n    }\\n};\\n\\nclass TextEditor {\\npublic:\\n    link *l,*he,*h;\\n    TextEditor() {\\n        l = new link(\\'#\\');\\n        h = l;\\n        l->pre = NULL;\\n        l->next = new link(\\'|\\');\\n        l->next->pre = l;\\n        l = l->next;\\n        he = l;\\n    }\\n    \\n    void addText(string t) {\\n        link *tem = new link(t[0]);\\n        tem->pre = he->pre;\\n        he->pre->next = tem;\\n        for(int i=1; i<t.size(); ++i)\\n        {\\n            tem->next = new link(t[i]);\\n            tem->next->pre = tem;\\n            tem = tem->next;\\n        }        \\n        tem->next = he;\\n        he->pre = tem;\\n        \\n    }\\n    \\n    int deleteText(int k) {\\n        int ans = 0;\\n        link *tem = he->pre;\\n        // cout<<he->pre->val<<\" \";\\n        while(k--)\\n        {\\n            if(tem->val==\\'#\\')\\n                break;\\n            tem = tem->pre;\\n            ans++;\\n        }\\n        \\n        tem->next = he;\\n        he->pre = tem;\\n        return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n\\n        while(k--)\\n        {\\n            if(he->pre->val==\\'#\\')\\n                break;\\n            swap(he->val,he->pre->val);\\n            he = he->pre;\\n        }\\n        \\n        int x = 10;\\n        string s=\"\";\\n        link *tem = he->pre;\\n        while(x--)\\n        {\\n            if((tem->val==\\'#\\'))\\n                break;\\n            s.push_back(tem->val);\\n            tem = tem->pre;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    \\n    string cursorRight(int k) {\\n        \\n        while(k--)\\n        {\\n            if(he->next==NULL)\\n                break;\\n            swap(he->val,he->next->val);\\n            he = he->next;\\n        }\\n        \\n        int x = 10;\\n        string s=\"\";\\n        link *tem = he->pre;\\n        while(x--)\\n        {\\n            if((tem->val==\\'#\\'))\\n                break;\\n            s.push_back(tem->val);\\n            tem = tem->pre;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass link{\\npublic:\\n    char val;\\n    link *pre;\\n    link *next;\\n    link(char ch)\\n    {\\n        val = ch;\\n        next=NULL;\\n    }\\n};\\n\\nclass TextEditor {\\npublic:\\n    link *l,*he,*h;\\n    TextEditor() {\\n        l = new link(\\'#\\');\\n        h = l;\\n        l->pre = NULL;\\n        l->next = new link(\\'|\\');\\n        l->next->pre = l;\\n        l = l->next;\\n        he = l;\\n    }\\n    \\n    void addText(string t) {\\n        link *tem = new link(t[0]);\\n        tem->pre = he->pre;\\n        he->pre->next = tem;\\n        for(int i=1; i<t.size(); ++i)\\n        {\\n            tem->next = new link(t[i]);\\n            tem->next->pre = tem;\\n            tem = tem->next;\\n        }        \\n        tem->next = he;\\n        he->pre = tem;\\n        \\n    }\\n    \\n    int deleteText(int k) {\\n        int ans = 0;\\n        link *tem = he->pre;\\n        // cout<<he->pre->val<<\" \";\\n        while(k--)\\n        {\\n            if(tem->val==\\'#\\')\\n                break;\\n            tem = tem->pre;\\n            ans++;\\n        }\\n        \\n        tem->next = he;\\n        he->pre = tem;\\n        return ans;\\n    }\\n    \\n    string cursorLeft(int k) {\\n\\n        while(k--)\\n        {\\n            if(he->pre->val==\\'#\\')\\n                break;\\n            swap(he->val,he->pre->val);\\n            he = he->pre;\\n        }\\n        \\n        int x = 10;\\n        string s=\"\";\\n        link *tem = he->pre;\\n        while(x--)\\n        {\\n            if((tem->val==\\'#\\'))\\n                break;\\n            s.push_back(tem->val);\\n            tem = tem->pre;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n    \\n    string cursorRight(int k) {\\n        \\n        while(k--)\\n        {\\n            if(he->next==NULL)\\n                break;\\n            swap(he->val,he->next->val);\\n            he = he->next;\\n        }\\n        \\n        int x = 10;\\n        string s=\"\";\\n        link *tem = he->pre;\\n        while(x--)\\n        {\\n            if((tem->val==\\'#\\'))\\n                break;\\n            s.push_back(tem->val);\\n            tem = tem->pre;\\n        }\\n        \\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2112768,
                "title": "rust-two-stacks",
                "content": "```rust\\nuse std::cmp::{min, max};\\n\\nstruct TextEditor {\\n    left: Vec<char>,\\n    right: Vec<char>\\n}\\n\\nimpl TextEditor {\\n\\n    fn new() -> Self {\\n        Self{\\n            left:vec![],\\n            right:vec![]\\n        }\\n    }\\n    \\n    fn add_text(&mut self, text: String) {\\n        for c in text.chars(){\\n            self.left.push(c);\\n        }\\n    }\\n    \\n    fn delete_text(&mut self, k: i32) -> i32 {\\n        let n = min(self.left.len() as i32, k);\\n        for i in 0..n{\\n            self.left.pop();\\n        }\\n        \\n        n\\n    }\\n    \\n    fn cursor_left(&mut self, k: i32) -> String {\\n        let n = min(self.left.len() as i32, k);\\n        \\n        for i in 0..n{\\n            let c = self.left.pop().unwrap();\\n            self.right.push(c);\\n        }\\n        \\n        let mut slice = &self.left[max(self.left.len() as i32 - 10, 0) as usize..];\\n        slice.iter().collect::<String>()\\n    }\\n    \\n    fn cursor_right(&mut self, k: i32) -> String {\\n        let n = min(self.right.len() as i32, k);\\n        \\n        for i in 0..n{\\n            let c = self.right.pop().unwrap();\\n            self.left.push(c);\\n        }\\n        \\n        self.cursor_left(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```rust\\nuse std::cmp::{min, max};\\n\\nstruct TextEditor {\\n    left: Vec<char>,\\n    right: Vec<char>\\n}\\n\\nimpl TextEditor {\\n\\n    fn new() -> Self {\\n        Self{\\n            left:vec![],\\n            right:vec![]\\n        }\\n    }\\n    \\n    fn add_text(&mut self, text: String) {\\n        for c in text.chars(){\\n            self.left.push(c);\\n        }\\n    }\\n    \\n    fn delete_text(&mut self, k: i32) -> i32 {\\n        let n = min(self.left.len() as i32, k);\\n        for i in 0..n{\\n            self.left.pop();\\n        }\\n        \\n        n\\n    }\\n    \\n    fn cursor_left(&mut self, k: i32) -> String {\\n        let n = min(self.left.len() as i32, k);\\n        \\n        for i in 0..n{\\n            let c = self.left.pop().unwrap();\\n            self.right.push(c);\\n        }\\n        \\n        let mut slice = &self.left[max(self.left.len() as i32 - 10, 0) as usize..];\\n        slice.iter().collect::<String>()\\n    }\\n    \\n    fn cursor_right(&mut self, k: i32) -> String {\\n        let n = min(self.right.len() as i32, k);\\n        \\n        for i in 0..n{\\n            let c = self.right.pop().unwrap();\\n            self.left.push(c);\\n        }\\n        \\n        self.cursor_left(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112670,
                "title": "doubly-linked-list-cpp-stl",
                "content": "```\\nclass TextEditor {\\npublic:\\n    list<char> ll;\\n    std::list<char>::iterator it;\\n    TextEditor() {\\n        ll.clear();\\n        ll.push_front(\\'1\\');\\n        it = ll.begin();\\n    }\\n    \\n    void addText(string text) {\\n        cout<<\"adding text\"<<endl;\\n        for(int i=0;i<(int)text.size();i++){\\n            auto temp = it;\\n            ++temp;\\n            ll.emplace(temp, text[i]);\\n            it++;\\n            //ll.push_back(text[i]);            \\n        }\\n        cout<<\"text added\"<<endl;\\n    }\\n    \\n    int deleteText(int k) {\\n        int c=0;\\n        while(it != ll.begin() && k > 0){\\n            auto temp = it;\\n            it--;\\n            ll.erase(temp);   \\n            c++;\\n            k--;\\n        }\\n        cout<<\"text deleted\"<<endl;\\n        return c;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(it != ll.begin() && k > 0){\\n            it--;\\n            k--;\\n        }\\n        auto temp = it;\\n        string res=\"\";\\n        int c=10;\\n        while(temp != ll.begin() && c > 0){\\n            res = (*temp) + res;\\n            c--;\\n            temp--;\\n        }\\n        return res;\\n        cout<<\"cursor moved to left\"<<endl;\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(it != (--ll.end()) && k > 0){\\n            it++;\\n            k--;\\n        }\\n        auto temp = it;\\n        string res=\"\";\\n        int c=10;\\n        while(temp != ll.begin() && c > 0){\\n            res = *temp + res;\\n            c--;\\n            temp--;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    list<char> ll;\\n    std::list<char>::iterator it;\\n    TextEditor() {\\n        ll.clear();\\n        ll.push_front(\\'1\\');\\n        it = ll.begin();\\n    }\\n    \\n    void addText(string text) {\\n        cout<<\"adding text\"<<endl;\\n        for(int i=0;i<(int)text.size();i++){\\n            auto temp = it;\\n            ++temp;\\n            ll.emplace(temp, text[i]);\\n            it++;\\n            //ll.push_back(text[i]);            \\n        }\\n        cout<<\"text added\"<<endl;\\n    }\\n    \\n    int deleteText(int k) {\\n        int c=0;\\n        while(it != ll.begin() && k > 0){\\n            auto temp = it;\\n            it--;\\n            ll.erase(temp);   \\n            c++;\\n            k--;\\n        }\\n        cout<<\"text deleted\"<<endl;\\n        return c;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(it != ll.begin() && k > 0){\\n            it--;\\n            k--;\\n        }\\n        auto temp = it;\\n        string res=\"\";\\n        int c=10;\\n        while(temp != ll.begin() && c > 0){\\n            res = (*temp) + res;\\n            c--;\\n            temp--;\\n        }\\n        return res;\\n        cout<<\"cursor moved to left\"<<endl;\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(it != (--ll.end()) && k > 0){\\n            it++;\\n            k--;\\n        }\\n        auto temp = it;\\n        string res=\"\";\\n        int c=10;\\n        while(temp != ll.begin() && c > 0){\\n            res = *temp + res;\\n            c--;\\n            temp--;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2112593,
                "title": "java-not-doubly-linked-list",
                "content": "The idea is simple. Keep two stacks. We need two stack because when the cursor has to go to the middle, we have to pop from the stack and without the second one those characters will go to waste. The code should be self-explanatory and do let me know if some specific part is not comprehensible\\n\\n```\\nclass TextEditor {\\n    Stack<Character> left=new Stack<>();\\n    Stack<Character> right=new Stack<>();\\n    \\n    public TextEditor() {\\n    }\\n    \\n    public void addText(String text) {\\n        for(int i=0;i<text.length();i++){\\n            left.push(text.charAt(i));\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int count=0;\\n        while(!left.isEmpty()&&k>0){\\n            count++;\\n            left.pop();\\n            k--;\\n        }\\n        return count;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while(!left.isEmpty()&&k>0){\\n            right.push(left.pop());\\n            k--;\\n        }\\n        int len=Math.min(10,left.size());\\n        String res=\"\";\\n        while(len>0){\\n            res=left.pop()+res;\\n            len--;\\n        }\\n        int c=0;\\n        while(c<res.length()){\\n            left.push(res.charAt(c++));\\n        }\\n        return res;\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while(!right.isEmpty() && k>0){\\n            left.push(right.pop());\\n            k--;\\n        }\\n        int len=Math.min(10,left.size());\\n        String res=\"\";\\n        while(len>0){\\n            res=left.pop()+res;\\n            len--;\\n        }\\n        int c=0;\\n        while(c<res.length()){\\n            left.push(res.charAt(c++));\\n        }\\n        return res;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass TextEditor {\\n    Stack<Character> left=new Stack<>();\\n    Stack<Character> right=new Stack<>();\\n    \\n    public TextEditor() {\\n    }\\n    \\n    public void addText(String text) {\\n        for(int i=0;i<text.length();i++){\\n            left.push(text.charAt(i));\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int count=0;\\n        while(!left.isEmpty()&&k>0){\\n            count++;\\n            left.pop();\\n            k--;\\n        }\\n        return count;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while(!left.isEmpty()&&k>0){\\n            right.push(left.pop());\\n            k--;\\n        }\\n        int len=Math.min(10,left.size());\\n        String res=\"\";\\n        while(len>0){\\n            res=left.pop()+res;\\n            len--;\\n        }\\n        int c=0;\\n        while(c<res.length()){\\n            left.push(res.charAt(c++));\\n        }\\n        return res;\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while(!right.isEmpty() && k>0){\\n            left.push(right.pop());\\n            k--;\\n        }\\n        int len=Math.min(10,left.size());\\n        String res=\"\";\\n        while(len>0){\\n            res=left.pop()+res;\\n            len--;\\n        }\\n        int c=0;\\n        while(c<res.length()){\\n            left.push(res.charAt(c++));\\n        }\\n        return res;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112553,
                "title": "c-using-stl-s-list-easy",
                "content": "- The problem asks us to add and delete at a certain index within the text\\n- The cursor only moves left and right one-by-one\\n- Constraints are small (k <= 40, only about 20,000 calls would be made)\\n\\n**These are all obvious hints that a Linked List would be the best data structure to solve this problem**\\n\\nWe can use the default list that STL gives us. It is a doubly linked list.\\nInsertion and Deletion would be done in O(1)\\n\\n```text\\n- We use a Linked List to represent the text\\n- We use a list iterator to represent the cursor\\n\\naddText()\\n- Simply insert every character behind the iterator\\n\\ndeleteText()\\n- Simply erase every character BEHIND iterator until\\n\\teither the cursor hits the beginning, or we have erased \"k\" characters\\n- Pay attention that we need to erase the character BEHIND the iterator\\n\\ncursorLeft() and cursorRight()\\n- We simply move the iterator untill we have moved \"k\" characters or it hits the starting or the end of the list.\\n- We create another getLastTen() function to retrieve the last 10 characters\\n```\\n\\n```\\nclass TextEditor {\\n    list<char> ll;\\n    list<char>::iterator it;\\npublic:\\n    TextEditor() {\\n        ll = list<char>();\\n        it = ll.begin();\\n    }\\n\\n    string getLastTen() {\\n        auto it1 = it;\\n        string res = \"\";\\n        int x = 10;\\n        while(x && it1 != ll.begin()) {\\n            it1--;\\n            x--;\\n\\t\\t\\t// appending to string is faster than prepending, we reverse the string later\\n            res += *it1;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void addText(string text) {\\n        for(auto& c: text)\\n            ll.insert(it, c);\\n    }\\n    \\n    int deleteText(int k) {\\n        int res = 0;\\n        while(k && it != ll.begin()) {\\n            k--;\\n            auto it1 = it;\\n            it1--;\\n            ll.erase(it1);\\n            res++;\\n        }\\n        return res;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k && it != ll.begin()) {\\n            k--;\\n            it--;\\n        }\\n        return getLastTen();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k && it != ll.end()) {\\n            k--;\\n            it++;\\n            if(it == ll.end()) break;\\n        }\\n        return getLastTen();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```text\\n- We use a Linked List to represent the text\\n- We use a list iterator to represent the cursor\\n\\naddText()\\n- Simply insert every character behind the iterator\\n\\ndeleteText()\\n- Simply erase every character BEHIND iterator until\\n\\teither the cursor hits the beginning, or we have erased \"k\" characters\\n- Pay attention that we need to erase the character BEHIND the iterator\\n\\ncursorLeft() and cursorRight()\\n- We simply move the iterator untill we have moved \"k\" characters or it hits the starting or the end of the list.\\n- We create another getLastTen() function to retrieve the last 10 characters\\n```\n```\\nclass TextEditor {\\n    list<char> ll;\\n    list<char>::iterator it;\\npublic:\\n    TextEditor() {\\n        ll = list<char>();\\n        it = ll.begin();\\n    }\\n\\n    string getLastTen() {\\n        auto it1 = it;\\n        string res = \"\";\\n        int x = 10;\\n        while(x && it1 != ll.begin()) {\\n            it1--;\\n            x--;\\n\\t\\t\\t// appending to string is faster than prepending, we reverse the string later\\n            res += *it1;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    void addText(string text) {\\n        for(auto& c: text)\\n            ll.insert(it, c);\\n    }\\n    \\n    int deleteText(int k) {\\n        int res = 0;\\n        while(k && it != ll.begin()) {\\n            k--;\\n            auto it1 = it;\\n            it1--;\\n            ll.erase(it1);\\n            res++;\\n        }\\n        return res;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(k && it != ll.begin()) {\\n            k--;\\n            it--;\\n        }\\n        return getLastTen();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k && it != ll.end()) {\\n            k--;\\n            it++;\\n            if(it == ll.end()) break;\\n        }\\n        return getLastTen();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112516,
                "title": "c-solution-list-stl",
                "content": "```\\nclass TextEditor {\\npublic:\\n    std::list<char> v;\\n    std::list<char>::iterator itr;\\n    TextEditor() {\\n        v.clear();\\n        v.insert(v.begin(), \\'#\\');\\n        itr = v.end();\\n    }\\n    void showme()\\n    {        \\n        for (auto &i : v)\\n            cout << i;\\n        cout << endl;\\n    }\\n    void addText(string text) {\\n        for (auto &i : text)\\n            v.insert(itr, i);\\n    }\\n    \\n    int deleteText(int k) {\\n        int res = 0;\\n        while (k-- and itr != v.begin())\\n            itr--, res++;\\n        if (itr == v.begin())\\n            itr++, res--;\\n        k = res;\\n        while (res-- and itr != v.end())\\n            itr = v.erase(itr);\\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while (k-- and itr != v.begin())\\n            itr--;\\n        if (itr == v.begin())\\n        {\\n            itr++;\\n            return \"\";\\n        }\\n        auto it = itr;\\n        k = 10;\\n        string ans = \"\";\\n        while (it != v.begin() and k--)\\n        {\\n            it--;\\n            ans += *it;\\n        }\\n        if (it == v.begin())\\n        {\\n            ans.pop_back();\\n            it++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        while (k-- and itr != v.end())\\n            itr++;\\n        auto it = itr;\\n        k = 10;\\n        string ans = \"\";\\n        while (it != v.begin() and k--)\\n        {\\n            it--;\\n            ans += *it;\\n        }\\n        if (it == v.begin())\\n        {\\n            ans.pop_back();\\n            it++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TextEditor {\\npublic:\\n    std::list<char> v;\\n    std::list<char>::iterator itr;\\n    TextEditor() {\\n        v.clear();\\n        v.insert(v.begin(), \\'#\\');\\n        itr = v.end();\\n    }\\n    void showme()\\n    {        \\n        for (auto &i : v)\\n            cout << i;\\n        cout << endl;\\n    }\\n    void addText(string text) {\\n        for (auto &i : text)\\n            v.insert(itr, i);\\n    }\\n    \\n    int deleteText(int k) {\\n        int res = 0;\\n        while (k-- and itr != v.begin())\\n            itr--, res++;\\n        if (itr == v.begin())\\n            itr++, res--;\\n        k = res;\\n        while (res-- and itr != v.end())\\n            itr = v.erase(itr);\\n        return k;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while (k-- and itr != v.begin())\\n            itr--;\\n        if (itr == v.begin())\\n        {\\n            itr++;\\n            return \"\";\\n        }\\n        auto it = itr;\\n        k = 10;\\n        string ans = \"\";\\n        while (it != v.begin() and k--)\\n        {\\n            it--;\\n            ans += *it;\\n        }\\n        if (it == v.begin())\\n        {\\n            ans.pop_back();\\n            it++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        while (k-- and itr != v.end())\\n            itr++;\\n        auto it = itr;\\n        k = 10;\\n        string ans = \"\";\\n        while (it != v.begin() and k--)\\n        {\\n            it--;\\n            ans += *it;\\n        }\\n        if (it == v.begin())\\n        {\\n            ans.pop_back();\\n            it++;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2112486,
                "title": "c-2-deque",
                "content": "**Idea:** Maitain a prefix and suffix deque, one which contains all the letters to the left of the pointer( say **left** deque) and other to the right( say **right** deque ) of the pointer. \\n* **addText()** : push_back the letters from the end of left.\\n* **deleteText()** : pop_back the letters to the end to left **K** times\\n* **cursorLeft()** : pop element from back of left and insert the poped element infront of right. Repeat this **K** times.\\n* **cursorRight()** : pop element from front of right and insert the poped element at back of left. Repeat this k times.\\n```\\nclass TextEditor {\\n    deque<char> left,right;\\n    int len;\\npublic:\\n    TextEditor() {\\n        len = 0;\\n    }\\n     \\n    string find(int k){\\n        string re;\\n        for(auto i = left.rbegin(); i!=left.rend() && k--; i++) re+=string(1,*i);\\n        reverse(re.begin(),re.end());\\n        return re;\\n    }\\n    \\n    void addText(string text) {\\n        for(int i = 0; i<text.size();++i) {left.push_back(text[i]); len++;}\\n    }\\n    \\n    int deleteText(int k) {\\n        int n = 0;\\n        while(left.size() && k--) {left.pop_back(); n++; len--;}\\n        return n;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int n  = k;\\n        while(left.size() && k--){\\n            right.push_front(left.back());\\n            left.pop_back();\\n        }\\n        return find(min(len,10));\\n    }\\n    \\n    string cursorRight(int k) {\\n        int n  = k;\\n        while(right.size() && k--){\\n            left.push_back(right.front());\\n            right.pop_front();\\n        }\\n        return find(min(len,10));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass TextEditor {\\n    deque<char> left,right;\\n    int len;\\npublic:\\n    TextEditor() {\\n        len = 0;\\n    }\\n     \\n    string find(int k){\\n        string re;\\n        for(auto i = left.rbegin(); i!=left.rend() && k--; i++) re+=string(1,*i);\\n        reverse(re.begin(),re.end());\\n        return re;\\n    }\\n    \\n    void addText(string text) {\\n        for(int i = 0; i<text.size();++i) {left.push_back(text[i]); len++;}\\n    }\\n    \\n    int deleteText(int k) {\\n        int n = 0;\\n        while(left.size() && k--) {left.pop_back(); n++; len--;}\\n        return n;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int n  = k;\\n        while(left.size() && k--){\\n            right.push_front(left.back());\\n            left.pop_back();\\n        }\\n        return find(min(len,10));\\n    }\\n    \\n    string cursorRight(int k) {\\n        int n  = k;\\n        while(right.size() && k--){\\n            left.push_back(right.front());\\n            right.pop_front();\\n        }\\n        return find(min(len,10));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112406,
                "title": "easy-c-solution",
                "content": "```\\nclass TextEditor {\\npublic:\\n    deque<char> s1, s2;\\n    TextEditor() {\\n        s1.clear();\\n        s2.clear();\\n    }\\n    void addText(string text) {\\n        for(auto c : text) {\\n            s1.push_back(c);\\n        }\\n    }\\n    int deleteText(int k) {\\n        int cnt = 0;\\n        while(s1.size() > 0 && k > 0) {\\n            s1.pop_back();\\n            k--, cnt++;\\n        }\\n        return cnt;\\n    }\\n    string cursorLeft(int k) {\\n        while(s1.size() > 0 && k > 0) {\\n            s2.push_front(s1.back());\\n            s1.pop_back();\\n            k--;\\n        }\\n        return GetString(s1);\\n    }\\n    string cursorRight(int k) {\\n        while(s2.size() > 0 && k > 0) {\\n            s1.push_back(s2.front());\\n            s2.pop_front();\\n            k--;\\n        }\\n        return GetString(s1);\\n    }\\n    string GetString(deque<char> &s1) {\\n        string st = \"\";\\n        for(int i = 0; i < 10 && s1.size() > 0; i++) {\\n            st += s1.back();\\n            s1.pop_back();\\n        }\\n        reverse(st.begin(), st.end());\\n        for(auto c : st) {\\n            s1.push_back(c);\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Queue"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    deque<char> s1, s2;\\n    TextEditor() {\\n        s1.clear();\\n        s2.clear();\\n    }\\n    void addText(string text) {\\n        for(auto c : text) {\\n            s1.push_back(c);\\n        }\\n    }\\n    int deleteText(int k) {\\n        int cnt = 0;\\n        while(s1.size() > 0 && k > 0) {\\n            s1.pop_back();\\n            k--, cnt++;\\n        }\\n        return cnt;\\n    }\\n    string cursorLeft(int k) {\\n        while(s1.size() > 0 && k > 0) {\\n            s2.push_front(s1.back());\\n            s1.pop_back();\\n            k--;\\n        }\\n        return GetString(s1);\\n    }\\n    string cursorRight(int k) {\\n        while(s2.size() > 0 && k > 0) {\\n            s1.push_back(s2.front());\\n            s2.pop_front();\\n            k--;\\n        }\\n        return GetString(s1);\\n    }\\n    string GetString(deque<char> &s1) {\\n        string st = \"\";\\n        for(int i = 0; i < 10 && s1.size() > 0; i++) {\\n            st += s1.back();\\n            s1.pop_back();\\n        }\\n        reverse(st.begin(), st.end());\\n        for(auto c : st) {\\n            s1.push_back(c);\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112397,
                "title": "python-string-slicing",
                "content": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.text = \\'\\'\\n        self.ptr = len(self.text) \\n\\n    def addText(self, text: str) -> None:\\n        self.text = self.text[:self.ptr] + text + self.text[self.ptr:]\\n        self.ptr += len(text)\\n        \\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        \\n        while self.ptr > 0 and k > 0:\\n            k-=1\\n            count += 1 \\n            self.ptr -= 1\\n        \\n        self.text = self.text[:self.ptr] + self.text[self.ptr + count:]\\n        return count\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.ptr = max(0, self.ptr - k)\\n        return self.text[max(self.ptr - 10, 0):self.ptr]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.ptr = min(len(self.text), self.ptr + k)\\n        return self.text[max(self.ptr - 10, 0):self.ptr]\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.text = \\'\\'\\n        self.ptr = len(self.text) \\n\\n    def addText(self, text: str) -> None:\\n        self.text = self.text[:self.ptr] + text + self.text[self.ptr:]\\n        self.ptr += len(text)\\n        \\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        \\n        while self.ptr > 0 and k > 0:\\n            k-=1\\n            count += 1 \\n            self.ptr -= 1\\n        \\n        self.text = self.text[:self.ptr] + self.text[self.ptr + count:]\\n        return count\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.ptr = max(0, self.ptr - k)\\n        return self.text[max(self.ptr - 10, 0):self.ptr]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.ptr = min(len(self.text), self.ptr + k)\\n        return self.text[max(self.ptr - 10, 0):self.ptr]\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112236,
                "title": "please-help-on-why-my-code-gives-mle-tle",
                "content": "\\n\\n\\tclass TextEditor {\\n    \\n\\n\\t public:\\n\\n\\tint cursor = 0;\\n    \\n\\tstring s = \"\";\\n    \\n\\tTextEditor() {\\n\\t\\n    }\\n    \\n    void addText(string text) {\\n        \\n        if(cursor==s.size()){\\n            s += text;\\n            cursor += text.size();\\n            return;\\n        }\\n        \\n        string str = \"\";\\n        str += s.substr(0,cursor);\\n        str += text;\\n        str += s.substr(cursor,s.size()-cursor);\\n        \\n        cursor += text.size();\\n        \\n        s = str;\\n    }\\n    \\n    int deleteText(int k) {\\n        if(k >= cursor){\\n            if(cursor==s.size())\\n            {\\n                int n = s.size();\\n                s = \"\";\\n                cursor = 0;\\n                return n;\\n            }\\n            s = s.substr(cursor,s.size()-cursor);\\n            int res = cursor;\\n            cursor = 0;\\n            return res;\\n        }\\n        else{\\n            string str = \"\";\\n            str += s.substr(0,cursor-k);\\n            str += s.substr(cursor,s.size()-cursor);\\n            cursor -= k;\\n            s = str;\\n            return k;\\n        }\\n    }\\n    \\n    string cursorLeft(int k) {\\n        if(k>=cursor){\\n            cursor = 0;\\n            return \"\";\\n        }\\n        else{\\n            cursor -= k;\\n            int len = min(10,cursor);\\n            return s.substr(cursor-len,len);\\n        }\\n    }\\n    \\n    string cursorRight(int k) {\\n        if(k+cursor >= s.size()){\\n            cursor = s.size();\\n            int len = min(10,(int)(s.size()));\\n            return s.substr(cursor-len,len);\\n        }\\n        else{\\n            cursor += k;\\n            int len = min(10,cursor);\\n            return s.substr(cursor-len,len);\\n        }\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n\\tclass TextEditor {\\n    \\n\\n\\t public:\\n\\n\\tint cursor = 0;\\n    \\n\\tstring s = \"\";\\n    \\n\\tTextEditor() {\\n\\t\\n    }\\n    \\n    void addText(string text) {\\n        \\n        if(cursor==s.size()){\\n            s += text;\\n            cursor += text.size();\\n            return;\\n        }\\n        \\n        string str = \"\";\\n        str += s.substr(0,cursor);\\n        str += text;\\n        str += s.substr(cursor,s.size()-cursor);\\n        \\n        cursor += text.size();\\n        \\n        s = str;\\n    }\\n    \\n    int deleteText(int k) {\\n        if(k >= cursor){\\n            if(cursor==s.size())\\n            {\\n                int n = s.size();\\n                s = \"\";\\n                cursor = 0;\\n                return n;\\n            }\\n            s = s.substr(cursor,s.size()-cursor);\\n            int res = cursor;\\n            cursor = 0;\\n            return res;\\n        }\\n        else{\\n            string str = \"\";\\n            str += s.substr(0,cursor-k);\\n            str += s.substr(cursor,s.size()-cursor);\\n            cursor -= k;\\n            s = str;\\n            return k;\\n        }\\n    }\\n    \\n    string cursorLeft(int k) {\\n        if(k>=cursor){\\n            cursor = 0;\\n            return \"\";\\n        }\\n        else{\\n            cursor -= k;\\n            int len = min(10,cursor);\\n            return s.substr(cursor-len,len);\\n        }\\n    }\\n    \\n    string cursorRight(int k) {\\n        if(k+cursor >= s.size()){\\n            cursor = s.size();\\n            int len = min(10,(int)(s.size()));\\n            return s.substr(cursor-len,len);\\n        }\\n        else{\\n            cursor += k;\\n            int len = min(10,cursor);\\n            return s.substr(cursor-len,len);\\n        }\\n    }\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2112227,
                "title": "java-solution-with-intuition-doubly-linked-list-fully-explained",
                "content": "**Intuition:**\\nThe problem says to create a text editor which supports insertion anywhere, along with deletion anywhere and it also allows the movement among the list freely. We need a data structure which supports these things.\\nTherefore, what comes up is, Doubly Linked List as we can insert anywhere delete anywhere and we can move both left and right using the next and prev pointers.\\n\\n**Implementation:**\\nWe need to implement nothing but a normal doubly linked list of characters with `addTail()` , `insert(currentPosition)`, `removeTail()` and `remove(currentPosition)` API\\'s. \\n\\n**Code**:\\n```\\nclass TextEditor {\\n    \\n    //Node of Doubly Linked List\\n    class Node{\\n        Node next,prev; char data;\\n        public Node(char data){\\n            this.data=data;\\n        }\\n    }\\n    \\n    private Node addTail(char ch){\\n        Node p=new Node(ch);//Create new node with this character\\n        p.prev=current;//Set it\\'s prev to cursor\\n        current.next=p;//Set cursor\\'s next to this node\\n        return current.next;//Move cursor ahead\\n    }\\n    \\n    private Node insert(char ch){\\n        Node p=new Node(ch);//Create new node with this character\\n        Node q=current.next;//Keep next node\\n        q.prev=p;//Set prev of next node to this new node\\n        p.next=q;//Set next of the new node to next node\\n        p.prev=current;//Set prev of new node to current\\n        current.next=p;//Set next of current to new node\\n        return current.next; //move it ahead\\n    }\\n    \\n    private Node removeTail(){\\n        current=current.prev;//Move cursor left\\n        current.next.prev=null;//Mark prev of next as null to delete link\\n        current.next=null; //Set next of cursor as null as it\\'s deleted\\n        return current; //return the new cursor\\n    }\\n    \\n    private Node remove(){\\n        Node p=current.prev;//Keep prev of node\\n        p.next=current.next;//Link next of this prev node to next node skipping the middle node\\n        current.next.prev=p;//Link the prev of the next to prev , skipping here as well\\n        return p;//Return the prev node as it is where the cursor points now.\\n    }\\n    \\n    private String createString(){\\n        Node p=current;int limit=10;\\n        StringBuilder sb=new StringBuilder();\\n        while(limit>0&&p!=head){\\n            sb.insert(0,p.data);//inserts character at the beginning of string\\n            p=p.prev;\\n            limit--;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    Node head; //To keep a mark of left exterme\\n    Node current; //Keeps the current cursor position after which add/remove will occur\\n    \\n    public TextEditor() {\\n        head=new Node(\\'0\\');\\n        current=head;//Keeping cursor in beginning at left most position\\n    }\\n    \\n    public void addText(String text) {\\n        for(char ch:text.toCharArray()){\\n            if(current.next==null)\\n                //If we are at right extreme, it is just similar to adding a node at end\\n                current=addTail(ch);\\n            else\\n                //We need to insert this character at cursor location and move cursor one ahead\\n                current=insert(ch);\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int ans=0;\\n        while(k>0&&current!=head){\\n            if(current.next==null)\\n                //If we are at right extreme, it is just similar to removing a node at end\\n                current=removeTail();\\n            else\\n                //Moving cursor left by 1 position after deleting node at the cursor position and moving left\\n                current=remove();\\n            ans++;k--;\\n        }\\n        return ans;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        //Keep moving cursor left till it reaches left extreme (=head) or k becomes 0\\n        while(current!=head&&k>0){\\n            current=current.prev;\\n            k--;\\n        }\\n        return createString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        //Keep moving cursor right till it reaches right extreme (=null) or k becomes 0\\n        while(current.next!=null&&k>0){\\n            current=current.next;\\n            k--;\\n        }\\n        return createString();\\n    }\\n}\\n```\\n**An upvote would be great if you understood the intuition and solution**",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass TextEditor {\\n    \\n    //Node of Doubly Linked List\\n    class Node{\\n        Node next,prev; char data;\\n        public Node(char data){\\n            this.data=data;\\n        }\\n    }\\n    \\n    private Node addTail(char ch){\\n        Node p=new Node(ch);//Create new node with this character\\n        p.prev=current;//Set it\\'s prev to cursor\\n        current.next=p;//Set cursor\\'s next to this node\\n        return current.next;//Move cursor ahead\\n    }\\n    \\n    private Node insert(char ch){\\n        Node p=new Node(ch);//Create new node with this character\\n        Node q=current.next;//Keep next node\\n        q.prev=p;//Set prev of next node to this new node\\n        p.next=q;//Set next of the new node to next node\\n        p.prev=current;//Set prev of new node to current\\n        current.next=p;//Set next of current to new node\\n        return current.next; //move it ahead\\n    }\\n    \\n    private Node removeTail(){\\n        current=current.prev;//Move cursor left\\n        current.next.prev=null;//Mark prev of next as null to delete link\\n        current.next=null; //Set next of cursor as null as it\\'s deleted\\n        return current; //return the new cursor\\n    }\\n    \\n    private Node remove(){\\n        Node p=current.prev;//Keep prev of node\\n        p.next=current.next;//Link next of this prev node to next node skipping the middle node\\n        current.next.prev=p;//Link the prev of the next to prev , skipping here as well\\n        return p;//Return the prev node as it is where the cursor points now.\\n    }\\n    \\n    private String createString(){\\n        Node p=current;int limit=10;\\n        StringBuilder sb=new StringBuilder();\\n        while(limit>0&&p!=head){\\n            sb.insert(0,p.data);//inserts character at the beginning of string\\n            p=p.prev;\\n            limit--;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    Node head; //To keep a mark of left exterme\\n    Node current; //Keeps the current cursor position after which add/remove will occur\\n    \\n    public TextEditor() {\\n        head=new Node(\\'0\\');\\n        current=head;//Keeping cursor in beginning at left most position\\n    }\\n    \\n    public void addText(String text) {\\n        for(char ch:text.toCharArray()){\\n            if(current.next==null)\\n                //If we are at right extreme, it is just similar to adding a node at end\\n                current=addTail(ch);\\n            else\\n                //We need to insert this character at cursor location and move cursor one ahead\\n                current=insert(ch);\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int ans=0;\\n        while(k>0&&current!=head){\\n            if(current.next==null)\\n                //If we are at right extreme, it is just similar to removing a node at end\\n                current=removeTail();\\n            else\\n                //Moving cursor left by 1 position after deleting node at the cursor position and moving left\\n                current=remove();\\n            ans++;k--;\\n        }\\n        return ans;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        //Keep moving cursor left till it reaches left extreme (=head) or k becomes 0\\n        while(current!=head&&k>0){\\n            current=current.prev;\\n            k--;\\n        }\\n        return createString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        //Keep moving cursor right till it reaches right extreme (=null) or k becomes 0\\n        while(current.next!=null&&k>0){\\n            current=current.next;\\n            k--;\\n        }\\n        return createString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112222,
                "title": "c-substr-function-clean-and-concise",
                "content": "```\\nclass TextEditor {\\npublic:\\n    string s=\"\";\\n    int posCursor=0;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        s=s.insert(posCursor,text);\\n        posCursor+=text.size();\\n        \\n    }\\n    \\n    int deleteText(int k) {\\n        int temp=min(posCursor,k);\\n        s.erase(posCursor-temp,temp);\\n        posCursor-=temp;\\n        \\n        return temp;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int temp=min(k,posCursor);\\n        posCursor-=temp;\\n        int remain=min(10,posCursor);\\n        \\n        string ans=s.substr(posCursor-remain,remain);\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int p=s.size();\\n        int temp=min(k,p-posCursor);\\n        posCursor+=temp;\\n        int remain=min(10,posCursor);\\n        string ans=s.substr(posCursor-remain,remain);\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    string s=\"\";\\n    int posCursor=0;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        s=s.insert(posCursor,text);\\n        posCursor+=text.size();\\n        \\n    }\\n    \\n    int deleteText(int k) {\\n        int temp=min(posCursor,k);\\n        s.erase(posCursor-temp,temp);\\n        posCursor-=temp;\\n        \\n        return temp;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int temp=min(k,posCursor);\\n        posCursor-=temp;\\n        int remain=min(10,posCursor);\\n        \\n        string ans=s.substr(posCursor-remain,remain);\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int p=s.size();\\n        int temp=min(k,p-posCursor);\\n        posCursor+=temp;\\n        int remain=min(10,posCursor);\\n        string ans=s.substr(posCursor-remain,remain);\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112128,
                "title": "golang-using-list",
                "content": "```\\ntype TextEditor struct {\\n    text *list.List\\n    cursor *list.Element\\n}\\n\\n\\nfunc Constructor() TextEditor {\\n    l := list.New()\\n    l.PushBack(\\'*\\')\\n    return TextEditor {\\n        text: l,\\n        cursor: l.Front(),\\n    }\\n}\\n\\n\\nfunc (this *TextEditor) AddText(text string)  {\\n    for _, c := range text {\\n        this.text.InsertAfter(c, this.cursor)\\n        this.cursor = this.cursor.Next()\\n    }\\n}\\n\\n\\nfunc (this *TextEditor) DeleteText(k int) int {\\n    count := 0\\n    for this.cursor != this.text.Front() && count < k {\\n        count++\\n        b := this.cursor.Prev()\\n        this.text.Remove(this.cursor)\\n        this.cursor = b\\n    }\\n    return count\\n}\\n\\n\\nfunc (this *TextEditor) CursorLeft(k int) string {\\n    count := 0\\n    for this.cursor != this.text.Front() && count < k {\\n        this.cursor = this.cursor.Prev()\\n        count++\\n    }\\n    return this.GetPrev(10)\\n}\\n\\n\\nfunc (this *TextEditor) CursorRight(k int) string {\\n    count := 0\\n    for this.cursor != this.text.Back() && count < k {\\n        this.cursor = this.cursor.Next()\\n        count++\\n    }\\n    return this.GetPrev(10)\\n}\\n\\nfunc (this *TextEditor) GetPrev(k int) string {\\n    count, itr := 0, this.cursor\\n    for itr != this.text.Front() && count < k {\\n        itr = itr.Prev()\\n        count++\\n    }\\n    itr = itr.Next()\\n    \\n    sb := strings.Builder{}\\n    for ; itr != this.cursor.Next(); itr = itr.Next() {\\n        sb.WriteRune(itr.Value.(rune))\\n    }\\n    return sb.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype TextEditor struct {\\n    text *list.List\\n    cursor *list.Element\\n}\\n\\n\\nfunc Constructor() TextEditor {\\n    l := list.New()\\n    l.PushBack(\\'*\\')\\n    return TextEditor {\\n        text: l,\\n        cursor: l.Front(),\\n    }\\n}\\n\\n\\nfunc (this *TextEditor) AddText(text string)  {\\n    for _, c := range text {\\n        this.text.InsertAfter(c, this.cursor)\\n        this.cursor = this.cursor.Next()\\n    }\\n}\\n\\n\\nfunc (this *TextEditor) DeleteText(k int) int {\\n    count := 0\\n    for this.cursor != this.text.Front() && count < k {\\n        count++\\n        b := this.cursor.Prev()\\n        this.text.Remove(this.cursor)\\n        this.cursor = b\\n    }\\n    return count\\n}\\n\\n\\nfunc (this *TextEditor) CursorLeft(k int) string {\\n    count := 0\\n    for this.cursor != this.text.Front() && count < k {\\n        this.cursor = this.cursor.Prev()\\n        count++\\n    }\\n    return this.GetPrev(10)\\n}\\n\\n\\nfunc (this *TextEditor) CursorRight(k int) string {\\n    count := 0\\n    for this.cursor != this.text.Back() && count < k {\\n        this.cursor = this.cursor.Next()\\n        count++\\n    }\\n    return this.GetPrev(10)\\n}\\n\\nfunc (this *TextEditor) GetPrev(k int) string {\\n    count, itr := 0, this.cursor\\n    for itr != this.text.Front() && count < k {\\n        itr = itr.Prev()\\n        count++\\n    }\\n    itr = itr.Next()\\n    \\n    sb := strings.Builder{}\\n    for ; itr != this.cursor.Next(); itr = itr.Next() {\\n        sb.WriteRune(itr.Value.(rune))\\n    }\\n    return sb.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112060,
                "title": "java-linkedlist-solution-with-explanation-t-max-k-text-length-ops-s-o-total-text-length",
                "content": "Idea: Since, we don\\'t need random access of the already inserted text and also we need to append string anywhere within the text, we can go for linkedlist.\\n```\\nclass TextEditor {\\n    Node head,tail,trav;\\n    public TextEditor() {\\n\\t\\t// creating two dummy nodes to point the start and end.\\n        head=new Node(\\'!\\');\\n        tail=new Node(\\'!\\');\\n        head.next=tail;\\n        tail.prev=head;\\n\\t\\t\\n\\t\\t// trav will be the cursor.\\n        trav=head;\\n    }\\n    \\n    public void addText(String text) {\\n\\t// appending string to the right starting from the cursor. T=O(text.length), S=O(text.length)\\n        char []chrr=text.toCharArray();\\n        for(char c:chrr){\\n            insertRight(new Node(c));\\n            trav=trav.next;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n\\t// deleting the node trav is pointing to, i.e, deleting the character left to the cursor. T=O(k), S=O(1)\\n        int cnt=0;\\n        while(cnt<k&&trav!=head){\\n            delete();\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    public String cursorLeft(int k) { // T=O(k), S=O(1)\\n\\t// moving cursor left.\\n        while(k-->0&&trav!=head){\\n            trav=trav.prev;\\n        }\\n\\t\\t\\n\\t// returning the required number of characters in the left of the cursor.\\n        Node temp=trav;\\n        k=10;\\n        StringBuilder sbr=new StringBuilder();\\n        while(k-->0&&temp!=head){\\n            sbr.append(temp.c);\\n            temp=temp.prev;\\n        }\\n        return sbr.reverse().toString();\\n    }\\n    \\n    public String cursorRight(int k) { // T=O(k), S=O(1)\\n\\t// moving cursor right.\\n        while(k-->0&&trav.next!=tail){\\n            trav=trav.next;\\n        }\\n\\t\\t\\n\\t// returning the required number of characters in the left of the cursor.\\n        Node temp=trav;\\n        k=10;\\n        StringBuilder sbr=new StringBuilder();\\n        while(k-->0&&temp!=head){\\n            sbr.append(temp.c);\\n            temp=temp.prev;\\n        }\\n        return sbr.reverse().toString();\\n    }\\n    public void insertRight(Node newNode){ \\n\\t// adding a node to the right of trav. T=O(1), S=O(1)\\n        newNode.next=trav.next;\\n        newNode.prev=trav;\\n        newNode.prev.next=newNode;\\n        newNode.next.prev=newNode;        \\n    }\\n    public void delete(){\\n\\t// deletes the node trav is pointing to, from the linkedlist and moves to left. T=O(1), S=O(1)\\n        trav.next.prev=trav.prev;\\n        trav.prev.next=trav.next;\\n        trav=trav.prev;\\n    }\\n}\\nclass Node{\\n    char c;\\n    Node prev,next;\\n    Node(char ch){\\n        c=ch;\\n    }\\n}\\n```\\nPlease upvote if this helps.",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass TextEditor {\\n    Node head,tail,trav;\\n    public TextEditor() {\\n\\t\\t// creating two dummy nodes to point the start and end.\\n        head=new Node(\\'!\\');\\n        tail=new Node(\\'!\\');\\n        head.next=tail;\\n        tail.prev=head;\\n\\t\\t\\n\\t\\t// trav will be the cursor.\\n        trav=head;\\n    }\\n    \\n    public void addText(String text) {\\n\\t// appending string to the right starting from the cursor. T=O(text.length), S=O(text.length)\\n        char []chrr=text.toCharArray();\\n        for(char c:chrr){\\n            insertRight(new Node(c));\\n            trav=trav.next;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n\\t// deleting the node trav is pointing to, i.e, deleting the character left to the cursor. T=O(k), S=O(1)\\n        int cnt=0;\\n        while(cnt<k&&trav!=head){\\n            delete();\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    public String cursorLeft(int k) { // T=O(k), S=O(1)\\n\\t// moving cursor left.\\n        while(k-->0&&trav!=head){\\n            trav=trav.prev;\\n        }\\n\\t\\t\\n\\t// returning the required number of characters in the left of the cursor.\\n        Node temp=trav;\\n        k=10;\\n        StringBuilder sbr=new StringBuilder();\\n        while(k-->0&&temp!=head){\\n            sbr.append(temp.c);\\n            temp=temp.prev;\\n        }\\n        return sbr.reverse().toString();\\n    }\\n    \\n    public String cursorRight(int k) { // T=O(k), S=O(1)\\n\\t// moving cursor right.\\n        while(k-->0&&trav.next!=tail){\\n            trav=trav.next;\\n        }\\n\\t\\t\\n\\t// returning the required number of characters in the left of the cursor.\\n        Node temp=trav;\\n        k=10;\\n        StringBuilder sbr=new StringBuilder();\\n        while(k-->0&&temp!=head){\\n            sbr.append(temp.c);\\n            temp=temp.prev;\\n        }\\n        return sbr.reverse().toString();\\n    }\\n    public void insertRight(Node newNode){ \\n\\t// adding a node to the right of trav. T=O(1), S=O(1)\\n        newNode.next=trav.next;\\n        newNode.prev=trav;\\n        newNode.prev.next=newNode;\\n        newNode.next.prev=newNode;        \\n    }\\n    public void delete(){\\n\\t// deletes the node trav is pointing to, from the linkedlist and moves to left. T=O(1), S=O(1)\\n        trav.next.prev=trav.prev;\\n        trav.prev.next=trav.next;\\n        trav=trav.prev;\\n    }\\n}\\nclass Node{\\n    char c;\\n    Node prev,next;\\n    Node(char ch){\\n        c=ch;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112054,
                "title": "reason-for-mle",
                "content": "Can anyone explain why this code gives MLE?\\n```\\nclass TextEditor {\\npublic:\\n    string s,s1,s2;\\n    \\n    int ind=0;\\n    string ans;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n         s=s.substr(0,ind)+text+s.substr(ind);\\n        // s=s1+text+s2;\\n        ind=ind+text.size();\\n        // cout<<s<<endl;\\n    }\\n    \\n    int deleteText(int k) {\\n        if(k>ind){\\n            s=s.substr(ind);\\n            int c=ind;\\n            ind=0;\\n            return c;\\n        }\\n        else{\\n             s1=s.substr(0,ind-k);\\n             s2=s.substr(ind);\\n            s=s1+s2;\\n            ind=ind-k;\\n            return k;\\n        }\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int p=ind-k;\\n        ind=max(p,0);\\n        // cout<<ind;\\n        int mn=min(ind,10);\\n         s2=s.substr(0,ind);\\n        if(ind-mn<0)\\n            return s2;\\n         s1=s2.substr(ind-mn);\\n        return s1;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int p=ind+k;\\n        ind=min(p,(int)s.size());\\n        //cout<<ind;\\n        int mn=min(ind,10);\\n         s2=s.substr(0,ind);\\n        if(ind-mn<0)\\n            return s2;\\n        string s1=s2.substr(ind-mn);\\n        return s1;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */",
                "solutionTags": [],
                "code": "Can anyone explain why this code gives MLE?\\n```\\nclass TextEditor {\\npublic:\\n    string s,s1,s2;\\n    \\n    int ind=0;\\n    string ans;\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n         s=s.substr(0,ind)+text+s.substr(ind);\\n        // s=s1+text+s2;\\n        ind=ind+text.size();\\n        // cout<<s<<endl;\\n    }\\n    \\n    int deleteText(int k) {\\n        if(k>ind){\\n            s=s.substr(ind);\\n            int c=ind;\\n            ind=0;\\n            return c;\\n        }\\n        else{\\n             s1=s.substr(0,ind-k);\\n             s2=s.substr(ind);\\n            s=s1+s2;\\n            ind=ind-k;\\n            return k;\\n        }\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int p=ind-k;\\n        ind=max(p,0);\\n        // cout<<ind;\\n        int mn=min(ind,10);\\n         s2=s.substr(0,ind);\\n        if(ind-mn<0)\\n            return s2;\\n         s1=s2.substr(ind-mn);\\n        return s1;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int p=ind+k;\\n        ind=min(p,(int)s.size());\\n        //cout<<ind;\\n        int mn=min(ind,10);\\n         s2=s.substr(0,ind);\\n        if(ind-mn<0)\\n            return s2;\\n        string s1=s2.substr(ind-mn);\\n        return s1;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */",
                "codeTag": "C++"
            },
            {
                "id": 2111997,
                "title": "c-simple-stringbuilder",
                "content": "```\\npublic class TextEditor\\n{\\n    StringBuilder sb;\\n    int index = -1;\\n    public TextEditor()\\n    {\\n        sb = new StringBuilder();\\n    }\\n\\n    public void AddText(string text)\\n    {\\n        sb.Insert(index+1, text);\\n        index += text.Length;\\n    }\\n\\n    public int DeleteText(int k)\\n    {\\n        int startIndex = Math.Max(0, index - k + 1);\\n        int length = index - startIndex + 1;\\n        sb.Remove(startIndex, length);\\n        index -= length;\\n        return length;\\n    }\\n\\n    public string CursorLeft(int k)\\n    {\\n        index = Math.Max(-1, index - k);\\n        int startIndex = Math.Max(0, index - 9);\\n        int length = index - startIndex +1;\\n        return sb.ToString(startIndex, length);\\n    }\\n\\n    public string CursorRight(int k)\\n    {\\n        index = Math.Min(sb.Length - 1, index + k);\\n        int startIndex = Math.Max(0, index - 9);\\n        int length = index - startIndex + 1;\\n        return sb.ToString(startIndex, length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\npublic class TextEditor\\n{\\n    StringBuilder sb;\\n    int index = -1;\\n    public TextEditor()\\n    {\\n        sb = new StringBuilder();\\n    }\\n\\n    public void AddText(string text)\\n    {\\n        sb.Insert(index+1, text);\\n        index += text.Length;\\n    }\\n\\n    public int DeleteText(int k)\\n    {\\n        int startIndex = Math.Max(0, index - k + 1);\\n        int length = index - startIndex + 1;\\n        sb.Remove(startIndex, length);\\n        index -= length;\\n        return length;\\n    }\\n\\n    public string CursorLeft(int k)\\n    {\\n        index = Math.Max(-1, index - k);\\n        int startIndex = Math.Max(0, index - 9);\\n        int length = index - startIndex +1;\\n        return sb.ToString(startIndex, length);\\n    }\\n\\n    public string CursorRight(int k)\\n    {\\n        index = Math.Min(sb.Length - 1, index + k);\\n        int startIndex = Math.Max(0, index - 9);\\n        int length = index - startIndex + 1;\\n        return sb.ToString(startIndex, length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111981,
                "title": "2-deques-c",
                "content": "```\\nclass TextEditor {\\npublic:\\n    deque<char>left;\\n    deque<char>right;\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        for(auto &x: text){\\n            left.push_back(x);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int count= 0;\\n        while(!left.empty() && k){\\n            left.pop_back();\\n            k--;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int charsLeft = left.size();\\n        int len = 0;\\n        for(int i=0;i<min(charsLeft,k);i++){\\n            right.push_front(left.back());\\n            left.pop_back();\\n            len++;\\n        }\\n        int n = min(10,charsLeft-len);\\n        string temp(n,\\'0\\');\\n        for(int i=n-1;i>=0;i--){\\n            temp[i] = left.back();\\n            left.pop_back();\\n        }\\n        for(auto &x: temp){\\n            left.push_back(x);\\n        }\\n        return temp;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int charsRight = right.size();\\n        int len = 0;\\n        for(int i=0;i<min(charsRight,k);i++){\\n            left.push_back(right.front());\\n            right.pop_front();\\n            len++;\\n        }\\n        // cout<<left.size()<<endl;\\n        int n = min(10,(int)left.size());\\n        string temp(n,\\'0\\');\\n        for(int i=n-1;i>=0;i--){\\n            temp[i] = left.back();\\n            // cout<<temp[i];\\n            left.pop_back();\\n        }\\n        // cout<<endl;\\n        for(auto &x: temp){\\n            left.push_back(x);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    deque<char>left;\\n    deque<char>right;\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        for(auto &x: text){\\n            left.push_back(x);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int count= 0;\\n        while(!left.empty() && k){\\n            left.pop_back();\\n            k--;\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        int charsLeft = left.size();\\n        int len = 0;\\n        for(int i=0;i<min(charsLeft,k);i++){\\n            right.push_front(left.back());\\n            left.pop_back();\\n            len++;\\n        }\\n        int n = min(10,charsLeft-len);\\n        string temp(n,\\'0\\');\\n        for(int i=n-1;i>=0;i--){\\n            temp[i] = left.back();\\n            left.pop_back();\\n        }\\n        for(auto &x: temp){\\n            left.push_back(x);\\n        }\\n        return temp;\\n    }\\n    \\n    string cursorRight(int k) {\\n        int charsRight = right.size();\\n        int len = 0;\\n        for(int i=0;i<min(charsRight,k);i++){\\n            left.push_back(right.front());\\n            right.pop_front();\\n            len++;\\n        }\\n        // cout<<left.size()<<endl;\\n        int n = min(10,(int)left.size());\\n        string temp(n,\\'0\\');\\n        for(int i=n-1;i>=0;i--){\\n            temp[i] = left.back();\\n            // cout<<temp[i];\\n            left.pop_back();\\n        }\\n        // cout<<endl;\\n        for(auto &x: temp){\\n            left.push_back(x);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4058193,
                "title": "doubly-linkedlist-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor {\\n    private static class Node{\\n        Node left,right;\\n        char ch;\\n        Node(char ch){\\n            this.ch=ch;\\n            this.left=this.right=null;\\n\\n        }\\n    }\\nNode head,tail,current;\\n    public TextEditor() {\\n        head=tail=current=new Node(\\'\\\\0\\');\\n    }\\n    \\n    public void addText(String text) {\\n        Node newHead = new Node(text.charAt(0));\\n        Node cn= newHead;\\n        for ( int i=1; i< text.length(); i++){\\n            Node newNode = new Node(text.charAt(i));\\n            newNode.left = cn;\\n            cn.right =newNode;\\n            cn = newNode;\\n        }\\n        Node nextNode = this.current.right;\\n        this.current.right= newHead;\\n        newHead.left = this.current;\\n        this.current = cn;\\n        this.current.right = nextNode;\\n        if ( nextNode != null){\\n            nextNode.left = this.current;\\n        } \\n    }\\n    \\n    public int deleteText(int k) {\\n        Node nextNode = this.current.right;\\n        Node node = this.current;\\n        int n = k;\\n        while ( k > 0 && this.current.ch != \\'\\\\0\\'){\\n            this.current = this.current.left;\\n            k--;\\n        } \\n        this.current.right = nextNode;\\n        if ( nextNode != null){\\n            nextNode.left = this.current;\\n        }\\n        return (n-k); \\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while ( k > 0 && this.current.ch != \\'\\\\0\\'){\\n            this.current = this.current.left;\\n            k--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        Node node = this.current;\\n        int count = 10; \\n        while ( count > 0 && node.ch != \\'\\\\0\\'){\\n            sb.insert(0, node.ch);\\n            node = node.left;\\n            count--;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n         while ( k > 0 && this.current.right != null){\\n            this.current =this.current.right;\\n            k--;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Node node = this.current;\\n        int count = 10; \\n        while ( count > 0 && node.ch != \\'\\\\0\\'){\\n            sb.insert(0, node.ch);\\n            node = node.left;\\n            count--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n    private static class Node{\\n        Node left,right;\\n        char ch;\\n        Node(char ch){\\n            this.ch=ch;\\n            this.left=this.right=null;\\n\\n        }\\n    }\\nNode head,tail,current;\\n    public TextEditor() {\\n        head=tail=current=new Node(\\'\\\\0\\');\\n    }\\n    \\n    public void addText(String text) {\\n        Node newHead = new Node(text.charAt(0));\\n        Node cn= newHead;\\n        for ( int i=1; i< text.length(); i++){\\n            Node newNode = new Node(text.charAt(i));\\n            newNode.left = cn;\\n            cn.right =newNode;\\n            cn = newNode;\\n        }\\n        Node nextNode = this.current.right;\\n        this.current.right= newHead;\\n        newHead.left = this.current;\\n        this.current = cn;\\n        this.current.right = nextNode;\\n        if ( nextNode != null){\\n            nextNode.left = this.current;\\n        } \\n    }\\n    \\n    public int deleteText(int k) {\\n        Node nextNode = this.current.right;\\n        Node node = this.current;\\n        int n = k;\\n        while ( k > 0 && this.current.ch != \\'\\\\0\\'){\\n            this.current = this.current.left;\\n            k--;\\n        } \\n        this.current.right = nextNode;\\n        if ( nextNode != null){\\n            nextNode.left = this.current;\\n        }\\n        return (n-k); \\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while ( k > 0 && this.current.ch != \\'\\\\0\\'){\\n            this.current = this.current.left;\\n            k--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        Node node = this.current;\\n        int count = 10; \\n        while ( count > 0 && node.ch != \\'\\\\0\\'){\\n            sb.insert(0, node.ch);\\n            node = node.left;\\n            count--;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n         while ( k > 0 && this.current.right != null){\\n            this.current =this.current.right;\\n            k--;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Node node = this.current;\\n        int count = 10; \\n        while ( count > 0 && node.ch != \\'\\\\0\\'){\\n            sb.insert(0, node.ch);\\n            node = node.left;\\n            count--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052332,
                "title": "o-k-solution-implemented-with-double-linked-list",
                "content": "# Intuition\\nEach character is represented by a node. There are start and end nodes representing the limits of the text, and there\\'s a node representing the cursor.\\n\\nNot the most efficient solution in terms of cpu and memory, but it doesn\\'s rely on python specific data structures (queues, for example), so it\\'s a solution that can be translated to any language.\\n\\n# Approach\\nMoving the cursor left or right requires reconnecting the nodes properly.\\nAdding text requires adding more nodes (and connect then properly) to the left of the cursor.\\nRemoving text requires reconnecting the cursor to the previous node of the cursor\\'s previous node, n times.\\n\\nThe computational cost is O(k), as every loop is limited by k (or the length of the string to add)\\n\\n# Complexity\\n- Time complexity:\\nO(k)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Character:\\n    def __init__(self, prev, next, val):\\n        self.prev = prev\\n        self.next = next\\n        self.val = val\\n\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.start = Character(None, None, None)\\n        self.end = Character(None, None, None)\\n        self.cursor = Character(self.start, self.end, \"|\")\\n\\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            character = Character(self.cursor.prev, self.cursor, c)\\n            self.cursor.prev.next = character\\n            self.cursor.prev = character\\n\\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while (i < k) and self.cursor.prev != self.start:\\n            self.cursor.prev = self.cursor.prev.prev\\n            self.cursor.prev.next = self.cursor\\n            i += 1\\n        return i        \\n\\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while (i < k) and (self.cursor.prev != self.start):\\n            prevprev = self.cursor.prev.prev\\n            prev = self.cursor.prev\\n            next = self.cursor.next\\n            prevprev.next = self.cursor\\n            self.cursor.prev = prevprev\\n            self.cursor.next = prev\\n            prev.prev = self.cursor\\n            prev.next = next\\n            next.prev = prev\\n            i += 1\\n        return self._previousString(10)\\n        \\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while (i < k) and (self.cursor.next != self.end):\\n            prev = self.cursor.prev\\n            next = self.cursor.next\\n            nextnext = self.cursor.next.next\\n            prev.next = next\\n            next.prev = prev\\n            next.next = self.cursor\\n            self.cursor.prev = next\\n            self.cursor.next = nextnext\\n            nextnext.prev = self.cursor\\n            i += 1\\n        return self._previousString(10)\\n    \\n    def text(self) -> str:\\n        return self._stringFrom(self.start.next, inf)\\n    \\n    def _stringFrom(self, start: Character, l: Optional[int]) -> str:\\n        current = start\\n        res = \"\"\\n        i = 0\\n        if l is None:\\n            l = inf\\n        while i < l and current != self.end:\\n            if current == self.cursor:\\n                current = current.next\\n            else:\\n                if current is not None:\\n                    if current.val is not None:\\n                        res += current.val\\n                    if current.next is not None:\\n                        current = current.next\\n                i += 1\\n        return res\\n    \\n    def _previousString(self, length) -> str:\\n        i = 0\\n        current = self.cursor\\n        while i < length and current != self.start:\\n            current = current.prev\\n            i += 1\\n        return self._stringFrom(current, i)\\n\\n\\n\\n\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Character:\\n    def __init__(self, prev, next, val):\\n        self.prev = prev\\n        self.next = next\\n        self.val = val\\n\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.start = Character(None, None, None)\\n        self.end = Character(None, None, None)\\n        self.cursor = Character(self.start, self.end, \"|\")\\n\\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            character = Character(self.cursor.prev, self.cursor, c)\\n            self.cursor.prev.next = character\\n            self.cursor.prev = character\\n\\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while (i < k) and self.cursor.prev != self.start:\\n            self.cursor.prev = self.cursor.prev.prev\\n            self.cursor.prev.next = self.cursor\\n            i += 1\\n        return i        \\n\\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while (i < k) and (self.cursor.prev != self.start):\\n            prevprev = self.cursor.prev.prev\\n            prev = self.cursor.prev\\n            next = self.cursor.next\\n            prevprev.next = self.cursor\\n            self.cursor.prev = prevprev\\n            self.cursor.next = prev\\n            prev.prev = self.cursor\\n            prev.next = next\\n            next.prev = prev\\n            i += 1\\n        return self._previousString(10)\\n        \\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while (i < k) and (self.cursor.next != self.end):\\n            prev = self.cursor.prev\\n            next = self.cursor.next\\n            nextnext = self.cursor.next.next\\n            prev.next = next\\n            next.prev = prev\\n            next.next = self.cursor\\n            self.cursor.prev = next\\n            self.cursor.next = nextnext\\n            nextnext.prev = self.cursor\\n            i += 1\\n        return self._previousString(10)\\n    \\n    def text(self) -> str:\\n        return self._stringFrom(self.start.next, inf)\\n    \\n    def _stringFrom(self, start: Character, l: Optional[int]) -> str:\\n        current = start\\n        res = \"\"\\n        i = 0\\n        if l is None:\\n            l = inf\\n        while i < l and current != self.end:\\n            if current == self.cursor:\\n                current = current.next\\n            else:\\n                if current is not None:\\n                    if current.val is not None:\\n                        res += current.val\\n                    if current.next is not None:\\n                        current = current.next\\n                i += 1\\n        return res\\n    \\n    def _previousString(self, length) -> str:\\n        i = 0\\n        current = self.cursor\\n        while i < length and current != self.start:\\n            current = current.prev\\n            i += 1\\n        return self._stringFrom(current, i)\\n\\n\\n\\n\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025654,
                "title": "cpp-doubly-linked-list-with-detailed-approach",
                "content": "# Intuition\\nThe task can be done by a data structure that could insert, delete, and traverse to its adjacent element(both directions) in constant time. The cursor itself determines the position of insertion and deletion, so it is not arbitrary but rather identical to earlier calls. \\nAppropriate DS. :\\n- *Doubly linked list*\\n- *Array *x* 2*\\n\\n---\\n\\n\\n# Approach\\nUsing doubly linked list to store text and traverse, the cursor position is stored in a pointer and is consequently referred to during updating, deleting, and traversing.\\n\\n- **Add** : *Insert node(s) from cursor onwards (cursor increments leftwards).*\\n- **Delete** : *Delete node(s) from cursor onwards (cursor increments rightwards).*\\n- **Move** : *Traverse \\'cursor\\' through nodes as intended.*\\n\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(k) \\\\ per \\\\ call$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n---\\n\\n\\n\\n# Code\\n```\\n//doubly linked list \\n\\nclass node{\\n    public:\\n    char ch;\\n    node * left=nullptr;\\n    node * right=nullptr;\\n};\\n\\nstatic string ans=\"\";\\n\\nclass TextEditor {\\n    public:   \\n \\n    node * cursor=nullptr;    //cursor\\'s position is btw pointer \\n    node * head=nullptr;      //\\'cursor\\' and \\'cursor->right\\'\\n    node * tail=nullptr;\\n    \\n\\n    TextEditor() {\\n\\n        head=new node;\\n        tail=new node;\\n        cursor=head;\\n\\n        head->right=tail;\\n        tail->left=head;     \\n   \\n    }\\n    \\n    void addText(string text) {\\n        for(char c:text){\\n\\n            node * temp = new node;\\n            temp -> ch = c;    \\n\\n            cursor -> right -> left = temp;  // inserting nodes in DLL\\n            temp -> right = cursor -> right ;\\n            cursor -> right = temp;\\n            temp -> left = cursor;\\n\\n            cursor = cursor -> right;\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int charDeleted=0;\\n        while(k--){\\n            if(cursor!=head){\\n\\n                cursor->left->right=cursor->right;\\n                cursor->right->left=cursor->left;\\n                                \\n                node * temp = cursor;      \\n                cursor = cursor->left;          \\n                delete temp; // deleting node from DLL \\n\\n                charDeleted++;                  // increment count\\n            }\\n        }\\n        return charDeleted;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        ans.clear();\\n        while(k--){                         // traverse left\\n            if(cursor!=head){\\n                cursor=cursor->left;\\n            }\\n        }\\n        node * temp = cursor;\\n        k=10;\\n        while(k--){     \\n            if(temp!=head){\\n                ans+=temp->ch;\\n                temp=temp->left;\\n            }\\n        }\\n        for(int i=0;i<ans.length()/2;i++)   // reversal of str\\n            swap(ans[i],ans[ans.length()-1-i]);\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n\\n        ans.clear();\\n\\n        while(k--){                         // traverse right\\n            if(cursor->right!=tail){                \\n                cursor=cursor->right;\\n            }\\n        }\\n\\n        node * temp = cursor ;\\n        k=10;\\n        while(k--){\\n            if(temp!=head){\\n                ans+=temp->ch;\\n                temp=temp->left;\\n            }\\n        }\\n\\n        for(int i=0;i<ans.length()/2;i++)    // reversal of str\\n            swap(ans[i],ans[ans.length()-1-i]);\\n        return ans;\\n    }\\n\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "String",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "```\\n//doubly linked list \\n\\nclass node{\\n    public:\\n    char ch;\\n    node * left=nullptr;\\n    node * right=nullptr;\\n};\\n\\nstatic string ans=\"\";\\n\\nclass TextEditor {\\n    public:   \\n \\n    node * cursor=nullptr;    //cursor\\'s position is btw pointer \\n    node * head=nullptr;      //\\'cursor\\' and \\'cursor->right\\'\\n    node * tail=nullptr;\\n    \\n\\n    TextEditor() {\\n\\n        head=new node;\\n        tail=new node;\\n        cursor=head;\\n\\n        head->right=tail;\\n        tail->left=head;     \\n   \\n    }\\n    \\n    void addText(string text) {\\n        for(char c:text){\\n\\n            node * temp = new node;\\n            temp -> ch = c;    \\n\\n            cursor -> right -> left = temp;  // inserting nodes in DLL\\n            temp -> right = cursor -> right ;\\n            cursor -> right = temp;\\n            temp -> left = cursor;\\n\\n            cursor = cursor -> right;\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int charDeleted=0;\\n        while(k--){\\n            if(cursor!=head){\\n\\n                cursor->left->right=cursor->right;\\n                cursor->right->left=cursor->left;\\n                                \\n                node * temp = cursor;      \\n                cursor = cursor->left;          \\n                delete temp; // deleting node from DLL \\n\\n                charDeleted++;                  // increment count\\n            }\\n        }\\n        return charDeleted;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        ans.clear();\\n        while(k--){                         // traverse left\\n            if(cursor!=head){\\n                cursor=cursor->left;\\n            }\\n        }\\n        node * temp = cursor;\\n        k=10;\\n        while(k--){     \\n            if(temp!=head){\\n                ans+=temp->ch;\\n                temp=temp->left;\\n            }\\n        }\\n        for(int i=0;i<ans.length()/2;i++)   // reversal of str\\n            swap(ans[i],ans[ans.length()-1-i]);\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n\\n        ans.clear();\\n\\n        while(k--){                         // traverse right\\n            if(cursor->right!=tail){                \\n                cursor=cursor->right;\\n            }\\n        }\\n\\n        node * temp = cursor ;\\n        k=10;\\n        while(k--){\\n            if(temp!=head){\\n                ans+=temp->ch;\\n                temp=temp->left;\\n            }\\n        }\\n\\n        for(int i=0;i<ans.length()/2;i++)    // reversal of str\\n            swap(ans[i],ans[ans.length()-1-i]);\\n        return ans;\\n    }\\n\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014287,
                "title": "easy-solution-using-dll",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question asks you to build a text editor with basic functions moving left, moving right, deleting text, adding text. So basic double linked list can be used for storing each character (To make the movements easier). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitiate cursor with a node with any value (other than lower case alphabets). \\n\\n**AddText**: Add a node to the right of the cursor and move it to the right.\\n\\n**deleteText**: Delete the current node and move to left (Only if it is not on the initial node). \\n\\n**cursorLeft**: Move the cursor to left k times or until there is no previous node. read  10 or remaining all characters to the left and return them. \\n\\n**cursorRight**: Move the cursor to right k times or until there is no next node. read 10 or remaining all characters to the left and return them. \\n\\n\\n# Complexity\\n- Time complexity: $$O(k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Node{\\n    public: \\n    Node *prev, *next; char val; \\n    Node(char s): val(s), prev(NULL), next(NULL) {}\\n}; \\n\\nclass TextEditor {\\npublic:\\n    Node *cursor; \\n    TextEditor() {\\n        cursor = new Node(\\'\\n```); \\n    }\\n\\n    int deleteNode(){\\n        if(!cursor) return 0; \\n        else if(cursor->val == \\'\\n```) return 0; \\n        else if(!cursor->next){\\n            cursor = cursor->prev; \\n            cursor->next = NULL; \\n        }\\n        else {\\n            Node *after, *before; \\n            after = cursor->next; before = cursor->prev; \\n            cursor = before; \\n            before->next = after; \\n            after->prev = before; \\n        }\\n        return 1; \\n    }\\n    \\n    void addText(string text) {\\n        for(auto s: text){\\n            Node *new_node = new Node(s); \\n            if(!cursor->next){\\n             cursor->next = new_node; \\n             new_node->prev = cursor; \\n             cursor = cursor->next;\\n            }\\n            else{\\n                Node *after = cursor->next; \\n                cursor->next = new_node; \\n                new_node->prev = cursor; \\n                new_node->next = after; \\n                after->prev = new_node; \\n                cursor = new_node; \\n            }\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int count = 0; \\n        for(int i = 0; i<k; i++) count += deleteNode(); \\n        return count; \\n    }\\n    \\n    string cursorLeft(int k) {\\n        for(int i = 0; i<k; i++) if(cursor->prev) cursor = cursor->prev; \\n        string ans = \"\"; Node *temp = cursor; \\n        while(ans.length() <10 && temp->val != \\'\\n```) {\\n            ans.push_back(temp->val); temp = temp->prev; \\n        }\\n        reverse(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n    \\n    string cursorRight(int k) {\\n         for(int i = 0; i<k; i++) if(cursor->next) cursor = cursor->next; \\n         string ans = \"\"; Node *temp = cursor; \\n        while(ans.length() <10 && temp->val != \\'\\n```) {\\n            ans.push_back(temp->val); temp = temp->prev; \\n        }\\n        reverse(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Design",
                    "Simulation",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass Node{\\n    public: \\n    Node *prev, *next; char val; \\n    Node(char s): val(s), prev(NULL), next(NULL) {}\\n}; \\n\\nclass TextEditor {\\npublic:\\n    Node *cursor; \\n    TextEditor() {\\n        cursor = new Node(\\'\\n```\n```) return 0; \\n        else if(!cursor->next){\\n            cursor = cursor->prev; \\n            cursor->next = NULL; \\n        }\\n        else {\\n            Node *after, *before; \\n            after = cursor->next; before = cursor->prev; \\n            cursor = before; \\n            before->next = after; \\n            after->prev = before; \\n        }\\n        return 1; \\n    }\\n    \\n    void addText(string text) {\\n        for(auto s: text){\\n            Node *new_node = new Node(s); \\n            if(!cursor->next){\\n             cursor->next = new_node; \\n             new_node->prev = cursor; \\n             cursor = cursor->next;\\n            }\\n            else{\\n                Node *after = cursor->next; \\n                cursor->next = new_node; \\n                new_node->prev = cursor; \\n                new_node->next = after; \\n                after->prev = new_node; \\n                cursor = new_node; \\n            }\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int count = 0; \\n        for(int i = 0; i<k; i++) count += deleteNode(); \\n        return count; \\n    }\\n    \\n    string cursorLeft(int k) {\\n        for(int i = 0; i<k; i++) if(cursor->prev) cursor = cursor->prev; \\n        string ans = \"\"; Node *temp = cursor; \\n        while(ans.length() <10 && temp->val != \\'\\n```\n```) {\\n            ans.push_back(temp->val); temp = temp->prev; \\n        }\\n        reverse(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010790,
                "title": "java-doubly-linked-list-simple-intuitive",
                "content": "\\n\\n# Code\\n```\\nclass TextEditor {\\n    private static class Node{\\n        Node left, right;\\n        char ch;\\n        Node(char ch){\\n            this.ch = ch;\\n            this.left = this.right = null;\\n        }\\n    }\\n    Node head, tail, current;\\n    public TextEditor() {\\n        head = tail =current = new Node(\\'\\\\0\\'); // initialization with null character.\\n    }\\n    \\n    public void addText(String text) {\\n        // create a linked list \\n        Node newHead = new Node(text.charAt(0));\\n        Node cn= newHead;\\n        for ( int i=1; i< text.length(); i++){\\n            Node newNode = new Node(text.charAt(i));\\n            newNode.left = cn;\\n            cn.right =newNode;\\n            cn = newNode;\\n        }\\n        // the new text will be added after the text or character to which cursor is pointing.\\n        Node nextNode = this.current.right;\\n        this.current.right= newHead;\\n        newHead.left = this.current;\\n        this.current = cn; // the last character of the added text.\\n        this.current.right = nextNode;\\n        if ( nextNode != null){\\n            nextNode.left = this.current;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        // delete characters from the current position of the cursor.\\n        Node nextNode = this.current.right;\\n        Node node = this.current;\\n        int n = k;\\n        while ( k > 0 && this.current.ch != \\'\\\\0\\'){\\n            this.current = this.current.left;\\n            k --;\\n        } \\n        this.current.right = nextNode;\\n        if ( nextNode != null){\\n            nextNode.left = this.current;\\n        }\\n        return (n-k);\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while ( k > 0 && this.current.ch != \\'\\\\0\\'){\\n            this.current = this.current.left;\\n            k--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        Node node = this.current;\\n        int count = 10; \\n        while ( count > 0 && node.ch != \\'\\\\0\\'){\\n            sb.insert(0, node.ch);\\n            node = node.left;\\n            count--;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while ( k > 0 && this.current.right != null){\\n            this.current =this.current.right;\\n            k--;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Node node = this.current;\\n        int count = 10; \\n        while ( count > 0 && node.ch != \\'\\\\0\\'){\\n            sb.insert(0, node.ch);\\n            node = node.left;\\n            count--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n    private static class Node{\\n        Node left, right;\\n        char ch;\\n        Node(char ch){\\n            this.ch = ch;\\n            this.left = this.right = null;\\n        }\\n    }\\n    Node head, tail, current;\\n    public TextEditor() {\\n        head = tail =current = new Node(\\'\\\\0\\'); // initialization with null character.\\n    }\\n    \\n    public void addText(String text) {\\n        // create a linked list \\n        Node newHead = new Node(text.charAt(0));\\n        Node cn= newHead;\\n        for ( int i=1; i< text.length(); i++){\\n            Node newNode = new Node(text.charAt(i));\\n            newNode.left = cn;\\n            cn.right =newNode;\\n            cn = newNode;\\n        }\\n        // the new text will be added after the text or character to which cursor is pointing.\\n        Node nextNode = this.current.right;\\n        this.current.right= newHead;\\n        newHead.left = this.current;\\n        this.current = cn; // the last character of the added text.\\n        this.current.right = nextNode;\\n        if ( nextNode != null){\\n            nextNode.left = this.current;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        // delete characters from the current position of the cursor.\\n        Node nextNode = this.current.right;\\n        Node node = this.current;\\n        int n = k;\\n        while ( k > 0 && this.current.ch != \\'\\\\0\\'){\\n            this.current = this.current.left;\\n            k --;\\n        } \\n        this.current.right = nextNode;\\n        if ( nextNode != null){\\n            nextNode.left = this.current;\\n        }\\n        return (n-k);\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while ( k > 0 && this.current.ch != \\'\\\\0\\'){\\n            this.current = this.current.left;\\n            k--;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        Node node = this.current;\\n        int count = 10; \\n        while ( count > 0 && node.ch != \\'\\\\0\\'){\\n            sb.insert(0, node.ch);\\n            node = node.left;\\n            count--;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while ( k > 0 && this.current.right != null){\\n            this.current =this.current.right;\\n            k--;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        Node node = this.current;\\n        int count = 10; \\n        while ( count > 0 && node.ch != \\'\\\\0\\'){\\n            sb.insert(0, node.ch);\\n            node = node.left;\\n            count--;\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970982,
                "title": "golang-doubly-linked-list",
                "content": "# Code\\n```\\ntype TextEditor struct {\\n    n *node\\n    maxChars int\\n}\\n\\n\\nfunc Constructor() TextEditor {    \\n    return TextEditor{&node{},10}\\n}\\n\\n\\nfunc (this *TextEditor) AddText(text string)  {\\n    \\n    for _,c:=range text{\\n        n:=&node{char:c}                \\n        next:=this.n.next\\n        if next!=nil{\\n            next.prev=n\\n        }        \\n        n.prev=this.n\\n        n.next=next        \\n        this.n.next=n\\n        this.n=n\\n    }    \\n}\\n\\n\\nfunc (this *TextEditor) DeleteText(k int) int {\\n    \\n    count:=0\\n    for this.n.char!=0&&k>0{        \\n        this.n.prev.next=this.n.next\\n        if this.n.next!=nil{\\n            this.n.next.prev=this.n.prev\\n        }\\n        this.n=this.n.prev\\n        count++\\n        k--\\n    }\\n\\n    return count\\n}\\n\\n\\nfunc (this *TextEditor) CursorLeft(k int) string {\\n  \\n    for this.n.char!=0&&k>0{\\n        this.n=this.n.prev\\n        k--\\n    }\\n\\n    return this.seek()\\n}\\n\\n\\nfunc (this *TextEditor) CursorRight(k int) string {\\n    \\n    for this.n.next!=nil&&k>0{\\n        this.n=this.n.next\\n        k--\\n    }\\n\\n    return this.seek()\\n}\\n\\nfunc (this *TextEditor) seek() string {\\n    \\n    curr:=this.n\\n    res:=[]rune{}\\n    max:=this.maxChars\\n    for curr.char!=0&&max>0{          \\n        res=append([]rune{curr.char},res...)        \\n        curr=curr.prev\\n        max--\\n    }\\n\\n    return string(res)\\n}\\n\\n\\ntype node struct {\\n    char rune\\n    prev *node\\n    next *node\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.AddText(text);\\n * param_2 := obj.DeleteText(k);\\n * param_3 := obj.CursorLeft(k);\\n * param_4 := obj.CursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype TextEditor struct {\\n    n *node\\n    maxChars int\\n}\\n\\n\\nfunc Constructor() TextEditor {    \\n    return TextEditor{&node{},10}\\n}\\n\\n\\nfunc (this *TextEditor) AddText(text string)  {\\n    \\n    for _,c:=range text{\\n        n:=&node{char:c}                \\n        next:=this.n.next\\n        if next!=nil{\\n            next.prev=n\\n        }        \\n        n.prev=this.n\\n        n.next=next        \\n        this.n.next=n\\n        this.n=n\\n    }    \\n}\\n\\n\\nfunc (this *TextEditor) DeleteText(k int) int {\\n    \\n    count:=0\\n    for this.n.char!=0&&k>0{        \\n        this.n.prev.next=this.n.next\\n        if this.n.next!=nil{\\n            this.n.next.prev=this.n.prev\\n        }\\n        this.n=this.n.prev\\n        count++\\n        k--\\n    }\\n\\n    return count\\n}\\n\\n\\nfunc (this *TextEditor) CursorLeft(k int) string {\\n  \\n    for this.n.char!=0&&k>0{\\n        this.n=this.n.prev\\n        k--\\n    }\\n\\n    return this.seek()\\n}\\n\\n\\nfunc (this *TextEditor) CursorRight(k int) string {\\n    \\n    for this.n.next!=nil&&k>0{\\n        this.n=this.n.next\\n        k--\\n    }\\n\\n    return this.seek()\\n}\\n\\nfunc (this *TextEditor) seek() string {\\n    \\n    curr:=this.n\\n    res:=[]rune{}\\n    max:=this.maxChars\\n    for curr.char!=0&&max>0{          \\n        res=append([]rune{curr.char},res...)        \\n        curr=curr.prev\\n        max--\\n    }\\n\\n    return string(res)\\n}\\n\\n\\ntype node struct {\\n    char rune\\n    prev *node\\n    next *node\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.AddText(text);\\n * param_2 := obj.DeleteText(k);\\n * param_3 := obj.CursorLeft(k);\\n * param_4 := obj.CursorRight(k);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903437,
                "title": "java-2-stacks",
                "content": "# Code\\n```\\nclass TextEditor {\\n\\n    Stack<Character> left;\\n    Stack<Character> right;\\n    public TextEditor() {\\n        left = new Stack<>();\\n        right = new Stack<>();\\n    }\\n    \\n    public void addText(String text) {\\n        for (char c : text.toCharArray()) {\\n            left.push(c);\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int count = 0;\\n        while (count < k && !left.isEmpty()) {\\n            left.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        int count = 0; \\n        while(count < k && !left.isEmpty()) {\\n            right.push(left.pop());\\n            count++;\\n        }\\n        count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(count < 10 && !left.isEmpty()) {\\n            char c = left.pop();\\n            right.push(c);\\n            sb.append(c);\\n            count++;\\n        }\\n        while(count > 0) {\\n            left.push(right.pop());\\n            count--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        int count = 0; \\n        while(count < k && !right.isEmpty()) {\\n            left.push(right.pop());\\n            count++;\\n        }\\n        count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(count < 10 && !left.isEmpty()) {\\n            char c = left.pop();\\n            right.push(c);\\n            sb.append(c);\\n            count++;\\n        }\\n        while(count > 0) {\\n            left.push(right.pop());\\n            count--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    Stack<Character> left;\\n    Stack<Character> right;\\n    public TextEditor() {\\n        left = new Stack<>();\\n        right = new Stack<>();\\n    }\\n    \\n    public void addText(String text) {\\n        for (char c : text.toCharArray()) {\\n            left.push(c);\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int count = 0;\\n        while (count < k && !left.isEmpty()) {\\n            left.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        int count = 0; \\n        while(count < k && !left.isEmpty()) {\\n            right.push(left.pop());\\n            count++;\\n        }\\n        count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(count < 10 && !left.isEmpty()) {\\n            char c = left.pop();\\n            right.push(c);\\n            sb.append(c);\\n            count++;\\n        }\\n        while(count > 0) {\\n            left.push(right.pop());\\n            count--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        int count = 0; \\n        while(count < k && !right.isEmpty()) {\\n            left.push(right.pop());\\n            count++;\\n        }\\n        count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(count < 10 && !left.isEmpty()) {\\n            char c = left.pop();\\n            right.push(c);\\n            sb.append(c);\\n            count++;\\n        }\\n        while(count > 0) {\\n            left.push(right.pop());\\n            count--;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841891,
                "title": "beats-100-00-of-users-easy-2-stack-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncursor will be in center of two texts and some insertion and deletion will be made so think which data structure will do easily insertion and deletion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep two stack a and b to perform insertion and deletion easily \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$ per query \\n# Code\\n```\\nclass TextEditor {\\npublic:\\n    stack<char>a,b;\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        for(char i: text) a.push(i);\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt=0;\\n        while(k-- and !a.empty()){\\n            a.pop();\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    string fun(){\\n        string ans;\\n        int cnt=10;\\n        while(cnt-- and !a.empty()){\\n            ans+=a.top();\\n            a.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        for(char i:ans) a.push(i);\\n        return ans;\\n    }\\n\\n    string cursorLeft(int k) {\\n        while(k-- and !a.empty()){\\n            b.push(a.top());\\n            a.pop();\\n        }\\n        return fun();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k-- and !b.empty()){\\n            a.push(b.top());\\n            b.pop();\\n        }\\n        return fun();\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    stack<char>a,b;\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        for(char i: text) a.push(i);\\n    }\\n    \\n    int deleteText(int k) {\\n        int cnt=0;\\n        while(k-- and !a.empty()){\\n            a.pop();\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    string fun(){\\n        string ans;\\n        int cnt=10;\\n        while(cnt-- and !a.empty()){\\n            ans+=a.top();\\n            a.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        for(char i:ans) a.push(i);\\n        return ans;\\n    }\\n\\n    string cursorLeft(int k) {\\n        while(k-- and !a.empty()){\\n            b.push(a.top());\\n            a.pop();\\n        }\\n        return fun();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(k-- and !b.empty()){\\n            a.push(b.top());\\n            b.pop();\\n        }\\n        return fun();\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835949,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass TextEditor {\\n    StringBuilder sb;\\n    int index=0;\\n    public TextEditor() {\\n        sb=new StringBuilder(\"\");\\n    }\\n    \\n    public void addText(String text) {\\n        if(sb.length()==0)\\n        {\\n            sb.append(text);\\n            index=sb.length();\\n        }\\n        else\\n        {\\n            sb.insert(index,text);\\n            index=index+text.length();\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        if(index-k>=0)\\n        {\\n            sb.delete(index-k,index);\\n            index=index-k;\\n            return k;\\n        }\\n        else\\n        {\\n            sb.delete(0,index);\\n            int p=index;\\n            index=0;\\n            return p;\\n        }\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        index=index-k;\\n        if(index<0)\\n        {\\n            index=0;\\n            return \"\";\\n        }\\n        else\\n        {\\n           if(index>=10)\\n           {\\n               return sb.substring(index-10,index);\\n           }\\n           else\\n           {\\n               return sb.substring(0,index);\\n           }\\n        }\\n    }\\n    \\n    public String cursorRight(int k) {\\n        if(index+k>sb.length())\\n        {\\n             index=sb.length();\\n        }\\n        else\\n        {\\n            index=index+k;\\n        }\\n        if(index>=10)\\n           {\\n               return sb.substring(index-10,index);\\n           }\\n           else\\n           {\\n               return sb.substring(0,index);\\n           }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n    StringBuilder sb;\\n    int index=0;\\n    public TextEditor() {\\n        sb=new StringBuilder(\"\");\\n    }\\n    \\n    public void addText(String text) {\\n        if(sb.length()==0)\\n        {\\n            sb.append(text);\\n            index=sb.length();\\n        }\\n        else\\n        {\\n            sb.insert(index,text);\\n            index=index+text.length();\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        if(index-k>=0)\\n        {\\n            sb.delete(index-k,index);\\n            index=index-k;\\n            return k;\\n        }\\n        else\\n        {\\n            sb.delete(0,index);\\n            int p=index;\\n            index=0;\\n            return p;\\n        }\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        index=index-k;\\n        if(index<0)\\n        {\\n            index=0;\\n            return \"\";\\n        }\\n        else\\n        {\\n           if(index>=10)\\n           {\\n               return sb.substring(index-10,index);\\n           }\\n           else\\n           {\\n               return sb.substring(0,index);\\n           }\\n        }\\n    }\\n    \\n    public String cursorRight(int k) {\\n        if(index+k>sb.length())\\n        {\\n             index=sb.length();\\n        }\\n        else\\n        {\\n            index=index+k;\\n        }\\n        if(index>=10)\\n           {\\n               return sb.substring(index-10,index);\\n           }\\n           else\\n           {\\n               return sb.substring(0,index);\\n           }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769141,
                "title": "2296-design-a-text-editor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe TextEditor class aims to simulate a text editor with cursor functionality. The addText, deleteText, cursorLeft, and cursorRight methods are implemented to modify the text and cursor position based on the given operations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the TextEditor class with an empty text and cursor position at the start (0).\\n2. In the addText method, insert the given text at the current cursor position, update the text, and move the cursor to the end of the inserted text.\\n3. In the deleteText method, delete k characters to the left of the cursor by removing the corresponding substring from the text. Update the text and move the cursor accordingly.\\n4. In the cursorLeft method, move the cursor k times to the left and return the substring of the text that is the last min(10, len) characters to the left of the cursor.\\n5. In the cursorRight method, move the cursor k times to the right and return the substring of the text that is the last min(10, len) characters to the left of the cursor.\\n6. The time and space complexity of each operation depends on the length of the text and the number of characters to be added or deleted.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. The addText operation takes O(n) time, where n is the length of the given text to be added.\\n2. The deleteText operation takes O(k) time, where k is the number of characters to be deleted.\\n3. The cursorLeft and cursorRight operations take O(k) time, where k is the number of times the cursor needs to be moved.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), where n is the total length of the text stored in the TextEditor object.\\n\\nPlease comment if you have any better approach.\\n# Code\\n```\\nclass TextEditor:\\n    def __init__(self):\\n        self.text = \"\"\\n        self.cursor = 0\\n    \\n    def addText(self, text: str) -> None:\\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\\n        self.cursor += len(text)\\n    \\n    def deleteText(self, k: int) -> int:\\n        k = min(k, self.cursor)\\n        deleted_text = self.text[self.cursor - k: self.cursor]\\n        self.text = self.text[:self.cursor - k] + self.text[self.cursor:]\\n        self.cursor -= k\\n        return len(deleted_text)\\n    \\n    def cursorLeft(self, k: int) -> str:\\n        k = min(k, self.cursor)\\n        self.cursor -= k\\n        return self.text[self.cursor - min(10, self.cursor):self.cursor]\\n    \\n    def cursorRight(self, k: int) -> str:\\n        k = min(k, len(self.text) - self.cursor)\\n        self.cursor += k\\n        return self.text[self.cursor - min(10, self.cursor):self.cursor]\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n    def __init__(self):\\n        self.text = \"\"\\n        self.cursor = 0\\n    \\n    def addText(self, text: str) -> None:\\n        self.text = self.text[:self.cursor] + text + self.text[self.cursor:]\\n        self.cursor += len(text)\\n    \\n    def deleteText(self, k: int) -> int:\\n        k = min(k, self.cursor)\\n        deleted_text = self.text[self.cursor - k: self.cursor]\\n        self.text = self.text[:self.cursor - k] + self.text[self.cursor:]\\n        self.cursor -= k\\n        return len(deleted_text)\\n    \\n    def cursorLeft(self, k: int) -> str:\\n        k = min(k, self.cursor)\\n        self.cursor -= k\\n        return self.text[self.cursor - min(10, self.cursor):self.cursor]\\n    \\n    def cursorRight(self, k: int) -> str:\\n        k = min(k, len(self.text) - self.cursor)\\n        self.cursor += k\\n        return self.text[self.cursor - min(10, self.cursor):self.cursor]\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742873,
                "title": "c-less-than-4-lines-per-method-beats-90-on-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor {\\npublic:\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        _text.insert(_text.begin() + _cursor_index, text.begin(), text.end());\\n        _cursor_index += text.size();\\n    }\\n    \\n    int deleteText(int k) {\\n        auto old_cursor_index = _cursor_index;\\n        _cursor_index = max(_cursor_index - k, 0);\\n        auto deletion_length = min(old_cursor_index, min(k, (int)_text.length()));\\n        _text.erase(_cursor_index, deletion_length);\\n        return deletion_length;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        _cursor_index = max(_cursor_index - k, 0);\\n        auto character_to_return = min(_cursor_index, 10);\\n        auto start = max(0, _cursor_index - character_to_return);\\n        return _text.substr(start, character_to_return);\\n    }\\n    \\n    string cursorRight(int k) {\\n        _cursor_index = min(_cursor_index + k, (int)_text.size());\\n        auto character_to_return = min(_cursor_index, 10);\\n        auto start = max(0, _cursor_index - character_to_return);\\n        return _text.substr(start, character_to_return);\\n    }\\n\\n    int _cursor_index{};\\n    string _text{};\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    TextEditor() {\\n    }\\n    \\n    void addText(string text) {\\n        _text.insert(_text.begin() + _cursor_index, text.begin(), text.end());\\n        _cursor_index += text.size();\\n    }\\n    \\n    int deleteText(int k) {\\n        auto old_cursor_index = _cursor_index;\\n        _cursor_index = max(_cursor_index - k, 0);\\n        auto deletion_length = min(old_cursor_index, min(k, (int)_text.length()));\\n        _text.erase(_cursor_index, deletion_length);\\n        return deletion_length;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        _cursor_index = max(_cursor_index - k, 0);\\n        auto character_to_return = min(_cursor_index, 10);\\n        auto start = max(0, _cursor_index - character_to_return);\\n        return _text.substr(start, character_to_return);\\n    }\\n    \\n    string cursorRight(int k) {\\n        _cursor_index = min(_cursor_index + k, (int)_text.size());\\n        auto character_to_return = min(_cursor_index, 10);\\n        auto start = max(0, _cursor_index - character_to_return);\\n        return _text.substr(start, character_to_return);\\n    }\\n\\n    int _cursor_index{};\\n    string _text{};\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725591,
                "title": "using-two-strings-c",
                "content": "# Code\\n```\\nclass TextEditor {\\nprivate:\\n    string left;\\n    string right;\\npublic:\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        for(char letter : text) {\\n            left += letter;\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int count = 0;\\n        while(!left.empty() && k-- > 0) {\\n            left.pop_back();\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(!left.empty() && k-- > 0) {\\n            right += left.back();\\n            left.pop_back();\\n        }\\n        return lastChars();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(right.size() > 0 && k > 0) {\\n            left += right.back();\\n            right.pop_back();\\n            k--;\\n        }\\n        return lastChars();\\n    }\\n\\n    string lastChars() {\\n        if(left.size() < 10) {\\n            return left;\\n        } else {\\n            return left.substr(left.size() - 10, 10);\\n        }\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TextEditor {\\nprivate:\\n    string left;\\n    string right;\\npublic:\\n    TextEditor() {\\n        \\n    }\\n    \\n    void addText(string text) {\\n        for(char letter : text) {\\n            left += letter;\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int count = 0;\\n        while(!left.empty() && k-- > 0) {\\n            left.pop_back();\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        while(!left.empty() && k-- > 0) {\\n            right += left.back();\\n            left.pop_back();\\n        }\\n        return lastChars();\\n    }\\n    \\n    string cursorRight(int k) {\\n        while(right.size() > 0 && k > 0) {\\n            left += right.back();\\n            right.pop_back();\\n            k--;\\n        }\\n        return lastChars();\\n    }\\n\\n    string lastChars() {\\n        if(left.size() < 10) {\\n            return left;\\n        } else {\\n            return left.substr(left.size() - 10, 10);\\n        }\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716802,
                "title": "clean-java-code-doubly-linked-list-o-k",
                "content": "# Intuition\\nConsider each letter as single entity and we have cursor that can go right and left through each letters. From this, we sure that using doubly linked list we can solve this problem.\\n\\n# Approach\\nUsing structure of doubly linked list we can handle cursor\\'s position.\\n \\n# Complexity\\n- Time complexity:\\nO(K)\\n\\n- Space complexity:\\nO(L) -> length of input characters\\n\\n# Code\\n```\\nclass TextEditor {\\n\\n    private Keyboard keyboard;\\n    public TextEditor() {\\n        keyboard = new Keyboard();\\n    }\\n    \\n    public void addText(String text) {\\n        for(char ch : text.toCharArray()){\\n            keyboard.type(ch);\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int deleted = 0;\\n        for(int i = 0; i < k; i++){\\n            if(keyboard.backspace()){\\n                deleted++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return deleted;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        for(int i = 0; i < k; i++){\\n            if(!keyboard.back()){\\n                break;\\n            }\\n        }\\n\\n        return keyboard.last10();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        for(int i = 0; i < k; i++){\\n            if(!keyboard.next()){\\n                break;\\n            }\\n        }\\n\\n        return keyboard.last10();\\n    }\\n}\\n\\nclass Node{\\n    char ch;\\n    Node next;\\n    Node prev;\\n\\n    Node(char ch){\\n        this.ch = ch;\\n        this.next = next;\\n        this.prev = prev;\\n    }\\n}\\n\\nclass Keyboard{\\n\\n    private Node head,tail,cursor;\\n    \\n    Keyboard(){\\n        head = new Node(\\'#\\');\\n        tail = new Node(\\'#\\');\\n\\n        head.next = tail;\\n        tail.prev = head;\\n\\n        cursor = head;\\n    }\\n\\n    public void type(char ch){\\n        Node node = new Node(ch);\\n        node.next = cursor.next;\\n        cursor.next.prev = node;\\n        cursor.next = node;\\n        node.prev = cursor;\\n        cursor = cursor.next;\\n    }\\n\\n    public boolean backspace(){\\n        if(cursor != head){\\n            Node cursorNext = cursor.next;\\n            cursor = cursor.prev;\\n            cursor.next = cursorNext;\\n            cursorNext.prev = cursor;\\n            \\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean back(){\\n        if(cursor != head){\\n            cursor = cursor.prev;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean next(){\\n        if(cursor.next != tail){\\n            cursor = cursor.next;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public String last10(){\\n        StringBuilder sb = new StringBuilder();\\n        Node dummyCursor = cursor;\\n        int k = 0;\\n        while(dummyCursor != head && k++ < 10){\\n            char ch = dummyCursor.ch;\\n            sb.append(ch);\\n            dummyCursor = dummyCursor.prev;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Design",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    private Keyboard keyboard;\\n    public TextEditor() {\\n        keyboard = new Keyboard();\\n    }\\n    \\n    public void addText(String text) {\\n        for(char ch : text.toCharArray()){\\n            keyboard.type(ch);\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int deleted = 0;\\n        for(int i = 0; i < k; i++){\\n            if(keyboard.backspace()){\\n                deleted++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return deleted;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        for(int i = 0; i < k; i++){\\n            if(!keyboard.back()){\\n                break;\\n            }\\n        }\\n\\n        return keyboard.last10();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        for(int i = 0; i < k; i++){\\n            if(!keyboard.next()){\\n                break;\\n            }\\n        }\\n\\n        return keyboard.last10();\\n    }\\n}\\n\\nclass Node{\\n    char ch;\\n    Node next;\\n    Node prev;\\n\\n    Node(char ch){\\n        this.ch = ch;\\n        this.next = next;\\n        this.prev = prev;\\n    }\\n}\\n\\nclass Keyboard{\\n\\n    private Node head,tail,cursor;\\n    \\n    Keyboard(){\\n        head = new Node(\\'#\\');\\n        tail = new Node(\\'#\\');\\n\\n        head.next = tail;\\n        tail.prev = head;\\n\\n        cursor = head;\\n    }\\n\\n    public void type(char ch){\\n        Node node = new Node(ch);\\n        node.next = cursor.next;\\n        cursor.next.prev = node;\\n        cursor.next = node;\\n        node.prev = cursor;\\n        cursor = cursor.next;\\n    }\\n\\n    public boolean backspace(){\\n        if(cursor != head){\\n            Node cursorNext = cursor.next;\\n            cursor = cursor.prev;\\n            cursor.next = cursorNext;\\n            cursorNext.prev = cursor;\\n            \\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean back(){\\n        if(cursor != head){\\n            cursor = cursor.prev;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public boolean next(){\\n        if(cursor.next != tail){\\n            cursor = cursor.next;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public String last10(){\\n        StringBuilder sb = new StringBuilder();\\n        Node dummyCursor = cursor;\\n        int k = 0;\\n        while(dummyCursor != head && k++ < 10){\\n            char ch = dummyCursor.ch;\\n            sb.append(ch);\\n            dummyCursor = dummyCursor.prev;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690150,
                "title": "giving-tle-even-after-passing-all-test-cases-please-help",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nMy code is giving TLE even after passing all the test cases\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// /**\\n//  * Your TextEditor object will be instantiated and called as such:\\n//  * TextEditor* obj = new TextEditor();\\n//  * obj->addText(text);\\n//  * int param_2 = obj->deleteText(k);\\n//  * string param_3 = obj->cursorLeft(k);\\n//  * string param_4 = obj->cursorRight(k);\\n//  */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass TextEditor {\\n    string a;\\n    int curr;\\n\\npublic:\\n    TextEditor() {\\n        a = \"\";\\n        curr = 0;\\n    }\\n\\n    void addText(const string& text) {\\n        if (curr == a.size()) {\\n            a += text;\\n            curr = a.size();\\n        } else {\\n            a.insert(curr, text);\\n            curr += text.size();\\n        }\\n    }\\n\\n    int deleteText(int k) {\\n        int deletedCount = 0;\\n        if (curr <= k) {\\n            deletedCount = curr;\\n            a.erase(0, curr);\\n            curr = 0;\\n        } else {\\n            deletedCount = k;\\n            a.erase(curr - k, k);\\n            curr -= k;\\n        }\\n        return deletedCount;\\n    }\\n\\n    string cursorLeft(int k) {\\n        string ans;\\n        if (curr <= k) {\\n            curr = 0;\\n            ans = a.substr(0, curr);\\n        } else {\\n            curr -= k;\\n            if (curr >= 10) {\\n                ans = a.substr(curr - 10, 10);\\n            } else {\\n                ans = a.substr(0, curr);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    string cursorRight(int k) {\\n        string ans;\\n        if (a.size() - curr >= k) {\\n            curr += k;\\n            if (curr >= 10) {\\n                ans = a.substr(curr - 10, 10);\\n            } else {\\n                ans = a.substr(0, curr);\\n            }\\n        } else {\\n            curr = a.size();\\n            if (curr > 10) {\\n                ans = a.substr(curr - 10, 10);\\n            } else {\\n                ans = a;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n// /**\\n//  * Your TextEditor object will be instantiated and called as such:\\n//  * TextEditor* obj = new TextEditor();\\n//  * obj->addText(text);\\n//  * int param_2 = obj->deleteText(k);\\n//  * string param_3 = obj->cursorLeft(k);\\n//  * string param_4 = obj->cursorRight(k);\\n//  */\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass TextEditor {\\n    string a;\\n    int curr;\\n\\npublic:\\n    TextEditor() {\\n        a = \"\";\\n        curr = 0;\\n    }\\n\\n    void addText(const string& text) {\\n        if (curr == a.size()) {\\n            a += text;\\n            curr = a.size();\\n        } else {\\n            a.insert(curr, text);\\n            curr += text.size();\\n        }\\n    }\\n\\n    int deleteText(int k) {\\n        int deletedCount = 0;\\n        if (curr <= k) {\\n            deletedCount = curr;\\n            a.erase(0, curr);\\n            curr = 0;\\n        } else {\\n            deletedCount = k;\\n            a.erase(curr - k, k);\\n            curr -= k;\\n        }\\n        return deletedCount;\\n    }\\n\\n    string cursorLeft(int k) {\\n        string ans;\\n        if (curr <= k) {\\n            curr = 0;\\n            ans = a.substr(0, curr);\\n        } else {\\n            curr -= k;\\n            if (curr >= 10) {\\n                ans = a.substr(curr - 10, 10);\\n            } else {\\n                ans = a.substr(0, curr);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    string cursorRight(int k) {\\n        string ans;\\n        if (a.size() - curr >= k) {\\n            curr += k;\\n            if (curr >= 10) {\\n                ans = a.substr(curr - 10, 10);\\n            } else {\\n                ans = a.substr(0, curr);\\n            }\\n        } else {\\n            curr = a.size();\\n            if (curr > 10) {\\n                ans = a.substr(curr - 10, 10);\\n            } else {\\n                ans = a;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683920,
                "title": "easy-java-solution-9-ms-100-working",
                "content": "# Steps to Solving This Problem\\n\\nAs reading the problem, my initial thoughts on solving it are as follows:\\n\\n1. Since we need to perform various operations on a text editor, we need a data structure to store the text. Using a StringBuilder would be a suitable choice as it provides efficient string manipulation operations.\\n\\n2. We also need to keep track of the cursor position, which indicates the index of the character to the right of the cursor. We can use an integer variable to store the cursor position.\\n\\n3. For the `addText` operation, we can simply insert the given text at the current cursor position in the StringBuilder and update the cursor accordingly.\\n\\n4. For the `deleteText` operation, we need to delete a specific number of characters to the left of the cursor. We can calculate the number of characters to delete by taking the minimum of the given number `k` and the current cursor position. We can then use the `delete` method of StringBuilder to remove the characters from the text and update the cursor accordingly.\\n\\n5. For the `cursorLeft` operation, we need to move the cursor to the left a certain number of times. Again, we can calculate the number of characters to move by taking the minimum of the given number `k` and the current cursor position. We can update the cursor position accordingly and return the substring of the text representing the last minimum of 10 characters to the left of the cursor.\\n\\n6. For the `cursorRight` operation, we need to move the cursor to the right a certain number of times. We can calculate the number of characters to move by taking the minimum of the given number `k` and the remaining characters to the right of the cursor. We can update the cursor position accordingly and return the substring of the text representing the last minimum of 10 characters to the left of the cursor.\\n\\n# Code\\n```\\nclass TextEditor {\\n    private StringBuilder text;\\n    private int cursor;\\n\\n    public TextEditor() {\\n        text = new StringBuilder();\\n        cursor = 0;\\n    }\\n\\n    public void addText(String textToAdd) {\\n        text.insert(cursor, textToAdd);\\n        cursor += textToAdd.length();\\n    }\\n\\n    public int deleteText(int k) {\\n        int charsToDelete = Math.min(k, cursor);\\n        text.delete(cursor - charsToDelete, cursor);\\n        cursor -= charsToDelete;\\n        return charsToDelete;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        int charsToMove = Math.min(k, cursor);\\n        cursor -= charsToMove;\\n        return text.substring(cursor - Math.min(10, cursor), cursor);\\n    }\\n\\n    public String cursorRight(int k) {\\n        int charsToMove = Math.min(k, text.length() - cursor);\\n        cursor += charsToMove;\\n        return text.substring(cursor - Math.min(10, cursor), cursor);\\n    }\\n}\\n```\\n\\n# Complexity\\n\\n``addText``\\n\\n* Time Complexity: O(n), where n is the length of the textToAdd. Since we are using a StringBuilder, inserting text at the cursor position will take O(n) time complexity, where n is the length of the textToAdd.\\n\\n* Space Complexity: O(1). The space used by the StringBuilder and cursor variable is constant and does not depend on the size of the input.\\n\\n``deleteText``\\n\\n* Time Complexity: O(k), where k is the number of characters to delete. Since we are using the delete method of StringBuilder, deleting characters will take O(k) time complexity.\\n\\n* Space Complexity: O(1). The space used by the StringBuilder and cursor variable is constant and does not depend on the size of the input.\\n\\n``cursorLeft``\\n\\n* Time Complexity: O(k), where k is the number of times the cursor needs to move to the left. Taking the substring and updating the cursor position both take O(k) time complexity.\\n\\n* Space Complexity: O(k). The substring returned will have a length of at most k characters.\\n\\n``cursorRight``\\n\\n* Time Complexity: O(k), where k is the number of times the cursor needs to move to the right. Taking the substring and updating the cursor position both take O(k) time complexity.\\n\\n* Space Complexity: O(k). The substring returned will have a length of at most k characters.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "String",
                    "Stack",
                    "Design"
                ],
                "code": "```\\nclass TextEditor {\\n    private StringBuilder text;\\n    private int cursor;\\n\\n    public TextEditor() {\\n        text = new StringBuilder();\\n        cursor = 0;\\n    }\\n\\n    public void addText(String textToAdd) {\\n        text.insert(cursor, textToAdd);\\n        cursor += textToAdd.length();\\n    }\\n\\n    public int deleteText(int k) {\\n        int charsToDelete = Math.min(k, cursor);\\n        text.delete(cursor - charsToDelete, cursor);\\n        cursor -= charsToDelete;\\n        return charsToDelete;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        int charsToMove = Math.min(k, cursor);\\n        cursor -= charsToMove;\\n        return text.substring(cursor - Math.min(10, cursor), cursor);\\n    }\\n\\n    public String cursorRight(int k) {\\n        int charsToMove = Math.min(k, text.length() - cursor);\\n        cursor += charsToMove;\\n        return text.substring(cursor - Math.min(10, cursor), cursor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682386,
                "title": "beats-100-runtime",
                "content": "# Intuition & Approach\\nActually did not start with this approach at all, I went the easiest route of slicing (and dicing lol), but that made everything so much slower that while the solution technically worked, it timed out.\\n\\nSo, I had to reduce the loops by a lot, and it got me thinking. How could I do that? By increasing array checks, which is just O(n) as opposed to constantly running for loops to create and concat arrays.\\n\\nThe solution? Maintain two arrays! everything before the text blinker (forgot what its called) is in one, and everything after is in the second. To make it easier, I ended up saving the second part in reverse order, so I could just push() and pop() like normal. This allowed me to reduce it down to only for loops: one in each of cursor left and cursor right.\\n\\n# Code\\n```\\nvar TextEditor = function() {\\n    this.front = [];\\n    this.back = [];\\n};\\n\\n/** \\n * @param {string} text\\n * @return {void}\\n */\\nTextEditor.prototype.addText = function(text) {\\n    for (letter of text) {\\n        this.front.push(letter);\\n    }\\n};\\n\\n/** \\n * @param {number} k\\n * @return {number}\\n */\\nTextEditor.prototype.deleteText = function(k) {\\n    let deleted = 0;\\n    for (let i=0;i<k;i++) {\\n        if (this.front.length === 0) {\\n            return deleted;\\n        }\\n        this.front.pop();\\n        deleted++;\\n    }\\n    return deleted;\\n};\\n\\n/** \\n * @param {number} k\\n * @return {string}\\n */\\nTextEditor.prototype.cursorLeft = function(k) {\\n    let iterator = k;\\n    if (this.front.length === 0) {\\n        return getLeft(this.front);\\n    }\\n    if (this.front.length < k) {\\n        iterator = this.front.length\\n    }\\n    for (let i=0;i<iterator;i++) {\\n        this.back.push(this.front.pop());\\n    }\\n    //write return here\\n    return getLeft(this.front);\\n};\\n\\n/** \\n * @param {number} k\\n * @return {string}\\n */\\nTextEditor.prototype.cursorRight = function(k) {\\n    let iterator = k;\\n    if (this.back.length === 0) {\\n        return getLeft(this.front);\\n    }\\n    if (this.back.length < k) {\\n        iterator = this.back.length\\n    }\\n    for (let i=0;i<iterator;i++) {\\n        this.front.push(this.back.pop());\\n    }\\n    // write return\\n    return getLeft(this.front);\\n};\\n\\nfunction getLeft(array) {\\n    if (array.length <= 10) {\\n        return array.join(\"\");\\n    }\\n    return array.slice(array.length-10,array.length).join(\"\");\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TextEditor = function() {\\n    this.front = [];\\n    this.back = [];\\n};\\n\\n/** \\n * @param {string} text\\n * @return {void}\\n */\\nTextEditor.prototype.addText = function(text) {\\n    for (letter of text) {\\n        this.front.push(letter);\\n    }\\n};\\n\\n/** \\n * @param {number} k\\n * @return {number}\\n */\\nTextEditor.prototype.deleteText = function(k) {\\n    let deleted = 0;\\n    for (let i=0;i<k;i++) {\\n        if (this.front.length === 0) {\\n            return deleted;\\n        }\\n        this.front.pop();\\n        deleted++;\\n    }\\n    return deleted;\\n};\\n\\n/** \\n * @param {number} k\\n * @return {string}\\n */\\nTextEditor.prototype.cursorLeft = function(k) {\\n    let iterator = k;\\n    if (this.front.length === 0) {\\n        return getLeft(this.front);\\n    }\\n    if (this.front.length < k) {\\n        iterator = this.front.length\\n    }\\n    for (let i=0;i<iterator;i++) {\\n        this.back.push(this.front.pop());\\n    }\\n    //write return here\\n    return getLeft(this.front);\\n};\\n\\n/** \\n * @param {number} k\\n * @return {string}\\n */\\nTextEditor.prototype.cursorRight = function(k) {\\n    let iterator = k;\\n    if (this.back.length === 0) {\\n        return getLeft(this.front);\\n    }\\n    if (this.back.length < k) {\\n        iterator = this.back.length\\n    }\\n    for (let i=0;i<iterator;i++) {\\n        this.front.push(this.back.pop());\\n    }\\n    // write return\\n    return getLeft(this.front);\\n};\\n\\nfunction getLeft(array) {\\n    if (array.length <= 10) {\\n        return array.join(\"\");\\n    }\\n    return array.slice(array.length-10,array.length).join(\"\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668472,
                "title": "go-doubly-linked-list-dll-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\ntype charNode struct {\\n\\tval  uint8\\n\\ttext string\\n\\tprev *charNode\\n\\tnext *charNode\\n}\\n\\ntype TextEditor struct {\\n\\tlist *charNode\\n}\\n\\nfunc Constructor() TextEditor {\\n\\treturn TextEditor{list: &charNode{}}\\n}\\n\\nfunc (this *TextEditor) AddText(text string) {\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\tchar := &charNode{\\n\\t\\t\\tval:  text[i],\\n\\t\\t\\ttext: string(text[i]),\\n\\t\\t}\\n\\n\\t\\tlistNext := this.list.next\\n\\t\\tif listNext != nil {\\n\\t\\t\\tlistNext.prev = char\\n\\t\\t}\\n\\n\\t\\tthis.list.next = char\\n\\t\\tchar.prev = this.list\\n\\t\\tchar.next = listNext\\n\\t\\tthis.list = char\\n\\t}\\n}\\n\\n// int deleteText(int k)\\n// Deletes k characters to the left of the cursor.\\n// Returns the number of characters actually deleted.\\nfunc (this *TextEditor) DeleteText(k int) int {\\n\\tvar n int\\n\\tfor this.list.val > 0 && k-n > 0 {\\n\\t\\tthis.list.prev.next = this.list.next\\n\\t\\tif this.list.next != nil {\\n\\t\\t\\tthis.list.next.prev = this.list.prev\\n\\t\\t}\\n\\t\\tthis.list = this.list.prev\\n\\t\\tn++\\n\\t}\\n\\treturn n\\n}\\n\\n// string cursorLeft(int k) Moves the cursor to the left k times.\\n// Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\\nfunc (this *TextEditor) CursorLeft(k int) string {\\n\\tvar n int\\n\\tfor this.list.val > 0 && k-n > 0 {\\n\\t\\tthis.list = this.list.prev\\n\\t\\tn++\\n\\t}\\n\\n\\th := this.list\\n\\tvar result []uint8\\n\\tn = 10\\n\\tfor h.val > 0 && n > 0 {\\n\\t\\tresult = append([]uint8{h.val}, result...)\\n\\t\\th = h.prev\\n\\t\\tn--\\n\\t}\\n\\treturn string(result)\\n}\\n\\n// string cursorRight(int k) Moves the cursor to the right k times.\\n// Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\\nfunc (this *TextEditor) CursorRight(k int) string {\\n\\tvar n int\\n\\tfor this.list.next != nil && k-n > 0 {\\n\\t\\tthis.list = this.list.next\\n\\t\\tn++\\n\\t}\\n\\n\\th := this.list\\n\\tvar result []uint8\\n\\tn = 10\\n\\tfor h.val > 0 && n > 0 {\\n\\t\\tresult = append([]uint8{h.val}, result...)\\n\\t\\th = h.prev\\n\\t\\tn--\\n\\t}\\n\\treturn string(result)\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype charNode struct {\\n\\tval  uint8\\n\\ttext string\\n\\tprev *charNode\\n\\tnext *charNode\\n}\\n\\ntype TextEditor struct {\\n\\tlist *charNode\\n}\\n\\nfunc Constructor() TextEditor {\\n\\treturn TextEditor{list: &charNode{}}\\n}\\n\\nfunc (this *TextEditor) AddText(text string) {\\n\\tfor i := 0; i < len(text); i++ {\\n\\t\\tchar := &charNode{\\n\\t\\t\\tval:  text[i],\\n\\t\\t\\ttext: string(text[i]),\\n\\t\\t}\\n\\n\\t\\tlistNext := this.list.next\\n\\t\\tif listNext != nil {\\n\\t\\t\\tlistNext.prev = char\\n\\t\\t}\\n\\n\\t\\tthis.list.next = char\\n\\t\\tchar.prev = this.list\\n\\t\\tchar.next = listNext\\n\\t\\tthis.list = char\\n\\t}\\n}\\n\\n// int deleteText(int k)\\n// Deletes k characters to the left of the cursor.\\n// Returns the number of characters actually deleted.\\nfunc (this *TextEditor) DeleteText(k int) int {\\n\\tvar n int\\n\\tfor this.list.val > 0 && k-n > 0 {\\n\\t\\tthis.list.prev.next = this.list.next\\n\\t\\tif this.list.next != nil {\\n\\t\\t\\tthis.list.next.prev = this.list.prev\\n\\t\\t}\\n\\t\\tthis.list = this.list.prev\\n\\t\\tn++\\n\\t}\\n\\treturn n\\n}\\n\\n// string cursorLeft(int k) Moves the cursor to the left k times.\\n// Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\\nfunc (this *TextEditor) CursorLeft(k int) string {\\n\\tvar n int\\n\\tfor this.list.val > 0 && k-n > 0 {\\n\\t\\tthis.list = this.list.prev\\n\\t\\tn++\\n\\t}\\n\\n\\th := this.list\\n\\tvar result []uint8\\n\\tn = 10\\n\\tfor h.val > 0 && n > 0 {\\n\\t\\tresult = append([]uint8{h.val}, result...)\\n\\t\\th = h.prev\\n\\t\\tn--\\n\\t}\\n\\treturn string(result)\\n}\\n\\n// string cursorRight(int k) Moves the cursor to the right k times.\\n// Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\\nfunc (this *TextEditor) CursorRight(k int) string {\\n\\tvar n int\\n\\tfor this.list.next != nil && k-n > 0 {\\n\\t\\tthis.list = this.list.next\\n\\t\\tn++\\n\\t}\\n\\n\\th := this.list\\n\\tvar result []uint8\\n\\tn = 10\\n\\tfor h.val > 0 && n > 0 {\\n\\t\\tresult = append([]uint8{h.val}, result...)\\n\\t\\th = h.prev\\n\\t\\tn--\\n\\t}\\n\\treturn string(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644457,
                "title": "python-two-stacks-well-commented-solution",
                "content": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        # Two Stacks\\n        \\n        # This will have the text on the left of the cursor\\n        self.leftStack = []\\n        \\n        # This will have the text on the right of the cursor\\n        self.rightStack = []\\n\\n    def addText(self, text: str) -> None:\\n        # Add text to the leftStack\\n        # We will add character by character\\n        # So that it is easier to return when we want to return some portion\\n        for c in text: self.leftStack.append(c)\\n        \\n\\n    def deleteText(self, k: int) -> int:\\n        # At any time, wherever the cursor is\\n        # The text on left of that cursor will always be in leftStack\\n        \\n        # And it is also possible that \"k\" is more than the size of leftStack\\n        # so, we also need to handle those scenarios\\n        # We can empty at most the whole leftStack\\n        k = min(k, len(self.leftStack))\\n        \\n        # Delete \"k\" elements\\n        n = k\\n        while n > 0:\\n            self.leftStack.pop()\\n            n -= 1\\n            \\n        # Return the number of elements deleted, that is, \"k\"\\n        return k\\n        \\n\\n    def cursorLeft(self, k: int) -> str:\\n        # Return the characters\\n        return self.moveCursorAndReturnCharacters(k, self.leftStack, self.rightStack, True) \\n\\n    def cursorRight(self, k: int) -> str:\\n        # Return the characters\\n        return self.moveCursorAndReturnCharacters(k, self.leftStack, self.rightStack, False)\\n    \\n    def moveCursorAndReturnCharacters(self, k, leftStack, rightStack, isLeft):\\n        # When we move the cursor to left/right\\n        # It simply means, take the elements from top of leftStack/rightStack\\n        # And put then in rightStack/leftStack\\n        \\n        # Again, \"k\" might be larger than length of leftStack/rightStack\\n        # So that\\'s also something we need to take care of\\n        n = min(k, len(self.leftStack) if isLeft else len(self.rightStack))\\n        \\n        \\n        while n > 0:\\n            if isLeft: self.rightStack.append(self.leftStack.pop())\\n            else: self.leftStack.append(self.rightStack.pop())\\n            n -= 1\\n        \\n        # Finally, we can figure out how many characters to return\\n        charactersToReturn = min(10, len(self.leftStack))\\n        startIdx = len(self.leftStack) - charactersToReturn\\n        \\n        # Return the characters\\n        return \"\".join(self.leftStack[startIdx:])\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        # Two Stacks\\n        \\n        # This will have the text on the left of the cursor\\n        self.leftStack = []\\n        \\n        # This will have the text on the right of the cursor\\n        self.rightStack = []\\n\\n    def addText(self, text: str) -> None:\\n        # Add text to the leftStack\\n        # We will add character by character\\n        # So that it is easier to return when we want to return some portion\\n        for c in text: self.leftStack.append(c)\\n        \\n\\n    def deleteText(self, k: int) -> int:\\n        # At any time, wherever the cursor is\\n        # The text on left of that cursor will always be in leftStack\\n        \\n        # And it is also possible that \"k\" is more than the size of leftStack\\n        # so, we also need to handle those scenarios\\n        # We can empty at most the whole leftStack\\n        k = min(k, len(self.leftStack))\\n        \\n        # Delete \"k\" elements\\n        n = k\\n        while n > 0:\\n            self.leftStack.pop()\\n            n -= 1\\n            \\n        # Return the number of elements deleted, that is, \"k\"\\n        return k\\n        \\n\\n    def cursorLeft(self, k: int) -> str:\\n        # Return the characters\\n        return self.moveCursorAndReturnCharacters(k, self.leftStack, self.rightStack, True) \\n\\n    def cursorRight(self, k: int) -> str:\\n        # Return the characters\\n        return self.moveCursorAndReturnCharacters(k, self.leftStack, self.rightStack, False)\\n    \\n    def moveCursorAndReturnCharacters(self, k, leftStack, rightStack, isLeft):\\n        # When we move the cursor to left/right\\n        # It simply means, take the elements from top of leftStack/rightStack\\n        # And put then in rightStack/leftStack\\n        \\n        # Again, \"k\" might be larger than length of leftStack/rightStack\\n        # So that\\'s also something we need to take care of\\n        n = min(k, len(self.leftStack) if isLeft else len(self.rightStack))\\n        \\n        \\n        while n > 0:\\n            if isLeft: self.rightStack.append(self.leftStack.pop())\\n            else: self.leftStack.append(self.rightStack.pop())\\n            n -= 1\\n        \\n        # Finally, we can figure out how many characters to return\\n        charactersToReturn = min(10, len(self.leftStack))\\n        startIdx = len(self.leftStack) - charactersToReturn\\n        \\n        # Return the characters\\n        return \"\".join(self.leftStack[startIdx:])\\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642232,
                "title": "python-simplest-solution-2-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nKeep everything on left in stackL\\nKeep everything on right in stackR\\n\\nCursor is between stackL and stackR.\\n\\n# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.stackL = []\\n        self.stackR = []\\n        \\n    def addText(self, text: str) -> None:\\n        for ch in text:\\n            self.stackL.append(ch)\\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        for _ in range(k):\\n            if self.stackL:\\n                self.stackL.pop()\\n                count += 1\\n        return count\\n\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.stackL:\\n                self.stackR.append(self.stackL.pop())\\n        return self._getLastTenChar()\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.stackR:\\n                self.stackL.append(self.stackR.pop())\\n        return self._getLastTenChar()\\n\\n    def _getLastTenChar(self):\\n        result = []\\n        i = len(self.stackL) - 1\\n        for _ in range(10):\\n            if i >= 0:\\n                result.append(self.stackL[i])\\n                i -= 1\\n        return \"\".join(reversed(result))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.stackL = []\\n        self.stackR = []\\n        \\n    def addText(self, text: str) -> None:\\n        for ch in text:\\n            self.stackL.append(ch)\\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        for _ in range(k):\\n            if self.stackL:\\n                self.stackL.pop()\\n                count += 1\\n        return count\\n\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.stackL:\\n                self.stackR.append(self.stackL.pop())\\n        return self._getLastTenChar()\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(k):\\n            if self.stackR:\\n                self.stackL.append(self.stackR.pop())\\n        return self._getLastTenChar()\\n\\n    def _getLastTenChar(self):\\n        result = []\\n        i = len(self.stackL) - 1\\n        for _ in range(10):\\n            if i >= 0:\\n                result.append(self.stackL[i])\\n                i -= 1\\n        return \"\".join(reversed(result))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635206,
                "title": "typescript-solution-beats-90-two-stacks-approach",
                "content": "# Intuition\\nInitially hit issues with timeouts because I was trying to do a pointer approach with splicing. Using the array as a stack is significantly more time efficient and also simplifies logic at the ends of the array (e.g. if you try to delete more characters than exist).\\n\\n# Approach\\nUse two stacks, one for maintaining what\\'s at the left of the cursor and one for maintaining what\\'s at the right. \\n\\n# Code\\n```\\nclass TextEditor {\\n    left: string[];\\n    right: string[];\\n    constructor() {\\n        this.left = [];\\n        this.right = [];\\n    }\\n\\n\\n    addText(text: string): void {\\n        this.left.push(...text.split(\\'\\'));\\n    }\\n\\n    deleteText(k: number): number {\\n        for (let i = 0; i < k; i++) {\\n            if (this.left.length === 0) return i;\\n            this.left.pop();\\n        }\\n        return k;\\n    }\\n\\n    cursorLeft(k: number): string {\\n        for (let i = 0; i < k; i++) if (!!this.left.length) this.right.push(this.left.pop());\\n        return this.getLeftChars(10);\\n    }\\n\\n    cursorRight(k: number): string {\\n        for (let i = 0; i < k; i++) if (!!this.right.length) this.left.push(this.right.pop());\\n        return this.getLeftChars(10);\\n    }\\n\\n    private getLeftChars(charCount: number): string {\\n        return this.left.slice(Math.max(0, this.left.length - 10)).join(\\'\\');\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * var obj = new TextEditor()\\n * obj.addText(text)\\n * var param_2 = obj.deleteText(k)\\n * var param_3 = obj.cursorLeft(k)\\n * var param_4 = obj.cursorRight(k)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TextEditor {\\n    left: string[];\\n    right: string[];\\n    constructor() {\\n        this.left = [];\\n        this.right = [];\\n    }\\n\\n\\n    addText(text: string): void {\\n        this.left.push(...text.split(\\'\\'));\\n    }\\n\\n    deleteText(k: number): number {\\n        for (let i = 0; i < k; i++) {\\n            if (this.left.length === 0) return i;\\n            this.left.pop();\\n        }\\n        return k;\\n    }\\n\\n    cursorLeft(k: number): string {\\n        for (let i = 0; i < k; i++) if (!!this.left.length) this.right.push(this.left.pop());\\n        return this.getLeftChars(10);\\n    }\\n\\n    cursorRight(k: number): string {\\n        for (let i = 0; i < k; i++) if (!!this.right.length) this.left.push(this.right.pop());\\n        return this.getLeftChars(10);\\n    }\\n\\n    private getLeftChars(charCount: number): string {\\n        return this.left.slice(Math.max(0, this.left.length - 10)).join(\\'\\');\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * var obj = new TextEditor()\\n * obj.addText(text)\\n * var param_2 = obj.deleteText(k)\\n * var param_3 = obj.cursorLeft(k)\\n * var param_4 = obj.cursorRight(k)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584294,
                "title": "perfection",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.stack=\"\"\\n        self.cursor=0\\n    def addText(self, text: str) -> None:\\n        self.stack=self.stack[:self.cursor]+text+self.stack[self.cursor:]\\n        self.cursor+=len(text)\\n    def deleteText(self, k: int) -> int:\\n        if k>self.cursor:\\n            ex=self.cursor\\n            self.stack=self.stack[self.cursor:]  \\n            self.cursor=0\\n            return ex\\n        else:\\n            self.stack=self.stack[:self.cursor-k]+self.stack[self.cursor:]  \\n            self.cursor-=k\\n            return k\\n    def cursorLeft(self, k: int) -> str:\\n        if k>self.cursor:\\n            self.cursor=0\\n            return \"\"\\n        else:\\n            self.cursor-=k\\n            if self.cursor<0:self.cursor=0\\n            if self.cursor<10:return self.stack[:self.cursor]\\n            else:return self.stack[self.cursor-10:self.cursor]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor+=k\\n        if len(self.stack)<self.cursor:self.cursor=len(self.stack)\\n        if self.cursor<10:return self.stack[:self.cursor]\\n        else:return self.stack[self.cursor-10:self.cursor]\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.stack=\"\"\\n        self.cursor=0\\n    def addText(self, text: str) -> None:\\n        self.stack=self.stack[:self.cursor]+text+self.stack[self.cursor:]\\n        self.cursor+=len(text)\\n    def deleteText(self, k: int) -> int:\\n        if k>self.cursor:\\n            ex=self.cursor\\n            self.stack=self.stack[self.cursor:]  \\n            self.cursor=0\\n            return ex\\n        else:\\n            self.stack=self.stack[:self.cursor-k]+self.stack[self.cursor:]  \\n            self.cursor-=k\\n            return k\\n    def cursorLeft(self, k: int) -> str:\\n        if k>self.cursor:\\n            self.cursor=0\\n            return \"\"\\n        else:\\n            self.cursor-=k\\n            if self.cursor<0:self.cursor=0\\n            if self.cursor<10:return self.stack[:self.cursor]\\n            else:return self.stack[self.cursor-10:self.cursor]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor+=k\\n        if len(self.stack)<self.cursor:self.cursor=len(self.stack)\\n        if self.cursor<10:return self.stack[:self.cursor]\\n        else:return self.stack[self.cursor-10:self.cursor]\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582606,
                "title": "based-doubly-linked-list-solution-c",
                "content": "# Code\\n```\\nclass DoublyLinkedListNode\\n{\\npublic:\\n    char val;\\n    DoublyLinkedListNode* next;\\n    DoublyLinkedListNode* prev;\\n\\n    DoublyLinkedListNode(const char& val): val(val), next(nullptr), prev(nullptr) {}\\n\\n    ~DoublyLinkedListNode() = default;\\n};\\n\\nclass DoublyLinkedList\\n{\\nprivate:\\n    DoublyLinkedListNode* head;\\n    DoublyLinkedListNode* tail;\\n    DoublyLinkedListNode* curr;\\n\\n    void addAtCurr(const char& newVal)\\n    {\\n        auto* newNode = new DoublyLinkedListNode(newVal);\\n        newNode -> prev = curr;\\n        newNode -> next = curr -> next;\\n        curr -> next -> prev = newNode;\\n        curr -> next = newNode;\\n        curr = curr -> next;\\n    }\\n\\n    void deleteCurr()\\n    {\\n        if (curr == head || curr == tail)\\n            return;\\n        auto* prev = curr -> prev;\\n        curr -> prev -> next = curr -> next;\\n        curr -> next -> prev = curr -> prev;\\n        delete curr;\\n        curr = prev;\\n    }\\n\\n    void print() const \\n    {\\n        auto* currNode = head -> next;\\n        while (currNode && currNode != tail)\\n        {\\n            cout << currNode -> val;\\n            currNode = currNode -> next;\\n        }\\n        cout << \\'\\\\n\\';\\n    }\\n\\n    string stringTraverseUtil(const int& k, function<DoublyLinkedListNode*(DoublyLinkedListNode*)> dirFunc)\\n    {\\n        int count = 0;\\n        while (curr != head && count < k)\\n        {\\n            curr = dirFunc(curr);\\n            ++count;\\n        }\\n        string res = \"\";\\n        count = 0;\\n        auto* traversingNode = curr;\\n        while (traversingNode != head && count < 10)\\n        {\\n            res += traversingNode -> val;\\n            traversingNode = traversingNode -> prev;\\n            ++count;\\n        }\\n        return res;\\n    }\\npublic:\\n    DoublyLinkedList()\\n    {\\n        head = new DoublyLinkedListNode(\\'a\\');\\n        tail = new DoublyLinkedListNode(\\'b\\');\\n        tail -> prev = head;\\n        head -> next = tail;\\n        curr = head;\\n    }\\n\\n    ~DoublyLinkedList()\\n    {\\n        auto* currNode = head;\\n        while (currNode)\\n        {\\n            auto* nextNode = currNode -> next;\\n            delete currNode;\\n            currNode = nextNode;\\n        }\\n    }\\n\\n    void addText(const string& text)\\n    {   \\n        for (auto& c : text)\\n            addAtCurr(c);\\n    }\\n\\n    int deleteText(const int& k)\\n    {\\n        int count = 0;\\n        while (curr != head && count < k)\\n        {\\n            deleteCurr();\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\n    string cursorLeft(const int& k)\\n    {\\n        int count = 0;\\n        while (curr != head && count < k)\\n        {\\n            curr = curr -> prev;\\n            ++count;\\n        }\\n        if (curr == head)\\n            return \"\";\\n        string res = \"\";\\n        count = 0;\\n        auto* traversingNode = curr;\\n        while (traversingNode != head && count < 10)\\n        {\\n            res += traversingNode -> val;\\n            traversingNode = traversingNode -> prev;\\n            ++count;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n\\n    string cursorRight(const int& k)\\n    {\\n        int count = 0;\\n        while (curr != tail && count < k)\\n        {\\n            curr = curr -> next;\\n            ++count;\\n        }\\n        if (curr == tail)\\n            curr = tail -> prev;\\n        string res = \"\";\\n        count = 0;\\n        auto* traversingNode = curr;\\n        while (traversingNode != head && count < 10)\\n        {\\n            res += traversingNode -> val;\\n            traversingNode = traversingNode -> prev;\\n            ++count;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n\\nclass TextEditor {\\nprivate:\\n    DoublyLinkedList* list;\\npublic:\\n    TextEditor() {\\n        list = new DoublyLinkedList();\\n    }\\n\\n    ~TextEditor()\\n    {\\n        delete list;\\n    }\\n    \\n    void addText(string text) {\\n        list -> addText(text);\\n    }\\n    \\n    int deleteText(int k) {\\n        return list -> deleteText(k);\\n    }\\n    \\n    string cursorLeft(int k) {\\n        return list -> cursorLeft(k);\\n    }\\n    \\n    string cursorRight(int k) {\\n        return list -> cursorRight(k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DoublyLinkedListNode\\n{\\npublic:\\n    char val;\\n    DoublyLinkedListNode* next;\\n    DoublyLinkedListNode* prev;\\n\\n    DoublyLinkedListNode(const char& val): val(val), next(nullptr), prev(nullptr) {}\\n\\n    ~DoublyLinkedListNode() = default;\\n};\\n\\nclass DoublyLinkedList\\n{\\nprivate:\\n    DoublyLinkedListNode* head;\\n    DoublyLinkedListNode* tail;\\n    DoublyLinkedListNode* curr;\\n\\n    void addAtCurr(const char& newVal)\\n    {\\n        auto* newNode = new DoublyLinkedListNode(newVal);\\n        newNode -> prev = curr;\\n        newNode -> next = curr -> next;\\n        curr -> next -> prev = newNode;\\n        curr -> next = newNode;\\n        curr = curr -> next;\\n    }\\n\\n    void deleteCurr()\\n    {\\n        if (curr == head || curr == tail)\\n            return;\\n        auto* prev = curr -> prev;\\n        curr -> prev -> next = curr -> next;\\n        curr -> next -> prev = curr -> prev;\\n        delete curr;\\n        curr = prev;\\n    }\\n\\n    void print() const \\n    {\\n        auto* currNode = head -> next;\\n        while (currNode && currNode != tail)\\n        {\\n            cout << currNode -> val;\\n            currNode = currNode -> next;\\n        }\\n        cout << \\'\\\\n\\';\\n    }\\n\\n    string stringTraverseUtil(const int& k, function<DoublyLinkedListNode*(DoublyLinkedListNode*)> dirFunc)\\n    {\\n        int count = 0;\\n        while (curr != head && count < k)\\n        {\\n            curr = dirFunc(curr);\\n            ++count;\\n        }\\n        string res = \"\";\\n        count = 0;\\n        auto* traversingNode = curr;\\n        while (traversingNode != head && count < 10)\\n        {\\n            res += traversingNode -> val;\\n            traversingNode = traversingNode -> prev;\\n            ++count;\\n        }\\n        return res;\\n    }\\npublic:\\n    DoublyLinkedList()\\n    {\\n        head = new DoublyLinkedListNode(\\'a\\');\\n        tail = new DoublyLinkedListNode(\\'b\\');\\n        tail -> prev = head;\\n        head -> next = tail;\\n        curr = head;\\n    }\\n\\n    ~DoublyLinkedList()\\n    {\\n        auto* currNode = head;\\n        while (currNode)\\n        {\\n            auto* nextNode = currNode -> next;\\n            delete currNode;\\n            currNode = nextNode;\\n        }\\n    }\\n\\n    void addText(const string& text)\\n    {   \\n        for (auto& c : text)\\n            addAtCurr(c);\\n    }\\n\\n    int deleteText(const int& k)\\n    {\\n        int count = 0;\\n        while (curr != head && count < k)\\n        {\\n            deleteCurr();\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\n    string cursorLeft(const int& k)\\n    {\\n        int count = 0;\\n        while (curr != head && count < k)\\n        {\\n            curr = curr -> prev;\\n            ++count;\\n        }\\n        if (curr == head)\\n            return \"\";\\n        string res = \"\";\\n        count = 0;\\n        auto* traversingNode = curr;\\n        while (traversingNode != head && count < 10)\\n        {\\n            res += traversingNode -> val;\\n            traversingNode = traversingNode -> prev;\\n            ++count;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n\\n    string cursorRight(const int& k)\\n    {\\n        int count = 0;\\n        while (curr != tail && count < k)\\n        {\\n            curr = curr -> next;\\n            ++count;\\n        }\\n        if (curr == tail)\\n            curr = tail -> prev;\\n        string res = \"\";\\n        count = 0;\\n        auto* traversingNode = curr;\\n        while (traversingNode != head && count < 10)\\n        {\\n            res += traversingNode -> val;\\n            traversingNode = traversingNode -> prev;\\n            ++count;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n\\nclass TextEditor {\\nprivate:\\n    DoublyLinkedList* list;\\npublic:\\n    TextEditor() {\\n        list = new DoublyLinkedList();\\n    }\\n\\n    ~TextEditor()\\n    {\\n        delete list;\\n    }\\n    \\n    void addText(string text) {\\n        list -> addText(text);\\n    }\\n    \\n    int deleteText(int k) {\\n        return list -> deleteText(k);\\n    }\\n    \\n    string cursorLeft(int k) {\\n        return list -> cursorLeft(k);\\n    }\\n    \\n    string cursorRight(int k) {\\n        return list -> cursorRight(k);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3573588,
                "title": "python-linkedlist-without-node-simple",
                "content": "# Code\\n```\\nclass TextEditor:\\n    def __init__(self):\\n        first = [-1,None,None]\\n        self.cur = first\\n    def add(self,val):\\n        node = [val,None,None]\\n        nxt = self.cur[2]\\n        node[1] = self.cur\\n        node[2] = nxt\\n        if nxt: nxt[1] = node\\n        self.cur[2] = node\\n        self.cur = node\\n\\n    def addText(self, text: str) -> None:\\n        for x in text: self.add(x)\\n\\n    def deleteText(self, k: int) -> int:\\n        nxt = self.cur[2]\\n        cnt = self.move(k,1)\\n        self.cur[2] = nxt\\n        if nxt: nxt[1] = self.cur\\n        return cnt\\n\\n    def move(self,k,dir):\\n        cnt = 0\\n        while(self.cur[dir] and cnt<k):\\n            self.cur = self.cur[dir]\\n            cnt +=1\\n        return cnt\\n    def last(self):\\n        s = \"\"\\n        temp  =self.cur\\n        while(temp[0]!=-1 and len(s)<10):\\n            s += temp[0]\\n            temp = temp[1]\\n        return s[::-1]\\n    def cursorLeft(self, k: int) -> str:\\n        self.move(k,1)\\n        return self.last()\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.move(k,2)\\n        return self.last()\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n    def __init__(self):\\n        first = [-1,None,None]\\n        self.cur = first\\n    def add(self,val):\\n        node = [val,None,None]\\n        nxt = self.cur[2]\\n        node[1] = self.cur\\n        node[2] = nxt\\n        if nxt: nxt[1] = node\\n        self.cur[2] = node\\n        self.cur = node\\n\\n    def addText(self, text: str) -> None:\\n        for x in text: self.add(x)\\n\\n    def deleteText(self, k: int) -> int:\\n        nxt = self.cur[2]\\n        cnt = self.move(k,1)\\n        self.cur[2] = nxt\\n        if nxt: nxt[1] = self.cur\\n        return cnt\\n\\n    def move(self,k,dir):\\n        cnt = 0\\n        while(self.cur[dir] and cnt<k):\\n            self.cur = self.cur[dir]\\n            cnt +=1\\n        return cnt\\n    def last(self):\\n        s = \"\"\\n        temp  =self.cur\\n        while(temp[0]!=-1 and len(s)<10):\\n            s += temp[0]\\n            temp = temp[1]\\n        return s[::-1]\\n    def cursorLeft(self, k: int) -> str:\\n        self.move(k,1)\\n        return self.last()\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.move(k,2)\\n        return self.last()\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529840,
                "title": "two-stacks-90-time-clean-code-clear-approach-explanation",
                "content": "# Intuition\\nThis question can easily be done with the help of two stacks.\\n\\n# Approach\\n1. We can make two arrays i.e. one array stores the text left of the cursor and the other stores the text right of the cursor.\\n2. If we want to simulate `backspace` then we can remove those number of backspaces from the left text array.\\n3. **(Additional)** If we want to simulate `delete` then we can remove those number of deletes from the right text array.\\n4. For moving the cursor, either left of right, we can pop from the left text array and store the poped values in right text array or vice-versa respectively.\\n\\n# Complexity\\n- Time complexity: \\n    - $$O(n)$$ for `addText`, where `n` is the length of the input `text`\\n    - $$O(k)$$ for all the other functions i.e. `deleteText`, `cursorLeft` and `cursorRight`.\\n\\n- Space complexity:\\n    - $$O(n)$$, where `n` is the current length of the total text. \\n\\n# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.leftText = []\\n        self.rightText = []\\n        self.cursor = 0\\n\\n    def addText(self, text: str) -> None:\\n        for i in text:\\n            self.leftText.append(i)\\n            self.cursor += 1\\n\\n    def deleteText(self, k: int) -> int:\\n        deleted = 0\\n        for i in range(min(k, self.cursor)):\\n            self.leftText.pop()\\n            self.cursor -= 1\\n            deleted += 1\\n        return deleted\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for i in range(min(k, len(self.leftText))):\\n            self.rightText.append(self.leftText.pop())\\n            self.cursor -= 1\\n        return self.last10Chars()\\n            \\n    def cursorRight(self, k: int) -> str:\\n        for i in range(min(k, len(self.rightText))):\\n            self.leftText.append(self.rightText.pop())\\n            self.cursor += 1\\n        return self.last10Chars()\\n    \\n    def last10Chars(self) -> str:\\n        res = []\\n        for i in range(min(10, len(self.leftText))):\\n            res.append(self.leftText[-1 - i])\\n        res.reverse()\\n        return \\'\\'.join(res)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.leftText = []\\n        self.rightText = []\\n        self.cursor = 0\\n\\n    def addText(self, text: str) -> None:\\n        for i in text:\\n            self.leftText.append(i)\\n            self.cursor += 1\\n\\n    def deleteText(self, k: int) -> int:\\n        deleted = 0\\n        for i in range(min(k, self.cursor)):\\n            self.leftText.pop()\\n            self.cursor -= 1\\n            deleted += 1\\n        return deleted\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for i in range(min(k, len(self.leftText))):\\n            self.rightText.append(self.leftText.pop())\\n            self.cursor -= 1\\n        return self.last10Chars()\\n            \\n    def cursorRight(self, k: int) -> str:\\n        for i in range(min(k, len(self.rightText))):\\n            self.leftText.append(self.rightText.pop())\\n            self.cursor += 1\\n        return self.last10Chars()\\n    \\n    def last10Chars(self) -> str:\\n        res = []\\n        for i in range(min(10, len(self.leftText))):\\n            res.append(self.leftText[-1 - i])\\n        res.reverse()\\n        return \\'\\'.join(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517698,
                "title": "simple-solution-using-slicing",
                "content": "```\\nclass TextEditor:\\n    def __init__(self):\\n        self.txt = \\'\\'\\n        self.pos = 0\\n\\n    def addText(self, s: str) -> None:\\n        self.txt = self.txt[:self.pos] + s + self.txt[self.pos:]\\n        self.pos += len(s)\\n\\n    def deleteText(self, k: int) -> int:\\n        length = len(self.txt)\\n        start = max(self.pos-k, 0)\\n        self.txt = self.txt[:start] + self.txt[self.pos:]\\n        self.pos = start\\n        return length-len(self.txt)\\n    \\n    def cursorLeft(self, k: int) -> str:\\n        self.pos = max(self.pos-k, 0)\\n        start = min(10, len(self.txt[:self.pos]))\\n        return self.txt[self.pos-start:self.pos]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.pos = min(self.pos+k, len(self.txt))\\n        start = min(10, len(self.txt[:self.pos]))\\n        return self.txt[self.pos-start:self.pos]    \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass TextEditor:\\n    def __init__(self):\\n        self.txt = \\'\\'\\n        self.pos = 0\\n\\n    def addText(self, s: str) -> None:\\n        self.txt = self.txt[:self.pos] + s + self.txt[self.pos:]\\n        self.pos += len(s)\\n\\n    def deleteText(self, k: int) -> int:\\n        length = len(self.txt)\\n        start = max(self.pos-k, 0)\\n        self.txt = self.txt[:start] + self.txt[self.pos:]\\n        self.pos = start\\n        return length-len(self.txt)\\n    \\n    def cursorLeft(self, k: int) -> str:\\n        self.pos = max(self.pos-k, 0)\\n        start = min(10, len(self.txt[:self.pos]))\\n        return self.txt[self.pos-start:self.pos]\\n\\n    def cursorRight(self, k: int) -> str:\\n        self.pos = min(self.pos+k, len(self.txt))\\n        start = min(10, len(self.txt[:self.pos]))\\n        return self.txt[self.pos-start:self.pos]    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467588,
                "title": "design-a-text-editor",
                "content": "\\n\\n# Code\\n```\\nclass TextEditor {\\n public:\\n  void addText(string text) {\\n    s += text;\\n  }\\n\\n  int deleteText(int k) {\\n    const int numDeleted = min(k, static_cast<int>(s.length()));\\n    for (int i = 0; i < numDeleted; ++i)\\n      s.pop_back();\\n    return numDeleted;\\n  }\\n\\n  string cursorLeft(int k) {\\n    while (!s.empty() && k--)\\n      stack.push(s.back()), s.pop_back();\\n    return getString();\\n  }\\n\\n  string cursorRight(int k) {\\n    while (!stack.empty() && k--)\\n      s += stack.top(), stack.pop();\\n    return getString();\\n  }\\n\\n  string getString() {\\n    if (s.length() < 10)\\n      return s;\\n    return s.substr(s.length() - 10);\\n  }\\n\\n private:\\n  string s;\\n  stack<char> stack;\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TextEditor {\\n public:\\n  void addText(string text) {\\n    s += text;\\n  }\\n\\n  int deleteText(int k) {\\n    const int numDeleted = min(k, static_cast<int>(s.length()));\\n    for (int i = 0; i < numDeleted; ++i)\\n      s.pop_back();\\n    return numDeleted;\\n  }\\n\\n  string cursorLeft(int k) {\\n    while (!s.empty() && k--)\\n      stack.push(s.back()), s.pop_back();\\n    return getString();\\n  }\\n\\n  string cursorRight(int k) {\\n    while (!stack.empty() && k--)\\n      s += stack.top(), stack.pop();\\n    return getString();\\n  }\\n\\n  string getString() {\\n    if (s.length() < 10)\\n      return s;\\n    return s.substr(s.length() - 10);\\n  }\\n\\n private:\\n  string s;\\n  stack<char> stack;\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447837,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.txt = \"\"\\n        self.cursor = 0\\n\\n    def addText(self, text):\\n        self.txt = self.txt[:self.cursor] + text + self.txt[self.cursor:]\\n        self.cursor += len(text)\\n\\n    def deleteText(self, k):\\n        ans = min(k,self.cursor)\\n        cur = self.cursor\\n        self.cursor = max(0,self.cursor-k)\\n        self.txt = self.txt[:self.cursor] + self.txt[cur:]\\n        return ans\\n\\n    def cursorLeft(self, k):\\n        self.cursor = max(0,self.cursor-k)\\n        start = max(0,self.cursor-10)\\n        return self.txt[start:self.cursor]\\n\\n    def cursorRight(self, k):\\n        self.cursor = min(self.cursor+k,len(self.txt))\\n        start = max(0,self.cursor-10)\\n        return self.txt[start:self.cursor]\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.txt = \"\"\\n        self.cursor = 0\\n\\n    def addText(self, text):\\n        self.txt = self.txt[:self.cursor] + text + self.txt[self.cursor:]\\n        self.cursor += len(text)\\n\\n    def deleteText(self, k):\\n        ans = min(k,self.cursor)\\n        cur = self.cursor\\n        self.cursor = max(0,self.cursor-k)\\n        self.txt = self.txt[:self.cursor] + self.txt[cur:]\\n        return ans\\n\\n    def cursorLeft(self, k):\\n        self.cursor = max(0,self.cursor-k)\\n        start = max(0,self.cursor-10)\\n        return self.txt[start:self.cursor]\\n\\n    def cursorRight(self, k):\\n        self.cursor = min(self.cursor+k,len(self.txt))\\n        start = max(0,self.cursor-10)\\n        return self.txt[start:self.cursor]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436415,
                "title": "c-solution-using-stringbuilder",
                "content": "# Code\\n```\\npublic class TextEditor {\\n    private StringBuilder sb;\\n    private int cursor; \\n    \\n    public TextEditor() {\\n        sb = new ();\\n        cursor = 0;\\n    }\\n    \\n    public void AddText(string text) {\\n        if(cursor >= sb.Length) \\n            sb.Append(text);\\n        else     \\n            sb.Insert(cursor, text);\\n    \\n        cursor += text.Length;\\n    }\\n    \\n    public int DeleteText(int k) {\\n        int len = Math.Min(cursor, k);\\n        cursor = Math.Max(cursor - k, 0);\\n        sb.Remove(cursor, len);\\n    \\n        return len;\\n    }\\n    \\n    public string CursorLeft(int k) {\\n        cursor = Math.Max(cursor - k, 0);\\n\\n        return GetText();\\n   }\\n    \\n    public string CursorRight(int k) {\\n        cursor = Math.Min(sb.Length, cursor + k);\\n     \\n        return GetText();\\n    }\\n\\n    private string GetText() {\\n        if(cursor < 10) return sb.ToString(0, cursor);\\n    \\n        return sb.ToString(cursor - 10, 10);\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.AddText(text);\\n * int param_2 = obj.DeleteText(k);\\n * string param_3 = obj.CursorLeft(k);\\n * string param_4 = obj.CursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class TextEditor {\\n    private StringBuilder sb;\\n    private int cursor; \\n    \\n    public TextEditor() {\\n        sb = new ();\\n        cursor = 0;\\n    }\\n    \\n    public void AddText(string text) {\\n        if(cursor >= sb.Length) \\n            sb.Append(text);\\n        else     \\n            sb.Insert(cursor, text);\\n    \\n        cursor += text.Length;\\n    }\\n    \\n    public int DeleteText(int k) {\\n        int len = Math.Min(cursor, k);\\n        cursor = Math.Max(cursor - k, 0);\\n        sb.Remove(cursor, len);\\n    \\n        return len;\\n    }\\n    \\n    public string CursorLeft(int k) {\\n        cursor = Math.Max(cursor - k, 0);\\n\\n        return GetText();\\n   }\\n    \\n    public string CursorRight(int k) {\\n        cursor = Math.Min(sb.Length, cursor + k);\\n     \\n        return GetText();\\n    }\\n\\n    private string GetText() {\\n        if(cursor < 10) return sb.ToString(0, cursor);\\n    \\n        return sb.ToString(cursor - 10, 10);\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.AddText(text);\\n * int param_2 = obj.DeleteText(k);\\n * string param_3 = obj.CursorLeft(k);\\n * string param_4 = obj.CursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436230,
                "title": "two-stacks-python-with-explanation-and-intuition-easily-to-extend-in-interview",
                "content": "# Intuition\\n1. To delete or insert characters in O(1), I would think of stack because of easy to append and pop. \\n2. Since the cursor could be in the middle of texts. To remove characters, I first thought is to separate texts into two stacks based on the cursor position. We can easily delete the characters on the left side of the cursor. \\n\\n# Approach\\nApproach of using two stacks to store the text and implementing insertion and deletion in time complexity O(1).\\n\\nIn the interview, this method could easily being extend to other functionality of text editor, such as redo/undo. \\nWe can use a separate stack to keep track of the last modification made and its type (add or delete) would allow us to revert or redo the previous action easily.\\n\\n# Complexity\\n- Time complexity:\\nAll operations are in constant time\\nAdd & Delete : O(1)\\ncursorLeft & cursorRight : O(1)\\n\\n\\n\\n- Space complexity:\\nstack size : O(n)\\n\\n# Code\\n```\\nclass TextEditor:\\n    #ex : product \\n    # left = [p, r, o] right = [t, c, u, d]\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        for c in text :\\n            self.left.append(c)\\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        while self.left and count < k :\\n            self.left.pop()\\n            count+=1\\n        return count\\n\\n    def cursorLeft(self, k: int) -> str:\\n        while self.left and k :\\n            c = self.left.pop()\\n            self.right.append(c)\\n            k-=1\\n        if len(self.left) <= 10 :\\n            return \"\".join(self.left)\\n        else :\\n            return\"\".join(self.left[len(self.left)-10 : ])\\n\\n    def cursorRight(self, k: int) -> str:\\n        while self.right and k :\\n            c = self.right.pop()\\n            self.left.append(c)\\n            k-=1\\n        if len(self.left) <= 10 :\\n            return \"\".join(self.left)\\n        else :\\n            return\"\".join(self.left[len(self.left)-10 : ])\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor:\\n    #ex : product \\n    # left = [p, r, o] right = [t, c, u, d]\\n\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        for c in text :\\n            self.left.append(c)\\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        while self.left and count < k :\\n            self.left.pop()\\n            count+=1\\n        return count\\n\\n    def cursorLeft(self, k: int) -> str:\\n        while self.left and k :\\n            c = self.left.pop()\\n            self.right.append(c)\\n            k-=1\\n        if len(self.left) <= 10 :\\n            return \"\".join(self.left)\\n        else :\\n            return\"\".join(self.left[len(self.left)-10 : ])\\n\\n    def cursorRight(self, k: int) -> str:\\n        while self.right and k :\\n            c = self.right.pop()\\n            self.left.append(c)\\n            k-=1\\n        if len(self.left) <= 10 :\\n            return \"\".join(self.left)\\n        else :\\n            return\"\".join(self.left[len(self.left)-10 : ])\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428335,
                "title": "javascript-just-using-substring-method",
                "content": "# Have fun with my code(^___^)\\n```\\nclass TextEditor  {\\n    constructor() { \\n        this.str = \"\"\\n        this.cursor = 0\\n    }\\n};\\nTextEditor.prototype.addText = function(text) {\\n    this.str = this.str.substring(0, this.cursor) + text + this.str.substring(this.cursor)\\n    this.cursor += text.length \\n};\\nTextEditor.prototype.deleteText = function(k) {\\n    const prevCursor = this.cursor\\n    if (this.cursor >= k) { \\n        this.cursor -= k\\n        this.str = this.str.substring(0, this.cursor) + this.str.substring(prevCursor)\\n        return k\\n    }\\n    else { \\n        const len = this.cursor\\n        this.str = this.str.substring(this.cursor)\\n        this.cursor = 0\\n        return len\\n    }\\n};\\nTextEditor.prototype.helper = function(cursor) { \\n    if (this.cursor > 10) { \\n        return this.str.substring(this.cursor - 10, this.cursor)\\n    } else return this.str.substring(0, this.cursor)\\n}\\nTextEditor.prototype.cursorLeft = function(k) {\\n    if (this.cursor >= k) this.cursor -= k\\n    else this.cursor = 0\\n    return this.helper(this.cursor)\\n};\\n\\nTextEditor.prototype.cursorRight = function(k) {\\n    if (this.str.length - this.cursor >= k) this.cursor += k\\n    else this.cursor = this.str.length\\n    return this.helper(this.cursor)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TextEditor  {\\n    constructor() { \\n        this.str = \"\"\\n        this.cursor = 0\\n    }\\n};\\nTextEditor.prototype.addText = function(text) {\\n    this.str = this.str.substring(0, this.cursor) + text + this.str.substring(this.cursor)\\n    this.cursor += text.length \\n};\\nTextEditor.prototype.deleteText = function(k) {\\n    const prevCursor = this.cursor\\n    if (this.cursor >= k) { \\n        this.cursor -= k\\n        this.str = this.str.substring(0, this.cursor) + this.str.substring(prevCursor)\\n        return k\\n    }\\n    else { \\n        const len = this.cursor\\n        this.str = this.str.substring(this.cursor)\\n        this.cursor = 0\\n        return len\\n    }\\n};\\nTextEditor.prototype.helper = function(cursor) { \\n    if (this.cursor > 10) { \\n        return this.str.substring(this.cursor - 10, this.cursor)\\n    } else return this.str.substring(0, this.cursor)\\n}\\nTextEditor.prototype.cursorLeft = function(k) {\\n    if (this.cursor >= k) this.cursor -= k\\n    else this.cursor = 0\\n    return this.helper(this.cursor)\\n};\\n\\nTextEditor.prototype.cursorRight = function(k) {\\n    if (this.str.length - this.cursor >= k) this.cursor += k\\n    else this.cursor = this.str.length\\n    return this.helper(this.cursor)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313485,
                "title": "java-linked-list-solution-beats-97",
                "content": "# Code\\n```\\nclass TextEditor {\\n\\n    private CharNode cursor = new CharNode(null, \\'|\\');\\n\\n    public void addText(String text) {\\n        for (char ch : text.toCharArray()) {\\n            CharNode node = new CharNode(cursor.prev, ch, cursor);\\n            if (cursor.prev != null) cursor.prev.next = node;\\n            cursor.prev = node;\\n        }\\n    }\\n\\n    public int deleteText(int k) {\\n        int deleted = 0;\\n        while (deleted < k && cursor.prev != null) {\\n            cursor.prev = cursor.prev.prev;\\n            deleted++;\\n        }\\n        if (cursor.prev != null) cursor.prev.next = cursor;\\n        return deleted;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        for (int i = 0; i < k; i++) {\\n            if (cursor.prev == null) break;\\n            cursor = cursor.prev;\\n        }\\n        return get10LeftChars();\\n    }\\n\\n    public String cursorRight(int k) {\\n        for (int i = 0; i < k; i++) {\\n            if (cursor.next == null) break;\\n            cursor = cursor.next;\\n        }\\n        return get10LeftChars();\\n    }\\n\\n    private String get10LeftChars() {\\n        StringBuilder sb = new StringBuilder();\\n        CharNode left = cursor.prev;\\n        for (int i = 0; i < 10; i++) {\\n            if (left == null) break;\\n            sb.append(left.val);\\n            left = left.prev;\\n        }\\n        return sb.reverse().toString();\\n    }\\n\\n    private static class CharNode {\\n        char val;\\n        CharNode prev;\\n        CharNode next;\\n\\n        CharNode(CharNode prev, char val, CharNode next) {\\n            this.prev = prev;\\n            this.val = val;\\n            this.next = next;\\n        }\\n\\n        CharNode(CharNode prev, char val) {\\n            this.prev = prev;\\n            this.val = val;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    private CharNode cursor = new CharNode(null, \\'|\\');\\n\\n    public void addText(String text) {\\n        for (char ch : text.toCharArray()) {\\n            CharNode node = new CharNode(cursor.prev, ch, cursor);\\n            if (cursor.prev != null) cursor.prev.next = node;\\n            cursor.prev = node;\\n        }\\n    }\\n\\n    public int deleteText(int k) {\\n        int deleted = 0;\\n        while (deleted < k && cursor.prev != null) {\\n            cursor.prev = cursor.prev.prev;\\n            deleted++;\\n        }\\n        if (cursor.prev != null) cursor.prev.next = cursor;\\n        return deleted;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        for (int i = 0; i < k; i++) {\\n            if (cursor.prev == null) break;\\n            cursor = cursor.prev;\\n        }\\n        return get10LeftChars();\\n    }\\n\\n    public String cursorRight(int k) {\\n        for (int i = 0; i < k; i++) {\\n            if (cursor.next == null) break;\\n            cursor = cursor.next;\\n        }\\n        return get10LeftChars();\\n    }\\n\\n    private String get10LeftChars() {\\n        StringBuilder sb = new StringBuilder();\\n        CharNode left = cursor.prev;\\n        for (int i = 0; i < 10; i++) {\\n            if (left == null) break;\\n            sb.append(left.val);\\n            left = left.prev;\\n        }\\n        return sb.reverse().toString();\\n    }\\n\\n    private static class CharNode {\\n        char val;\\n        CharNode prev;\\n        CharNode next;\\n\\n        CharNode(CharNode prev, char val, CharNode next) {\\n            this.prev = prev;\\n            this.val = val;\\n            this.next = next;\\n        }\\n\\n        CharNode(CharNode prev, char val) {\\n            this.prev = prev;\\n            this.val = val;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299333,
                "title": "easy-python-solution",
                "content": "To understand the flow just uncomment the print statements\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.text = \"\"\\n        self.pointer = 0\\n\\n    def addText(self, text: str) -> None:\\n        # print(\"addText -> \", self.pointer, end=\" -> \")\\n        if self.pointer == len(self.text) : \\n            self.text += str(text)\\n            self.pointer = len(self.text)\\n            # print(self.text, self.pointer)\\n        else : \\n            self.text = self.text[:self.pointer] + str(text) + self.text[self.pointer:]\\n            self.pointer += len(text)\\n            # print(self.text, self.pointer)\\n\\n    def deleteText(self, k: int) -> int:\\n        # print(\"deleteText -> \", self.pointer, end=\" -> \")\\n        if self.pointer - k >= 0 : \\n            self.text = self.text[:self.pointer-k] + self.text[self.pointer:]\\n            self.pointer -= k\\n            # print(self.text, self.pointer)\\n            return k\\n        else : \\n            self.text = self.text[self.pointer:]\\n            toReturn = self.pointer\\n            self.pointer = 0\\n            # print(self.text, self.pointer)\\n            return toReturn\\n\\n    def cursorLeft(self, k: int) -> str:\\n        # print(\"cursorLeft -> \", self.pointer, end=\" -> \")\\n        self.pointer -= min(k, self.pointer)\\n        # print(self.text, self.pointer)\\n        return self.text[self.pointer - min(10, self.pointer):self.pointer]\\n\\n    def cursorRight(self, k: int) -> str:\\n        # print(\"cursorRight -> \", self.pointer, end=\" -> \")\\n        toMove = len(self.text) - self.pointer \\n        self.pointer += min(toMove, k)\\n        # print(self.text, self.pointer)\\n        return self.text[self.pointer - min(10, self.pointer):self.pointer]\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.text = \"\"\\n        self.pointer = 0\\n\\n    def addText(self, text: str) -> None:\\n        # print(\"addText -> \", self.pointer, end=\" -> \")\\n        if self.pointer == len(self.text) : \\n            self.text += str(text)\\n            self.pointer = len(self.text)\\n            # print(self.text, self.pointer)\\n        else : \\n            self.text = self.text[:self.pointer] + str(text) + self.text[self.pointer:]\\n            self.pointer += len(text)\\n            # print(self.text, self.pointer)\\n\\n    def deleteText(self, k: int) -> int:\\n        # print(\"deleteText -> \", self.pointer, end=\" -> \")\\n        if self.pointer - k >= 0 : \\n            self.text = self.text[:self.pointer-k] + self.text[self.pointer:]\\n            self.pointer -= k\\n            # print(self.text, self.pointer)\\n            return k\\n        else : \\n            self.text = self.text[self.pointer:]\\n            toReturn = self.pointer\\n            self.pointer = 0\\n            # print(self.text, self.pointer)\\n            return toReturn\\n\\n    def cursorLeft(self, k: int) -> str:\\n        # print(\"cursorLeft -> \", self.pointer, end=\" -> \")\\n        self.pointer -= min(k, self.pointer)\\n        # print(self.text, self.pointer)\\n        return self.text[self.pointer - min(10, self.pointer):self.pointer]\\n\\n    def cursorRight(self, k: int) -> str:\\n        # print(\"cursorRight -> \", self.pointer, end=\" -> \")\\n        toMove = len(self.text) - self.pointer \\n        self.pointer += min(toMove, k)\\n        # print(self.text, self.pointer)\\n        return self.text[self.pointer - min(10, self.pointer):self.pointer]\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279830,
                "title": "cpp-easy",
                "content": "class TextEditor \\n{\\n    struct st\\n    {\\n      char c;\\n      st *next,*prev;\\n      \\n    };\\npublic:\\n    st *te;\\n    TextEditor() \\n    {\\n        te=new st();\\n        te->c=\\'-\\';\\n      \\n    }\\n    void addText(string text) \\n    {\\n        int i=0;\\n      while(i<text.length())\\n      {\\n          st * t=new st();\\n          t->c=text[i];\\n          if(te->prev!=NULL)\\n          {\\n              te->prev->next=t;\\n          }\\n          t->prev=te->prev;\\n          t->next=te;\\n          te->prev=t;\\n          ++i;\\n      }\\n  \\n     }\\n    \\n    \\n    int deleteText(int k) \\n    {\\n           st *s=te->prev;\\n           te->prev=NULL;\\n           int  c=0;\\n           while(k>0 && s!=NULL)\\n           {\\n               st * p=s;\\n               s=s->prev;\\n               --k;\\n               ++c;\\n               \\n               delete(p);\\n           }\\n        if(s!=NULL)\\n        {\\n            te->prev=s;\\n            s->next=te;\\n        }\\n        \\n        return c;\\n    }\\n    \\n    string cursorLeft(int k) \\n    {\\n        while(k>0 && te->prev!=NULL)\\n        {\\n            --k;\\n            te=te->prev;\\n        }\\n         string str=\"\";\\n        if(k>0)\\n        {\\n            return \"\";\\n        }\\n       \\n        k=10;\\n        st *ptr=te->prev;\\n        while(k>0 && ptr!=NULL)\\n        {\\n            str.push_back(ptr->c);\\n            ptr=ptr->prev;\\n            --k;\\n        }\\n        reverse(str.begin(),str.end());\\n      \\n        return str;\\n    }\\n    \\n    string cursorRight(int k) \\n    {\\n        while(k>0 && te->c!=\\'-\\')\\n        {\\n            --k;\\n            te=te->next;\\n        }          \\n        string str=\"\";\\n        k=10;        \\n        st *ptr=te->prev;\\n        while(k>0 && ptr!=NULL)\\n        {\\n            str.push_back(ptr->c);\\n            ptr=ptr->prev;\\n            --k;\\n        }\\n        reverse(str.begin(),str.end());\\n       \\n        return str;\\n    }\\n};",
                "solutionTags": [],
                "code": "class TextEditor \\n{\\n    struct st\\n    {\\n      char c;\\n      st *next,*prev;\\n      \\n    };\\npublic:\\n    st *te;\\n    TextEditor() \\n    {\\n        te=new st();\\n        te->c=\\'-\\';\\n      \\n    }\\n    void addText(string text) \\n    {\\n        int i=0;\\n      while(i<text.length())\\n      {\\n          st * t=new st();\\n          t->c=text[i];\\n          if(te->prev!=NULL)\\n          {\\n              te->prev->next=t;\\n          }\\n          t->prev=te->prev;\\n          t->next=te;\\n          te->prev=t;\\n          ++i;\\n      }\\n  \\n     }\\n    \\n    \\n    int deleteText(int k) \\n    {\\n           st *s=te->prev;\\n           te->prev=NULL;\\n           int  c=0;\\n           while(k>0 && s!=NULL)\\n           {\\n               st * p=s;\\n               s=s->prev;\\n               --k;\\n               ++c;\\n               \\n               delete(p);\\n           }\\n        if(s!=NULL)\\n        {\\n            te->prev=s;\\n            s->next=te;\\n        }\\n        \\n        return c;\\n    }\\n    \\n    string cursorLeft(int k) \\n    {\\n        while(k>0 && te->prev!=NULL)\\n        {\\n            --k;\\n            te=te->prev;\\n        }\\n         string str=\"\";\\n        if(k>0)\\n        {\\n            return \"\";\\n        }\\n       \\n        k=10;\\n        st *ptr=te->prev;\\n        while(k>0 && ptr!=NULL)\\n        {\\n            str.push_back(ptr->c);\\n            ptr=ptr->prev;\\n            --k;\\n        }\\n        reverse(str.begin(),str.end());\\n      \\n        return str;\\n    }\\n    \\n    string cursorRight(int k) \\n    {\\n        while(k>0 && te->c!=\\'-\\')\\n        {\\n            --k;\\n            te=te->next;\\n        }          \\n        string str=\"\";\\n        k=10;        \\n        st *ptr=te->prev;\\n        while(k>0 && ptr!=NULL)\\n        {\\n            str.push_back(ptr->c);\\n            ptr=ptr->prev;\\n            --k;\\n        }\\n        reverse(str.begin(),str.end());\\n       \\n        return str;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3268616,
                "title": "link-list-python",
                "content": "```\\nclass DLLNode:\\n    def __init__(self,char,l,r):\\n        self.char = char \\n        self.left = l\\n        self.right = r\\n\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.cursor_left = None\\n        self.cursor_right = None  \\n        \\n\\n    def addText(self, text: str) -> None:\\n        for character in text:\\n            new_char = DLLNode(character,None,None)\\n\\n            if self.cursor_left:\\n                self.cursor_left.right = new_char\\n                new_char.left = self.cursor_left\\n                self.cursor_left = new_char \\n            else:\\n                self.cursor_left = new_char\\n        \\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        while k > 0:\\n            if self.cursor_left:\\n                count += 1\\n                k -= 1\\n                self.cursor_left = self.cursor_left.left\\n                if self.cursor_left:\\n                    self.cursor_left.right = None \\n            else:\\n                break \\n        return count \\n                \\n        \\n\\n    def cursorLeft(self, k: int) -> str:\\n        while k > 0:\\n            if self.cursor_left:\\n                k -= 1\\n                temp = self.cursor_left.left\\n                self.cursor_left.right = self.cursor_right\\n                self.cursor_left.left = None \\n                self.cursor_right = self.cursor_left\\n                self.cursor_left = temp\\n                if self.cursor_left:\\n                    self.cursor_left.right = None\\n            else:\\n                break\\n        left = []\\n        p = self.cursor_left\\n        while p and len(left) < 10 :\\n            left.append(p.char)\\n            p = p.left\\n        left.reverse()\\n        return \\'\\'.join(left)\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        while k > 0:\\n            if self.cursor_right:\\n                k -= 1\\n                temp = self.cursor_right.right\\n                self.cursor_right.left = self.cursor_left\\n                self.cursor_right.right = None \\n                self.cursor_left = self.cursor_right\\n                self.cursor_right = temp \\n                if self.cursor_right:\\n                    self.cursor_right.left = None \\n            else:break\\n        left = []\\n        p = self.cursor_left\\n        while p and len(left) < 10 :\\n            left.append(p.char)\\n            p = p.left\\n        left.reverse()\\n        return \\'\\'.join(left)",
                "solutionTags": [],
                "code": "```\\nclass DLLNode:\\n    def __init__(self,char,l,r):\\n        self.char = char \\n        self.left = l\\n        self.right = r\\n\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.cursor_left = None\\n        self.cursor_right = None  \\n        \\n\\n    def addText(self, text: str) -> None:\\n        for character in text:\\n            new_char = DLLNode(character,None,None)\\n\\n            if self.cursor_left:\\n                self.cursor_left.right = new_char\\n                new_char.left = self.cursor_left\\n                self.cursor_left = new_char \\n            else:\\n                self.cursor_left = new_char\\n        \\n\\n    def deleteText(self, k: int) -> int:\\n        count = 0\\n        while k > 0:\\n            if self.cursor_left:\\n                count += 1\\n                k -= 1\\n                self.cursor_left = self.cursor_left.left\\n                if self.cursor_left:\\n                    self.cursor_left.right = None \\n            else:\\n                break \\n        return count \\n                \\n        \\n\\n    def cursorLeft(self, k: int) -> str:\\n        while k > 0:\\n            if self.cursor_left:\\n                k -= 1\\n                temp = self.cursor_left.left\\n                self.cursor_left.right = self.cursor_right\\n                self.cursor_left.left = None \\n                self.cursor_right = self.cursor_left\\n                self.cursor_left = temp\\n                if self.cursor_left:\\n                    self.cursor_left.right = None\\n            else:\\n                break\\n        left = []\\n        p = self.cursor_left\\n        while p and len(left) < 10 :\\n            left.append(p.char)\\n            p = p.left\\n        left.reverse()\\n        return \\'\\'.join(left)\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        while k > 0:\\n            if self.cursor_right:\\n                k -= 1\\n                temp = self.cursor_right.right\\n                self.cursor_right.left = self.cursor_left\\n                self.cursor_right.right = None \\n                self.cursor_left = self.cursor_right\\n                self.cursor_right = temp \\n                if self.cursor_right:\\n                    self.cursor_right.left = None \\n            else:break\\n        left = []\\n        p = self.cursor_left\\n        while p and len(left) < 10 :\\n            left.append(p.char)\\n            p = p.left\\n        left.reverse()\\n        return \\'\\'.join(left)",
                "codeTag": "Java"
            },
            {
                "id": 3266544,
                "title": "c-linkedlist-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNot the most efficient but the most intuitive IMO.\\nStacks under the hood would work in a similar way.\\n# Complexity\\n- Time complexity: O(n), where n is a max number of chars that is held in the list at the same time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIn my algo I always consider the coursor to be the Node on the left from where the coursor actually is\\n\\n# Code\\n```\\npublic class TextEditor {\\n    LinkedList<char> ll = new LinkedList<char>();\\n    LinkedListNode<char> index;\\n\\n    public TextEditor() {\\n        \\n    }\\n    \\n    public void AddText(string text) {\\n        var start = 0;\\n\\n        if(index == null) {\\n            ll.AddFirst(text[0]);\\n            index = ll.First;\\n            start = 1;\\n        }\\n\\n        for(var i = start; i < text.Length; i++) {\\n            ll.AddAfter(index, text[i]);\\n            index = index.Next;\\n        }\\n        //Console.WriteLine(Print());\\n    }\\n    \\n    public int DeleteText(int k) {\\n        var i = 0;\\n\\n        while(index != null && k-- > 0) {\\n            var toDelete = index;\\n            index = index.Previous;\\n\\n            ll.Remove(toDelete);\\n            i++;\\n        }\\n        \\n        //Console.WriteLine(Print());\\n        return i;\\n    }\\n    \\n    public string CursorLeft(int k) {\\n        while(index != null && k-- > 0) {\\n            index = index.Previous;\\n        }\\n        //Console.WriteLine(index != null ? index.Value : \"*\");\\n\\n        return GetLastChars();\\n    }\\n    \\n    public string CursorRight(int k) {\\n        if(index == null && ll.First != null) {\\n            index = ll.First;\\n            k--;\\n        }\\n\\n        while(index != null && index.Next != null && k-- > 0) {\\n            index = index.Next;\\n        }\\n\\n        //Console.WriteLine(index != null ? index.Value : \"*\");\\n        return GetLastChars();\\n    }\\n\\n    private string GetLastChars() {\\n        var tempIndex = index;\\n        var sb = new StringBuilder();\\n\\n        for(int i = 0; tempIndex != null && i < 10; i++) {\\n            sb.Append(tempIndex.Value);\\n            tempIndex = tempIndex.Previous;\\n        }\\n\\n        return new string(sb.ToString().Reverse().ToArray());\\n    }\\n\\n    private string Print() {\\n        return string.Join(\"\",ll.ToArray());\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.AddText(text);\\n * int param_2 = obj.DeleteText(k);\\n * string param_3 = obj.CursorLeft(k);\\n * string param_4 = obj.CursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class TextEditor {\\n    LinkedList<char> ll = new LinkedList<char>();\\n    LinkedListNode<char> index;\\n\\n    public TextEditor() {\\n        \\n    }\\n    \\n    public void AddText(string text) {\\n        var start = 0;\\n\\n        if(index == null) {\\n            ll.AddFirst(text[0]);\\n            index = ll.First;\\n            start = 1;\\n        }\\n\\n        for(var i = start; i < text.Length; i++) {\\n            ll.AddAfter(index, text[i]);\\n            index = index.Next;\\n        }\\n        //Console.WriteLine(Print());\\n    }\\n    \\n    public int DeleteText(int k) {\\n        var i = 0;\\n\\n        while(index != null && k-- > 0) {\\n            var toDelete = index;\\n            index = index.Previous;\\n\\n            ll.Remove(toDelete);\\n            i++;\\n        }\\n        \\n        //Console.WriteLine(Print());\\n        return i;\\n    }\\n    \\n    public string CursorLeft(int k) {\\n        while(index != null && k-- > 0) {\\n            index = index.Previous;\\n        }\\n        //Console.WriteLine(index != null ? index.Value : \"*\");\\n\\n        return GetLastChars();\\n    }\\n    \\n    public string CursorRight(int k) {\\n        if(index == null && ll.First != null) {\\n            index = ll.First;\\n            k--;\\n        }\\n\\n        while(index != null && index.Next != null && k-- > 0) {\\n            index = index.Next;\\n        }\\n\\n        //Console.WriteLine(index != null ? index.Value : \"*\");\\n        return GetLastChars();\\n    }\\n\\n    private string GetLastChars() {\\n        var tempIndex = index;\\n        var sb = new StringBuilder();\\n\\n        for(int i = 0; tempIndex != null && i < 10; i++) {\\n            sb.Append(tempIndex.Value);\\n            tempIndex = tempIndex.Previous;\\n        }\\n\\n        return new string(sb.ToString().Reverse().ToArray());\\n    }\\n\\n    private string Print() {\\n        return string.Join(\"\",ll.ToArray());\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.AddText(text);\\n * int param_2 = obj.DeleteText(k);\\n * string param_3 = obj.CursorLeft(k);\\n * string param_4 = obj.CursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266447,
                "title": "java-two-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is a medium problem tops, just need to keep in mind reverse the poll direction on right side.\\n\\nleft and right list maintain the full text, move the elment around to simulate the cursor movement\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor {\\n  private LinkedList<Character> left;\\n    private LinkedList<Character> right;\\n\\n    public TextEditor() {\\n        left = new LinkedList<>();\\n        right = new LinkedList<>();\\n    }\\n\\n    public void addText(String text) {\\n        for (char c : text.toCharArray()) {\\n            left.add(c);\\n        }\\n    }\\n\\n    public int deleteText(int k) {\\n        int actualDeleted=0;\\n        while (left.size()> 0 && k > 0) {\\n            left.removeLast();\\n            actualDeleted++;\\n            k--;\\n        }\\n        return actualDeleted;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        while (k > 0 && left.size()> 0) {\\n            right.addFirst(left.pollLast());\\n            k--;\\n        }\\n\\n        return getLastTenToTheLeft();\\n    }\\n\\n    private String getLastTenToTheLeft() {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (int i = Math.max(0, left.size() -10); i <  left.size(); i++) {\\n            stringBuilder.append(left.get(i));\\n\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n   public String cursorRight(int k) {\\n        while (k > 0 && right.size()>0) {\\n            left.add(right.pollFirst());\\n            k--;\\n        }\\n        return getLastTenToTheLeft();\\n    }\\n\\n\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n  private LinkedList<Character> left;\\n    private LinkedList<Character> right;\\n\\n    public TextEditor() {\\n        left = new LinkedList<>();\\n        right = new LinkedList<>();\\n    }\\n\\n    public void addText(String text) {\\n        for (char c : text.toCharArray()) {\\n            left.add(c);\\n        }\\n    }\\n\\n    public int deleteText(int k) {\\n        int actualDeleted=0;\\n        while (left.size()> 0 && k > 0) {\\n            left.removeLast();\\n            actualDeleted++;\\n            k--;\\n        }\\n        return actualDeleted;\\n    }\\n\\n    public String cursorLeft(int k) {\\n        while (k > 0 && left.size()> 0) {\\n            right.addFirst(left.pollLast());\\n            k--;\\n        }\\n\\n        return getLastTenToTheLeft();\\n    }\\n\\n    private String getLastTenToTheLeft() {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (int i = Math.max(0, left.size() -10); i <  left.size(); i++) {\\n            stringBuilder.append(left.get(i));\\n\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n   public String cursorRight(int k) {\\n        while (k > 0 && right.size()>0) {\\n            left.add(right.pollFirst());\\n            k--;\\n        }\\n        return getLastTenToTheLeft();\\n    }\\n\\n\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263834,
                "title": "java-solution-using-double-linked-list-stringbuilder",
                "content": "# Intuition\\nStore the cursor as a Node within a doubly linked list\\n\\n# Approach\\nImplemented the 4 operations based on the cursor Node, updating its placement when necessary by swapping it with its neighbors. We use a StringBuilder to get the text on the left of the cursor in the last 2 operations.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass TextEditor {\\n    class Node {\\n        Node prev;\\n        Node next;\\n        Character c;\\n        public Node(Character c) {\\n            this.c = c;\\n        }\\n    }\\n\\n    Node cursor;\\n\\n    public TextEditor() {\\n        cursor = new Node(\\'|\\');\\n    }\\n    \\n    public void addText(String text) {\\n        Node prev = cursor.prev;\\n        for (int i=0; i<text.length(); i++) {\\n            Character c = text.charAt(i);\\n            Node node = new Node(c);\\n            node.prev = prev;\\n            if (prev != null) prev.next = node;\\n            prev = node;\\n        }\\n        prev.next = cursor;\\n        cursor.prev = prev;\\n    }\\n    \\n    public int deleteText(int k) {\\n        int count = 0;\\n        while (k>0 && cursor.prev !=null) {\\n            cursor.prev = cursor.prev.prev;\\n            count++;\\n            k--;\\n        }\\n        if (cursor.prev != null) cursor.prev.next = cursor;\\n        return count;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while (k>0 && cursor.prev !=null) {\\n            Node prev = cursor.prev;\\n            Node next = cursor.next;\\n            \\n            cursor.next = prev;\\n            cursor.prev = prev.prev;\\n            prev.next = next;\\n            prev.prev = cursor;\\n            if (next != null) next.prev = prev;\\n            k--;\\n        }\\n\\n        if (cursor.prev != null) cursor.prev.next = cursor;\\n\\n        return getLeftText();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while (k>0 && cursor.next !=null) {\\n            Node prev = cursor.prev;\\n            Node next = cursor.next;\\n            \\n            cursor.next = next.next;\\n            cursor.prev = next;\\n            next.next = cursor;\\n            next.prev = prev;\\n            if (prev != null) prev.next = next;\\n            k--;\\n        }\\n\\n        if (cursor.next != null) cursor.next.prev = cursor;\\n\\n        return getLeftText();\\n    }\\n\\n    private String getLeftText() {\\n        StringBuilder sb = new StringBuilder();\\n\\n        Node node = cursor.prev;\\n\\n        for (int i=0; i<10; i++) {\\n            if (node == null) break;\\n            sb.append(node.c);\\n            node = node.prev;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n    class Node {\\n        Node prev;\\n        Node next;\\n        Character c;\\n        public Node(Character c) {\\n            this.c = c;\\n        }\\n    }\\n\\n    Node cursor;\\n\\n    public TextEditor() {\\n        cursor = new Node(\\'|\\');\\n    }\\n    \\n    public void addText(String text) {\\n        Node prev = cursor.prev;\\n        for (int i=0; i<text.length(); i++) {\\n            Character c = text.charAt(i);\\n            Node node = new Node(c);\\n            node.prev = prev;\\n            if (prev != null) prev.next = node;\\n            prev = node;\\n        }\\n        prev.next = cursor;\\n        cursor.prev = prev;\\n    }\\n    \\n    public int deleteText(int k) {\\n        int count = 0;\\n        while (k>0 && cursor.prev !=null) {\\n            cursor.prev = cursor.prev.prev;\\n            count++;\\n            k--;\\n        }\\n        if (cursor.prev != null) cursor.prev.next = cursor;\\n        return count;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while (k>0 && cursor.prev !=null) {\\n            Node prev = cursor.prev;\\n            Node next = cursor.next;\\n            \\n            cursor.next = prev;\\n            cursor.prev = prev.prev;\\n            prev.next = next;\\n            prev.prev = cursor;\\n            if (next != null) next.prev = prev;\\n            k--;\\n        }\\n\\n        if (cursor.prev != null) cursor.prev.next = cursor;\\n\\n        return getLeftText();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while (k>0 && cursor.next !=null) {\\n            Node prev = cursor.prev;\\n            Node next = cursor.next;\\n            \\n            cursor.next = next.next;\\n            cursor.prev = next;\\n            next.next = cursor;\\n            next.prev = prev;\\n            if (prev != null) prev.next = next;\\n            k--;\\n        }\\n\\n        if (cursor.next != null) cursor.next.prev = cursor;\\n\\n        return getLeftText();\\n    }\\n\\n    private String getLeftText() {\\n        StringBuilder sb = new StringBuilder();\\n\\n        Node node = cursor.prev;\\n\\n        for (int i=0; i<10; i++) {\\n            if (node == null) break;\\n            sb.append(node.c);\\n            node = node.prev;\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260932,
                "title": "beats-73-33-runtime-and-91-43-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor\\n{\\n    std::stack<char> left;\\n    std::stack<char> right;\\n\\npublic:\\n    TextEditor() {}\\n\\n    void addText(string text)\\n    {\\n        for (auto& c : text)\\n        {\\n            left.push(c);\\n        }\\n    }\\n\\n    int deleteText(int k)\\n    {\\n        int cnt = 0;\\n        while (!left.empty() and k > 0)\\n        {\\n            left.pop();\\n            cnt++;\\n            k--;\\n        }\\n        return cnt;\\n    }\\n\\n    std::string cursorLeft(int k)\\n    {\\n        while (!left.empty() and k > 0)\\n        {\\n            char c = left.top();\\n            left.pop();\\n            right.push(c);\\n            k--;\\n        }\\n        return cursorShiftString();\\n    }\\n\\n    std::string cursorRight(int k)\\n    {\\n        while (!right.empty() and k > 0)\\n        {\\n            char c = right.top();\\n            right.pop();\\n            left.push(c);\\n            k--;\\n        }\\n        return cursorShiftString();\\n    }\\n\\n    std::string cursorShiftString()\\n    {\\n        std::string rtn = \"\";\\n        int         cnt = 10;\\n        while (!left.empty() and cnt > 0)\\n        {\\n            char c = left.top();\\n            left.pop();\\n            rtn += c;\\n            cnt--;\\n        }\\n        std::reverse(rtn.begin(), rtn.end());\\n        for (int i = 0; i < rtn.size(); i++)\\n        {\\n            left.push(rtn[i]);\\n        }\\n        return rtn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TextEditor\\n{\\n    std::stack<char> left;\\n    std::stack<char> right;\\n\\npublic:\\n    TextEditor() {}\\n\\n    void addText(string text)\\n    {\\n        for (auto& c : text)\\n        {\\n            left.push(c);\\n        }\\n    }\\n\\n    int deleteText(int k)\\n    {\\n        int cnt = 0;\\n        while (!left.empty() and k > 0)\\n        {\\n            left.pop();\\n            cnt++;\\n            k--;\\n        }\\n        return cnt;\\n    }\\n\\n    std::string cursorLeft(int k)\\n    {\\n        while (!left.empty() and k > 0)\\n        {\\n            char c = left.top();\\n            left.pop();\\n            right.push(c);\\n            k--;\\n        }\\n        return cursorShiftString();\\n    }\\n\\n    std::string cursorRight(int k)\\n    {\\n        while (!right.empty() and k > 0)\\n        {\\n            char c = right.top();\\n            right.pop();\\n            left.push(c);\\n            k--;\\n        }\\n        return cursorShiftString();\\n    }\\n\\n    std::string cursorShiftString()\\n    {\\n        std::string rtn = \"\";\\n        int         cnt = 10;\\n        while (!left.empty() and cnt > 0)\\n        {\\n            char c = left.top();\\n            left.pop();\\n            rtn += c;\\n            cnt--;\\n        }\\n        std::reverse(rtn.begin(), rtn.end());\\n        for (int i = 0; i < rtn.size(); i++)\\n        {\\n            left.push(rtn[i]);\\n        }\\n        return rtn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224635,
                "title": "java-using-two-stacks-clean-code",
                "content": "# Intuition\\nUsed 2 stacks naming left and right. Add or delete text to left stack. If moving cursor, move elements from left to right stack or right to left stack for left/right movement.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor {\\n    private Deque<Character> leftStack;\\n    private Deque<Character> rightStack;\\n\\n    public TextEditor() {\\n        leftStack = new ArrayDeque<>();\\n        rightStack = new ArrayDeque<>();    \\n    }\\n    \\n    public void addText(String text) {\\n        for (char c : text.toCharArray()) {\\n            leftStack.addFirst(c);\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int delCount = 0;\\n        while (!leftStack.isEmpty() && k-- > 0) {\\n            leftStack.removeFirst();\\n            delCount++;\\n        }\\n        return delCount;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while (!leftStack.isEmpty() && k-- > 0) {\\n            rightStack.addFirst(leftStack.removeFirst());\\n        }\\n        StringBuilder res = new StringBuilder();\\n        int count = 0;\\n        for (Iterator itr = leftStack.iterator(); count < 10 && itr.hasNext(); count++) {\\n            res.append(itr.next());\\n        }\\n        return res.reverse().toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while (!rightStack.isEmpty() && k-- > 0) {\\n            leftStack.addFirst(rightStack.removeFirst());\\n        }\\n        StringBuilder res = new StringBuilder();\\n        int count = 0;\\n        for (Iterator itr = leftStack.iterator(); count < 10 && itr.hasNext(); count++) {\\n            res.append(itr.next());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n    private Deque<Character> leftStack;\\n    private Deque<Character> rightStack;\\n\\n    public TextEditor() {\\n        leftStack = new ArrayDeque<>();\\n        rightStack = new ArrayDeque<>();    \\n    }\\n    \\n    public void addText(String text) {\\n        for (char c : text.toCharArray()) {\\n            leftStack.addFirst(c);\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int delCount = 0;\\n        while (!leftStack.isEmpty() && k-- > 0) {\\n            leftStack.removeFirst();\\n            delCount++;\\n        }\\n        return delCount;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while (!leftStack.isEmpty() && k-- > 0) {\\n            rightStack.addFirst(leftStack.removeFirst());\\n        }\\n        StringBuilder res = new StringBuilder();\\n        int count = 0;\\n        for (Iterator itr = leftStack.iterator(); count < 10 && itr.hasNext(); count++) {\\n            res.append(itr.next());\\n        }\\n        return res.reverse().toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while (!rightStack.isEmpty() && k-- > 0) {\\n            leftStack.addFirst(rightStack.removeFirst());\\n        }\\n        StringBuilder res = new StringBuilder();\\n        int count = 0;\\n        for (Iterator itr = leftStack.iterator(); count < 10 && itr.hasNext(); count++) {\\n            res.append(itr.next());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220061,
                "title": "concise-python-two-stacks-solution",
                "content": "Basically posting this because a lot of the two stacks solutions were unecessarily verbose.  This is readable, pythonic, and short.\\n\\n# Intuition\\ntwo lists used stack-like representing left of cursor and right of cursor.  \\n\\n# Approach\\nI\\'ll just put details here relevant to other two stacks solutions that are more verbose.\\n- `extend` can handle a string just fine.  Don\\'t need to make it a list, don\\'t need to explicitly iterate.\\n- `slicing` from the end is I THINK faster than iteratively popping.  Or maybe it\\'s supposed to be `del list[-x:]`.  In anycase, there\\'s a faster option than iteratively popping.\\n- regardless of whether you use `del list[-x:]` or `list[-x:]=[]`, you don\\'t need to do a length check as slicing \"too much\" just returns however much there is.  With that, this means you can write SHORTER CODE! Huzzah! (But still readable!)\\n\\n# Complexity\\n- Time complexity:\\nO(k) on any method.  \\n\\n- Space complexity:\\nO(text)\\n\\n# Code\\n```\\nclass TextEditor:\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        self.left.extend(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        rem = min(len(self.left),k)\\n        self.left[-k:]=[]\\n        return rem\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(min(k, len(self.left))):\\n            self.right.append(self.left.pop())\\n        return \\'\\'.join(self.left[-10:])\\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(min(k, len(self.right))):\\n            self.left.append(self.right.pop())\\n        return \\'\\'.join(self.left[-10:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n    def __init__(self):\\n        self.left = []\\n        self.right = []\\n\\n    def addText(self, text: str) -> None:\\n        self.left.extend(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        rem = min(len(self.left),k)\\n        self.left[-k:]=[]\\n        return rem\\n\\n    def cursorLeft(self, k: int) -> str:\\n        for _ in range(min(k, len(self.left))):\\n            self.right.append(self.left.pop())\\n        return \\'\\'.join(self.left[-10:])\\n\\n    def cursorRight(self, k: int) -> str:\\n        for _ in range(min(k, len(self.right))):\\n            self.left.append(self.right.pop())\\n        return \\'\\'.join(self.left[-10:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135186,
                "title": "very-simple-stack-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will have 2 stacks for left side of cursor and right side of cursor , so whenever we want to delete we cam delete from left stack and if we add we can add to left stack and to move cursor we can move chars from left to right .\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TextEditor {\\npublic:\\n    stack<char> left, right;\\n    string ans;\\n    TextEditor(){\\n    }\\n    \\n    void addText(string text){\\n        for(char c: text){\\n            left.push(c);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int t = 0;\\n        while(!left.empty() && k > 0){\\n            left.pop(); t++,k--;\\n        }\\n        return t;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        ans = \"\"; // we have to take only 10 or len substring to left of left curser\\n        while(!left.empty() && k>0){\\n            right.push(left.top());\\n            left.pop();\\n            k--;\\n        }\\n        for(int cnt = 0; !left.empty() && cnt < 10; cnt++, left.pop()){\\n            ans = left.top() + ans;\\n        }\\n        for(char c: ans){\\n            left.push(c);\\n        }\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        ans = \"\";\\n        while(!right.empty() && k>0){\\n            left.push(right.top());\\n            right.pop();\\n            k--;\\n        }\\n        for(int cnt = 0; !left.empty() && cnt < 10; cnt++, left.pop()){\\n            ans = left.top() + ans;\\n        }\\n        for(char c: ans){\\n            left.push(c);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor {\\npublic:\\n    stack<char> left, right;\\n    string ans;\\n    TextEditor(){\\n    }\\n    \\n    void addText(string text){\\n        for(char c: text){\\n            left.push(c);\\n        }\\n    }\\n    \\n    int deleteText(int k) {\\n        int t = 0;\\n        while(!left.empty() && k > 0){\\n            left.pop(); t++,k--;\\n        }\\n        return t;\\n    }\\n    \\n    string cursorLeft(int k) {\\n        ans = \"\"; // we have to take only 10 or len substring to left of left curser\\n        while(!left.empty() && k>0){\\n            right.push(left.top());\\n            left.pop();\\n            k--;\\n        }\\n        for(int cnt = 0; !left.empty() && cnt < 10; cnt++, left.pop()){\\n            ans = left.top() + ans;\\n        }\\n        for(char c: ans){\\n            left.push(c);\\n        }\\n        return ans;\\n    }\\n    \\n    string cursorRight(int k) {\\n        ans = \"\";\\n        while(!right.empty() && k>0){\\n            left.push(right.top());\\n            right.pop();\\n            k--;\\n        }\\n        for(int cnt = 0; !left.empty() && cnt < 10; cnt++, left.pop()){\\n            ans = left.top() + ans;\\n        }\\n        for(char c: ans){\\n            left.push(c);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor* obj = new TextEditor();\\n * obj->addText(text);\\n * int param_2 = obj->deleteText(k);\\n * string param_3 = obj->cursorLeft(k);\\n * string param_4 = obj->cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122001,
                "title": "elixir-double-stack",
                "content": "# Code\\n```elixir\\ndefmodule TextEditor do\\n  use GenServer\\n\\n  @spec init_() :: any\\n  def init_() do\\n    GenServer.start_link(__MODULE__, nil, [name: __MODULE__])\\n    GenServer.call(__MODULE__, :reset)\\n  end\\n\\n  @spec add_text(text :: String.t) :: any\\n  def add_text(text) do\\n    GenServer.call(__MODULE__, {:add, text})\\n  end\\n\\n  @spec delete_text(k :: integer) :: integer\\n  def delete_text(k) do\\n    GenServer.call(__MODULE__, {:delete, k})\\n  end\\n\\n  @spec cursor_left(k :: integer) :: String.t\\n  def cursor_left(k) do\\n    GenServer.call(__MODULE__, {:goLeft, k})\\n  end\\n\\n  @spec cursor_right(k :: integer) :: String.t\\n  def cursor_right(k) do\\n    GenServer.call(__MODULE__, {:goRight, k})\\n  end\\n\\n  @impl true\\n  def init(_) do\\n    {:ok, nil}\\n  end\\n\\n  @impl true\\n  def handle_call(:reset, _, _) do\\n    {:reply, true, {[], []}}\\n  end\\n\\n  def handle_call({:add, text}, _, state) do\\n    state =\\n      String.codepoints(text)\\n      |> Enum.reduce(state, fn ch, {back, front} ->\\n        {[ch | back], front}\\n      end)\\n    {:reply, true, state}\\n  end\\n\\n  def handle_call({:delete, k}, _, state) do\\n    {i, state} = delete(state, 0, k)\\n    {:reply, i, state}\\n  end\\n\\n  def handle_call({:goLeft, k}, _, state) do\\n    {back, front} = go_left(state, k)\\n    {:reply, print_last_10(back), {back, front}}\\n  end\\n\\n  def handle_call({:goRight, k}, _, state) do\\n    {back, front} = go_right(state, k)\\n    {:reply, print_last_10(back), {back, front}}\\n  end\\n\\n  defp delete(state, k, k), do: {k, state}\\n  defp delete({[], _} = state, i, _), do: {i, state}\\n  defp delete({[_ | back], front}, i, k) do\\n    delete({back, front}, i + 1, k)\\n  end\\n\\n  defp go_left(state, 0), do: state\\n  defp go_left({[], _} = state, _), do: state\\n  defp go_left({[ch | back], front}, k) do\\n    go_left({back, [ch | front]}, k - 1)\\n  end\\n\\n  defp go_right(state, 0), do: state\\n  defp go_right({_, []} = state, _), do: state\\n  defp go_right({back, [ch | front]}, k) do\\n    go_right({[ch | back], front}, k - 1)\\n  end\\n\\n  defp print_last_10(back) do\\n    Enum.take(back, 10)\\n    |> Enum.reverse()\\n    |> to_string()\\n  end\\nend\\n\\n# Your functions will be called as such:\\n# TextEditor.init_()\\n# TextEditor.add_text(text)\\n# param_2 = TextEditor.delete_text(k)\\n# param_3 = TextEditor.cursor_left(k)\\n# param_4 = TextEditor.cursor_right(k)\\n\\n# TextEditor.init_ will be called before every test case, in which you can do some necessary initializations.\\n```",
                "solutionTags": [
                    "Elixir",
                    "Stack"
                ],
                "code": "```elixir\\ndefmodule TextEditor do\\n  use GenServer\\n\\n  @spec init_() :: any\\n  def init_() do\\n    GenServer.start_link(__MODULE__, nil, [name: __MODULE__])\\n    GenServer.call(__MODULE__, :reset)\\n  end\\n\\n  @spec add_text(text :: String.t) :: any\\n  def add_text(text) do\\n    GenServer.call(__MODULE__, {:add, text})\\n  end\\n\\n  @spec delete_text(k :: integer) :: integer\\n  def delete_text(k) do\\n    GenServer.call(__MODULE__, {:delete, k})\\n  end\\n\\n  @spec cursor_left(k :: integer) :: String.t\\n  def cursor_left(k) do\\n    GenServer.call(__MODULE__, {:goLeft, k})\\n  end\\n\\n  @spec cursor_right(k :: integer) :: String.t\\n  def cursor_right(k) do\\n    GenServer.call(__MODULE__, {:goRight, k})\\n  end\\n\\n  @impl true\\n  def init(_) do\\n    {:ok, nil}\\n  end\\n\\n  @impl true\\n  def handle_call(:reset, _, _) do\\n    {:reply, true, {[], []}}\\n  end\\n\\n  def handle_call({:add, text}, _, state) do\\n    state =\\n      String.codepoints(text)\\n      |> Enum.reduce(state, fn ch, {back, front} ->\\n        {[ch | back], front}\\n      end)\\n    {:reply, true, state}\\n  end\\n\\n  def handle_call({:delete, k}, _, state) do\\n    {i, state} = delete(state, 0, k)\\n    {:reply, i, state}\\n  end\\n\\n  def handle_call({:goLeft, k}, _, state) do\\n    {back, front} = go_left(state, k)\\n    {:reply, print_last_10(back), {back, front}}\\n  end\\n\\n  def handle_call({:goRight, k}, _, state) do\\n    {back, front} = go_right(state, k)\\n    {:reply, print_last_10(back), {back, front}}\\n  end\\n\\n  defp delete(state, k, k), do: {k, state}\\n  defp delete({[], _} = state, i, _), do: {i, state}\\n  defp delete({[_ | back], front}, i, k) do\\n    delete({back, front}, i + 1, k)\\n  end\\n\\n  defp go_left(state, 0), do: state\\n  defp go_left({[], _} = state, _), do: state\\n  defp go_left({[ch | back], front}, k) do\\n    go_left({back, [ch | front]}, k - 1)\\n  end\\n\\n  defp go_right(state, 0), do: state\\n  defp go_right({_, []} = state, _), do: state\\n  defp go_right({back, [ch | front]}, k) do\\n    go_right({[ch | back], front}, k - 1)\\n  end\\n\\n  defp print_last_10(back) do\\n    Enum.take(back, 10)\\n    |> Enum.reverse()\\n    |> to_string()\\n  end\\nend\\n\\n# Your functions will be called as such:\\n# TextEditor.init_()\\n# TextEditor.add_text(text)\\n# param_2 = TextEditor.delete_text(k)\\n# param_3 = TextEditor.cursor_left(k)\\n# param_4 = TextEditor.cursor_right(k)\\n\\n# TextEditor.init_ will be called before every test case, in which you can do some necessary initializations.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3115456,
                "title": "two-stack-swift-solution",
                "content": "```\\nclass TextEditor {\\n\\n    var left: [Character]\\n    var right: [Character]\\n    var cursor = 0\\n    init() {\\n        self.left = []\\n        self.right = []\\n        self.cursor = 0\\n    }\\n    \\n    func addText(_ text: String) {\\n       for c in text {\\n           left.append(c)\\n       }\\n    }\\n    \\n    func deleteText(_ k: Int) -> Int {\\n        var n = k\\n        while n > 0 && !left.isEmpty {\\n            left.removeLast()\\n            n -= 1\\n        }\\n        return n == 0 ? k : k - n\\n    }\\n    \\n    func cursorLeft(_ k: Int) -> String {\\n        var k = k\\n        while k > 0 && !left.isEmpty {\\n            let a = left.removeLast()\\n            right.append(a)\\n            k -= 1\\n        }\\n        let n = left.count, start = n - min(10,n)\\n        return String(left[start..<left.count])\\n    }\\n    \\n    func cursorRight(_ k: Int) -> String {\\n        var k = k\\n        while k > 0 && !right.isEmpty {\\n            let b = right.removeLast()\\n            left.append(b)\\n            k -= 1\\n        }\\n        let n = left.count, start = n - min(10,n)\\n        return String(left[start..<left.count])\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * let obj = TextEditor()\\n * obj.addText(text)\\n * let ret_2: Int = obj.deleteText(k)\\n * let ret_3: String = obj.cursorLeft(k)\\n * let ret_4: String = obj.cursorRight(k)\\n */\\n```",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    var left: [Character]\\n    var right: [Character]\\n    var cursor = 0\\n    init() {\\n        self.left = []\\n        self.right = []\\n        self.cursor = 0\\n    }\\n    \\n    func addText(_ text: String) {\\n       for c in text {\\n           left.append(c)\\n       }\\n    }\\n    \\n    func deleteText(_ k: Int) -> Int {\\n        var n = k\\n        while n > 0 && !left.isEmpty {\\n            left.removeLast()\\n            n -= 1\\n        }\\n        return n == 0 ? k : k - n\\n    }\\n    \\n    func cursorLeft(_ k: Int) -> String {\\n        var k = k\\n        while k > 0 && !left.isEmpty {\\n            let a = left.removeLast()\\n            right.append(a)\\n            k -= 1\\n        }\\n        let n = left.count, start = n - min(10,n)\\n        return String(left[start..<left.count])\\n    }\\n    \\n    func cursorRight(_ k: Int) -> String {\\n        var k = k\\n        while k > 0 && !right.isEmpty {\\n            let b = right.removeLast()\\n            left.append(b)\\n            k -= 1\\n        }\\n        let n = left.count, start = n - min(10,n)\\n        return String(left[start..<left.count])\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * let obj = TextEditor()\\n * obj.addText(text)\\n * let ret_2: Int = obj.deleteText(k)\\n * let ret_3: String = obj.cursorLeft(k)\\n * let ret_4: String = obj.cursorRight(k)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102491,
                "title": "java-simple-and-easy",
                "content": "### Code\\n```\\nclass TextEditor {\\n\\n    private StringBuilder txt;\\n    private int cursor;\\n\\n    public TextEditor() {\\n        txt = new StringBuilder();\\n        cursor = 0;\\n    }\\n    \\n    public void addText(String text) {\\n        txt.insert(cursor, text);\\n        cursor += text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int c = cursor;\\n        cursor = cursor - k < 0 ? 0 : cursor - k;\\n        txt.delete(cursor, c);\\n        return c - cursor;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor = cursor - k < 0 ? 0 : cursor - k;\\n        return txt.substring(Math.max(cursor - 10, 0), cursor);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        cursor = cursor + k > txt.length() ? txt.length() : cursor + k;\\n        return txt.substring(Math.max(cursor - 10, 0), cursor);\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    private StringBuilder txt;\\n    private int cursor;\\n\\n    public TextEditor() {\\n        txt = new StringBuilder();\\n        cursor = 0;\\n    }\\n    \\n    public void addText(String text) {\\n        txt.insert(cursor, text);\\n        cursor += text.length();\\n    }\\n    \\n    public int deleteText(int k) {\\n        int c = cursor;\\n        cursor = cursor - k < 0 ? 0 : cursor - k;\\n        txt.delete(cursor, c);\\n        return c - cursor;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        cursor = cursor - k < 0 ? 0 : cursor - k;\\n        return txt.substring(Math.max(cursor - 10, 0), cursor);\\n    }\\n    \\n    public String cursorRight(int k) {\\n        cursor = cursor + k > txt.length() ? txt.length() : cursor + k;\\n        return txt.substring(Math.max(cursor - 10, 0), cursor);\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060025,
                "title": "python-stack-and-queue",
                "content": "# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.q = []\\n\\n    def addText(self, text: str) -> None:\\n        self.l.extend([*text])\\n\\n    def deleteText(self, k: int) -> int:\\n        for i in range(k):\\n            if len(self.l):\\n                self.l.pop(-1)\\n            else:\\n                return i\\n        return i+1\\n\\n    def cursorLeft(self, k: int) -> str:\\n        i=0\\n        while self.l and i<k:\\n            self.q.append(self.l.pop(-1))\\n            i+=1\\n        return \"\".join(self.l[-10:]) if len(self.l)>=10 else \"\".join(self.l)\\n    def cursorRight(self, k: int) -> str:\\n        i=0\\n        while self.q and i<k:\\n            self.l.append(self.q.pop(-1))\\n            i+=1\\n        return \"\".join(self.l[-10:]) if len(self.l)>=10 else \"\".join(self.l)\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.q = []\\n\\n    def addText(self, text: str) -> None:\\n        self.l.extend([*text])\\n\\n    def deleteText(self, k: int) -> int:\\n        for i in range(k):\\n            if len(self.l):\\n                self.l.pop(-1)\\n            else:\\n                return i\\n        return i+1\\n\\n    def cursorLeft(self, k: int) -> str:\\n        i=0\\n        while self.l and i<k:\\n            self.q.append(self.l.pop(-1))\\n            i+=1\\n        return \"\".join(self.l[-10:]) if len(self.l)>=10 else \"\".join(self.l)\\n    def cursorRight(self, k: int) -> str:\\n        i=0\\n        while self.q and i<k:\\n            self.l.append(self.q.pop(-1))\\n            i+=1\\n        return \"\".join(self.l[-10:]) if len(self.l)>=10 else \"\".join(self.l)\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033341,
                "title": "o-k-solution-java",
                "content": "class Node \\n{\\n    char val;\\n    Node next;\\n    Node prev;\\n    Node(char val)\\n    {\\n        this.val=val;:\\n        this.next=null;\\n        this.prev=null;\\n    }\\n}\\nclass TextEditor {\\n    Node cursor;\\n    public TextEditor() {\\n        cursor=new Node(\\'|\\');\\n    }\\n    \\n    public void addText(String text) {\\n        for(int i=0;i<text.length();i++)\\n        {\\n            Node node=new Node(text.charAt(i));\\n            if(cursor.prev!=null)\\n            {\\n                cursor.prev.next=node;\\n            }\\n            node.prev=cursor.prev;\\n            node.next=cursor;\\n            cursor.prev=node;\\n        }\\n        \\n    }\\n    \\n    public int deleteText(int k) {\\n          int actCount=0;\\n          while(actCount<k&&cursor.prev!=null&&cursor.prev.prev!=null)\\n          {\\n              cursor.prev.prev.next=cursor;\\n              cursor.prev=cursor.prev.prev;\\n              ++actCount;\\n          }\\n        if(cursor.prev!=null&&actCount<k)\\n        {\\n            cursor.prev=null;\\n            ++actCount;\\n        }\\n        return actCount;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n           while(cursor.prev!=null&&(k--)>0)\\n           {   \\n               Node temp=cursor.prev;\\n               boolean isPrevNull=false;\\n               if(cursor.prev.prev!=null)\\n               {\\n                   cursor.prev.prev.next=cursor;\\n                   cursor.prev=cursor.prev.prev;\\n               }\\n               else\\n               {\\n                   isPrevNull=true;\\n               }\\n               temp.next=cursor.next;\\n               if(cursor.next!=null)\\n               {\\n                   cursor.next.prev=temp;\\n               }\\n               cursor.next=temp;\\n               temp.prev=cursor;\\n               if(isPrevNull)\\n               {\\n                   cursor.prev=null;\\n               }\\n           }\\n        int i=0;\\n        Node temp=cursor;\\n        String res=\"\";\\n        \\n        while(i<10&&temp.prev!=null)\\n        { \\n         res=String.valueOf(temp.prev.val)+res;\\n            ++i;\\n            temp=temp.prev;\\n        }\\n        return res;\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while(cursor.next!=null&&(k--)>0)\\n        {   \\n            Node temp=cursor.next;\\n            boolean isRightNull=false;\\n            if(cursor.next.next!=null)\\n            {\\n                cursor.next.next.prev=cursor;\\n                cursor.next=cursor.next.next;\\n            }\\n            else\\n            {\\n                isRightNull=true;\\n            }\\n            temp.prev=cursor.prev;\\n            if(cursor.prev!=null)\\n            {\\n                cursor.prev.next=temp;\\n            }\\n            cursor.prev=temp;\\n            temp.next=cursor;\\n            if(isRightNull)\\n            {\\n                cursor.next=null;\\n            }\\n        }\\n        int i=0;\\n        Node temp=cursor;\\n        String res=\"\";\\n        while(i<10&&temp.prev!=null)\\n        {\\n            res=String.valueOf(temp.prev.val)+res;\\n            ++i;\\n            temp=temp.prev;\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */",
                "solutionTags": [],
                "code": "class Node \\n{\\n    char val;\\n    Node next;\\n    Node prev;\\n    Node(char val)\\n    {\\n        this.val=val;:\\n        this.next=null;\\n        this.prev=null;\\n    }\\n}\\nclass TextEditor {\\n    Node cursor;\\n    public TextEditor() {\\n        cursor=new Node(\\'|\\');\\n    }\\n    \\n    public void addText(String text) {\\n        for(int i=0;i<text.length();i++)\\n        {\\n            Node node=new Node(text.charAt(i));\\n            if(cursor.prev!=null)\\n            {\\n                cursor.prev.next=node;\\n            }\\n            node.prev=cursor.prev;\\n            node.next=cursor;\\n            cursor.prev=node;\\n        }\\n        \\n    }\\n    \\n    public int deleteText(int k) {\\n          int actCount=0;\\n          while(actCount<k&&cursor.prev!=null&&cursor.prev.prev!=null)\\n          {\\n              cursor.prev.prev.next=cursor;\\n              cursor.prev=cursor.prev.prev;\\n              ++actCount;\\n          }\\n        if(cursor.prev!=null&&actCount<k)\\n        {\\n            cursor.prev=null;\\n            ++actCount;\\n        }\\n        return actCount;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n           while(cursor.prev!=null&&(k--)>0)\\n           {   \\n               Node temp=cursor.prev;\\n               boolean isPrevNull=false;\\n               if(cursor.prev.prev!=null)\\n               {\\n                   cursor.prev.prev.next=cursor;\\n                   cursor.prev=cursor.prev.prev;\\n               }\\n               else\\n               {\\n                   isPrevNull=true;\\n               }\\n               temp.next=cursor.next;\\n               if(cursor.next!=null)\\n               {\\n                   cursor.next.prev=temp;\\n               }\\n               cursor.next=temp;\\n               temp.prev=cursor;\\n               if(isPrevNull)\\n               {\\n                   cursor.prev=null;\\n               }\\n           }\\n        int i=0;\\n        Node temp=cursor;\\n        String res=\"\";\\n        \\n        while(i<10&&temp.prev!=null)\\n        { \\n         res=String.valueOf(temp.prev.val)+res;\\n            ++i;\\n            temp=temp.prev;\\n        }\\n        return res;\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while(cursor.next!=null&&(k--)>0)\\n        {   \\n            Node temp=cursor.next;\\n            boolean isRightNull=false;\\n            if(cursor.next.next!=null)\\n            {\\n                cursor.next.next.prev=cursor;\\n                cursor.next=cursor.next.next;\\n            }\\n            else\\n            {\\n                isRightNull=true;\\n            }\\n            temp.prev=cursor.prev;\\n            if(cursor.prev!=null)\\n            {\\n                cursor.prev.next=temp;\\n            }\\n            cursor.prev=temp;\\n            temp.next=cursor;\\n            if(isRightNull)\\n            {\\n                cursor.next=null;\\n            }\\n        }\\n        int i=0;\\n        Node temp=cursor;\\n        String res=\"\";\\n        while(i<10&&temp.prev!=null)\\n        {\\n            res=String.valueOf(temp.prev.val)+res;\\n            ++i;\\n            temp=temp.prev;\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your TextEditor object will be instantiated and called as such:\\n * TextEditor obj = new TextEditor();\\n * obj.addText(text);\\n * int param_2 = obj.deleteText(k);\\n * String param_3 = obj.cursorLeft(k);\\n * String param_4 = obj.cursorRight(k);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3027311,
                "title": "python-solution-o-n-by-chatgpt",
                "content": "# Intuition\\nGenerated by ChatGPT\\n\\n# Approach\\nGenerated by ChatGPT\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.text = \\'\\'\\n        self.cursor_position = 0\\n\\n\\n    def addText(self, text: str) -> None:\\n        self.text = self.text[:self.cursor_position] + text + self.text[self.cursor_position:]\\n        self.cursor_position += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        deleted_chars = min(k, self.cursor_position)\\n        self.text = self.text[:self.cursor_position - deleted_chars] + self.text[self.cursor_position:]\\n        self.cursor_position -= deleted_chars\\n        return deleted_chars\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor_position = max(0, self.cursor_position - k)\\n        return self.text[self.cursor_position - min(10, self.cursor_position):self.cursor_position]\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor_position = min(len(self.text), self.cursor_position + k)\\n        return self.text[self.cursor_position - min(10, self.cursor_position):self.cursor_position]\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.text = \\'\\'\\n        self.cursor_position = 0\\n\\n\\n    def addText(self, text: str) -> None:\\n        self.text = self.text[:self.cursor_position] + text + self.text[self.cursor_position:]\\n        self.cursor_position += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        deleted_chars = min(k, self.cursor_position)\\n        self.text = self.text[:self.cursor_position - deleted_chars] + self.text[self.cursor_position:]\\n        self.cursor_position -= deleted_chars\\n        return deleted_chars\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor_position = max(0, self.cursor_position - k)\\n        return self.text[self.cursor_position - min(10, self.cursor_position):self.cursor_position]\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor_position = min(len(self.text), self.cursor_position + k)\\n        return self.text[self.cursor_position - min(10, self.cursor_position):self.cursor_position]\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027310,
                "title": "python-solution-o-n-by-chatgpt",
                "content": "# Intuition\\nGenerated by ChatGPT\\n\\n# Approach\\nGenerated by ChatGPT\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.text = \\'\\'\\n        self.cursor_position = 0\\n\\n\\n    def addText(self, text: str) -> None:\\n        self.text = self.text[:self.cursor_position] + text + self.text[self.cursor_position:]\\n        self.cursor_position += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        deleted_chars = min(k, self.cursor_position)\\n        self.text = self.text[:self.cursor_position - deleted_chars] + self.text[self.cursor_position:]\\n        self.cursor_position -= deleted_chars\\n        return deleted_chars\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor_position = max(0, self.cursor_position - k)\\n        return self.text[self.cursor_position - min(10, self.cursor_position):self.cursor_position]\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor_position = min(len(self.text), self.cursor_position + k)\\n        return self.text[self.cursor_position - min(10, self.cursor_position):self.cursor_position]\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TextEditor:\\n\\n    def __init__(self):\\n        self.text = \\'\\'\\n        self.cursor_position = 0\\n\\n\\n    def addText(self, text: str) -> None:\\n        self.text = self.text[:self.cursor_position] + text + self.text[self.cursor_position:]\\n        self.cursor_position += len(text)\\n\\n    def deleteText(self, k: int) -> int:\\n        deleted_chars = min(k, self.cursor_position)\\n        self.text = self.text[:self.cursor_position - deleted_chars] + self.text[self.cursor_position:]\\n        self.cursor_position -= deleted_chars\\n        return deleted_chars\\n\\n    def cursorLeft(self, k: int) -> str:\\n        self.cursor_position = max(0, self.cursor_position - k)\\n        return self.text[self.cursor_position - min(10, self.cursor_position):self.cursor_position]\\n        \\n\\n    def cursorRight(self, k: int) -> str:\\n        self.cursor_position = min(len(self.text), self.cursor_position + k)\\n        return self.text[self.cursor_position - min(10, self.cursor_position):self.cursor_position]\\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016001,
                "title": "java-my-doubly-linkedlist-solution",
                "content": "# Code\\n```\\nclass TextEditor {\\n\\n    class Node {\\n        Node left, right;\\n        char letter;\\n        Node() {}\\n        Node(char letter) {\\n            this.letter = letter;\\n        }\\n    }\\n\\n    private Node head, tail, cursor;\\n\\n    public TextEditor() {\\n        this.head = new Node(\\' \\');\\n        this.cursor = this.head;\\n        this.tail = this.head;\\n    }\\n    \\n    public void addText(String text) {\\n        // generate new text Nodes first\\n        Node dummyHead = new Node();\\n        Node textTail = dummyHead;\\n        for (char c : text.toCharArray()) {\\n            textTail.right = new Node(c);\\n            textTail.right.left = textTail;\\n            textTail = textTail.right;\\n        }\\n        Node textHead = dummyHead.right; \\n\\n        if (cursor.right != null) {\\n            /* insert text into the middle */\\n            Node next = cursor.right;\\n            cursor.right = textHead;\\n            textTail.right = next;\\n            cursor.right.left = cursor;\\n            textTail.right.left = textTail;\\n\\n            // move the cursor\\n            cursor = textTail;\\n        } else {\\n            /* append the text at the end */\\n            cursor.right = textHead;\\n            cursor.right.left = cursor;\\n\\n            // move the cursor and keep tail being consistant\\n            cursor = textTail;\\n            tail = cursor;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int numDeleted = 0;\\n        // keep the cursor\\'s right nodes first\\n        Node next = cursor.right;\\n        while (k > 0 && cursor != head) {\\n            cursor = cursor.left;\\n            cursor.right = null;\\n            k -= 1;\\n            numDeleted += 1;\\n        }\\n        // connect the cursor with the original right nodes\\n        cursor.right = next;\\n        \\n        if (next == null) {\\n            // if previously cursor is at the tail, then move tail currently\\n            tail = cursor;\\n        } else {\\n            next.left = cursor;\\n        }\\n        return numDeleted;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while (k > 0 && cursor.left != null) {\\n            cursor = cursor.left;\\n            k -= 1;\\n        }\\n        Node pointer = cursor;\\n        int ub = 10;\\n        StringBuilder builder = new StringBuilder();\\n        while (pointer != head && ub > 0) {\\n            builder.append(pointer.letter);\\n            pointer = pointer.left;\\n            ub -= 1;\\n        }\\n        return builder.reverse().toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while (k > 0 && cursor.right != null) {\\n            cursor = cursor.right;\\n            k -= 1;\\n        }\\n        Node pointer = cursor;\\n        int ub = 10;\\n        StringBuilder builder = new StringBuilder();\\n        while (pointer != head && ub > 0) {\\n            builder.append(pointer.letter);\\n            pointer = pointer.left;\\n            ub -= 1;\\n        }\\n        return builder.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Doubly-Linked List"
                ],
                "code": "```\\nclass TextEditor {\\n\\n    class Node {\\n        Node left, right;\\n        char letter;\\n        Node() {}\\n        Node(char letter) {\\n            this.letter = letter;\\n        }\\n    }\\n\\n    private Node head, tail, cursor;\\n\\n    public TextEditor() {\\n        this.head = new Node(\\' \\');\\n        this.cursor = this.head;\\n        this.tail = this.head;\\n    }\\n    \\n    public void addText(String text) {\\n        // generate new text Nodes first\\n        Node dummyHead = new Node();\\n        Node textTail = dummyHead;\\n        for (char c : text.toCharArray()) {\\n            textTail.right = new Node(c);\\n            textTail.right.left = textTail;\\n            textTail = textTail.right;\\n        }\\n        Node textHead = dummyHead.right; \\n\\n        if (cursor.right != null) {\\n            /* insert text into the middle */\\n            Node next = cursor.right;\\n            cursor.right = textHead;\\n            textTail.right = next;\\n            cursor.right.left = cursor;\\n            textTail.right.left = textTail;\\n\\n            // move the cursor\\n            cursor = textTail;\\n        } else {\\n            /* append the text at the end */\\n            cursor.right = textHead;\\n            cursor.right.left = cursor;\\n\\n            // move the cursor and keep tail being consistant\\n            cursor = textTail;\\n            tail = cursor;\\n        }\\n    }\\n    \\n    public int deleteText(int k) {\\n        int numDeleted = 0;\\n        // keep the cursor\\'s right nodes first\\n        Node next = cursor.right;\\n        while (k > 0 && cursor != head) {\\n            cursor = cursor.left;\\n            cursor.right = null;\\n            k -= 1;\\n            numDeleted += 1;\\n        }\\n        // connect the cursor with the original right nodes\\n        cursor.right = next;\\n        \\n        if (next == null) {\\n            // if previously cursor is at the tail, then move tail currently\\n            tail = cursor;\\n        } else {\\n            next.left = cursor;\\n        }\\n        return numDeleted;\\n    }\\n    \\n    public String cursorLeft(int k) {\\n        while (k > 0 && cursor.left != null) {\\n            cursor = cursor.left;\\n            k -= 1;\\n        }\\n        Node pointer = cursor;\\n        int ub = 10;\\n        StringBuilder builder = new StringBuilder();\\n        while (pointer != head && ub > 0) {\\n            builder.append(pointer.letter);\\n            pointer = pointer.left;\\n            ub -= 1;\\n        }\\n        return builder.reverse().toString();\\n    }\\n    \\n    public String cursorRight(int k) {\\n        while (k > 0 && cursor.right != null) {\\n            cursor = cursor.right;\\n            k -= 1;\\n        }\\n        Node pointer = cursor;\\n        int ub = 10;\\n        StringBuilder builder = new StringBuilder();\\n        while (pointer != head && ub > 0) {\\n            builder.append(pointer.letter);\\n            pointer = pointer.left;\\n            ub -= 1;\\n        }\\n        return builder.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564817,
                "content": [
                    {
                        "username": "rtmkz",
                        "content": "In Weekly Contest 296 I found that for the last problem (Design a Text Editor) my very first solution which got Time Limit during the contest was accepted after submitting the same code again. I was really struggling to figure out the problem since my code was optimal in terms of constants. Once it was accepted, I tried submitting it again and sometimes it gets accepted, sometimes time limit.\\n\\nNormally, in competitive programming competitions, if the optimal solution sometimes gets Time Limit authors/organazers make sure to increase the time limit so that participants don\\'t struggle squeezing the optimal solution by tunning constants.\\n\\nIn the case many people had the same issue or let\\'s say if Leetcode redudges all the submissions and not all solutions which passed during the contest would pass again or vice verca, I think organizers should increase the time limit and rejudge all solutions.\\n\\nShare what you think in the comments below."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "It\\'s not a hard problem. A medium one maybe..."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s definitely not a hard problem :|"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 2047890,
                "content": [
                    {
                        "username": "rtmkz",
                        "content": "In Weekly Contest 296 I found that for the last problem (Design a Text Editor) my very first solution which got Time Limit during the contest was accepted after submitting the same code again. I was really struggling to figure out the problem since my code was optimal in terms of constants. Once it was accepted, I tried submitting it again and sometimes it gets accepted, sometimes time limit.\\n\\nNormally, in competitive programming competitions, if the optimal solution sometimes gets Time Limit authors/organazers make sure to increase the time limit so that participants don\\'t struggle squeezing the optimal solution by tunning constants.\\n\\nIn the case many people had the same issue or let\\'s say if Leetcode redudges all the submissions and not all solutions which passed during the contest would pass again or vice verca, I think organizers should increase the time limit and rejudge all solutions.\\n\\nShare what you think in the comments below."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "It\\'s not a hard problem. A medium one maybe..."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s definitely not a hard problem :|"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1711247,
                "content": [
                    {
                        "username": "rtmkz",
                        "content": "In Weekly Contest 296 I found that for the last problem (Design a Text Editor) my very first solution which got Time Limit during the contest was accepted after submitting the same code again. I was really struggling to figure out the problem since my code was optimal in terms of constants. Once it was accepted, I tried submitting it again and sometimes it gets accepted, sometimes time limit.\\n\\nNormally, in competitive programming competitions, if the optimal solution sometimes gets Time Limit authors/organazers make sure to increase the time limit so that participants don\\'t struggle squeezing the optimal solution by tunning constants.\\n\\nIn the case many people had the same issue or let\\'s say if Leetcode redudges all the submissions and not all solutions which passed during the contest would pass again or vice verca, I think organizers should increase the time limit and rejudge all solutions.\\n\\nShare what you think in the comments below."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "It\\'s not a hard problem. A medium one maybe..."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s definitely not a hard problem :|"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1763843,
                "content": [
                    {
                        "username": "rtmkz",
                        "content": "In Weekly Contest 296 I found that for the last problem (Design a Text Editor) my very first solution which got Time Limit during the contest was accepted after submitting the same code again. I was really struggling to figure out the problem since my code was optimal in terms of constants. Once it was accepted, I tried submitting it again and sometimes it gets accepted, sometimes time limit.\\n\\nNormally, in competitive programming competitions, if the optimal solution sometimes gets Time Limit authors/organazers make sure to increase the time limit so that participants don\\'t struggle squeezing the optimal solution by tunning constants.\\n\\nIn the case many people had the same issue or let\\'s say if Leetcode redudges all the submissions and not all solutions which passed during the contest would pass again or vice verca, I think organizers should increase the time limit and rejudge all solutions.\\n\\nShare what you think in the comments below."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "It\\'s not a hard problem. A medium one maybe..."
                    },
                    {
                        "username": "Msey",
                        "content": "It\\'s definitely not a hard problem :|"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    }
]