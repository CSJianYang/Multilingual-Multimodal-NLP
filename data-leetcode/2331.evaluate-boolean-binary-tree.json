[
    {
        "title": "Evaluate Boolean Binary Tree",
        "question_content": "You are given the root of a full binary tree with the following properties:\n\n\tLeaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.\n\tNon-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.\n\nThe evaluation of a node is as follows:\n\n\tIf the node is a leaf node, the evaluation is the value of the node, i.e. True or False.\n\tOtherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.\n\nReturn the boolean result of evaluating the root node.\nA full binary tree is a binary tree where each node has either 0 or 2 children.\nA leaf node is a node that has zero children.\n&nbsp;\nExample 1:\n\nInput: root = [2,1,3,null,null,0,1]\nOutput: true\nExplanation: The above diagram illustrates the evaluation process.\nThe AND node evaluates to False AND True = False.\nThe OR node evaluates to True OR False = True.\nThe root node evaluates to True, so we return true.\nExample 2:\n\nInput: root = [0]\nOutput: false\nExplanation: The root node is a leaf node and it evaluates to false, so we return false.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 1000].\n\t0 <= Node.val <= 3\n\tEvery node has either 0 or 2 children.\n\tLeaf nodes have a value of 0 or 1.\n\tNon-leaf nodes have a value of 2 or 3.",
        "solutions": [
            {
                "id": 2260557,
                "title": "switch",
                "content": "A bit mouthful, cos I felt like doing something different today.\\n\\n**C++**\\n```cpp\\nbool evaluateTree(TreeNode* n) {\\n    switch(n->val) {\\n        case 0:\\n        case 1:\\n            return n->val;\\n        case 2:\\n            return evaluateTree(n->left) || evaluateTree(n->right);\\n        default:\\n            return evaluateTree(n->left) && evaluateTree(n->right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool evaluateTree(TreeNode* n) {\\n    switch(n->val) {\\n        case 0:\\n        case 1:\\n            return n->val;\\n        case 2:\\n            return evaluateTree(n->left) || evaluateTree(n->right);\\n        default:\\n            return evaluateTree(n->left) && evaluateTree(n->right);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259221,
                "title": "recursive-java",
                "content": "```\\npublic boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        boolean l = evaluateTree(root.left);\\n        boolean r = evaluateTree(root.right);\\n        return root.val==2 ? l|r : l&r;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        boolean l = evaluateTree(root.left);\\n        boolean r = evaluateTree(root.right);\\n        return root.val==2 ? l|r : l&r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259785,
                "title": "c-pure-dfs-solution-100-7ms-100-space-14-9-mb",
                "content": "Pretty plain problem, we can solve it in a nice, neat recursive way just by reading the specs and little more, having three base cases:\\n* `root` is a leaf, in which case we `return` its boolean value (`0` or `1`);\\n* `root` is an OR node, in which case we `return` the result of ORing the results of the recursive calls to its `left` and `right` nodes;\\n* `root` is an AND node, in which case we `return` the result of ANDing the results of the recursive calls to its `left` and `right` nodes.\\n\\nAnd that\\'s it, really :)\\n\\nThe code::\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        // base case: leaf\\n        if (root->val < 2) return root->val;\\n        // or node\\n        else if (root->val == 2) return evaluateTree(root->left) || evaluateTree(root->right);\\n        // and node\\n        return evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n};\\n```\\n\\nOne-liner version of the same logic (I was tempted to write it from the beginning, but don\\'t do this in interviews!):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        return (root->val < 2) ? root->val : (root->val == 2) ? evaluateTree(root->left) || evaluateTree(root->right) : evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        // base case: leaf\\n        if (root->val < 2) return root->val;\\n        // or node\\n        else if (root->val == 2) return evaluateTree(root->left) || evaluateTree(root->right);\\n        // and node\\n        return evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        return (root->val < 2) ? root->val : (root->val == 2) ? evaluateTree(root->left) || evaluateTree(root->right) : evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259346,
                "title": "python-recursive-code",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool: \\n        def recur(node):\\n            if not node.left and not node.right: #leaf node\\n                return True if node.val == 1 else False\\n            left = recur(node.left)\\n            right = recur(node.right)\\n            if node.val == 2: #if node is or\\n                return left or right\\n            if node.val == 3: #if node is and\\n                return left and right\\n        return recur(root)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool: \\n        def recur(node):\\n            if not node.left and not node.right: #leaf node\\n                return True if node.val == 1 else False\\n            left = recur(node.left)\\n            right = recur(node.right)\\n            if node.val == 2: #if node is or\\n                return left or right\\n            if node.val == 3: #if node is and\\n                return left and right\\n        return recur(root)",
                "codeTag": "Java"
            },
            {
                "id": 2417137,
                "title": "python-elegant-short-94-5-faster-o-n-two-lines",
                "content": "![image](https://assets.leetcode.com/users/images/8eb386ec-53ce-4543-b793-6f5151b1721c_1660336623.5139685.png)\\n\\n```\\nfrom operator import and_, or_\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tMAPPING = {\\n\\t\\t0: lambda *_: False,\\n\\t\\t1: lambda *_: True,\\n\\t\\t2: or_,\\n\\t\\t3: and_,\\n\\t}\\n\\n\\tdef evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\tif root is not None:\\n\\t\\t\\treturn self.MAPPING[root.val](\\n\\t\\t\\t\\tself.evaluateTree(root.left),\\n\\t\\t\\t\\tself.evaluateTree(root.right),\\n\\t\\t\\t)\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom operator import and_, or_\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n)\\n\\tMemory: O(n)\\n\\t\"\"\"\\n\\n\\tMAPPING = {\\n\\t\\t0: lambda *_: False,\\n\\t\\t1: lambda *_: True,\\n\\t\\t2: or_,\\n\\t\\t3: and_,\\n\\t}\\n\\n\\tdef evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\tif root is not None:\\n\\t\\t\\treturn self.MAPPING[root.val](\\n\\t\\t\\t\\tself.evaluateTree(root.left),\\n\\t\\t\\t\\tself.evaluateTree(root.right),\\n\\t\\t\\t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259229,
                "title": "recursive",
                "content": "**TC - O(n)**\\n```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        if (!root->left and !root->right)   return root->val;\\n        int l = evaluateTree(root->left);\\n        int r = evaluateTree(root->right);\\n        return (root->val == 2) ? l or r : l and r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        if (!root->left and !root->right)   return root->val;\\n        int l = evaluateTree(root->left);\\n        int r = evaluateTree(root->right);\\n        return (root->val == 2) ? l or r : l and r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566445,
                "title": "easy-python-6-line-solution",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n            if root.val==0 or root.val==1:\\n                return root.val\\n            if root.val==2:\\n                return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n            if root.val==3:\\n                return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n            if root.val==0 or root.val==1:\\n                return root.val\\n            if root.val==2:\\n                return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n            if root.val==3:\\n                return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259277,
                "title": "evaluate-boolean-binary-tree-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 1)\\n            return true;\\n        if(root.val == 0)\\n            return false;\\n        if(root.val == 2)\\n            return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 1)\\n            return true;\\n        if(root.val == 0)\\n            return false;\\n        if(root.val == 2)\\n            return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925150,
                "title": "97-89-faster-python-solution",
                "content": "![Screenshot 2022-12-18 at 16.23.45.png](https://assets.leetcode.com/users/images/405791d7-4448-46b2-a9bc-6c5291d04855_1671362645.393128.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n        elif root.val==2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        return root.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n        elif root.val==2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        return root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259239,
                "title": "cpp-100-faster-easy-recursion",
                "content": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(root->val==1 || root->val==0) return root->val;\\n        \\n        bool l=evaluateTree(root->left);\\n        bool r=evaluateTree(root->right);\\n        \\n        if(root->val==3) return l and r;\\n        else return l or r;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(root->val==1 || root->val==0) return root->val;\\n        \\n        bool l=evaluateTree(root->left);\\n        bool r=evaluateTree(root->right);\\n        \\n        if(root->val==3) return l and r;\\n        else return l or r;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259180,
                "title": "java-only-5-concise-lines-fastest-0-ms",
                "content": "Switch-case is faster than several `if`s as it uses a table lookup i think.\\n\\n```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        switch(root.val){\\n            case 0: return false;\\n            case 1: return true;\\n            case 2: return evaluateTree(root.left) || evaluateTree(root.right);\\n            default: return evaluateTree(root.left) && evaluateTree(root.right);\\n        }\\n    }\\n}\\n```\\n\\nIf you really want to get shorter (not needed I think), you can skip one case:\\n\\n```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        switch(root.val){\\n            case 3: return evaluateTree(root.left) && evaluateTree(root.right);\\n\\t\\t\\tcase 2: return evaluateTree(root.left) || evaluateTree(root.right);\\n\\t\\t\\tdefault : return root.val == 1;\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        switch(root.val){\\n            case 0: return false;\\n            case 1: return true;\\n            case 2: return evaluateTree(root.left) || evaluateTree(root.right);\\n            default: return evaluateTree(root.left) && evaluateTree(root.right);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        switch(root.val){\\n            case 3: return evaluateTree(root.left) && evaluateTree(root.right);\\n\\t\\t\\tcase 2: return evaluateTree(root.left) || evaluateTree(root.right);\\n\\t\\t\\tdefault : return root.val == 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259156,
                "title": "java-simple-recursion-ternary-operator",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        \\n        if(root.val==0)\\n        return false;\\n        \\n        if(root.val==1)\\n        return true;\\n                \\n        return root.val==2 ? (evaluateTree(root.left) || evaluateTree(root.right)) : (evaluateTree(root.left) && evaluateTree(root.right));\\n        \\n    }\\n}\\n   \\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        \\n        if(root.val==0)\\n        return false;\\n        \\n        if(root.val==1)\\n        return true;\\n                \\n        return root.val==2 ? (evaluateTree(root.left) || evaluateTree(root.right)) : (evaluateTree(root.left) && evaluateTree(root.right));\\n        \\n    }\\n}\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275208,
                "title": "c-4-lines-clean-and-simple-recursion",
                "content": "```\\n bool value(TreeNode* root)\\n    {\\n        if(root->val<=1) return root->val;\\n        if(root->val==2) return (value(root->left) || value(root->right));\\n        return  (value(root->left) && value(root->right));\\n    }\\n    bool evaluateTree(TreeNode* root) {\\n        return value(root);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool value(TreeNode* root)\\n    {\\n        if(root->val<=1) return root->val;\\n        if(root->val==2) return (value(root->left) || value(root->right));\\n        return  (value(root->left) && value(root->right));\\n    }\\n    bool evaluateTree(TreeNode* root) {\\n        return value(root);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260266,
                "title": "javascript-solution-simple",
                "content": "```javascript\\n/**\\n0 -> False\\n1 -> True\\n2 -> OR\\n3 -> AND\\n*/\\n\\n// Depth First Search \\nvar evaluateTree = function (root) {\\n  const dfs = (node) => {\\n    if (!node) return;\\n    if (node.val === 0) return false;\\n    if (node.val === 1) return true;\\n\\n    if (node.val === 2) {\\n      return dfs(node.left) || dfs(node.right);\\n    } else if (node.val === 3) {\\n      return dfs(node.left) && dfs(node.right);\\n    }\\n  };\\n\\n  return dfs(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n0 -> False\\n1 -> True\\n2 -> OR\\n3 -> AND\\n*/\\n\\n// Depth First Search \\nvar evaluateTree = function (root) {\\n  const dfs = (node) => {\\n    if (!node) return;\\n    if (node.val === 0) return false;\\n    if (node.val === 1) return true;\\n\\n    if (node.val === 2) {\\n      return dfs(node.left) || dfs(node.right);\\n    } else if (node.val === 3) {\\n      return dfs(node.left) && dfs(node.right);\\n    }\\n  };\\n\\n  return dfs(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259206,
                "title": "recursion-dfs-beginner-friendly-my-notes",
                "content": "**Go to the depth and return the value if it doesn\\'t have children. (leaf node)\\nFor non leaf node, compute and/or of the leaf node values.**\\n\\n\\n```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        \\n        def evaluate(root):\\n            if root:\\n                if root.left is None and root.right is None:\\n                    return root.val\\n                \\n                left = evaluate(root.left)\\n                right = evaluate(root.right)\\n                \\n                if root.val == 2:\\n                    return (left or right)\\n                \\n                if root.val == 3:\\n                    return (left and right)\\n            \\n        return evaluate(root)\\n        \\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        \\n        def evaluate(root):\\n            if root:\\n                if root.left is None and root.right is None:\\n                    return root.val\\n                \\n                left = evaluate(root.left)\\n                right = evaluate(root.right)\\n                \\n                if root.val == 2:\\n                    return (left or right)\\n                \\n                if root.val == 3:\\n                    return (left and right)\\n            \\n        return evaluate(root)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081478,
                "title": "python-3-lines-easiest",
                "content": "# Upvote it :)\\n```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == 2: return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        elif root.val == 3: return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n        else: return root.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == 2: return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        elif root.val == 3: return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n        else: return root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631819,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val==0)\\n            return false;\\n        if(root.val==1)\\n            return true;\\n        \\n        if(root.val==2) return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val==0)\\n            return false;\\n        if(root.val==1)\\n            return true;\\n        \\n        if(root.val==2) return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541167,
                "title": "recursive-solution-c",
                "content": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(!root->left && !root->right)\\n            return root->val;\\n        int leftVal = evaluateTree(root->left);\\n        int rightVal = evaluateTree(root->right);\\n        if(root->val == 2) {\\n            root->val = leftVal or rightVal;\\n        }\\n        else {\\n            root->val = leftVal and rightVal;\\n        }\\n        return root->val;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(!root->left && !root->right)\\n            return root->val;\\n        int leftVal = evaluateTree(root->left);\\n        int rightVal = evaluateTree(root->right);\\n        if(root->val == 2) {\\n            root->val = leftVal or rightVal;\\n        }\\n        else {\\n            root->val = leftVal and rightVal;\\n        }\\n        return root->val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379669,
                "title": "python-iterative-dfs-modify-in-place",
                "content": "(P.S. I really want to know what Rust iterative looks like?)\\n\\n```python\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node.left and node.right:\\n                if node.left.val <= 1 and node.right.val <= 1:\\n                    if node.val == 2:\\n                        node.val = node.left.val or node.right.val\\n                    else:\\n                        node.val = node.left.val and node.right.val\\n                else:\\n                    stack.append(node)\\n                    stack.append(node.left)\\n                    stack.append(node.right)\\n            else:\\n                continue\\n        return node.val == 1\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node.left and node.right:\\n                if node.left.val <= 1 and node.right.val <= 1:\\n                    if node.val == 2:\\n                        node.val = node.left.val or node.right.val\\n                    else:\\n                        node.val = node.left.val and node.right.val\\n                else:\\n                    stack.append(node)\\n                    stack.append(node.left)\\n                    stack.append(node.right)\\n            else:\\n                continue\\n        return node.val == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341383,
                "title": "javascript-simple-recursive-solution",
                "content": "```\\nconst evaluateTree = function(root) {\\n    if(root.val == 2){\\n        return evaluateTree(root.left) || evaluateTree(root.right)\\n    }else if(root.val == 3){\\n        return evaluateTree(root.left) && evaluateTree(root.right)\\n    }\\n    return root.val\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst evaluateTree = function(root) {\\n    if(root.val == 2){\\n        return evaluateTree(root.left) || evaluateTree(root.right)\\n    }else if(root.val == 3){\\n        return evaluateTree(root.left) && evaluateTree(root.right)\\n    }\\n    return root.val\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2260150,
                "title": "go-python-c-w-comments",
                "content": "<iframe src=\"https://leetcode.com/playground/a8k3xokf/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Go"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/a8k3xokf/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3179830,
                "title": "elegant-c",
                "content": "```\\npublic class Solution\\n{\\n    public bool EvaluateTree(TreeNode node) => node.val switch\\n    {\\n        0 => false,\\n        1 => true,\\n        2 => EvaluateTree(node.left) || EvaluateTree(node.right),\\n        3 => EvaluateTree(node.left) && EvaluateTree(node.right),\\n    };\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool EvaluateTree(TreeNode node) => node.val switch\\n    {\\n        0 => false,\\n        1 => true,\\n        2 => EvaluateTree(node.left) || EvaluateTree(node.right),\\n        3 => EvaluateTree(node.left) && EvaluateTree(node.right),\\n    };\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035785,
                "title": "python-straightforward-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe big picture is that you need to evalute the root with left subtree and right subtree.\\nSo what is the termination condition? The answer is when you reach the leaf of the tree and return the boolean value of the leaf node.\\nAnd then let the recursion do its job.\\nIf the root value is 2, return an `or` between boolean values of left and right subtrees; `and` otherwise.\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\n        if not root.left and not root.right:\\n            return True if root.val else False\\n\\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        elif root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```\\n**Please upvote if you found this helpful.**",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\n        if not root.left and not root.right:\\n            return True if root.val else False\\n\\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        elif root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034350,
                "title": "single-line-solution",
                "content": "# Intuition\\nShorthand use of if-else\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return  (root.val==2)?(evaluateTree(root.left)||evaluateTree(root.right)):((root.val==3)?evaluateTree(root.left)&&evaluateTree(root.right):(root.val==1)? true:false);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return  (root.val==2)?(evaluateTree(root.left)||evaluateTree(root.right)):((root.val==3)?evaluateTree(root.left)&&evaluateTree(root.right):(root.val==1)? true:false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971158,
                "title": "python-match-case",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$ - where k is the depth of the tree \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        match root.val:\\n            case 2:\\n                return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n            case 3:\\n                return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n            case _:\\n                return root.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        match root.val:\\n            case 2:\\n                return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n            case 3:\\n                return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n            case _:\\n                return root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691625,
                "title": "c-recursion-easy-solution",
                "content": "```\\n bool evaluateTree(TreeNode* root) {\\n        if(root->val==0){\\n            return false;\\n        }\\n        if(root->val==1){\\n            return true;\\n        }\\n        bool a=evaluateTree(root->left);\\n        bool b=evaluateTree(root->right);\\n        if(root->val==2){\\n            return a||b;\\n        }\\n        else{\\n            return a&&b;\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n bool evaluateTree(TreeNode* root) {\\n        if(root->val==0){\\n            return false;\\n        }\\n        if(root->val==1){\\n            return true;\\n        }\\n        bool a=evaluateTree(root->left);\\n        bool b=evaluateTree(root->right);\\n        if(root->val==2){\\n            return a||b;\\n        }\\n        else{\\n            return a&&b;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2450520,
                "title": "python-recursive",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.left == None:\\n            return root.val\\n        if root.val == 2:\\n            res = self.evaluateTree(root.left)  or self.evaluateTree(root.right)\\n        else:\\n            res = self.evaluateTree(root.left)  and self.evaluateTree(root.right)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.left == None:\\n            return root.val\\n        if root.val == 2:\\n            res = self.evaluateTree(root.left)  or self.evaluateTree(root.right)\\n        else:\\n            res = self.evaluateTree(root.left)  and self.evaluateTree(root.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260492,
                "title": "python3-recursion-and-boolean-logic-5-lines",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root: TreeNode) -> bool:\\n                                #\\n                                # Recursion:\\n                                #\\n                                #   Base Case: node.val = 0 or 1. Return T or F\\n                                #   \\n                                #   Recursive Case: node.val = 2 or 3. Node value  is determined\\n\\t\\t\\t\\t\\t\\t\\t\\t#   upon the  values l = node.left.val, r = node.right.val, \\n                                #   and  v = T if node.val = OR  else F if node.val = AND\\n                                #\\n                                #   From a Venn diagram or a truth table for l, r, v, one can\\n                                #   see the return from the recursive call is l&r or l&v or r&v\\n                                #\\n        if root.val<2: return root.val\\n        l = self.evaluateTree(root.left)\\n        r = self.evaluateTree(root.right)\\n        v = root.val^1\\n\\n        return l&r or l&v or r&v",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: TreeNode) -> bool:\\n                                #\\n                                # Recursion:\\n                                #\\n                                #   Base Case: node.val = 0 or 1. Return T or F\\n                                #   \\n                                #   Recursive Case: node.val = 2 or 3. Node value  is determined\\n\\t\\t\\t\\t\\t\\t\\t\\t#   upon the  values l = node.left.val, r = node.right.val, \\n                                #   and  v = T if node.val = OR  else F if node.val = AND\\n                                #\\n                                #   From a Venn diagram or a truth table for l, r, v, one can\\n                                #   see the return from the recursive call is l&r or l&v or r&v\\n                                #\\n        if root.val<2: return root.val\\n        l = self.evaluateTree(root.left)\\n        r = self.evaluateTree(root.right)\\n        v = root.val^1\\n\\n        return l&r or l&v or r&v",
                "codeTag": "Java"
            },
            {
                "id": 2259649,
                "title": "100-fast-100-space",
                "content": "**BASE**\\nIf the value of treeNode is 0 or 1 return the value as it is.\\n**Recursion:**\\nIf the value is 2 or 3 return the or of the left and right and \\'and\\' of the left and right side respectively using recursion on the root->left and root->right nodes.\\n```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root -> val == 0 || root -> val == 1) return root -> val;\\n        return root -> val == 2 ? evaluateTree(root->left) || evaluateTree(root->right) : \\n        evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root -> val == 0 || root -> val == 1) return root -> val;\\n        return root -> val == 2 ? evaluateTree(root->left) || evaluateTree(root->right) : \\n        evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259245,
                "title": "easy-recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n     bool dfs(TreeNode* root){\\n        if(root->left == NULL && root->right == NULL)\\n            return root->val;\\n         if(root->val == 2){\\n             return dfs(root->left) | dfs(root->right);\\n         }\\n         if(root->val == 3){\\n             return dfs(root->left) & dfs(root->right);\\n         }\\n         return true;\\n    }\\n    bool evaluateTree(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     bool dfs(TreeNode* root){\\n        if(root->left == NULL && root->right == NULL)\\n            return root->val;\\n         if(root->val == 2){\\n             return dfs(root->left) | dfs(root->right);\\n         }\\n         if(root->val == 3){\\n             return dfs(root->left) & dfs(root->right);\\n         }\\n         return true;\\n    }\\n    bool evaluateTree(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965051,
                "title": "efficient-recursive-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- This function takes a TreeNode* named root as an input, representing the current node being evaluated.\\n- It first checks if the current node is a leaf node (no left or right children). If it is, it returns false if the node\\'s value is 0, and true otherwise.\\n- If the current node is not a leaf node, it recursively evaluates its left and right children using the evaluate function.\\n- If the node\\'s value is 2, it returns the logical OR of its left and right children\\'s evaluations.\\n- If the node\\'s value is 3, it returns the logical AND of its left and right children\\'s evaluations.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\nFor call stack only\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluate(TreeNode* root) {\\n        if(root->left == NULL && root->right == NULL) {\\n            if(root->val == 0)\\n                return false;\\n\\n            return true;\\n        }\\n\\n        bool leftAns = evaluate(root->left);\\n        bool rightAns = evaluate(root->right);\\n\\n        if(root->val == 2) {\\n            bool ans = (leftAns || rightAns);\\n            return ans;\\n        }\\n\\n        return (leftAns && rightAns);\\n    }\\n\\n    bool evaluateTree(TreeNode* root) {\\n        return evaluate(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluate(TreeNode* root) {\\n        if(root->left == NULL && root->right == NULL) {\\n            if(root->val == 0)\\n                return false;\\n\\n            return true;\\n        }\\n\\n        bool leftAns = evaluate(root->left);\\n        bool rightAns = evaluate(root->right);\\n\\n        if(root->val == 2) {\\n            bool ans = (leftAns || rightAns);\\n            return ans;\\n        }\\n\\n        return (leftAns && rightAns);\\n    }\\n\\n    bool evaluateTree(TreeNode* root) {\\n        return evaluate(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479330,
                "title": "beats-100-99-8-space-14-7-mb-with-explanation",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n# Explanation\\nThe Solution class has a single method called evaluateTree that takes a TreeNode object as an argument and returns a boolean value. The method recursively evaluates the TreeNode object and its children based on the values of the nodes.\\n\\nThe method first checks if the value of the root node is 1. If it is, the method returns true. If the value of the root node is 0, the method returns false. If the value of the root node is 2, the method recursively evaluates the left and right children of the root node using the or operator and returns the result. If the value of the root node is 3, the method recursively evaluates the left and right children of the root node using the and operator and returns the result. If the value of the root node is not 0, 1, 2, or 3, the method returns true.\\n\\nThe TreeNode object is a binary tree node that has a value and two children, left and right. The evaluateTree method recursively evaluates the TreeNode object and its children by calling itself on the left and right children of the root node.\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if( root->val ==1)return true;\\n        if( root->val ==0)return false;\\n        if (root->val ==2)return evaluateTree(root->left) or evaluateTree(root->right);\\n        if(root->val ==3)return evaluateTree(root->left) and evaluateTree (root->right);\\n        return true;\\n    }\\n};\\n```\\nOne-liner version of the same logic (I was tempted to write it from the beginning, but don\\'t do this in interviews!):\\n```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        return (root->val < 2) ? root->val : (root->val == 2) ? evaluateTree(root->left) || evaluateTree(root->right) : evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if( root->val ==1)return true;\\n        if( root->val ==0)return false;\\n        if (root->val ==2)return evaluateTree(root->left) or evaluateTree(root->right);\\n        if(root->val ==3)return evaluateTree(root->left) and evaluateTree (root->right);\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        return (root->val < 2) ? root->val : (root->val == 2) ? evaluateTree(root->left) || evaluateTree(root->right) : evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364853,
                "title": "java-simple-o-n-solution",
                "content": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return helper(root) == 0 ? false : true;\\n    }\\n\\n    public int helper(TreeNode root) {\\n        if(root.val == 0 || root.val == 1)\\n            return root.val;\\n\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n\\n        return root.val == 2 ? left | right : left & right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return helper(root) == 0 ? false : true;\\n    }\\n\\n    public int helper(TreeNode root) {\\n        if(root.val == 0 || root.val == 1)\\n            return root.val;\\n\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n\\n        return root.val == 2 ? left | right : left & right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284312,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    private static final int OR = 2;\\n    private static final int AND = 3;\\n    private static final int TRUE = 1;\\n    private static final int FALSE = 0;\\n\\n    public boolean evaluateTree(TreeNode root) {\\n        switch(root.val) {\\n            case TRUE: return true;\\n            case FALSE: return false;\\n            case OR: return evaluateTree(root.left) || evaluateTree(root.right);\\n            case AND: return evaluateTree(root.left) && evaluateTree(root.right);\\n            default: throw new IllegalArgumentException(\"Val:\" + root.val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int OR = 2;\\n    private static final int AND = 3;\\n    private static final int TRUE = 1;\\n    private static final int FALSE = 0;\\n\\n    public boolean evaluateTree(TreeNode root) {\\n        switch(root.val) {\\n            case TRUE: return true;\\n            case FALSE: return false;\\n            case OR: return evaluateTree(root.left) || evaluateTree(root.right);\\n            case AND: return evaluateTree(root.left) && evaluateTree(root.right);\\n            default: throw new IllegalArgumentException(\"Val:\" + root.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252388,
                "title": "golang-clean-solution",
                "content": "## dfs inorder\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc evaluateTree(root *TreeNode) bool {\\n    return dfs(root)\\n}\\n\\nfunc dfs(root *TreeNode) bool{\\n    if root != nil{\\n        if root.Val < 2{\\n            return root.Val != 0\\n        } else{\\n            if root.Val == 2{\\n                return dfs(root.Left) || dfs(root.Right)\\n            }\\n            if root.Val == 3{\\n                return dfs(root.Left) && dfs(root.Right)\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc evaluateTree(root *TreeNode) bool {\\n    return dfs(root)\\n}\\n\\nfunc dfs(root *TreeNode) bool{\\n    if root != nil{\\n        if root.Val < 2{\\n            return root.Val != 0\\n        } else{\\n            if root.Val == 2{\\n                return dfs(root.Left) || dfs(root.Right)\\n            }\\n            if root.Val == 3{\\n                return dfs(root.Left) && dfs(root.Right)\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212843,
                "title": "java-easy-0ms-beats-100-simple-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if (func(root)==1) return true;\\n        return false;\\n    }\\n    int func (TreeNode root) {\\n        if (root.left==null && root.right==null) return root.val;\\n        int left = func(root.left);\\n        int right = func(root.right);\\n        if (root.val==2) return left | right;\\n        if (root.val==3) return left & right;\\n        return root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if (func(root)==1) return true;\\n        return false;\\n    }\\n    int func (TreeNode root) {\\n        if (root.left==null && root.right==null) return root.val;\\n        int left = func(root.left);\\n        int right = func(root.right);\\n        if (root.val==2) return left | right;\\n        if (root.val==3) return left & right;\\n        return root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212817,
                "title": "python-inorder-traversal-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        def inorder(root):\\n            if root is None: return True\\n            val = root.val\\n            if root.left is not None and root.right is not None:\\n                if val == 2:\\n                    return inorder(root.left) or inorder(root.right)\\n                elif val == 3:\\n                    return inorder(root.left) and inorder(root.right)\\n            elif val == 1:\\n                return True\\n            return False\\n        return inorder(root) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        def inorder(root):\\n            if root is None: return True\\n            val = root.val\\n            if root.left is not None and root.right is not None:\\n                if val == 2:\\n                    return inorder(root.left) or inorder(root.right)\\n                elif val == 3:\\n                    return inorder(root.left) and inorder(root.right)\\n            elif val == 1:\\n                return True\\n            return False\\n        return inorder(root) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617807,
                "title": "java-explained-properly-recursive-100ms",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean evaluateTree(TreeNode root) {\\n\\t\\t//If the given node is False -> 0\\n\\t\\t\\tif(root.val == 0)\\n\\t\\t\\t\\treturn false ;\\n\\t\\t//I fthe given node is true -> 1\\n\\t\\t\\tif(root.val == 1)\\n\\t\\t\\t\\treturn true ;\\n\\t\\t\\t//Here root value 2 represents -> Boolean OR \\n\\t\\t\\tif(root.val == 2)\\n\\t\\t\\t\\treturn evaluateTree(root.left) || evaluateTree(root.right) ;\\n\\t\\t\\t//Here it Says that the Root Value is Neither 0,1,2 i.e its 3 -> Boolean AND Operation\\n\\t\\t\\treturn evaluateTree(root.left) && evaluateTree(root.right) ;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean evaluateTree(TreeNode root) {\\n\\t\\t//If the given node is False -> 0\\n\\t\\t\\tif(root.val == 0)\\n\\t\\t\\t\\treturn false ;\\n\\t\\t//I fthe given node is true -> 1\\n\\t\\t\\tif(root.val == 1)\\n\\t\\t\\t\\treturn true ;\\n\\t\\t\\t//Here root value 2 represents -> Boolean OR \\n\\t\\t\\tif(root.val == 2)\\n\\t\\t\\t\\treturn evaluateTree(root.left) || evaluateTree(root.right) ;\\n\\t\\t\\t//Here it Says that the Root Value is Neither 0,1,2 i.e its 3 -> Boolean AND Operation\\n\\t\\t\\treturn evaluateTree(root.left) && evaluateTree(root.right) ;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2431486,
                "title": "recursion-in-python",
                "content": "We could use classic DFS to traverse all the nodes:\\n\\n```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        if root.val == 0:\\n            return False\\n        elif root.val == 1:\\n            return True\\n        elif root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        elif root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        if root.val == 0:\\n            return False\\n        elif root.val == 1:\\n            return True\\n        elif root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        elif root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407526,
                "title": "easy-java-solution-using-dfs-postorder-recursion",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        boolean left = evaluateTree(root.left);\\n        boolean right = evaluateTree(root.right);\\n        return root.val == 2?left||right:left&&right;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        boolean left = evaluateTree(root.left);\\n        boolean right = evaluateTree(root.right);\\n        return root.val == 2?left||right:left&&right;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2309881,
                "title": "recursion-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) {\\n            //leaf node\\n            return(root->val==1? true:false);\\n        }\\n        bool left=evaluateTree(root->left); //left subtree\\n        bool right=evaluateTree(root->right); //right subtree\\n        if(root->val==2) {\\n            //or operator\\n            return(left || right);\\n        }\\n        if(root->val==3) {\\n            //and operator\\n            return(left && right);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL) {\\n            //leaf node\\n            return(root->val==1? true:false);\\n        }\\n        bool left=evaluateTree(root->left); //left subtree\\n        bool right=evaluateTree(root->right); //right subtree\\n        if(root->val==2) {\\n            //or operator\\n            return(left || right);\\n        }\\n        if(root->val==3) {\\n            //and operator\\n            return(left && right);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287950,
                "title": "recursion-python-explanation",
                "content": "```\\ndef evaluateTree(self, root: Optional[TreeNode]) -> bool:       \\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        elif root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n        return root.val\\n```\\n\\n- If our root is == 3, the answer is the result of our left AND our right\\n- If our root is == 2, the answer is the result of our left OR our right\\n- otherwise, the curr node is true/false, in which case we can return it",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef evaluateTree(self, root: Optional[TreeNode]) -> bool:       \\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        elif root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n        return root.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2264845,
                "title": "cpp-easy-understanding-recursive",
                "content": "```\\n  int check(TreeNode* root)\\n    {\\n \\n      if (!root->left && !root->right)  // root is leaf\\n        return root->val;\\n \\n     int lt= check(root->left);\\n     int rt= check(root->right);  \\n        \\n     if(root->val==2)       // depicting  boolean OR \\n         root->val= lt|rt;  // update root\\'s value  \\n        \\n     else if (root->val==3)  // depicting  boolean AND\\n         root->val= lt&rt;     // update root\\'s value \\n        \\n     return root->val;         // return the updated value\\n   }\\n    \\n    bool evaluateTree(TreeNode* root) {\\n        if(!root)  return false;\\n     return check(root);  // helper function\\n    }\\n```\\n\\n**PLEASE UPVOTE !!!**\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n  int check(TreeNode* root)\\n    {\\n \\n      if (!root->left && !root->right)  // root is leaf\\n        return root->val;\\n \\n     int lt= check(root->left);\\n     int rt= check(root->right);  \\n        \\n     if(root->val==2)       // depicting  boolean OR \\n         root->val= lt|rt;  // update root\\'s value  \\n        \\n     else if (root->val==3)  // depicting  boolean AND\\n         root->val= lt&rt;     // update root\\'s value \\n        \\n     return root->val;         // return the updated value\\n   }\\n    \\n    bool evaluateTree(TreeNode* root) {\\n        if(!root)  return false;\\n     return check(root);  // helper function\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259899,
                "title": "c-recursion-self-explanatory-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(!root)return 0;\\n        if(!root->left&&!root->right)return root->val;\\n        if(root->val==2)\\n        {\\n            return evaluateTree(root->left)||evaluateTree(root->right);\\n        }\\n        return evaluateTree(root->left)&&evaluateTree(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(!root)return 0;\\n        if(!root->left&&!root->right)return root->val;\\n        if(root->val==2)\\n        {\\n            return evaluateTree(root->left)||evaluateTree(root->right);\\n        }\\n        return evaluateTree(root->left)&&evaluateTree(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259756,
                "title": "with-intuition-faster-than-100-20-ms-easy-to-understand-recursive",
                "content": "***INTUITION--> first check at root if only root present then return root val else if root left and right is present leave the ans calculation work on recursion for left and right part you have to work on the answer that we have got from left and right.***\\n\\n**If you like the solution please upvote :)**\\u2705\\n```\\n bool evaluateTree(TreeNode* root) {\\n        \\n        if(root==NULL){\\n            return false;\\n        }\\n        \\n        if(!root->left&&!root->right){ // root->left==NULL&&root->right==NULL\\n            return root->val;\\n        }\\n        \\n        \\n        bool left=evaluateTree(root->left);\\n        bool right=evaluateTree(root->right);\\n        \\n         if(root->val==2){\\n                return left || right;   \\n            }\\n            \\n           return   left && right;  \\n    }\\n```\\n**If you like the solution please upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n bool evaluateTree(TreeNode* root) {\\n        \\n        if(root==NULL){\\n            return false;\\n        }\\n        \\n        if(!root->left&&!root->right){ // root->left==NULL&&root->right==NULL\\n            return root->val;\\n        }\\n        \\n        \\n        bool left=evaluateTree(root->left);\\n        bool right=evaluateTree(root->right);\\n        \\n         if(root->val==2){\\n                return left || right;   \\n            }\\n            \\n           return   left && right;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259427,
                "title": "easy-to-understand-pure-recursion-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr and root->right==nullptr)\\n            return root->val;\\n        \\n        if(root->val==2)\\n        {\\n            return evaluateTree(root->left) or evaluateTree(root->right);\\n        }\\n        \\n        return evaluateTree(root->left) and evaluateTree(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr and root->right==nullptr)\\n            return root->val;\\n        \\n        if(root->val==2)\\n        {\\n            return evaluateTree(root->left) or evaluateTree(root->right);\\n        }\\n        \\n        return evaluateTree(root->left) and evaluateTree(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259340,
                "title": "100-time-and-space-efficient-in-c-easy-approach",
                "content": "Given each node must have 0 of 2 child\\nso just checking if Node is leaf, return true for 1 and false for 0;\\nif Node is not leaf, get the left and right value from left and right child, perform the operation , that is OR for 2 and AND for 3, and return the value.\\n\\nUpvote for support, \\nThanks\\n\\n```class Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root==NULL)\\n            return true;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            if(root->val==1)\\n                return true;\\n            else\\n                return false;\\n        }\\n        bool left=evaluateTree(root->left);\\n        bool right=evaluateTree(root->right);\\n        if(root->val==2)\\n        {\\n            return left || right;\\n        }\\n        else\\n            return left && right;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root==NULL)\\n            return true;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            if(root->val==1)\\n                return true;\\n            else\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2259256,
                "title": "simple-c-solution",
                "content": "\\tbool solve(TreeNode* root)\\n    {\\n        if(root->val==2)\\n            return solve(root->left) | solve(root->right);\\n        if(root->val==3)\\n            return solve(root->left) & solve (root->right);\\n        \\n        return root->val;\\n            \\n    }\\n\\tpublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        if(!root->left)\\n            return root->val;\\n        return solve(root);\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tbool solve(TreeNode* root)\\n    {\\n        if(root->val==2)\\n            return solve(root->left) | solve(root->right);\\n        if(root->val==3)\\n            return solve(root->left) & solve (root->right);\\n        \\n        return root->val;\\n            \\n    }\\n\\tpublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        if(!root->left)\\n            return root->val;\\n        return solve(root);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4057079,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static boolean helper(TreeNode root){\\n        if(root.val==1) return true;\\n        else if(root.val==0) return false;\\n        else if(root.val==2) return helper(root.left)||helper(root.right);\\n        else return helper(root.left) && helper(root.right);\\n    }\\n    public boolean evaluateTree(TreeNode root) {\\n        return helper(root);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static boolean helper(TreeNode root){\\n        if(root.val==1) return true;\\n        else if(root.val==0) return false;\\n        else if(root.val==2) return helper(root.left)||helper(root.right);\\n        else return helper(root.left) && helper(root.right);\\n    }\\n    public boolean evaluateTree(TreeNode root) {\\n        return helper(root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013715,
                "title": "simple-solution-with-using-post-order-traversal-in-python3",
                "content": "# Intuition\\nThe problem descriprion is the following:\\n- there\\'s a **Full Binary Tree (FBT)**, whose values are in range **[0, 3]**\\n- our goal is to **evaluate** the logical expressions over operands\\n\\n```py\\n# Example\\nroot = [2, 1, 3, null, null, 0, 1]\\n\\n# This tree can be interpreted as the next logical expression\\nexpr = True || (False && True) => True || False => False\\n\\n# For this example we should use the POST-ORDER traversal.\\n# This means, that all of the operations with node etc will \\n# execute after all traversal in left and in right node.\\n\\n# Example of simple FBT\\n#   (2)\\n#  /   \\\\\\n# (1) (0)\\n# The post-order traversal will give us the next list representation \\nnums = [1, 0, 2]\\n\\n# And we represent the values as booleans, according to description\\nnums = [True, False, ||]\\n\\n# After the traversal we should perform an operation (\\n# the root node can represent operands and operators, \\n# while leafs - only OPERANDS).\\n# Thus returning value from that subtree is the evaluation\\n# True || False == True\\n``` \\n\\n# Approach\\n1. initialize a `dfs` function with **post-order** traversal\\n2. at each step initialize `left` and `right` as `False` values\\n3. do the **post-order traversal**, if node has children from both sides\\n4. match the `node.val` with corresponding values and do the operations, if it\\'s needed\\n5. return the result of logic expression as `dfs(root)`\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating over `root`\\n\\n- Space complexity: **O(n)**, because of recursive call stack.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(node):\\n            left, right = False, False\\n            \\n            if node.left:\\n                left = dfs(node.left)\\n            if node.right:\\n                right = dfs(node.right)\\n\\n            match node.val:\\n                case 0:\\n                    return False\\n                case 1:\\n                    return True\\n                case 2:\\n                    return left or right\\n                case _:\\n                    return left and right\\n\\n        return dfs(root)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```py\\n# Example\\nroot = [2, 1, 3, null, null, 0, 1]\\n\\n# This tree can be interpreted as the next logical expression\\nexpr = True || (False && True) => True || False => False\\n\\n# For this example we should use the POST-ORDER traversal.\\n# This means, that all of the operations with node etc will \\n# execute after all traversal in left and in right node.\\n\\n# Example of simple FBT\\n#   (2)\\n#  /   \\\\\\n# (1) (0)\\n# The post-order traversal will give us the next list representation \\nnums = [1, 0, 2]\\n\\n# And we represent the values as booleans, according to description\\nnums = [True, False, ||]\\n\\n# After the traversal we should perform an operation (\\n# the root node can represent operands and operators, \\n# while leafs - only OPERANDS).\\n# Thus returning value from that subtree is the evaluation\\n# True || False == True\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(node):\\n            left, right = False, False\\n            \\n            if node.left:\\n                left = dfs(node.left)\\n            if node.right:\\n                right = dfs(node.right)\\n\\n            match node.val:\\n                case 0:\\n                    return False\\n                case 1:\\n                    return True\\n                case 2:\\n                    return left or right\\n                case _:\\n                    return left and right\\n\\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848393,
                "title": "java-100-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null){\\n            if(root.val == 1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }    \\n\\n        boolean leftSide = evaluateTree(root.left);\\n        boolean rightSide = evaluateTree(root.right);\\n\\n        if(root.val == 3){\\n            return leftSide && rightSide;\\n        }else{\\n            return leftSide || rightSide;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null){\\n            if(root.val == 1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }    \\n\\n        boolean leftSide = evaluateTree(root.left);\\n        boolean rightSide = evaluateTree(root.right);\\n\\n        if(root.val == 3){\\n            return leftSide && rightSide;\\n        }else{\\n            return leftSide || rightSide;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808232,
                "title": "java-recursive-beats-100-onlyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return helper(root) == 0 ? false : true;\\n    }\\n\\n    public int helper(TreeNode root) {\\n        if(root.val == 0 || root.val == 1)\\n            return root.val;\\n\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n\\n        return root.val == 2 ? left | right : left & right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return helper(root) == 0 ? false : true;\\n    }\\n\\n    public int helper(TreeNode root) {\\n        if(root.val == 0 || root.val == 1)\\n            return root.val;\\n\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n\\n        return root.val == 2 ? left | right : left & right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703607,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        boolean res = false;\\n\\t\\t//declaring a boolean variable\\n        if(root.left == null && root.right == null){\\n           if(root.val == 1){\\n               return true;\\n           }\\n            if(root.val == 0){\\n                return false;\\n            }\\n        }\\n        if(root.val == 2){\\n            res = evaluateTree(root.left)||evaluateTree(root.right);\\n        }\\n        else if(root.val == 3){\\n                  res = evaluateTree(root.left)&&evaluateTree(root.right);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        boolean res = false;\\n\\t\\t//declaring a boolean variable\\n        if(root.left == null && root.right == null){\\n           if(root.val == 1){\\n               return true;\\n           }\\n            if(root.val == 0){\\n                return false;\\n            }\\n        }\\n        if(root.val == 2){\\n            res = evaluateTree(root.left)||evaluateTree(root.right);\\n        }\\n        else if(root.val == 3){\\n                  res = evaluateTree(root.left)&&evaluateTree(root.right);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335930,
                "title": "easy-javascript-solution-well-explained",
                "content": "# Intuition\\nEasy Approach Using Switch Case\\n\\n# Approach\\n 1-We first check if there\\'s not root --> there\\'s no tree --> null.\\n2-if there\\'s only a root(no children) then return the value of the root which is either true or false.\\n3- if there\\'s children(since its a full binary tree) it\\'s obvious there will always be 2 children; and the root will be either OR / AND\\nHeres how I solved in this case:\\n- Used Recurssion and stored each in a variable\\n- Used a switch case to evaulate based on the value of the root\\n4- I added return null at the end as a design choice and to avoid errors.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(h)  its proportional to the height\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n 1- leaf(no children) 0 or 1, false or true\\n 2-non leaf(no children)  or 3, 2 OR , and 3 AND\\n 3-if non leaf check the children andapply boolean operation on their values\\n */\\nvar evaluateTree = function(root) {\\n let curr=root;   \\nif(!root) return null;\\n// Case 1: root checking done,and if theres no children//\\nif(!root.left && !root.right)\\n return root.val ;\\n//Case 2: othercase, since its full so its gonna have 2 children//\\nif(root.left && root.right){\\nconst leftValue=evaluateTree(root.left);\\nconst rightValue=evaluateTree(root.right);\\nswitch(root.val){\\n    case 2:\\n    return leftValue || rightValue;\\n     case 3:\\n    return leftValue && rightValue;\\n}\\n}\\n\\nreturn null;  \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n 1- leaf(no children) 0 or 1, false or true\\n 2-non leaf(no children)  or 3, 2 OR , and 3 AND\\n 3-if non leaf check the children andapply boolean operation on their values\\n */\\nvar evaluateTree = function(root) {\\n let curr=root;   \\nif(!root) return null;\\n// Case 1: root checking done,and if theres no children//\\nif(!root.left && !root.right)\\n return root.val ;\\n//Case 2: othercase, since its full so its gonna have 2 children//\\nif(root.left && root.right){\\nconst leftValue=evaluateTree(root.left);\\nconst rightValue=evaluateTree(root.right);\\nswitch(root.val){\\n    case 2:\\n    return leftValue || rightValue;\\n     case 3:\\n    return leftValue && rightValue;\\n}\\n}\\n\\nreturn null;  \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3334261,
                "title": "noob-to-pro-solution",
                "content": "# Intuition\\n    - perform the inorder traversal and apply boolean expression evaluate logic\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) ~ stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static boolean evaluateTree(TreeNode root) {\\n        Map<Integer,String> operations = new HashMap<>();\\n        operations.put(0,\"FALSE\");\\n        operations.put(1,\"TRUE\");\\n        operations.put(2,\"OR\");\\n        operations.put(3,\"AND\");\\n\\n        String ans = evaluateBoolean(root, operations);\\n        if (Objects.nonNull(ans)) {\\n            return ans.equalsIgnoreCase(\"TRUE\");\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    private static String evaluateBoolean(TreeNode root, Map<Integer, String> operations) {\\n\\n        String left = null;\\n        String right = null;\\n\\n        if (root.left==null && root.right==null){\\n            return operations.get(root.val);\\n        }\\n\\n        if (root.left!=null)\\n            left = evaluateBoolean(root.left, operations);\\n\\n        if (root.right!=null)\\n            right = evaluateBoolean(root.right, operations);\\n    \\n        if (Objects.nonNull(left) && Objects.nonNull(right)) {\\n            boolean leftBoolValue = false;\\n            boolean rightBoolValue = false;\\n            boolean result = false;\\n        \\n            if (left.equalsIgnoreCase(\"TRUE\"))\\n                leftBoolValue = true;\\n\\n\\n            if (right.equalsIgnoreCase(\"TRUE\"))\\n                rightBoolValue = true;\\n\\n            if (root.val==2) {\\n                result =  leftBoolValue || rightBoolValue;\\n            } else if (root.val==3) {\\n                result =  leftBoolValue && rightBoolValue;\\n            }\\n\\n            if (result){\\n                return \"TRUE\";\\n            } else {\\n                return \"FALSE\";\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n```\\nBetter One\\n\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        boolean leftAns = evaluateTree(root.left);\\n        boolean rightAns = evaluateTree(root.right);\\n        return root.val==2 ? leftAns|rightAns : leftAnsBru&rightAns;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static boolean evaluateTree(TreeNode root) {\\n        Map<Integer,String> operations = new HashMap<>();\\n        operations.put(0,\"FALSE\");\\n        operations.put(1,\"TRUE\");\\n        operations.put(2,\"OR\");\\n        operations.put(3,\"AND\");\\n\\n        String ans = evaluateBoolean(root, operations);\\n        if (Objects.nonNull(ans)) {\\n            return ans.equalsIgnoreCase(\"TRUE\");\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    private static String evaluateBoolean(TreeNode root, Map<Integer, String> operations) {\\n\\n        String left = null;\\n        String right = null;\\n\\n        if (root.left==null && root.right==null){\\n            return operations.get(root.val);\\n        }\\n\\n        if (root.left!=null)\\n            left = evaluateBoolean(root.left, operations);\\n\\n        if (root.right!=null)\\n            right = evaluateBoolean(root.right, operations);\\n    \\n        if (Objects.nonNull(left) && Objects.nonNull(right)) {\\n            boolean leftBoolValue = false;\\n            boolean rightBoolValue = false;\\n            boolean result = false;\\n        \\n            if (left.equalsIgnoreCase(\"TRUE\"))\\n                leftBoolValue = true;\\n\\n\\n            if (right.equalsIgnoreCase(\"TRUE\"))\\n                rightBoolValue = true;\\n\\n            if (root.val==2) {\\n                result =  leftBoolValue || rightBoolValue;\\n            } else if (root.val==3) {\\n                result =  leftBoolValue && rightBoolValue;\\n            }\\n\\n            if (result){\\n                return \"TRUE\";\\n            } else {\\n                return \"FALSE\";\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nBetter One\\n\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        boolean leftAns = evaluateTree(root.left);\\n        boolean rightAns = evaluateTree(root.right);\\n        return root.val==2 ? leftAns|rightAns : leftAnsBru&rightAns;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245299,
                "title": "five-liner-63-ms-beats-100-easy-to-understand",
                "content": "# Code\\n```swift\\nfunc evaluateTree(_ root: TreeNode?) -> Bool {\\n    switch root!.val {\\n    case 2: return evaluateTree(root!.left) || evaluateTree(root!.right)\\n    case 3: return evaluateTree(root!.left) && evaluateTree(root!.right)\\n    default: return root!.val == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Recursion"
                ],
                "code": "```swift\\nfunc evaluateTree(_ root: TreeNode?) -> Bool {\\n    switch root!.val {\\n    case 2: return evaluateTree(root!.left) || evaluateTree(root!.right)\\n    case 3: return evaluateTree(root!.left) && evaluateTree(root!.right)\\n    default: return root!.val == 1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3168889,
                "title": "js-dfs-recursion",
                "content": "# Intuition\\nTo solve it recursively, think of the base case. In this case it is when root does not exist. Then call the function recursively for the left / right children.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the number of nodes the tree has. This is the worst case scenario because we will have to visit every node in the tree once.\\n\\n- Space complexity:\\nO(h) where h is the height of the tree. We store the calls to the function on the call stack up to the height of the tree. Average case of binary tree height is O(logn) worst case is O(n)\\n\\n# Code\\n```\\nvar evaluateTree = function(root) {\\n    if (!root) return\\n\\n    let left = evaluateTree(root.left)\\n    let right = evaluateTree(root.right)\\n\\n    if(root.val === 2) return left || right\\n    if(root.val === 3) return left && right\\n    \\n    return root.val\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar evaluateTree = function(root) {\\n    if (!root) return\\n\\n    let left = evaluateTree(root.left)\\n    let right = evaluateTree(root.right)\\n\\n    if(root.val === 2) return left || right\\n    if(root.val === 3) return left && right\\n    \\n    return root.val\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3156247,
                "title": "recursive-java-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val == 0 ? false : true;\\n        else if(root.val == 2) return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val == 0 ? false : true;\\n        else if(root.val == 2) return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130314,
                "title": "post-ordertraversal-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left==null && root.right==null){\\n            if(root.val==0){\\n                return false;\\n            }\\n            return true;\\n        }\\n        boolean left = evaluateTree(root.left);\\n        boolean right = evaluateTree(root.right);\\n\\n        if(root.val==2){\\n            return left || right;\\n        }\\n        return left&&right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left==null && root.right==null){\\n            if(root.val==0){\\n                return false;\\n            }\\n            return true;\\n        }\\n        boolean left = evaluateTree(root.left);\\n        boolean right = evaluateTree(root.right);\\n\\n        if(root.val==2){\\n            return left || right;\\n        }\\n        return left&&right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057080,
                "title": "small-brain-solution",
                "content": "# Code\\n```\\ntype Node = Option<std::rc::Rc<std::cell::RefCell<TreeNode>>>;\\nimpl Solution {\\n    pub fn evaluate_tree(root: Node) -> bool {\\n        Self::dfs(root)\\n    }\\n    fn dfs(n: Node) -> bool {\\n        let node = n.as_ref().unwrap().borrow();\\n        \\n        match node.val {\\n            0 =>  false,\\n            1 =>  true,\\n            2 =>  Self::dfs(node.right.clone()) || Self::dfs(node.left.clone()),\\n            _ =>  Self::dfs(node.right.clone()) && Self::dfs(node.left.clone()),\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\ntype Node = Option<std::rc::Rc<std::cell::RefCell<TreeNode>>>;\\nimpl Solution {\\n    pub fn evaluate_tree(root: Node) -> bool {\\n        Self::dfs(root)\\n    }\\n    fn dfs(n: Node) -> bool {\\n        let node = n.as_ref().unwrap().borrow();\\n        \\n        match node.val {\\n            0 =>  false,\\n            1 =>  true,\\n            2 =>  Self::dfs(node.right.clone()) || Self::dfs(node.left.clone()),\\n            _ =>  Self::dfs(node.right.clone()) && Self::dfs(node.left.clone()),\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052081,
                "title": "easy-solution-recursive-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n       int ans=0;\\n    int solve(TreeNode*root){\\n        \\n         if(root==NULL){\\n             return 0;\\n         }\\n        \\n        int lh=solve(root->left);\\n        int rh=solve(root->right);\\n        \\n        if(root->val==2){  // if OR\\n            ans= lh || rh;\\n        }else if(root->val==3){   // if AND\\n           ans= lh && rh;\\n        }\\n        else{\\n            ans=root->val;   \\n        }\\n        \\n       return ans; \\n        \\n    }\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        return solve(root);\\n          \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n       int ans=0;\\n    int solve(TreeNode*root){\\n        \\n         if(root==NULL){\\n             return 0;\\n         }\\n        \\n        int lh=solve(root->left);\\n        int rh=solve(root->right);\\n        \\n        if(root->val==2){  // if OR\\n            ans= lh || rh;\\n        }else if(root->val==3){   // if AND\\n           ans= lh && rh;\\n        }\\n        else{\\n            ans=root->val;   \\n        }\\n        \\n       return ans; \\n        \\n    }\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        return solve(root);\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957781,
                "title": "simple-recursive-solution-in-cpp",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if( root->val == 1)return true;\\n        if( root->val ==0)return false;\\n        if (root->val ==2)return evaluateTree(root->left) or evaluateTree(root->right);\\n        if(root->val ==3)return evaluateTree(root->left) and evaluateTree (root->right);\\n\\n        return true;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if( root->val == 1)return true;\\n        if( root->val ==0)return false;\\n        if (root->val ==2)return evaluateTree(root->left) or evaluateTree(root->right);\\n        if(root->val ==3)return evaluateTree(root->left) and evaluateTree (root->right);\\n\\n        return true;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915879,
                "title": "c-faster-tan-99-66-easy-to-understand",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* &root) {\\n        if(root == NULL) return 0;\\n\\n        if(root->val == 2)\\n            return (  evaluateTree(root->left) || evaluateTree(root->right));\\n        if(root->val == 3)\\n            return (  evaluateTree(root->left) && evaluateTree(root->right));\\n        \\n        return root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* &root) {\\n        if(root == NULL) return 0;\\n\\n        if(root->val == 2)\\n            return (  evaluateTree(root->left) || evaluateTree(root->right));\\n        if(root->val == 3)\\n            return (  evaluateTree(root->left) && evaluateTree(root->right));\\n        \\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856689,
                "title": "python-simple-python-solution-using-dfs-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 115 ms, faster than 52.00% of Python3 online submissions for Evaluate Boolean Binary Tree.\\n# Memory Usage: 14.7 MB, less than 60.14% of Python3 online submissions for Evaluate Boolean Binary Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef DFS(node):\\n\\n\\t\\t\\t\\tif node.val != 2 and node.val != 3:\\n\\t\\t\\t\\t\\treturn node.val\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tleft = DFS(node.left)\\n\\t\\t\\t\\t\\tright = DFS(node.right)\\n\\n\\t\\t\\t\\t\\tif node.val == 2:\\n\\t\\t\\t\\t\\t\\treturn left or right\\n\\t\\t\\t\\t\\tif node.val == 3:\\n\\t\\t\\t\\t\\t\\treturn left and right\\n\\n\\t\\t\\treturn DFS(root)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 115 ms, faster than 52.00% of Python3 online submissions for Evaluate Boolean Binary Tree.\\n# Memory Usage: 14.7 MB, less than 60.14% of Python3 online submissions for Evaluate Boolean Binary Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef DFS(node):\\n\\n\\t\\t\\t\\tif node.val != 2 and node.val != 3:\\n\\t\\t\\t\\t\\treturn node.val\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tleft = DFS(node.left)\\n\\t\\t\\t\\t\\tright = DFS(node.right)\\n\\n\\t\\t\\t\\t\\tif node.val == 2:\\n\\t\\t\\t\\t\\t\\treturn left or right\\n\\t\\t\\t\\t\\tif node.val == 3:\\n\\t\\t\\t\\t\\t\\treturn left and right\\n\\n\\t\\t\\treturn DFS(root)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2693180,
                "title": "cpp-simple-solution",
                "content": "```\\nbool evaluateTree(TreeNode* root) {\\n           if(root==NULL)\\n               return 0;\\n           if(root->val==1)\\n               return true;\\n           if(root->val==0)\\n               return false;\\n           if(root->val==2&&(evaluateTree(root->left)||evaluateTree(root->right)))\\n               return true;\\n           else if(root->val==3&&evaluateTree(root->left)&&evaluateTree(root->right))\\n               return true;\\n        return false;\\n               \\n    }",
                "solutionTags": [],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n           if(root==NULL)\\n               return 0;\\n           if(root->val==1)\\n               return true;\\n           if(root->val==0)\\n               return false;\\n           if(root->val==2&&(evaluateTree(root->left)||evaluateTree(root->right)))\\n               return true;\\n           else if(root->val==3&&evaluateTree(root->left)&&evaluateTree(root->right))\\n               return true;\\n        return false;\\n               \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2693043,
                "title": "golang",
                "content": "- Runtime: 25 ms, faster than 37.84% of Go online submissions for Evaluate Boolean Binary Tree.\\n- Memory Usage: 6.6 MB, less than 77.03% of Go online submissions for Evaluate Boolean Binary Tree.\\n\\n```\\nfunc evaluateTree(root *TreeNode) bool {\\n    if root == nil { return false }\\n    if root.Left == nil && root.Right == nil {\\n        if root.Val == 1 {\\n            return true\\n        }\\n        return false        \\n    }\\n\\n    if root.Val == 2 {\\n        return evaluateTree(root.Left) || evaluateTree(root.Right)\\n    }\\n    return evaluateTree(root.Left) && evaluateTree(root.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc evaluateTree(root *TreeNode) bool {\\n    if root == nil { return false }\\n    if root.Left == nil && root.Right == nil {\\n        if root.Val == 1 {\\n            return true\\n        }\\n        return false        \\n    }\\n\\n    if root.Val == 2 {\\n        return evaluateTree(root.Left) || evaluateTree(root.Right)\\n    }\\n    return evaluateTree(root.Left) && evaluateTree(root.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650282,
                "title": "java-easy-solution-100-faster-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return DFS(root) == 1;\\n    }\\n\\n    private int DFS(TreeNode root) {\\n        if (root.val == 2){\\n            int sum = DFS(root.left) + DFS(root.right);\\n            return (sum == 2) ? 1 : sum;   \\n        } \\n        if (root.val == 3)\\n            return DFS(root.left) * DFS(root.right);\\n        return root.val;\\n    }\\n}\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return DFS(root) == 1;\\n    }\\n\\n    private int DFS(TreeNode root) {\\n        if (root.val == 2){\\n            int sum = DFS(root.left) + DFS(root.right);\\n            return (sum == 2) ? 1 : sum;   \\n        } \\n        if (root.val == 3)\\n            return DFS(root.left) * DFS(root.right);\\n        return root.val;\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2579918,
                "title": "3-line-c-soultion-short-and-clean",
                "content": "```\\n bool evaluateTree(TreeNode* node) {\\n        if(node->val==2)return evaluateTree(node->left) || evaluateTree(node->right);\\n        if(node->val==3)return evaluateTree(node->left) && evaluateTree(node->right);\\n        return node->val;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n bool evaluateTree(TreeNode* node) {\\n        if(node->val==2)return evaluateTree(node->left) || evaluateTree(node->right);\\n        if(node->val==3)return evaluateTree(node->left) && evaluateTree(node->right);\\n        return node->val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2544388,
                "title": "recursive-java-dfs-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        int ans = helper(root);\\n        return (ans!=0);\\n    }\\n    int helper(TreeNode root){\\n        if(root == null) return 0;\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n        \\n        if(root.val == 2)\\n           root.val = (left | right);\\n            \\n        if(root.val == 3)\\n            root.val = left & right;\\n        \\n        return root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        int ans = helper(root);\\n        return (ans!=0);\\n    }\\n    int helper(TreeNode root){\\n        if(root == null) return 0;\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n        \\n        if(root.val == 2)\\n           root.val = (left | right);\\n            \\n        if(root.val == 3)\\n            root.val = left & right;\\n        \\n        return root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510941,
                "title": "100-fast-java-solution-4-line-of-logic-switch-case",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {        \\n        return (answer(root)== 1)? true: false;\\n    }\\n    public int answer(TreeNode root){\\n       \\n        switch(root.val) {\\n        case 0: return 0;\\n        case 1: \\n                return root.val;           \\n        case 2:\\n            return answer(root.left)|answer(root.right);\\n        default:\\n            return answer(root.left)&answer(root.right);           \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {        \\n        return (answer(root)== 1)? true: false;\\n    }\\n    public int answer(TreeNode root){\\n       \\n        switch(root.val) {\\n        case 0: return 0;\\n        case 1: \\n                return root.val;           \\n        case 2:\\n            return answer(root.left)|answer(root.right);\\n        default:\\n            return answer(root.left)&answer(root.right);           \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505601,
                "title": "simple-c-solution-dfs-just-handle-corner-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->val == 0) return false;\\n        if(root->val == 1) return true;\\n        \\n        bool left = evaluateTree(root->left);\\n        bool right = evaluateTree(root->right);\\n        \\n        if(root->val == 2) return left or right;\\n        else return left and right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->val == 0) return false;\\n        if(root->val == 1) return true;\\n        \\n        bool left = evaluateTree(root->left);\\n        bool right = evaluateTree(root->right);\\n        \\n        if(root->val == 2) return left or right;\\n        else return left and right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503328,
                "title": "java-solution-0-ms-100-faster-dfs-explained",
                "content": "I used recursive approach here.\\n\\nIn recursive method I first check the base case when both child nodes are null. If it\\'s true, then return true or false depending on value of a node.\\n\\nThen I check if node\\'s value is 2. If that\\'s true, then return values of child left subtree and child right subtree with OR expression.\\n\\nIf node\\'s value is 3. Then I return values of child left subtree and child right subtree with AND expression.\\n\\nFinally, I return if the value of current node is equal to 1.\\n\\nSubtree here means calling method recursively for a child of current node.\\nGood luck! :)\\n```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return traverseFullBinaryTree(root);\\n    }\\n    \\n    private boolean traverseFullBinaryTree(TreeNode node) {\\n        if (node.left == null && node.right == null) {\\n            return node.val == 1;\\n        }\\n\\n        if (node.val == 2) {\\n            node.val = traverseFullBinaryTree(node.left) || traverseFullBinaryTree(node.right) ? 1 : 0;\\n        } else if (node.val == 3) {\\n            node.val = traverseFullBinaryTree(node.left) && traverseFullBinaryTree(node.right) ? 1 : 0;\\n        }\\n        return node.val == 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        return traverseFullBinaryTree(root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2413429,
                "title": "simple-cpp-code-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left == NULL) return root->val;\\n        if(root -> val == 2) return (evaluateTree(root -> left) || evaluateTree(root -> right));\\n        else return (evaluateTree(root -> left) && evaluateTree(root -> right));\\n    }\\n};\\n```\\n\\nIts just plain and simple recursion in trees",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left == NULL) return root->val;\\n        if(root -> val == 2) return (evaluateTree(root -> left) || evaluateTree(root -> right));\\n        else return (evaluateTree(root -> left) && evaluateTree(root -> right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410885,
                "title": "java-recursive-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n      if(root.val == 1)\\n        return true;\\n      else if(root.val == 0)\\n        return false;\\n      else if(root.val == 2) \\n        return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right); \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n      if(root.val == 1)\\n        return true;\\n      else if(root.val == 0)\\n        return false;\\n      else if(root.val == 2) \\n        return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408009,
                "title": "postorder-recursive-java-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null){\\n            if(root.val == 0){\\n                return false;\\n            }else{\\n                return true;\\n            }\\n        }\\n        boolean lans = evaluateTree(root.left);\\n        boolean rans = evaluateTree(root.right);\\n        boolean myans = false;\\n        if(root.val == 2){\\n            myans = lans || rans;\\n        }else if(root.val == 3){\\n            myans = lans && rans;\\n        }\\n        return myans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null){\\n            if(root.val == 0){\\n                return false;\\n            }else{\\n                return true;\\n            }\\n        }\\n        boolean lans = evaluateTree(root.left);\\n        boolean rans = evaluateTree(root.right);\\n        boolean myans = false;\\n        if(root.val == 2){\\n            myans = lans || rans;\\n        }else if(root.val == 3){\\n            myans = lans && rans;\\n        }\\n        return myans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406537,
                "title": "easy-understandable-java-solution-recursive-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if (root.left == null && root.right == null) {\\n            if (root.val == 0) {\\n                return false;\\n            } else {\\n                return true;\\n            }\\n        }\\n        \\n        if (root.val == 2) {\\n            return evaluateTree(root.left) || evaluateTree(root.right);\\n        } else {\\n            return evaluateTree(root.right) && evaluateTree(root.left);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if (root.left == null && root.right == null) {\\n            if (root.val == 0) {\\n                return false;\\n            } else {\\n                return true;\\n            }\\n        }\\n        \\n        if (root.val == 2) {\\n            return evaluateTree(root.left) || evaluateTree(root.right);\\n        } else {\\n            return evaluateTree(root.right) && evaluateTree(root.left);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393874,
                "title": "evaluate-boolean-binary-tree-c-solution-faster-than-93-5",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        switch(root->val){\\n            case 0:return false;\\n            case 1:return true;\\n            case 2:return (evaluateTree(root->left) || evaluateTree(root->right));\\n            case 3:return (evaluateTree(root->left) && evaluateTree(root->right));             \\n        }\\n        return false;\\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        switch(root->val){\\n            case 0:return false;\\n            case 1:return true;\\n            case 2:return (evaluateTree(root->left) || evaluateTree(root->right));\\n            case 3:return (evaluateTree(root->left) && evaluateTree(root->right));             \\n        }\\n        return false;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2386193,
                "title": "simple-concise-code",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val<2)\\n            return root.val==1;\\n        else{\\n            return (root.val==2)?evaluateTree(root.left) | evaluateTree(root.right):\\n                                 evaluateTree(root.left) & evaluateTree(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val<2)\\n            return root.val==1;\\n        else{\\n            return (root.val==2)?evaluateTree(root.left) | evaluateTree(root.right):\\n                                 evaluateTree(root.left) & evaluateTree(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380663,
                "title": "simple-recursive-swift-solution-with-comments-no-nil-checks-needed",
                "content": "```\\nclass Solution {\\n    func evaluateTree(_ root: TreeNode?) -> Bool {\\n        // we never need to check for nil because we\\'ll never call this on nil node\\n        if root!.val == 1 { return true }\\n        if root!.val == 0 { return false }\\n        \\n        // OR case\\n        if root!.val == 2 { \\n            return evaluateTree(root!.left) || evaluateTree(root!.right) \\n        }\\n        \\n        // If we got this far then val must be 3 (AND)\\n        return evaluateTree(root!.left) && evaluateTree(root!.right)\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func evaluateTree(_ root: TreeNode?) -> Bool {\\n        // we never need to check for nil because we\\'ll never call this on nil node\\n        if root!.val == 1 { return true }\\n        if root!.val == 0 { return false }\\n        \\n        // OR case\\n        if root!.val == 2 { \\n            return evaluateTree(root!.left) || evaluateTree(root!.right) \\n        }\\n        \\n        // If we got this far then val must be 3 (AND)\\n        return evaluateTree(root!.left) && evaluateTree(root!.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379762,
                "title": "easy-c-solution",
                "content": "```\\nbool evaluateTree(TreeNode* root) {\\n\\tif(!root->left && !root->right){\\n\\t\\treturn root->val;\\n\\t}\\n\\telse if(root->val == 2){\\n\\t\\tbool x = evaluateTree(root->left);\\n\\t\\tbool y = evaluateTree(root->right);\\n\\t\\treturn x | y;\\n\\t}\\n\\telse{\\n\\t\\tbool x = evaluateTree(root->left);\\n\\t\\tbool y = evaluateTree(root->right);\\n\\t\\treturn x & y;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n\\tif(!root->left && !root->right){\\n\\t\\treturn root->val;\\n\\t}\\n\\telse if(root->val == 2){\\n\\t\\tbool x = evaluateTree(root->left);\\n\\t\\tbool y = evaluateTree(root->right);\\n\\t\\treturn x | y;\\n\\t}\\n\\telse{\\n\\t\\tbool x = evaluateTree(root->left);\\n\\t\\tbool y = evaluateTree(root->right);\\n\\t\\treturn x & y;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379591,
                "title": "100-faster-java-code-easy-to-understand",
                "content": "```\\npublic boolean evaluateTree(TreeNode root) {\\n        \\n        if(root.val==0)\\n            return false;\\n        if(root.val==1)\\n            return true;\\n        if(root.val==2)\\n            return(evaluateTree(root.left) || evaluateTree(root.right));\\n        else\\n            return(evaluateTree(root.left) && evaluateTree(root.right));\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean evaluateTree(TreeNode root) {\\n        \\n        if(root.val==0)\\n            return false;\\n        if(root.val==1)\\n            return true;\\n        if(root.val==2)\\n            return(evaluateTree(root.left) || evaluateTree(root.right));\\n        else\\n            return(evaluateTree(root.left) && evaluateTree(root.right));\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2375997,
                "title": "swift-simple-three-liner",
                "content": "**Simple DFS Evaluation (accepted answer)**\\n```\\nclass Solution {\\n    func evaluateTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root, root.val > 1 else { return root?.val == 1  }\\n        let (left, right) = (evaluateTree(root.left), evaluateTree(root.right))\\n        return root.val == 2 ? left || right : left && right\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func evaluateTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root, root.val > 1 else { return root?.val == 1  }\\n        let (left, right) = (evaluateTree(root.left), evaluateTree(root.right))\\n        return root.val == 2 ? left || right : left && right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372946,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        if(!root->left and !root->right) //leaf node detection\\n            return root->val;\\n        \\n        bool left = evaluateTree(root->left); //left subtree evaluation\\n        bool right = evaluateTree(root->right); //right subtree evaluation\\n        \\n        if(root->val == 2) //non-leaf node and value as 2\\n            return (left or right); //apply OR operation for its left and right nodes\\n        \\n        if(root->val == 3) //non-leaf node and value as 3\\n            return (left and right); //apply AND operation for its left and right nodes\\n    \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        if(!root->left and !root->right) //leaf node detection\\n            return root->val;\\n        \\n        bool left = evaluateTree(root->left); //left subtree evaluation\\n        bool right = evaluateTree(root->right); //right subtree evaluation\\n        \\n        if(root->val == 2) //non-leaf node and value as 2\\n            return (left or right); //apply OR operation for its left and right nodes\\n        \\n        if(root->val == 3) //non-leaf node and value as 3\\n            return (left and right); //apply AND operation for its left and right nodes\\n    \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366627,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        # if non-leaf node 2 -> OR\\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        # if non-leaf node 3 -> AND\\n        elif root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n        return root.val\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        # if non-leaf node 2 -> OR\\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        # if non-leaf node 3 -> AND\\n        elif root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n        return root.val\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361083,
                "title": "python-easy-3liner",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        if root.val < 2:\\n            return root.val\\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        if root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        if root.val < 2:\\n            return root.val\\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        if root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338047,
                "title": "java-solution-if-conditions",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0){\\n            return false;\\n        }\\n        if(root.val == 1){\\n            return true;\\n        }\\n        if(root.val == 3){\\n            return (evaluateTree(root.left) && evaluateTree(root.right));\\n        }\\n        if(root.val == 2){\\n            return (evaluateTree(root.left) || evaluateTree(root.right));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0){\\n            return false;\\n        }\\n        if(root.val == 1){\\n            return true;\\n        }\\n        if(root.val == 3){\\n            return (evaluateTree(root.left) && evaluateTree(root.right));\\n        }\\n        if(root.val == 2){\\n            return (evaluateTree(root.left) || evaluateTree(root.right));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331815,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func evaluateTree(_ root: TreeNode?) -> Bool {\\n        switch root { \\n        case .some(let node):\\n            switch node.val { \\n                case 1:\\n                    return true\\n                case 2:\\n                    return evaluateTree(root?.left) || evaluateTree(root?.right)\\n                case 3: \\n                    return evaluateTree(root?.left) && evaluateTree(root?.right)\\n                default: \\n                    return false\\n            }\\n        case .none:\\n            return false\\n        }\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    func evaluateTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return false }\\n        if root.left == nil && root.right == nil { \\n            if root.val == 0 { return false }\\n            if root.val == 1 { return true }\\n        }\\n        if root.val == 2 { \\n            return evaluateTree(root.left) || evaluateTree(root.right)\\n        }\\n        if root.val == 3 { \\n            return evaluateTree(root.left) && evaluateTree(root.right)\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func evaluateTree(_ root: TreeNode?) -> Bool {\\n        switch root { \\n        case .some(let node):\\n            switch node.val { \\n                case 1:\\n                    return true\\n                case 2:\\n                    return evaluateTree(root?.left) || evaluateTree(root?.right)\\n                case 3: \\n                    return evaluateTree(root?.left) && evaluateTree(root?.right)\\n                default: \\n                    return false\\n            }\\n        case .none:\\n            return false\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func evaluateTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return false }\\n        if root.left == nil && root.right == nil { \\n            if root.val == 0 { return false }\\n            if root.val == 1 { return true }\\n        }\\n        if root.val == 2 { \\n            return evaluateTree(root.left) || evaluateTree(root.right)\\n        }\\n        if root.val == 3 { \\n            return evaluateTree(root.left) && evaluateTree(root.right)\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331796,
                "title": "java-trees",
                "content": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left==null && root.right==null) \\n            return root.val==1?true:false;\\n        \\n        boolean lr=evaluateTree(root.left);\\n        boolean rr=evaluateTree(root.right);\\n        \\n        return (root.val==2)? lr | rr : lr & rr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left==null && root.right==null) \\n            return root.val==1?true:false;\\n        \\n        boolean lr=evaluateTree(root.left);\\n        boolean rr=evaluateTree(root.right);\\n        \\n        return (root.val==2)? lr | rr : lr & rr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314759,
                "title": "easiest-logic-beginner-friendly-0ms-faster-than-100-c-recursion",
                "content": "class Solution {\\npublic:\\n\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL){\\n            if(root->val == 0){\\n                return false;\\n            }\\n            if(root->val == 1){\\n                return true;\\n            }\\n        }\\n        bool left = evaluateTree(root->left);\\n        bool right = evaluateTree(root->right);\\n        \\n        if(root->val == 2){\\n            return left||right;\\n        }\\n        if(root->val == 3){\\n            return left && right;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL){\\n            if(root->val == 0){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2301426,
                "title": "java-3-lines",
                "content": "```\\npublic boolean evaluateTree(TreeNode root) {\\n\\tif(root.val == 2) return evaluateTree(root.left)||evaluateTree(root.right);\\n\\tif(root.val == 3) return evaluateTree(root.left)&&evaluateTree(root.right);\\n\\treturn root.val==1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean evaluateTree(TreeNode root) {\\n\\tif(root.val == 2) return evaluateTree(root.left)||evaluateTree(root.right);\\n\\tif(root.val == 3) return evaluateTree(root.left)&&evaluateTree(root.right);\\n\\treturn root.val==1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2300275,
                "title": "c-easy-recursive-code",
                "content": "# ****Recursive Code\\n       bool evaluateTree(TreeNode* node) {\\n        //base case\\n        if(node==NULL)\\n        {\\n            return false;\\n        }\\n        bool f1 = evaluateTree(node->left);\\n        bool f2 = evaluateTree(node->right);\\n        if(node->val==2)\\n        {\\n            return f1||f2;\\n        }\\n        else if(node->val==3)\\n        {\\n            return f1&&f2;\\n        }\\n        else if(node->val==1)\\n        {\\n            return true;\\n        }\\n        else\\n            return false;\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# ****Recursive Code\\n       bool evaluateTree(TreeNode* node) {\\n        //base case\\n        if(node==NULL)\\n        {\\n            return false;\\n        }\\n        bool f1 = evaluateTree(node->left);\\n        bool f2 = evaluateTree(node->right);\\n        if(node->val==2)\\n        {\\n            return f1||f2;\\n        }\\n        else if(node->val==3)\\n        {\\n            return f1&&f2;\\n        }\\n        else if(node->val==1)\\n        {\\n            return true;\\n        }\\n        else\\n            return false;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2291745,
                "title": "dfs-5-lines",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if not root.left:\\n            return root.val\\n        x = self.evaluateTree(root.left)\\n        y = self.evaluateTree(root.right)\\n        return x or y if root.val == 2 else x and y\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if not root.left:\\n            return root.val\\n        x = self.evaluateTree(root.left)\\n        y = self.evaluateTree(root.right)\\n        return x or y if root.val == 2 else x and y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290134,
                "title": "rust-solution",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn evaluate_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let node = root.as_ref().unwrap().borrow();\\n        match node.val {\\n            x @ (0 | 1) => x == 1,\\n            2 => {\\n                Solution::evaluate_tree(node.left.clone())\\n                    || Solution::evaluate_tree(node.right.clone())\\n            }\\n            _ => {\\n                Solution::evaluate_tree(node.left.clone())\\n                    && Solution::evaluate_tree(node.right.clone())\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn evaluate_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let node = root.as_ref().unwrap().borrow();\\n        match node.val {\\n            x @ (0 | 1) => x == 1,\\n            2 => {\\n                Solution::evaluate_tree(node.left.clone())\\n                    || Solution::evaluate_tree(node.right.clone())\\n            }\\n            _ => {\\n                Solution::evaluate_tree(node.left.clone())\\n                    && Solution::evaluate_tree(node.right.clone())\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2288431,
                "title": "java-easy-simple",
                "content": "```\\n /*\\n Wassup fellasssss!!!\\n \\n Alright that\\'s enough for greeting\\n here goes the logic\\n \\n any node will have any of the 4 values 0 or 1 or 2 or 3\\n and for every non leaf node we have to evaluate \\n leftNode.val || leftNode.val\\n OR \\n leftNode.val && leftNode.val \\n \\n So first we take the left node and take the right node (boolean result)\\n Once we have that then the remaining part is simple\\n if node val is 1 we return true\\n if node val is 0 we return false\\n if node val is 2 we take left and right node and return (left || right)\\n if node val is 3 we take left and right node and return (left && right)\\n Although we don\\'t really need to take 3 in the if condiion \\n as in the constraints it has mentioned that the values will be 0 or 1 or 2 or 3\\n \\n I hope the logic is super clear to whoever see\\'s this!!\\n Adiooosss!!!!\\n */\\nclass Solution {\\n    private boolean func(TreeNode root,boolean res) {\\n        if(root == null) return res;\\n        boolean left = func(root.left,res);\\n        boolean right = func(root.right,res);\\n        if(root.val == 1) return true;\\n        if(root.val == 0) return false;\\n        if(root.val == 2) return (left || right);\\n        return (left && right);\\n    }\\n    public boolean evaluateTree(TreeNode root) {\\n        boolean res = false;\\n        if(root == null) return false;\\n        return func(root,res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n /*\\n Wassup fellasssss!!!\\n \\n Alright that\\'s enough for greeting\\n here goes the logic\\n \\n any node will have any of the 4 values 0 or 1 or 2 or 3\\n and for every non leaf node we have to evaluate \\n leftNode.val || leftNode.val\\n OR \\n leftNode.val && leftNode.val \\n \\n So first we take the left node and take the right node (boolean result)\\n Once we have that then the remaining part is simple\\n if node val is 1 we return true\\n if node val is 0 we return false\\n if node val is 2 we take left and right node and return (left || right)\\n if node val is 3 we take left and right node and return (left && right)\\n Although we don\\'t really need to take 3 in the if condiion \\n as in the constraints it has mentioned that the values will be 0 or 1 or 2 or 3\\n \\n I hope the logic is super clear to whoever see\\'s this!!\\n Adiooosss!!!!\\n */\\nclass Solution {\\n    private boolean func(TreeNode root,boolean res) {\\n        if(root == null) return res;\\n        boolean left = func(root.left,res);\\n        boolean right = func(root.right,res);\\n        if(root.val == 1) return true;\\n        if(root.val == 0) return false;\\n        if(root.val == 2) return (left || right);\\n        return (left && right);\\n    }\\n    public boolean evaluateTree(TreeNode root) {\\n        boolean res = false;\\n        if(root == null) return false;\\n        return func(root,res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283898,
                "title": "c-2331-evaluate-boolean-binary-tree",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if (root->val == 0)\\n            return (false);\\n        if (root->val == 1)\\n            return (true);\\n        \\n        bool rightVal;\\n        bool leftVal;\\n        \\n        rightVal = evaluateTree(root->right);\\n        leftVal = evaluateTree(root->left);\\n        if (root->val == 2)\\n            return (rightVal || leftVal);\\n        return (rightVal && leftVal);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if (root->val == 0)\\n            return (false);\\n        if (root->val == 1)\\n            return (true);\\n        \\n        bool rightVal;\\n        bool leftVal;\\n        \\n        rightVal = evaluateTree(root->right);\\n        leftVal = evaluateTree(root->left);\\n        if (root->val == 2)\\n            return (rightVal || leftVal);\\n        return (rightVal && leftVal);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2270083,
                "title": "python3-dfs-recursive-iterative",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/04944f0a6a1f4d50ee6efd64fabfc227724cdc7a) for solutions of biweekly 82. \\n\\n```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val in (0, 1): return bool(root.val)\\n        elif root.val == 2: return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```\\n\\n```\\nclass Solution: \\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        mp = {}\\n        stack = []\\n        prev, node = None, root\\n        while node or stack: \\n            if node: \\n                stack.append(node)\\n                node = node.left\\n            else: \\n                node = stack[-1]\\n                if node.right and node.right != prev: node = node.right \\n                else: \\n                    if not node.left and not node.right: mp[node] = node.val\\n                    elif node.val == 2: mp[node] = mp[node.left] or mp[node.right]\\n                    else: mp[node] = mp[node.left] and mp[node.right]\\n                    stack.pop()\\n                    prev = node \\n                    node = None\\n        return mp[root] \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val in (0, 1): return bool(root.val)\\n        elif root.val == 2: return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```\n```\\nclass Solution: \\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        mp = {}\\n        stack = []\\n        prev, node = None, root\\n        while node or stack: \\n            if node: \\n                stack.append(node)\\n                node = node.left\\n            else: \\n                node = stack[-1]\\n                if node.right and node.right != prev: node = node.right \\n                else: \\n                    if not node.left and not node.right: mp[node] = node.val\\n                    elif node.val == 2: mp[node] = mp[node.left] or mp[node.right]\\n                    else: mp[node] = mp[node.left] and mp[node.right]\\n                    stack.pop()\\n                    prev = node \\n                    node = None\\n        return mp[root] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270042,
                "title": "c-dfs-postorder-traversal",
                "content": "1. If it is leaf node return same value\\n2. Evaluate left subtree\\n3. Evaluate right subtree\\n4. return the value depending on value of root\\n\\n```\\nbool evaluateTree(TreeNode* root) {\\n        \\n        if(!root->left && !root->right) return root->val;\\n        \\n        bool left = evaluateTree(root->left);\\n        bool right = evaluateTree(root->right);\\n        \\n        if(root->val == 2) return left || right;\\n        \\n        return left && right;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n        \\n        if(!root->left && !root->right) return root->val;\\n        \\n        bool left = evaluateTree(root->left);\\n        bool right = evaluateTree(root->right);\\n        \\n        if(root->val == 2) return left || right;\\n        \\n        return left && right;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269455,
                "title": "python-dfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.left is None and root.right is None:\\n            if root.val == 1:\\n                return True\\n            else:\\n                return False\\n        \\n        l = self.evaluateTree(root.left)         #find ans from left part\\n        r = self.evaluateTree(root.right)        #find ans from right part\\n        \\n        if root.val == 2:                         \\n            return l or r\\n        elif root.val == 3:\\n            return l and r\\n        \\n        \\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.left is None and root.right is None:\\n            if root.val == 1:\\n                return True\\n            else:\\n                return False\\n        \\n        l = self.evaluateTree(root.left)         #find ans from left part\\n        r = self.evaluateTree(root.right)        #find ans from right part\\n        \\n        if root.val == 2:                         \\n            return l or r\\n        elif root.val == 3:\\n            return l and r\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264402,
                "title": "c-100-faster-recursion",
                "content": "```\\nbool solve(TreeNode *root)\\n   {\\n     if(!root->left && !root->right)\\n      {\\n       if(root->val==0)\\n         return false;\\n       return true;\\n      }\\n     bool left=solve(root->left);\\n     bool right=solve(root->right);\\n     \\n     if(root->val==2)\\n       return left || right;\\n     \\n     return left & right;\\n     \\n   }\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        return solve(root);\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\nbool solve(TreeNode *root)\\n   {\\n     if(!root->left && !root->right)\\n      {\\n       if(root->val==0)\\n         return false;\\n       return true;\\n      }\\n     bool left=solve(root->left);\\n     bool right=solve(root->right);\\n     \\n     if(root->val==2)\\n       return left || right;\\n     \\n     return left & right;\\n     \\n   }\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        return solve(root);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260569,
                "title": "2331-evaluate-boolean-binary-tree-c-100-fast-solution-using-recursion-inorder",
                "content": "bool evaluateTree(TreeNode* root) \\n    {\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            if(root->val==1) return true;\\n            else return false;\\n        }\\n        bool left=evaluateTree(root->left);\\n        bool right=evaluateTree(root->right);\\n        \\n        if(root->val==2)\\n        {\\n            return left||right;\\n        }\\n      \\n            return left && right;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "bool evaluateTree(TreeNode* root) \\n    {\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            if(root->val==1) return true;\\n            else return false;\\n        }\\n        bool left=evaluateTree(root->left);\\n        bool right=evaluateTree(root->right);\\n        \\n        if(root->val==2)\\n        {\\n            return left||right;\\n        }\\n      \\n            return left && right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2260495,
                "title": "simple-dfs-solution-beginner-friendly",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(TreeNode* root, vector<int> &v)\\n\\t\\t{\\n\\t\\t\\tif(root->left)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(root->left, v);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->right)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(root->right, v);\\n\\t\\t\\t}\\n\\t\\t\\tv.push_back(root->val);\\n\\t\\t}\\n\\t\\tbool evaluateTree(TreeNode* root) {\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\tdfs(root, v);\\n\\t\\t\\tif(v.size()==1)return v[0];\\n\\t\\t\\tint n=v.size();\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(v[i]==0 || v[i]==1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push(v[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint x=st.top();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tint y=st.top();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tif(v[i]==2)st.push(x|y);\\n\\t\\t\\t\\t\\telse st.push(x&y);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn st.top();\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(TreeNode* root, vector<int> &v)\\n\\t\\t{\\n\\t\\t\\tif(root->left)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(root->left, v);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2260143,
                "title": "c-simple-dfs-recursive",
                "content": "```\\n bool evaluateTree(TreeNode* root) {\\n        switch (root->val) {\\n            case 1: return true;\\n            case 2: return evaluateTree(root->left) || evaluateTree(root->right);\\n            case 3: return evaluateTree(root->left) && evaluateTree(root->right);\\n            default: return false;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n bool evaluateTree(TreeNode* root) {\\n        switch (root->val) {\\n            case 1: return true;\\n            case 2: return evaluateTree(root->left) || evaluateTree(root->right);\\n            case 3: return evaluateTree(root->left) && evaluateTree(root->right);\\n            default: return false;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260084,
                "title": "go-solution",
                "content": "Using [multi valirable assignment](https://riptutorial.com/go/example/2193/multiple-variable-assignment) inside an `if`/`switch` statement can help redcue the line count. We also only have two cases so default return can be used.\\n\\nWe have the constrain that each node has exactly **0** or **2** children so on `Line 2` only one check is really needed.  \\n\\n```\\nfunc evaluateTree(root *TreeNode) bool {\\n\\tif root.Left != nil {\\n\\t\\tswitch l, r := evaluateTree(root.Left), evaluateTree(root.Right); root.Val {\\n\\t\\tcase 2:\\n\\t\\t\\treturn l || r\\n\\t\\tdefault:\\n\\t\\t\\treturn l && r\\n\\t\\t}\\n\\t}\\n\\n\\treturn root.Val != 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc evaluateTree(root *TreeNode) bool {\\n\\tif root.Left != nil {\\n\\t\\tswitch l, r := evaluateTree(root.Left), evaluateTree(root.Right); root.Val {\\n\\t\\tcase 2:\\n\\t\\t\\treturn l || r\\n\\t\\tdefault:\\n\\t\\t\\treturn l && r\\n\\t\\t}\\n\\t}\\n\\n\\treturn root.Val != 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260070,
                "title": "recursion-java",
                "content": "How to Think in Tree Problems ?\\n\\nUse Faith Strategy :-  i.e  Call left Subtree and have faith that it will give us result .\\n\\nSimilarly Call Right Subtree and have faith that it will also give us result.\\n\\nLastly : Solve and think only for root node. \\n\\nHow to Think for base Cases ?\\n\\nKey Idea : Think for smallest possible valid input.\\n\\n\\n```class Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        \\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(root.val == 0)\\n            {\\n                return false;\\n            }\\n            else\\n            { \\n                return true;\\n            }\\n        }\\n        \\n        boolean left = evaluateTree(root.left); // Have Faith that this function will evaluate LeftSubtree\\n        boolean right = evaluateTree(root.right);  // Have Faith that this function will evaluate RightSubTree\\n        \\n        if(root.val == 2)  // Process the root Manually\\n        {\\n            return left || right ;\\n        }\\n        \\n        return left && right; \\n        \\n        \\n    }\\n}```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```class Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        \\n        \\n        if(root.left == null && root.right == null)\\n        {\\n            if(root.val == 0)\\n            {\\n                return false;\\n            }\\n            else\\n            { \\n                return true;\\n            }\\n        }\\n        \\n        boolean left = evaluateTree(root.left); // Have Faith that this function will evaluate LeftSubtree\\n        boolean right = evaluateTree(root.right);  // Have Faith that this function will evaluate RightSubTree\\n        \\n        if(root.val == 2)  // Process the root Manually\\n        {\\n            return left || right ;\\n        }\\n        \\n        return left && right; \\n        \\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2259661,
                "title": "1-liner",
                "content": "```\\nbool evaluateTree(TreeNode* r) \\n{\\n\\treturn r->val<2 ? r->val : evaluateTree(r->left)+evaluateTree(r->right)>r->val-2;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool evaluateTree(TreeNode* r) \\n{\\n\\treturn r->val<2 ? r->val : evaluateTree(r->left)+evaluateTree(r->right)>r->val-2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259650,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root == NULL) {\\n            return true;\\n        }\\n        bool left = evaluateTree(root -> left), right = evaluateTree(root -> right);\\n        if(root -> val < 2) {\\n            return root -> val == 0 ? 0 : 1;\\n        }\\n        return root -> val == 2 ? left || right : left && right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root == NULL) {\\n            return true;\\n        }\\n        bool left = evaluateTree(root -> left), right = evaluateTree(root -> right);\\n        if(root -> val < 2) {\\n            return root -> val == 0 ? 0 : 1;\\n        }\\n        return root -> val == 2 ? left || right : left && right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259612,
                "title": "python3-solution-recursion-3-line",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root):\\n        if root.val <= 1: return root.val\\n        left, right = self.evaluateTree(root.left), self.evaluateTree(root.right)\\n        return (left or right) if root.val == 2 else (left and right)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root):\\n        if root.val <= 1: return root.val\\n        left, right = self.evaluateTree(root.left), self.evaluateTree(root.right)\\n        return (left or right) if root.val == 2 else (left and right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259453,
                "title": "java-easy-to-understand-solution-0-ms-recursive-beats-100",
                "content": "```\\npublic boolean evaluateTree(TreeNode root) {\\n        if(root==null) return false;\\n        else if(root.val==0) return false; \\n        else if(root.val==1) return true;\\n        boolean left = evaluateTree(root.left);\\n        boolean right = evaluateTree(root.right);\\n        if(root.val==2) return left||right;\\n        else return left&&right;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic boolean evaluateTree(TreeNode root) {\\n        if(root==null) return false;\\n        else if(root.val==0) return false; \\n        else if(root.val==1) return true;\\n        boolean left = evaluateTree(root.left);\\n        boolean right = evaluateTree(root.right);\\n        if(root.val==2) return left||right;\\n        else return left&&right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259373,
                "title": "c-3-liner-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(!root->left&&!root->right) return root->val;\\n        if(root->val==3) return evaluateTree(root->left)&evaluateTree(root->right);\\n        return evaluateTree(root->left)|evaluateTree(root->right);\\n\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(!root->left&&!root->right) return root->val;\\n        if(root->val==3) return evaluateTree(root->left)&evaluateTree(root->right);\\n        return evaluateTree(root->left)|evaluateTree(root->right);\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2259321,
                "title": "easy-to-understand-100-faster-recursive",
                "content": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(root->left==NULL&&root->right==NULL){\\n            return root->val;\\n        }\\n        if(root->left!=NULL &&root->right!=NULL){\\n            bool a=evaluateTree(root->left);\\n            bool b=evaluateTree(root->right);\\n            if(root->val==2){\\n                return a|b;\\n            }\\n            else{\\n                return a&b;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(root->left==NULL&&root->right==NULL){\\n            return root->val;\\n        }\\n        if(root->left!=NULL &&root->right!=NULL){\\n            bool a=evaluateTree(root->left);\\n            bool b=evaluateTree(root->right);\\n            if(root->val==2){\\n                return a|b;\\n            }\\n            else{\\n                return a&b;\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259290,
                "title": "c-simple-postorder-traversal",
                "content": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(!root)\\n            return false;\\n        if(root->val==0)\\n            return 0;\\n        if(root->val==1)\\n            return 1;\\n        bool l=evaluateTree(root->left);\\n        bool r=evaluateTree(root->right);\\n        if(root->val==2)\\n            return l||r;\\n        return l&&r;\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(!root)\\n            return false;\\n        if(root->val==0)\\n            return 0;\\n        if(root->val==1)\\n            return 1;\\n        bool l=evaluateTree(root->left);\\n        bool r=evaluateTree(root->right);\\n        if(root->val==2)\\n            return l||r;\\n        return l&&r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2259254,
                "title": "easiest-c-solution-only-3-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if (root->left==NULL) return root->val;\\n        if (root->val==2) return evaluateTree(root->left)||evaluateTree(root->right);\\n        return evaluateTree(root->left)&&evaluateTree(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if (root->left==NULL) return root->val;\\n        if (root->val==2) return evaluateTree(root->left)||evaluateTree(root->right);\\n        return evaluateTree(root->left)&&evaluateTree(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259251,
                "title": "very-easy-c-post-order-traversal",
                "content": "Faith of Recurrsion is - \\nleft subtree will return our answer \\nans Right subtree will return our answer \\nand we perform operation on the basic of root value\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left == nullptr && root->right==nullptr)return root->val;\\n        int left = evaluateTree(root->left);\\n        int right = evaluateTree(root->right);\\n        if(root->val == 2)\\n            return left || right ;\\n        return left && right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left == nullptr && root->right==nullptr)return root->val;\\n        int left = evaluateTree(root->left);\\n        int right = evaluateTree(root->right);\\n        if(root->val == 2)\\n            return left || right ;\\n        return left && right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259249,
                "title": "scala-the-simplest-solution-possible",
                "content": "```scala\\ndef evaluateTree(root: TreeNode): Boolean =\\n  root.value match {\\n    case 0 => false\\n    case 1 => true\\n    case 2 => evaluateTree(root.left) || evaluateTree(root.right)\\n    case 3 => evaluateTree(root.left) && evaluateTree(root.right)\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```scala\\ndef evaluateTree(root: TreeNode): Boolean =\\n  root.value match {\\n    case 0 => false\\n    case 1 => true\\n    case 2 => evaluateTree(root.left) || evaluateTree(root.right)\\n    case 3 => evaluateTree(root.left) && evaluateTree(root.right)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2259237,
                "title": "simple-dfs-solution",
                "content": "**Intuition:** If we reached the leaf node return T or F according to the value and once Left and right subtress are visited do the operation on the answers from them.\\n\\n```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n     \\n        if(root.left == null && root.right == null){\\n            return root.val == 0 ? false : true;\\n        }\\n        \\n        boolean fh = this.evaluateTree(root.left);\\n        boolean sh = this.evaluateTree(root.right);\\n        \\n        \\n        return root.val == 2 ? fh || sh : fh && sh;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n     \\n        if(root.left == null && root.right == null){\\n            return root.val == 0 ? false : true;\\n        }\\n        \\n        boolean fh = this.evaluateTree(root.left);\\n        boolean sh = this.evaluateTree(root.right);\\n        \\n        \\n        return root.val == 2 ? fh || sh : fh && sh;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259230,
                "title": "c-dfs-easy-to-understand-beginner-friendly",
                "content": "We are simply checking for our leaf nodes - \\n\\tIf leaf node\\'s value is 1 return TRUE\\n\\tIf leaf\\'s node value is 0 return FALSE\\n\\nNow check for non leaf nodes -\\n\\tIf value is 2 then call for left and right subtree and evaluate OR between them\\n\\tIf value is 3 then call for left and right subtree and evaluate AND between them\\n\\n```\\nbool evaluateTree(TreeNode* root) {\\n        if(!root)\\n            return false;\\n        if(root->left==NULL && root->right==NULL && root->val==1)\\n            return true;\\n        if(root->left==NULL && root->right==NULL && root->val==0)\\n            return false;\\n        if(root->left&&root->right && root->val==2)\\n            return evaluateTree(root->left)||evaluateTree(root->right);\\n        if(root->left&&root->right && root->val==3)\\n            return evaluateTree(root->left)&&evaluateTree(root->right);\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(!root)\\n            return false;\\n        if(root->left==NULL && root->right==NULL && root->val==1)\\n            return true;\\n        if(root->left==NULL && root->right==NULL && root->val==0)\\n            return false;\\n        if(root->left&&root->right && root->val==2)\\n            return evaluateTree(root->left)||evaluateTree(root->right);\\n        if(root->left&&root->right && root->val==3)\\n            return evaluateTree(root->left)&&evaluateTree(root->right);\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259227,
                "title": "easy-short-efficient-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if (!root->left)\\n            return root->val;\\n        bool l = evaluateTree(root->left),\\n            r = evaluateTree(root->right);\\n        if (root->val == 2)\\n            return (l || r);\\n        return (l && r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if (!root->left)\\n            return root->val;\\n        bool l = evaluateTree(root->left),\\n            r = evaluateTree(root->right);\\n        if (root->val == 2)\\n            return (l || r);\\n        return (l && r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259225,
                "title": "python-simple-dfs",
                "content": "```python\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(node):\\n            if node.left is node.right is None:\\n                return bool(node.val)\\n            \\n            # OR\\n            if node.val == 2:\\n                return dfs(node.left) or dfs(node.right)\\n\\n            # AND\\n            return dfs(node.left) and dfs(node.right)\\n            \\n        return dfs(root)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(node):\\n            if node.left is node.right is None:\\n                return bool(node.val)\\n            \\n            # OR\\n            if node.val == 2:\\n                return dfs(node.left) or dfs(node.right)\\n\\n            # AND\\n            return dfs(node.left) and dfs(node.right)\\n            \\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259219,
                "title": "4-lines-postorder-dfs-c-java",
                "content": "# Explanation:\\n1. First we should get the answer of left and right subtree.\\n2. Then on the basis of left and right subtree answer we apply `&&` , `||` operator accoring to value on the current node.\\n# C++   \\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr && root->right==nullptr) return root->val;\\n        bool x= evaluateTree(root->left);\\n        bool y= evaluateTree(root->right);\\n        return root->val==2? x || y : x && y;\\n    }\\n\\t\\n# Java\\t\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left==null && root.right==null) return root.val==1? true: false;\\n        boolean x= evaluateTree(root.left);\\n        boolean y= evaluateTree(root.right);\\n        return root.val==2? x || y : x && y;\\n    }\\nTime - O(n)\\nSpace - O(1) => ignoring recursion space",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# Explanation:\\n1. First we should get the answer of left and right subtree.\\n2. Then on the basis of left and right subtree answer we apply `&&` , `||` operator accoring to value on the current node.\\n# C++   \\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr && root->right==nullptr) return root->val;\\n        bool x= evaluateTree(root->left);\\n        bool y= evaluateTree(root->right);\\n        return root->val==2? x || y : x && y;\\n    }\\n\\t\\n# Java\\t\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left==null && root.right==null) return root.val==1? true: false;\\n        boolean x= evaluateTree(root.left);\\n        boolean y= evaluateTree(root.right);\\n        return root.val==2? x || y : x && y;\\n    }\\nTime - O(n)\\nSpace - O(1) => ignoring recursion space",
                "codeTag": "Unknown"
            },
            {
                "id": 2259213,
                "title": "c-dfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        function<bool(TreeNode*)> fn = [&](TreeNode* node) {\\n            if (node->val == 0 || node->val == 1) return (bool) node->val; \\n            if (node->val == 2) return fn(node->left) || fn(node->right); \\n            return fn(node->left) && fn(node->right); \\n        }; \\n        \\n        return fn(root); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        function<bool(TreeNode*)> fn = [&](TreeNode* node) {\\n            if (node->val == 0 || node->val == 1) return (bool) node->val; \\n            if (node->val == 2) return fn(node->left) || fn(node->right); \\n            return fn(node->left) && fn(node->right); \\n        }; \\n        \\n        return fn(root); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259208,
                "title": "3-lines-of-code",
                "content": "```java \\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        return root.val==2?(evaluateTree(root.left)||evaluateTree(root.right)):(evaluateTree(root.left)&&evaluateTree(root.right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java \\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        return root.val==2?(evaluateTree(root.left)||evaluateTree(root.right)):(evaluateTree(root.left)&&evaluateTree(root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259204,
                "title": "c-easy-solution-tree",
                "content": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    bool evaluateTree(TreeNode *root)\\n    {\\n        if (root->left == NULL && root->right == NULL)\\n            return root->val;\\n        if (root->val == 2)\\n            return evaluateTree(root->left) || evaluateTree(root->right);\\n        else\\n            return evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    bool evaluateTree(TreeNode *root)\\n    {\\n        if (root->left == NULL && root->right == NULL)\\n            return root->val;\\n        if (root->val == 2)\\n            return evaluateTree(root->left) || evaluateTree(root->right);\\n        else\\n            return evaluateTree(root->left) && evaluateTree(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259201,
                "title": "java-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public boolean evaluateTree(TreeNode root) {\\n        return recursive(root);    \\n    }\\n    \\n    boolean recursive(TreeNode node){\\n        if(node.left==null && node.right==null){\\n            return node.val==1;\\n        }\\n        boolean l = recursive(node.left);\\n        boolean r = recursive(node.right);\\n        if(node.val==2){\\n            return l||r;\\n        }else{\\n            return l&&r;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean evaluateTree(TreeNode root) {\\n        return recursive(root);    \\n    }\\n    \\n    boolean recursive(TreeNode node){\\n        if(node.left==null && node.right==null){\\n            return node.val==1;\\n        }\\n        boolean l = recursive(node.left);\\n        boolean r = recursive(node.right);\\n        if(node.val==2){\\n            return l||r;\\n        }else{\\n            return l&&r;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259197,
                "title": "100-fast-memory-speed-easy-recursion-for-kids",
                "content": "*Please **upvote** if it helped* \\uD83D\\uDE09\\n\\n```\\nbool evaluateTree(TreeNode *root)\\n{\\n    if (root->val == 1) return true;\\n    if (root->val == 0) return false;\\n    if (root->val == 2) return evaluateTree(root->left) or evaluateTree(root->right);\\n    if (root->val == 3) return evaluateTree(root->left) and evaluateTree(root->right);\\n\\treturn false;\\n}\\n```\\n\\n.\\n\\n\\n![image](https://assets.leetcode.com/users/images/f972f8df-0aec-4ed2-b3dc-2fff04140b72_1657383765.5364811.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nbool evaluateTree(TreeNode *root)\\n{\\n    if (root->val == 1) return true;\\n    if (root->val == 0) return false;\\n    if (root->val == 2) return evaluateTree(root->left) or evaluateTree(root->right);\\n    if (root->val == 3) return evaluateTree(root->left) and evaluateTree(root->right);\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259192,
                "title": "simple-video-explanation",
                "content": "Here\\'s a simple video explanation of the recursive algorithm: https://www.youtube.com/watch?v=6EA7BZxClpY\\nHope it helps!",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Here\\'s a simple video explanation of the recursive algorithm: https://www.youtube.com/watch?v=6EA7BZxClpY\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 2259187,
                "title": "c-easy-to-understand-tree",
                "content": "**C++**\\n        \\n\\t\\tbool evaluateTree(TreeNode* r) {\\n    if(r->left==NULL && r->right==NULL)\\n        {\\n            return r->val;\\n        }\\n        if(r->val==2)\\n        {\\n            return evaluateTree(r->left) || evaluateTree(r->right);\\n        }\\n        else\\n        {\\n            return evaluateTree(r->left) && evaluateTree(r->right);\\n        }\\n    }",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "**C++**\\n        \\n\\t\\tbool evaluateTree(TreeNode* r) {\\n    if(r->left==NULL && r->right==NULL)\\n        {\\n            return r->val;\\n        }\\n        if(r->val==2)\\n        {\\n            return evaluateTree(r->left) || evaluateTree(r->right);\\n        }\\n        else\\n        {\\n            return evaluateTree(r->left) && evaluateTree(r->right);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2259177,
                "title": "javascript-js-solution-ultrafast",
                "content": "```\\nfunction evaluateTree(root) {\\n    if (!root) {\\n        return false;\\n    }\\n\\n    if (root.val === 0) {\\n        return false;\\n    }\\n\\n    if (root.val === 1) {\\n        return true;\\n    }\\n\\n    if (root.val === 2) {\\n        return evaluateTree(root.left) || evaluateTree(root.right);\\n    }\\n\\n    if (root.val === 3) {\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction evaluateTree(root) {\\n    if (!root) {\\n        return false;\\n    }\\n\\n    if (root.val === 0) {\\n        return false;\\n    }\\n\\n    if (root.val === 1) {\\n        return true;\\n    }\\n\\n    if (root.val === 2) {\\n        return evaluateTree(root.left) || evaluateTree(root.right);\\n    }\\n\\n    if (root.val === 3) {\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259159,
                "title": "c-using-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL)   //leaf node\\n            return root->val;   \\n            \\n        bool left = evaluateTree(root->left);\\n        bool right = evaluateTree(root->right);\\n        \\n        if(root->val==2)    //OR\\n            return left || right;\\n        \\n        return left && right;\\n    }\\n};\\n```\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left==NULL && root->right==NULL)   //leaf node\\n            return root->val;   \\n            \\n        bool left = evaluateTree(root->left);\\n        bool right = evaluateTree(root->right);\\n        \\n        if(root->val==2)    //OR\\n            return left || right;\\n        \\n        return left && right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095474,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val==0)return false;\\n        else if(root.val==1)return true;\\n        else if(root.val==2)return evaluateTree(root.left)||evaluateTree(root.right);\\n        return evaluateTree(root.left)&&evaluateTree(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val==0)return false;\\n        else if(root.val==1)return true;\\n        else if(root.val==2)return evaluateTree(root.left)||evaluateTree(root.right);\\n        return evaluateTree(root.left)&&evaluateTree(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091285,
                "title": "python-2-approaches-recursion-iterative-stack",
                "content": "# Recursion\\n#### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Code\\n```python\\ndef dfs(root: Optional[TreeNode]) -> bool:\\n  if root.left is None and root.right is None:\\n    return root.val == 1\\n  if root.val == 2:\\n    return dfs(root.left) or dfs(root.right)\\n  return dfs(root.left) and dfs(root.right)\\n\\nclass Solution:\\n  def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n    return dfs(root)\\n```\\n# Iterative & Stack\\n#### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Code\\n```python\\nclass Solution:\\n  def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n    stack = [root]\\n    while len(stack) != 0:\\n      current_node = stack.pop()\\n      if current_node.val > 1:\\n        if current_node.left.val > 1 or current_node.right.val > 1:\\n          stack.append(current_node)\\n          if current_node.left.val > 1:\\n            stack.append(current_node.left)\\n          if current_node.right.val > 1:\\n            stack.append(current_node.right)\\n        else:\\n          if current_node.val == 2:\\n            current_node.val = current_node.left.val or current_node.right.val\\n          else:\\n            current_node.val = current_node.left.val and current_node.right.val\\n    return root.val == 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```python\\ndef dfs(root: Optional[TreeNode]) -> bool:\\n  if root.left is None and root.right is None:\\n    return root.val == 1\\n  if root.val == 2:\\n    return dfs(root.left) or dfs(root.right)\\n  return dfs(root.left) and dfs(root.right)\\n\\nclass Solution:\\n  def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n    return dfs(root)\\n```\n```python\\nclass Solution:\\n  def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n    stack = [root]\\n    while len(stack) != 0:\\n      current_node = stack.pop()\\n      if current_node.val > 1:\\n        if current_node.left.val > 1 or current_node.right.val > 1:\\n          stack.append(current_node)\\n          if current_node.left.val > 1:\\n            stack.append(current_node.left)\\n          if current_node.right.val > 1:\\n            stack.append(current_node.right)\\n        else:\\n          if current_node.val == 2:\\n            current_node.val = current_node.left.val or current_node.right.val\\n          else:\\n            current_node.val = current_node.left.val and current_node.right.val\\n    return root.val == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085809,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(h)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n       if (root.val < 2)\\n      return root.val == 1;\\n    if (root.val == 2) // OR\\n      return evaluateTree(root.left) || evaluateTree(root.right);\\n    // AND\\n    return evaluateTree(root.left) && evaluateTree(root.right); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n       if (root.val < 2)\\n      return root.val == 1;\\n    if (root.val == 2) // OR\\n      return evaluateTree(root.left) || evaluateTree(root.right);\\n    // AND\\n    return evaluateTree(root.left) && evaluateTree(root.right); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076350,
                "title": "0-ms-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null)\\n        {\\n            if(root.val == 1)\\n                return true;\\n            else\\n                return false;\\n        }\\n            \\n      boolean l =   evaluateTree(root.left);\\n      boolean r =   evaluateTree(root.right);\\n      if(root.val == 2)\\n      {\\n          return (l || r);\\n      }else\\n      {\\n          return (l && r);\\n      }\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.left == null && root.right == null)\\n        {\\n            if(root.val == 1)\\n                return true;\\n            else\\n                return false;\\n        }\\n            \\n      boolean l =   evaluateTree(root.left);\\n      boolean r =   evaluateTree(root.right);\\n      if(root.val == 2)\\n      {\\n          return (l || r);\\n      }else\\n      {\\n          return (l && r);\\n      }\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071924,
                "title": "recursive-c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public bool EvaluateTree(TreeNode root)\\n    {\\n        return root.val switch\\n        {\\n            1 => true,\\n            0 => false,\\n            2 => EvaluateTree(root.left!) || EvaluateTree(root.right!),\\n            _ => EvaluateTree(root.left!) && EvaluateTree(root.right!)\\n        };\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool EvaluateTree(TreeNode root)\\n    {\\n        return root.val switch\\n        {\\n            1 => true,\\n            0 => false,\\n            2 => EvaluateTree(root.left!) || EvaluateTree(root.right!),\\n            _ => EvaluateTree(root.left!) && EvaluateTree(root.right!)\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069669,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if (root == nullptr) {\\n            // If the node is null, return false (0 represents False)\\n            return false;\\n        }\\n        \\n        if (root->left == nullptr && root->right == nullptr) {\\n            // If the node is a leaf, return its value (0 or 1)\\n            return root->val == 1;\\n        }\\n        \\n        bool leftResult = evaluateTree(root->left);\\n        bool rightResult = evaluateTree(root->right);\\n        \\n        if (root->val == 2) {\\n            // If the node\\'s value is 2 (OR), return true if either child is true\\n            return leftResult || rightResult;\\n        } else if (root->val == 3) {\\n            // If the node\\'s value is 3 (AND), return true only if both children are true\\n            return leftResult && rightResult;\\n        } else {\\n            // Invalid value, return false\\n            return false;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if (root == nullptr) {\\n            // If the node is null, return false (0 represents False)\\n            return false;\\n        }\\n        \\n        if (root->left == nullptr && root->right == nullptr) {\\n            // If the node is a leaf, return its value (0 or 1)\\n            return root->val == 1;\\n        }\\n        \\n        bool leftResult = evaluateTree(root->left);\\n        bool rightResult = evaluateTree(root->right);\\n        \\n        if (root->val == 2) {\\n            // If the node\\'s value is 2 (OR), return true if either child is true\\n            return leftResult || rightResult;\\n        } else if (root->val == 3) {\\n            // If the node\\'s value is 3 (AND), return true only if both children are true\\n            return leftResult && rightResult;\\n        } else {\\n            // Invalid value, return false\\n            return false;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061071,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) \\n    {\\n        if(root->val == 1 || root->val == 0) return root->val;\\n        if(root->val == 2) return evaluateTree(root->left) || evaluateTree(root->right);\\n        return evaluateTree(root->left) && evaluateTree(root->right);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) \\n    {\\n        if(root->val == 1 || root->val == 0) return root->val;\\n        if(root->val == 2) return evaluateTree(root->left) || evaluateTree(root->right);\\n        return evaluateTree(root->left) && evaluateTree(root->right);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060812,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(node):\\n            if node.val == 0:\\n                return False\\n            if node.val == 1:\\n                return True\\n            \\n            if node.val == 2:\\n                return dfs(node.left) or dfs(node.right)\\n            \\n            if node.val == 3:\\n                return dfs(node.left) and dfs(node.right)\\n\\n        return dfs(root)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(node):\\n            if node.val == 0:\\n                return False\\n            if node.val == 1:\\n                return True\\n            \\n            if node.val == 2:\\n                return dfs(node.left) or dfs(node.right)\\n            \\n            if node.val == 3:\\n                return dfs(node.left) and dfs(node.right)\\n\\n        return dfs(root)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051868,
                "title": "very-easy",
                "content": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(!root->left && !root->right)return root->val;\\n        bool l = evaluateTree(root->left);\\n        bool r = evaluateTree(root->right);\\n        if(root->val == 2)return l || r;\\n        return l && r;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool evaluateTree(TreeNode* root) {\\n        if(!root->left && !root->right)return root->val;\\n        bool l = evaluateTree(root->left);\\n        bool r = evaluateTree(root->right);\\n        if(root->val == 2)return l || r;\\n        return l && r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045560,
                "title": "dfs-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        int flag = helper(root);\\n        if(flag == 1) return true;\\n        return false;\\n    }\\n    public int helper(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            return -1;\\n        }\\n\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n\\n        if(root.val == 2)\\n        {\\n            if(left == 0 && right == 0)\\n            {\\n                return 0;\\n            }\\n            if(left == 0 && right == 1)\\n            {\\n                return 1;\\n            }\\n            if(left == 1 && right == 0)\\n            {\\n                return 1;\\n            }\\n            if(left == 1 && right == 1)\\n            {\\n                return 1;\\n            }\\n        }\\n        if(root.val == 3)\\n        {\\n            if(left == 0 && right == 0)\\n            {\\n                return 0;\\n            }\\n            if(left == 0 && right == 1)\\n            {\\n                return 0;\\n            }\\n            if(left == 1 && right == 0)\\n            {\\n                return 0;\\n            }\\n            if(left == 1 && right == 1)\\n            {\\n                return 1;\\n            }\\n        }\\n       return root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        int flag = helper(root);\\n        if(flag == 1) return true;\\n        return false;\\n    }\\n    public int helper(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            return -1;\\n        }\\n\\n        int left = helper(root.left);\\n        int right = helper(root.right);\\n\\n        if(root.val == 2)\\n        {\\n            if(left == 0 && right == 0)\\n            {\\n                return 0;\\n            }\\n            if(left == 0 && right == 1)\\n            {\\n                return 1;\\n            }\\n            if(left == 1 && right == 0)\\n            {\\n                return 1;\\n            }\\n            if(left == 1 && right == 1)\\n            {\\n                return 1;\\n            }\\n        }\\n        if(root.val == 3)\\n        {\\n            if(left == 0 && right == 0)\\n            {\\n                return 0;\\n            }\\n            if(left == 0 && right == 1)\\n            {\\n                return 0;\\n            }\\n            if(left == 1 && right == 0)\\n            {\\n                return 0;\\n            }\\n            if(left == 1 && right == 1)\\n            {\\n                return 1;\\n            }\\n        }\\n       return root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042607,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool find(TreeNode *root){\\n        if(root==NULL)\\n            return false;\\n        if(root->val==0)\\n            return false;\\n        if(root->val==1)\\n            return true;\\n        if(root->val==2)\\n            return find(root->left) or find(root->right);\\n        if(root->val==3)\\n            return find(root->left) and find(root->right);\\n        return true;\\n    }\\n    bool evaluateTree(TreeNode* root) {        \\n        return find(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool find(TreeNode *root){\\n        if(root==NULL)\\n            return false;\\n        if(root->val==0)\\n            return false;\\n        if(root->val==1)\\n            return true;\\n        if(root->val==2)\\n            return find(root->left) or find(root->right);\\n        if(root->val==3)\\n            return find(root->left) and find(root->right);\\n        return true;\\n    }\\n    bool evaluateTree(TreeNode* root) {        \\n        return find(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035221,
                "title": "python-1-liner-recursion-fun",
                "content": "# Approach\\nUse node value as an index to select an operator from list. Apply this operator to the left and right subtree\\n\\n## Please UpVote if you like this solution! \\uD83D\\uDE4F\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, r: Optional[TreeNode]) -> bool:\\n        return [and_, eq, or_, and_][r.val](self.evaluateTree(r.left), self.evaluateTree(r.right)) if r else 0\\n\\n```\\n\\n## Thank You! \\uD83E\\uDD73 \\uD83E\\uDD73 \\uD83E\\uDD73",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, r: Optional[TreeNode]) -> bool:\\n        return [and_, eq, or_, and_][r.val](self.evaluateTree(r.left), self.evaluateTree(r.right)) if r else 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029829,
                "title": "c-easy-solution-recursion-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    bool solve(TreeNode *root,unordered_map<TreeNode*,bool>&dp){\\n        //base cases\\n        //as it is a complete binary tree\\n        if(!root->left && !root->right)\\n        return root->val;\\n\\n        if(dp.find(root)!=dp.end())\\n        return dp[root];\\n\\n        //logic\\n        bool ans;\\n        switch(root->val){\\n            case 2 : ans = solve(root->left,dp) || solve(root->right,dp);\\n                     break;\\n            case 3 : ans = solve(root->left,dp) && solve(root->right,dp);\\n                     break;\\n        }\\n        return dp[root] = ans;\\n    }\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        unordered_map<TreeNode*,bool> dp;\\n        return solve(root,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    bool solve(TreeNode *root,unordered_map<TreeNode*,bool>&dp){\\n        //base cases\\n        //as it is a complete binary tree\\n        if(!root->left && !root->right)\\n        return root->val;\\n\\n        if(dp.find(root)!=dp.end())\\n        return dp[root];\\n\\n        //logic\\n        bool ans;\\n        switch(root->val){\\n            case 2 : ans = solve(root->left,dp) || solve(root->right,dp);\\n                     break;\\n            case 3 : ans = solve(root->left,dp) && solve(root->right,dp);\\n                     break;\\n        }\\n        return dp[root] = ans;\\n    }\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        unordered_map<TreeNode*,bool> dp;\\n        return solve(root,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019580,
                "title": "easy-python-solution-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) each not visited once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(node):\\n            if node and node.val == 0 or node.val == 1:\\n                return node.val\\n            \\n            if node.val == 2:\\n                return dfs(node.left) or dfs(node.right)\\n            \\n            if node.val == 3:\\n                return dfs(node.left) and dfs(node.right)\\n        \\n        return dfs(root)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(node):\\n            if node and node.val == 0 or node.val == 1:\\n                return node.val\\n            \\n            if node.val == 2:\\n                return dfs(node.left) or dfs(node.right)\\n            \\n            if node.val == 3:\\n                return dfs(node.left) and dfs(node.right)\\n        \\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012443,
                "title": "simple-java-o-n-solution-0ms-beats-100-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        \\n        if(root.val == 0 || root.val == 1){\\n            if(root.val==0){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n\\n        boolean node = evaluateTree(root.left);\\n        boolean node2 = evaluateTree(root.right);\\n\\n        if(root.val==2){\\n            return node || node2;\\n        }\\n        else{\\n            return node && node2;\\n        }\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        \\n        if(root.val == 0 || root.val == 1){\\n            if(root.val==0){\\n                return false;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n\\n        boolean node = evaluateTree(root.left);\\n        boolean node2 = evaluateTree(root.right);\\n\\n        if(root.val==2){\\n            return node || node2;\\n        }\\n        else{\\n            return node && node2;\\n        }\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001684,
                "title": "simple-short-recursive-approach-o-n-java-c-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        if(root.val == 2) return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val == 0) return false;\\n        if(root.val == 1) return true;\\n        if(root.val == 2) return evaluateTree(root.left) || evaluateTree(root.right);\\n        return evaluateTree(root.left) && evaluateTree(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995478,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left == NULL and root->right == NULL){\\n           return root->val;\\n        }\\n        bool lefti = evaluateTree(root->left);\\n        bool righti = evaluateTree(root->right);\\n        if(root->val == 2){\\n            return lefti || righti;\\n        }\\n        else {\\n            return lefti && righti;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        if(root->left == NULL and root->right == NULL){\\n           return root->val;\\n        }\\n        bool lefti = evaluateTree(root->left);\\n        bool righti = evaluateTree(root->right);\\n        if(root->val == 2){\\n            return lefti || righti;\\n        }\\n        else {\\n            return lefti && righti;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987721,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val if not root.left else self.evaluateTree(root.left) or self.evaluateTree(root.right) if root.val == 2 else self.evaluateTree(root.left) and self.evaluateTree(root.right)       \\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val if not root.left else self.evaluateTree(root.left) or self.evaluateTree(root.right) if root.val == 2 else self.evaluateTree(root.left) and self.evaluateTree(root.right)       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987427,
                "title": "recursive-solution-in-java",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val==0) return false;\\n        else if(root.val == 1) return true;\\n\\n\\n        if(root.val == 2){\\n            return evaluateTree(root.left) | evaluateTree(root.right);\\n\\n\\n        }else if(root.val == 3){\\n            return evaluateTree(root.left) & evaluateTree(root.right);\\n        }\\n\\n\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean evaluateTree(TreeNode root) {\\n        if(root.val==0) return false;\\n        else if(root.val == 1) return true;\\n\\n\\n        if(root.val == 2){\\n            return evaluateTree(root.left) | evaluateTree(root.right);\\n\\n\\n        }else if(root.val == 3){\\n            return evaluateTree(root.left) & evaluateTree(root.right);\\n        }\\n\\n\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973650,
                "title": "postorder-traversal-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        preorder(root);\\n\\n        return root->val;\\n\\n\\n    }\\n    void preorder(TreeNode* root){\\n        if(root==nullptr) return;\\n\\n        preorder(root->left);\\n        preorder(root->right);\\n\\n        //data\\n        if(root->val==2){\\n            //OR operation on children\\n            if(root->right->val==1 || root->left->val==1){\\n                root->val=1;\\n            }\\n            else{\\n                root->val=0;\\n            }\\n        }\\n        else if(root->val ==3){\\n            //AND operation on children\\n            if(root->right->val==0 || root->left->val==0){\\n                root->val=0;\\n            }\\n            else{\\n                root->val=1;\\n            }\\n        }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool evaluateTree(TreeNode* root) {\\n        \\n        preorder(root);\\n\\n        return root->val;\\n\\n\\n    }\\n    void preorder(TreeNode* root){\\n        if(root==nullptr) return;\\n\\n        preorder(root->left);\\n        preorder(root->right);\\n\\n        //data\\n        if(root->val==2){\\n            //OR operation on children\\n            if(root->right->val==1 || root->left->val==1){\\n                root->val=1;\\n            }\\n            else{\\n                root->val=0;\\n            }\\n        }\\n        else if(root->val ==3){\\n            //AND operation on children\\n            if(root->right->val==0 || root->left->val==0){\\n                root->val=0;\\n            }\\n            else{\\n                root->val=1;\\n            }\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972356,
                "title": "easy-beats-98-o-n-3-lines",
                "content": "\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if not root.left and not root.right:\\n            return root.val\\n        \\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        \\n        if root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\\n        if not root.left and not root.right:\\n            return root.val\\n        \\n        if root.val == 2:\\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\\n        \\n        if root.val == 3:\\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968939,
                "title": "kotlin-dfs-recursive",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate fun evaluateTree(root: TreeNode?): Boolean {\\n    return when (root?.`val`) {\\n        0 -> false\\n        1 -> true\\n        2 -> evaluateTree(root.left) or evaluateTree(root.right)\\n        else -> evaluateTree(root?.left) and evaluateTree(root?.right)\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate fun evaluateTree(root: TreeNode?): Boolean {\\n    return when (root?.`val`) {\\n        0 -> false\\n        1 -> true\\n        2 -> evaluateTree(root.left) or evaluateTree(root.right)\\n        else -> evaluateTree(root?.left) and evaluateTree(root?.right)\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1723594,
                "content": [
                    {
                        "username": "luongminhduy",
                        "content": "Use recursion and think about what you get if you have root, root->left and root->right"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : recursion"
                    },
                    {
                        "username": "Shubhamg13",
                        "content": "    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return root->val;\\n        return (root->val == 2) ? (root->left || root->right) : (root->left && root->right); \\n\\nWhat is the issue with my logic?"
                    },
                    {
                        "username": "valdus02092000",
                        "content": "You need to call evaluateTree function for root->left and root->right:\\n\\nreturn (root->val == 2) ? (evaluateTree(root->left) || evaluateTree(root->right)) : (evaluateTree(root->left) && evaluateTree(root->right)); "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 2062597,
                "content": [
                    {
                        "username": "luongminhduy",
                        "content": "Use recursion and think about what you get if you have root, root->left and root->right"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : recursion"
                    },
                    {
                        "username": "Shubhamg13",
                        "content": "    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return root->val;\\n        return (root->val == 2) ? (root->left || root->right) : (root->left && root->right); \\n\\nWhat is the issue with my logic?"
                    },
                    {
                        "username": "valdus02092000",
                        "content": "You need to call evaluateTree function for root->left and root->right:\\n\\nreturn (root->val == 2) ? (evaluateTree(root->left) || evaluateTree(root->right)) : (evaluateTree(root->left) && evaluateTree(root->right)); "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1876229,
                "content": [
                    {
                        "username": "luongminhduy",
                        "content": "Use recursion and think about what you get if you have root, root->left and root->right"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : recursion"
                    },
                    {
                        "username": "Shubhamg13",
                        "content": "    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return root->val;\\n        return (root->val == 2) ? (root->left || root->right) : (root->left && root->right); \\n\\nWhat is the issue with my logic?"
                    },
                    {
                        "username": "valdus02092000",
                        "content": "You need to call evaluateTree function for root->left and root->right:\\n\\nreturn (root->val == 2) ? (evaluateTree(root->left) || evaluateTree(root->right)) : (evaluateTree(root->left) && evaluateTree(root->right)); "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1734254,
                "content": [
                    {
                        "username": "luongminhduy",
                        "content": "Use recursion and think about what you get if you have root, root->left and root->right"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : recursion"
                    },
                    {
                        "username": "Shubhamg13",
                        "content": "    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return root->val;\\n        return (root->val == 2) ? (root->left || root->right) : (root->left && root->right); \\n\\nWhat is the issue with my logic?"
                    },
                    {
                        "username": "valdus02092000",
                        "content": "You need to call evaluateTree function for root->left and root->right:\\n\\nreturn (root->val == 2) ? (evaluateTree(root->left) || evaluateTree(root->right)) : (evaluateTree(root->left) && evaluateTree(root->right)); "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            },
            {
                "id": 1728248,
                "content": [
                    {
                        "username": "luongminhduy",
                        "content": "Use recursion and think about what you get if you have root, root->left and root->right"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Hint : recursion"
                    },
                    {
                        "username": "Shubhamg13",
                        "content": "    bool evaluateTree(TreeNode* root) {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return root->val;\\n        return (root->val == 2) ? (root->left || root->right) : (root->left && root->right); \\n\\nWhat is the issue with my logic?"
                    },
                    {
                        "username": "valdus02092000",
                        "content": "You need to call evaluateTree function for root->left and root->right:\\n\\nreturn (root->val == 2) ? (evaluateTree(root->left) || evaluateTree(root->right)) : (evaluateTree(root->left) && evaluateTree(root->right)); "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    }
                ]
            }
        ]
    }
]