[
    {
        "title": "Find Missing Observations",
        "question_content": "You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls.\nYou are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.\nReturn an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array.\nThe average value of a set of k numbers is the sum of the numbers divided by k.\nNote that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.\n&nbsp;\nExample 1:\n\nInput: rolls = [3,2,4,3], mean = 4, n = 2\nOutput: [6,6]\nExplanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.\n\nExample 2:\n\nInput: rolls = [1,5,6], mean = 3, n = 4\nOutput: [2,3,2,2]\nExplanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.\n\nExample 3:\n\nInput: rolls = [1,2,3,4], mean = 6, n = 4\nOutput: []\nExplanation: It is impossible for the mean to be 6 no matter what the 4 missing rolls are.\n\n&nbsp;\nConstraints:\n\n\tm == rolls.length\n\t1 <= n, m <= 105\n\t1 <= rolls[i], mean <= 6",
        "solutions": [
            {
                "id": 1500256,
                "title": "c-java-python-math-then-div-mod-clean-concise",
                "content": "**Idea**\\n- We just need a little math to calculate `missingSum`. The average value of the `n + m` rolls is exactly `mean`, so:\\n\\t```\\n\\tcurSum = sum(rolls)\\n\\t(curSum + missingSum) / (n + m) == mean\\n\\tcurSum + missingSum = mean * (n+m)\\n\\tmissingSum = mean * (n+m) - curSum\\n\\t```\\n- Now, we just need to distribute `missingSum` into `n` roll dices, each roll dices must have values in range `[1..6]`.\\n\\n<iframe src=\"https://leetcode.com/playground/MWJk7Hpc/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M + N)`, where `M <= 10^5` is the length of `rolls` array, `N <= 10^5`.\\n- Space: `O(N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```\\n\\tcurSum = sum(rolls)\\n\\t(curSum + missingSum) / (n + m) == mean\\n\\tcurSum + missingSum = mean * (n+m)\\n\\tmissingSum = mean * (n+m) - curSum\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500155,
                "title": "java-easy-understandable-clear-and-concise-solution",
                "content": "**Idea**\\nWe need to add the n elements to the sum of total elements given in such that -\\nLets say total of n elements be x and total of m elements be sum only!\\n\\n(x+sum)\\n---------- = mean  \\n(m+n)\\n-------------------\\n\\n**Approach**\\nNow, we have to look after finding x from it!\\nWe can take two variable p and q and store x/n in p and x%n in q\\np will have same value in whole in array\\nq will add 1 next q times as if x is not divisible by n so we have to manage the remainder!\\n\\n\\n**Complexity -**\\nTime Complexity   - O(n)\\nSpace Complexity - O(n)\\n\\n````\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n    \\tint i,m=rolls.length,sum=0;\\n    \\tfor(i=0;i<m;i++)\\n    \\t\\tsum+=rolls[i];\\n\\t\\t\\t\\n    \\tint x=(mean*(m+n))-sum;\\n\\t\\t\\n\\t\\tif(x<=0||n*6<x||((x/n)==0)) {\\n    \\t\\treturn new int[] {};\\n\\t\\t}\\n\\t\\t\\t\\n    \\tint arr[]=new int[n];\\n    \\t\\n\\t\\tint p=x/n,q=x%n;\\n    \\tfor(i=0;i<n;i++)  {\\n\\t\\t\\n    \\t\\tarr[i]=p+(q>0?1:0);\\n    \\t\\tq--;\\n    \\t}\\n    \\treturn arr;\\n    }\\n}\\n````\\n\\nIf you found it **useful**  then I will be **happy** if you please give a **upvote**\\n\\n**All discussion are welcome!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n    \\tint i,m=rolls.length,sum=0;\\n    \\tfor(i=0;i<m;i++)\\n    \\t\\tsum+=rolls[i];\\n\\t\\t\\t\\n    \\tint x=(mean*(m+n))-sum;\\n\\t\\t\\n\\t\\tif(x<=0||n*6<x||((x/n)==0)) {\\n    \\t\\treturn new int[] {};\\n\\t\\t}\\n\\t\\t\\t\\n    \\tint arr[]=new int[n];\\n    \\t\\n\\t\\tint p=x/n,q=x%n;\\n    \\tfor(i=0;i<n;i++)  {\\n\\t\\t\\n    \\t\\tarr[i]=p+(q>0?1:0);\\n    \\t\\tq--;\\n    \\t}\\n    \\treturn arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500152,
                "title": "c-easy-with-explanation",
                "content": "**Explanation:-**\\n1. Find the sum of missing observation,that is = ``` mean*(n+rolls.size())-sum(rolls). ```\\n2. If ``` missingSum < \\'n\\' or missingSum>6*n ``` then we cannot create the array so return empty array.\\n3. After this we only have to distribute missingSum to ``` n ``` elements.So i used below method:-\\n4. Assign  ```missingSum/n``` to every element of new array.\\n5. if missingSum%n is not zero then after assigning ```missingSum/n```to every element we will left with ```missingSum%n```.So assign 1 to  ```missingSum%n``` elements of new array .\\n6. That\\'s it, You can use your own way to assign values. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int size=rolls.size(),sum=accumulate(rolls.begin(),rolls.end(),0),missingSum=0;\\n         missingSum=mean*(n+size)-sum;\\n        if(missingSum<n || missingSum>6*n)\\n            return {};\\n         int rem=missingSum%n;\\n         vector<int>ans(n,missingSum/n);\\n        for(int i=0;i<rem;i++)\\n            ans[i]+=1;\\n        return ans;   \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)\\nIf you have any question or suggestion then please mention in comment section.\\nThanks",
                "solutionTags": [
                    "C"
                ],
                "code": "``` mean*(n+rolls.size())-sum(rolls). ```\n``` missingSum < \\'n\\' or missingSum>6*n ```\n``` n ```\n```missingSum/n```\n```missingSum/n```\n```missingSum%n```\n```missingSum%n```\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int size=rolls.size(),sum=accumulate(rolls.begin(),rolls.end(),0),missingSum=0;\\n         missingSum=mean*(n+size)-sum;\\n        if(missingSum<n || missingSum>6*n)\\n            return {};\\n         int rem=missingSum%n;\\n         vector<int>ans(n,missingSum/n);\\n        for(int i=0;i<rem;i++)\\n            ans[i]+=1;\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502234,
                "title": "greedy",
                "content": "First, figure out the sum of `n` rolls (`n_sum`). If it\\'s smaller than `n`, or larger than `n * 6` - there is no solution.\\n\\nThen, we greedily populate the result using `6` as a value.\\n\\nNote that for `n` dice we need at least `n` points. When the remaining points equal `n`, we use `1` for the remaining dice. And of course, there is a \"turning\" die with `n_sum - n + 1` as a value.\\n\\n**C++**\\n```cpp\\nvector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n    int m = rolls.size(), m_sum = accumulate(begin(rolls), end(rolls), 0);\\n    int n_sum = mean * (n + m) - m_sum;\\n    vector<int> res;\\n    if (6 * n < n_sum || n > n_sum)\\n        return {};\\n    for (; n > 0; --n) {\\n        res.push_back(min(6, n_sum - n + 1));\\n        n_sum -= res.back();\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n    int m = rolls.size(), m_sum = accumulate(begin(rolls), end(rolls), 0);\\n    int n_sum = mean * (n + m) - m_sum;\\n    vector<int> res;\\n    if (6 * n < n_sum || n > n_sum)\\n        return {};\\n    for (; n > 0; --n) {\\n        res.push_back(min(6, n_sum - n + 1));\\n        n_sum -= res.back();\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500313,
                "title": "python-2-lines-solution",
                "content": "```py\\n    def missingRolls(self, A, mean, n):\\n        x = mean * (n + len(A)) - sum(A)\\n        return [x / n + (i < x % n)  for i in xrange(n)] if n <= x <= n * 6 else []\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def missingRolls(self, A, mean, n):\\n        x = mean * (n + len(A)) - sum(A)\\n        return [x / n + (i < x % n)  for i in xrange(n)] if n <= x <= n * 6 else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1507250,
                "title": "java-easy-to-understand-efficient-interview-solution",
                "content": "This problem is not too difficult if you give it a bit more thought, since any correct solution is a valid answer.\\n\\nThe problem is basically that you have `m` numbers and `n` missing numbers both of which are between `[1,6]`. You\\'re given the mean when the `n` numbers were not missing, and you\\'re given `n` itself along with the current `m` numbers.\\n\\nYou have to find those `n` numbers (any valid set).\\n\\nLet\\'s assume the sum of the lost `n` numbers is `sumLost`. The mean when those numbers were not lost is `mean`, and the sum of the `m` given numbers is `sumPresent`.\\n\\nNow since we are given `m` (length of `rolls` array) and `n` we can find the total numbers present before loss, which will be `div = n + m`.\\n\\nSo the basic equation of mean will be:\\n\\n```\\nsumLost + sumPresent\\n-------------------- = mean\\n\\t\\tdiv\\n```\\n\\nNow this gives us `sumLost = (mean * div) - sumPresent`.\\n\\nNow we have the value of `sumLost` and we have to find an array of `n` elements (each element between `[1,6]`) which sum to `sumLost`.\\n\\nNow, here we can also handle the `impossible` case. If the `sumLost` is less than `n` or is greater than `6 * n`, we must return empty array.\\n\\nWhy?\\nBecause, the minimum allowed number is 1 so minimum sum of `n` elements will be `n * 1 = n` and the maximum allowed number is 6, so maximum sum of `n` elements will be `n * 6`.\\n\\nNow let\\'s prepare an array filled with all 1s, since that is the minimum number.\\n\\nNow go through the array and increment each value upto 6 while checking that the `currentSum` is less than `sumLost`.\\n\\nAt the end we return the array. This approach will give us one valid solution (which is what we want).\\n\\nThe code would look something like this:\\n\\n```\\nclass Solution {\\n    private int[] makeSum(int sum, int[] arr) {\\n        int currentSum = arr.length;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            while (arr[i] < 6 && currentSum < sum) {\\n                arr[i]++;\\n                currentSum++;\\n            } \\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int[] arr = new int[n];\\n        Arrays.fill(arr, 1);\\n        int div = rolls.length + n;\\n        int sum = 0;\\n        \\n        for (int i = 0; i < rolls.length; i++) {\\n            sum += rolls[i];\\n        }\\n        \\n        int findSum = (mean * div) - sum;\\n        if (findSum < n || findSum > (6 * n)) {\\n            return new int[0];\\n        }\\n        \\n        return makeSum(findSum, arr);\\n    }\\n}\\n```\\n\\nHope it helps, please upvote if it did :)",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nsumLost + sumPresent\\n-------------------- = mean\\n\\t\\tdiv\\n```\n```\\nclass Solution {\\n    private int[] makeSum(int sum, int[] arr) {\\n        int currentSum = arr.length;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            while (arr[i] < 6 && currentSum < sum) {\\n                arr[i]++;\\n                currentSum++;\\n            } \\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int[] arr = new int[n];\\n        Arrays.fill(arr, 1);\\n        int div = rolls.length + n;\\n        int sum = 0;\\n        \\n        for (int i = 0; i < rolls.length; i++) {\\n            sum += rolls[i];\\n        }\\n        \\n        int findSum = (mean * div) - sum;\\n        if (findSum < n || findSum > (6 * n)) {\\n            return new int[0];\\n        }\\n        \\n        return makeSum(findSum, arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500805,
                "title": "c-easy-to-understand-solution-with-comments-and-explanations-in-points",
                "content": "### Things we need to do to find the remaining n numbers are:\\n* Find the remaining sum which is missing.\\n\\t`missing_sum = mean * (m + n) - sum_of_m_given_rolls`\\n* If the missing sum is less than n then we can\\'t distribute 1 to each n numbers.\\n* If the missing sum is more than `6*n` then we can\\'t distribute to n numbers, because a die has maximum value of 6.\\n* Else we can distribute the missing_sum to n numbers.\\n* Now if we have remainder left after distributing the missing_sum to n parts then we give each one a value of 1.\\n\\n```\\nvector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n    int total = 0, m = rolls.size();\\n    for (int it: rolls)\\n        total += it;\\n    int missing_sum = mean * (m + n) - total;\\n    if (missing_sum < n || missing_sum > 6 * n)\\n        return {};  // The first two if\\'s are handled\\n    // Each will get distribution\\n    int distribution = missing_sum / n, remaining = missing_sum % n;\\n    vector<int> ans(n, distribution);\\n    // We distribute the remaining to each\\n    for (int i = 0; i < remaining; i++)\\n        ++ans[i];\\n    return ans;\\n}\\n```\\n\\n\\n### Time Complexity: O(N)\\n### Space Complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nvector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n    int total = 0, m = rolls.size();\\n    for (int it: rolls)\\n        total += it;\\n    int missing_sum = mean * (m + n) - total;\\n    if (missing_sum < n || missing_sum > 6 * n)\\n        return {};  // The first two if\\'s are handled\\n    // Each will get distribution\\n    int distribution = missing_sum / n, remaining = missing_sum % n;\\n    vector<int> ans(n, distribution);\\n    // We distribute the remaining to each\\n    for (int i = 0; i < remaining; i++)\\n        ++ans[i];\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1702173,
                "title": "simple-approach-using-c-runtime-124-ms-faster-than-95-56",
                "content": "Since we need a total mean of (m+n) elements in the array rolls[n+m], where 1<= rolls[i] <=6, equal to given `mean`.\\n\\nLet rolls = [1,5,6], mean = 3, n = 4\\nwe have, m (size of rolls) = 3\\nn = 4\\ntherefore, length = m + n = 7\\n\\nwe know, mean = (rolls[0] + rolls[1] + ... + rolls[m+n-1]) / length\\n=> (sum of given m rolls + sum_of_n_missing numbers) / length = mean\\n=> (sum_m + sum_n) / (m+n) = mean\\n=> sum_n = mean * (m+n) - sum_m\\n\\nputting the given values in the above equation we got something like given below.\\nsum_n = 3 * (3 + 4) - 12 = 9\\n\\nNow, we need to find the `n` numbers whose sum is 9\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum_m = 0, m = rolls.size();\\n        for(auto val : rolls) {\\n            sum_m += val;\\n        }\\n\\t\\t\\n        // we have to find the n numbers whose sum is 9\\n        int sum_n = (mean*(n+m)) - sum_m;\\n        \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// E.g. sum_n = 100, n = 7, \\n\\t\\t// We won\\'t be able to get 7 numbers selecting between 1 to 6 whose sum will be 100\\n\\t\\t// Even after selecting seven 6\\'s we will end up having only sum of 42, but we need 100\\n\\t\\t// so this case will result an empty array\\n        if(sum_n > 6*n) return ans;\\n\\t\\t\\n\\t\\t// E.g. sum_n = 2, n = 7, \\n\\t\\t// We won\\'t be able to get 7 numbers selecting between 1 to 6 whose sum will be 2\\n\\t\\t// so this case will also result an empty array\\n        if(sum_n < n) return ans;\\n        \\n\\t\\t// sum_n = 9, n = 4, => val = 9/4 = 2\\n        int val = sum_n / n;\\n\\t\\t\\n\\t\\t// ans = [2, 2, 2, 2]\\n        for(int i=0; i<n; i++) \\n            ans.push_back(val);\\n\\t\\t\\t\\n\\t\\t// rem = 9 % 4 = 1\\n        int rem = sum_n % n;\\n\\t\\t\\n\\t\\t// ans = [2+1, 2, 2, 2] = [3, 2, 2, 2]\\n        for(int i=0; i<rem; i++) \\n            ans[i] += 1;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like !",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum_m = 0, m = rolls.size();\\n        for(auto val : rolls) {\\n            sum_m += val;\\n        }\\n\\t\\t\\n        // we have to find the n numbers whose sum is 9\\n        int sum_n = (mean*(n+m)) - sum_m;\\n        \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// E.g. sum_n = 100, n = 7, \\n\\t\\t// We won\\'t be able to get 7 numbers selecting between 1 to 6 whose sum will be 100\\n\\t\\t// Even after selecting seven 6\\'s we will end up having only sum of 42, but we need 100\\n\\t\\t// so this case will result an empty array\\n        if(sum_n > 6*n) return ans;\\n\\t\\t\\n\\t\\t// E.g. sum_n = 2, n = 7, \\n\\t\\t// We won\\'t be able to get 7 numbers selecting between 1 to 6 whose sum will be 2\\n\\t\\t// so this case will also result an empty array\\n        if(sum_n < n) return ans;\\n        \\n\\t\\t// sum_n = 9, n = 4, => val = 9/4 = 2\\n        int val = sum_n / n;\\n\\t\\t\\n\\t\\t// ans = [2, 2, 2, 2]\\n        for(int i=0; i<n; i++) \\n            ans.push_back(val);\\n\\t\\t\\t\\n\\t\\t// rem = 9 % 4 = 1\\n        int rem = sum_n % n;\\n\\t\\t\\n\\t\\t// ans = [2+1, 2, 2, 2] = [3, 2, 2, 2]\\n        for(int i=0; i<rem; i++) \\n            ans[i] += 1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500255,
                "title": "java-100-3ms-easy-solution",
                "content": "Runtime O(N + M) \\n\\tm = rolls.length\\n\\tn = n\\n\\n```java\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int target = mean * (n + rolls.length); \\n        \\n        int sumOfRolls = 0;\\n        for (int i = 0; i < rolls.length; i++){\\n            sumOfRolls += rolls[i];\\n        }\\n        \\n        int diff = target - sumOfRolls;\\n        int divisor = diff / n;\\n        int leftOver = diff % n;\\n        \\n        if (divisor == 0 || diff < 0 || n * 6 < target - sumOfRolls){\\n            return new int[] {};\\n        }\\n        \\n        int[] res = new int[n];\\n        \\n        for (int i = 0; i < res.length; i++){\\n            res[i] = divisor;\\n\\t\\t\\tif (leftOver > 0){\\n\\t\\t\\t\\tres[i]++;\\n\\t\\t\\t\\tleftOver--;\\n\\t\\t\\t}\\n        }\\n    \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int target = mean * (n + rolls.length); \\n        \\n        int sumOfRolls = 0;\\n        for (int i = 0; i < rolls.length; i++){\\n            sumOfRolls += rolls[i];\\n        }\\n        \\n        int diff = target - sumOfRolls;\\n        int divisor = diff / n;\\n        int leftOver = diff % n;\\n        \\n        if (divisor == 0 || diff < 0 || n * 6 < target - sumOfRolls){\\n            return new int[] {};\\n        }\\n        \\n        int[] res = new int[n];\\n        \\n        for (int i = 0; i < res.length; i++){\\n            res[i] = divisor;\\n\\t\\t\\tif (leftOver > 0){\\n\\t\\t\\t\\tres[i]++;\\n\\t\\t\\t\\tleftOver--;\\n\\t\\t\\t}\\n        }\\n    \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500232,
                "title": "python-solution",
                "content": "```\\nm = len(rolls)\\ndiff = mean * (m + n) - sum(rolls)\\nif diff > 6 * n or diff < n:\\n\\treturn []\\ndiv, mod = divmod(diff, n)\\nreturn [div + 1] * mod + [div] * (n - mod)\\n```",
                "solutionTags": [],
                "code": "```\\nm = len(rolls)\\ndiff = mean * (m + n) - sum(rolls)\\nif diff > 6 * n or diff < n:\\n\\treturn []\\ndiv, mod = divmod(diff, n)\\nreturn [div + 1] * mod + [div] * (n - mod)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500230,
                "title": "c-easiest-solution-split-a-val-in-n-parts",
                "content": "\\n# ***Approach***\\n```\\nThis problem boils down to diving a given val to n parts with each part in range(1 to 6 inclusive)\\n\\nHow to find val?\\nUse mean formula = sum of values / num of values = mean\\nIn our case =>     (sum(rolls) + val) / (rolls.size() + n) = mean\\n\\nwe have sum(rolls) , rolls.size() , n and mean given , we can easily calculate val!!!\\n\\n\\n=> Edge case : where given val can\\'t be divided into n parts\\n\\nNow partition val into n parts with each part in range[1 -> 6]\\n\\n(1) find rem = val % n\\n(2) Initially fill vector with (val/n) values\\n(3) then distribute remainder to as much values as you can to vector elements\\n\\nFor example val = 11 , n = 2\\n\\n(1) rem = val % n = 11 % 2 = 1\\n(2) Initially fill vector with (val/n) values ===> (11/2) = 5\\n\\tres = {5 , 5}\\n(3) res = {5 + 1 , 5}\\n\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int> &rolls, int mean, int n) {\\n        int val = (mean * (rolls.size() + n)) - accumulate(rolls.begin() , rolls.end() , 0); \\n        \\n        if(6 * n < val or val < 0 or val < n) // edge case\\n            return {};\\n        \\n        int rem = val % n;\\n        vector<int> res(n , val/n); \\n        \\n        for(int i = 0 ; i < res.size() ; ++i)\\n        {\\n            if(rem != 0)\\n                res[i] += 1 , --rem;\\n            else\\n                break;\\n\\n        }\\n        return res;\\n    }\\n};\\n```\\n# ***If you liked the Solution , Give it an Upvote :)***\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nThis problem boils down to diving a given val to n parts with each part in range(1 to 6 inclusive)\\n\\nHow to find val?\\nUse mean formula = sum of values / num of values = mean\\nIn our case =>     (sum(rolls) + val) / (rolls.size() + n) = mean\\n\\nwe have sum(rolls) , rolls.size() , n and mean given , we can easily calculate val!!!\\n\\n\\n=> Edge case : where given val can\\'t be divided into n parts\\n\\nNow partition val into n parts with each part in range[1 -> 6]\\n\\n(1) find rem = val % n\\n(2) Initially fill vector with (val/n) values\\n(3) then distribute remainder to as much values as you can to vector elements\\n\\nFor example val = 11 , n = 2\\n\\n(1) rem = val % n = 11 % 2 = 1\\n(2) Initially fill vector with (val/n) values ===> (11/2) = 5\\n\\tres = {5 , 5}\\n(3) res = {5 + 1 , 5}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int> &rolls, int mean, int n) {\\n        int val = (mean * (rolls.size() + n)) - accumulate(rolls.begin() , rolls.end() , 0); \\n        \\n        if(6 * n < val or val < 0 or val < n) // edge case\\n            return {};\\n        \\n        int rem = val % n;\\n        vector<int> res(n , val/n); \\n        \\n        for(int i = 0 ; i < res.size() ; ++i)\\n        {\\n            if(rem != 0)\\n                res[i] += 1 , --rem;\\n            else\\n                break;\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500157,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=accumulate(rolls.begin(),rolls.end(),0);\\n        int sz=rolls.size();\\n        int valSum=mean*(sz+n);\\n        valSum-=sum;\\n        if(valSum<=0)\\n            return {};\\n        if(valSum>(n*6))\\n            return {};\\n        int t=valSum/n;\\n        if(t==0)\\n            return {};\\n        vector<int> ans(n,t);\\n        int k=valSum%n;\\n        for(int i=0;i<k;i++)\\n            ans[i]++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=accumulate(rolls.begin(),rolls.end(),0);\\n        int sz=rolls.size();\\n        int valSum=mean*(sz+n);\\n        valSum-=sum;\\n        if(valSum<=0)\\n            return {};\\n        if(valSum>(n*6))\\n            return {};\\n        int t=valSum/n;\\n        if(t==0)\\n            return {};\\n        vector<int> ans(n,t);\\n        int k=valSum%n;\\n        for(int i=0;i<k;i++)\\n            ans[i]++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500150,
                "title": "java-o-n",
                "content": "Since, mean = (sum + sumOfMissing) / (rolls.length + n)\\nwe can say sumOfMissing = mean * (rolls.length + n) - sum\\n\\n```\\npublic int[] missingRolls(int[] rolls, int mean, int n) {\\n\\tint sum = 0;\\n\\tfor(int i: rolls) sum += i;\\n\\tint sumOfMissing = mean * (rolls.length + n) - sum;\\n\\tif(sumOfMissing < n || sumOfMissing > n* 6) return new int[] {};\\n\\tint[] result = new int[n];\\n\\tfor(int i = 0; sumOfMissing > 0; sumOfMissing -= result[i++]) \\n\\t\\tresult[i] = sumOfMissing/(n-i);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] missingRolls(int[] rolls, int mean, int n) {\\n\\tint sum = 0;\\n\\tfor(int i: rolls) sum += i;\\n\\tint sumOfMissing = mean * (rolls.length + n) - sum;\\n\\tif(sumOfMissing < n || sumOfMissing > n* 6) return new int[] {};\\n\\tint[] result = new int[n];\\n\\tfor(int i = 0; sumOfMissing > 0; sumOfMissing -= result[i++]) \\n\\t\\tresult[i] = sumOfMissing/(n-i);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713114,
                "title": "easy-c-solution-very-simple-approach-with-explanation-o-n-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size(), sum_m = 0, sum_n = 0, total_sum = 0;\\n        vector<int> ans;\\n        for(int i=0; i<m; i++) // Calculate the sum of given m observations\\n            sum_m += rolls[i];\\n        \\n        total_sum = (m+n)*mean;  // Total sum is sum of roll observation for both m and n\\n        if(total_sum<=sum_m)    return {}; // If total_sum is smaller than any of the sum then return {}\\n        \\n        sum_n = total_sum - sum_m; //Calculate sum of n observations\\n        if(sum_n > (n*6) || sum_n<n)    return {}; // If sum_n is gretaer than highest possible value or lower than least possible value then return {}\\n        \\n        int rem = sum_n%n, min = sum_n/n; // Calculate the minimum distribution of value and also the remainder to be later distributed\\n        for(int i=0; i<n; i++){\\n            ans.push_back(min);\\n            if((rem--)>0) // As long as we have remainder left, increment values by 1\\n                ans[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size(), sum_m = 0, sum_n = 0, total_sum = 0;\\n        vector<int> ans;\\n        for(int i=0; i<m; i++) // Calculate the sum of given m observations\\n            sum_m += rolls[i];\\n        \\n        total_sum = (m+n)*mean;  // Total sum is sum of roll observation for both m and n\\n        if(total_sum<=sum_m)    return {}; // If total_sum is smaller than any of the sum then return {}\\n        \\n        sum_n = total_sum - sum_m; //Calculate sum of n observations\\n        if(sum_n > (n*6) || sum_n<n)    return {}; // If sum_n is gretaer than highest possible value or lower than least possible value then return {}\\n        \\n        int rem = sum_n%n, min = sum_n/n; // Calculate the minimum distribution of value and also the remainder to be later distributed\\n        for(int i=0; i<n; i++){\\n            ans.push_back(min);\\n            if((rem--)>0) // As long as we have remainder left, increment values by 1\\n                ans[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500219,
                "title": "c",
                "content": "```\\nvector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m=rolls.size();\\n        int sum=accumulate(rolls.begin(),rolls.end(),0);\\n        \\n        int total=(n+m)*mean;\\n        int total_rem=total-sum;\\n        int no=total_rem/n;\\n        int rem=total_rem%n;\\n        \\n        if(total_rem<=0 || total_rem > 6*n || no==0)\\n            return {};\\n        \\n        vector<int> ans(n,no);\\n        for(int i=0; i<rem; i++)\\n        {\\n            ans[i]++;\\n        }\\n        \\n        return ans;        \\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m=rolls.size();\\n        int sum=accumulate(rolls.begin(),rolls.end(),0);\\n        \\n        int total=(n+m)*mean;\\n        int total_rem=total-sum;\\n        int no=total_rem/n;\\n        int rem=total_rem%n;\\n        \\n        if(total_rem<=0 || total_rem > 6*n || no==0)\\n            return {};\\n        \\n        vector<int> ans(n,no);\\n        for(int i=0; i<rem; i++)\\n        {\\n            ans[i]++;\\n        }\\n        \\n        return ans;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1500182,
                "title": "easy-solution-o-n-with-detail-explaination",
                "content": "Basic idea behind this is we can make an equation to find the left value : \\nFor ex. rolls = [3,2,4,3], mean = 4, n = 2\\nThen, (3 + 2 + 4 + 3 + x) / (4 + 2) = 4 \\n    x = mean * (n + size of array) - sum of array;\\n    Now if left/n > 6 as we have value 1 to 6 (dice) and left < 0 or left < n then return empty array.\\n    Then we distribute left/n values to ans array.\\n    and after it if left % n != 0 means something is left so whatever value is left we add it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = 0;\\n        for(int i = 0;i<m;i++) sum += rolls[i];\\n        \\n        int left = (mean * (n + m)) - sum;\\n        if(ceil((double)left/n) > 6 || left < 0 || left < n) return {};\\n    \\n        vector<int> ans(n);\\n        for(int i = 0;i<n;i++){\\n            ans[i] = left/n;\\n        }\\n        \\n        int left_val = left % n;\\n        for(int i = 0;i<left_val;i++){\\n            ans[i]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = 0;\\n        for(int i = 0;i<m;i++) sum += rolls[i];\\n        \\n        int left = (mean * (n + m)) - sum;\\n        if(ceil((double)left/n) > 6 || left < 0 || left < n) return {};\\n    \\n        vector<int> ans(n);\\n        for(int i = 0;i<n;i++){\\n            ans[i] = left/n;\\n        }\\n        \\n        int left_val = left % n;\\n        for(int i = 0;i<left_val;i++){\\n            ans[i]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500180,
                "title": "c-easy-basic-math-o-n",
                "content": "vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        int m=rolls.size();\\n        int sum=0;\\n        for(int i=0;i<m;i++)\\n            sum+=rolls[i];\\n        \\n        float required = mean*(n+m);\\n        float rem = required-sum;\\n        \\n        vector<int> ans;\\n        \\n        if(rem/n>6 || rem<n) return ans;\\n\\t\\t\\n        int d=rem/n;\\n        for(int i=0;i<n;i++)\\n            ans.push_back(d);\\n        \\n        int extra = rem-(d*n); \\n\\n        int k=0;\\n        while(extra>0){\\n            int g = 6-ans[k];\\n            if(g>f)\\n                g=extra;\\n            ans[k]+=g;\\n            k++;\\n            extra-=g;\\n        }\\n    \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        int m=rolls.size();\\n        int sum=0;\\n        for(int i=0;i<m;i++)\\n            sum+=rolls[i];\\n        \\n        float required = mean*(n+m);\\n        float rem = required-sum;\\n        \\n        vector<int> ans;\\n        \\n        if(rem/n>6 || rem<n) return ans;\\n\\t\\t\\n        int d=rem/n;\\n        for(int i=0;i<n;i++)\\n            ans.push_back(d);\\n        \\n        int extra = rem-(d*n); \\n\\n        int k=0;\\n        while(extra>0){\\n            int g = 6-ans[k];\\n            if(g>f)\\n                g=extra;\\n            ans[k]+=g;\\n            k++;\\n            extra-=g;\\n        }\\n    \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1500326,
                "title": "c-5-line-solution",
                "content": "I use `mean` to store the sum of `n` missing observations.\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int& mean, int& n) {\\n        mean = mean * (n + rolls.size()) - accumulate(rolls.begin(), rolls.end(), 0);\\n        if (mean < n || mean > n * 6) return {};\\n        rolls = vector(n, mean / n);\\n        for(n = mean % n; n > 0; --n) ++rolls[n];\\n        return rolls;\\n    }\\n};\\n```\\nTime complexity: O(M + N)\\nSpace complexity (not include input & output): O(1)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int& mean, int& n) {\\n        mean = mean * (n + rolls.size()) - accumulate(rolls.begin(), rolls.end(), 0);\\n        if (mean < n || mean > n * 6) return {};\\n        rolls = vector(n, mean / n);\\n        for(n = mean % n; n > 0; --n) ++rolls[n];\\n        return rolls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080791,
                "title": "c-solution-only-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        vector<int>temp;\\n        int sum=0,total=n+rolls.size();\\n        for(int i=0;i<rolls.size();i++){\\n            sum+=rolls[i];\\n        }\\n        int avg_sum=mean*total;\\n        int pending_sum=avg_sum-sum;\\n\\n        //we need to find n values<=6 which has sum = peding sum;\\n        if(pending_sum<0)return temp;\\n        int avg_val=pending_sum/n;\\n        int rem=pending_sum%n;\\n        int div=n-rem;\\n\\n        //if average value exceed range[1,6] return emplty array else fill values\\n        if(avg_val>6 || (avg_val==6 && rem!=0) || avg_val==0){\\n            return temp;\\n        }\\n\\n        //if remainder is in range [1,n-1] fill avg_val+1 remainder time else avg_val\\n        while(rem){\\n            temp.push_back(avg_val+1);\\n            rem--;\\n        }\\n        while(div){\\n            temp.push_back(avg_val);\\n            div--;\\n        }\\n        return temp;       \\n        \\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        vector<int>temp;\\n        int sum=0,total=n+rolls.size();\\n        for(int i=0;i<rolls.size();i++){\\n            sum+=rolls[i];\\n        }\\n        int avg_sum=mean*total;\\n        int pending_sum=avg_sum-sum;\\n\\n        //we need to find n values<=6 which has sum = peding sum;\\n        if(pending_sum<0)return temp;\\n        int avg_val=pending_sum/n;\\n        int rem=pending_sum%n;\\n        int div=n-rem;\\n\\n        //if average value exceed range[1,6] return emplty array else fill values\\n        if(avg_val>6 || (avg_val==6 && rem!=0) || avg_val==0){\\n            return temp;\\n        }\\n\\n        //if remainder is in range [1,n-1] fill avg_val+1 remainder time else avg_val\\n        while(rem){\\n            temp.push_back(avg_val+1);\\n            rem--;\\n        }\\n        while(div){\\n            temp.push_back(avg_val);\\n            div--;\\n        }\\n        return temp;       \\n        \\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788357,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = 0;\\n        for(int i : rolls) sum += i;\\n        \\n        int l = (rolls.size() + n) * mean - sum;\\n        if(l < n || l > n * 6) return {};\\n        \\n        int avg = l / n, rem = l % n;\\n        vector<int> ans(n, avg);\\n        \\n        for(int i=0; i<rem; i++) ans[i]++;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = 0;\\n        for(int i : rolls) sum += i;\\n        \\n        int l = (rolls.size() + n) * mean - sum;\\n        if(l < n || l > n * 6) return {};\\n        \\n        int avg = l / n, rem = l % n;\\n        vector<int> ans(n, avg);\\n        \\n        for(int i=0; i<rem; i++) ans[i]++;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676222,
                "title": "java-simplest-solution-explained",
                "content": "Hello, I tried 2 approaches here, where the first gave TLE (recursive approach), and 2nd worked!!\\n\\n**First Approach:**\\n\\nHere, the idea is:\\n- Find the remaining sum for the \\'n\\' rolls.\\n- Try to find possible values for these rolls using recursion.\\n- This solution gives TLE as the constraints are big for a recursive approach.\\n\\nBelow is the working code:\\n\\nSample TLE Test-case:\\n- rolls: {4,5,6,2,3,6,5,4,6,4,5,1,6,3,1,4,5,5,3,2,3,5,3,2,1,5,4,3,5,1,5}\\n- mean: 4\\n- n: 40\\n\\n```\\npublic int[] missingRolls(int[] rolls, int mean, int n) {\\n        int knownRollsSum = 0;\\n        for (int roll : rolls)\\n            knownRollsSum += roll;\\n        int unknownRollsSum = (rolls.length + n) * mean - knownRollsSum;\\n\\n        if (unknownRollsSum > n*6)\\n            return new int[0];\\n\\n        List<Integer> missingRolls = findMissingRolls(n, unknownRollsSum, new ArrayList<Integer>());\\n        return missingRolls == null ? new int[0] : missingRolls.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n\\n    private List<Integer> findMissingRolls(int n, int sum, List<Integer> rolls) {\\n        if (n == 0 && sum == 0)\\n            return rolls;\\n        if (n == 0 || sum == 0) {\\n            return null;\\n        }\\n        for (int i=1; i<=6; i++) {\\n            rolls.add(i);\\n            List<Integer> resp = findMissingRolls(n-1, sum-i, rolls);\\n            if (resp != null)\\n                return rolls;\\n            rolls.remove(rolls.size()-1);\\n        }\\n        return null;\\n    }\\n```\\n\\n**Second Approach:**\\n\\nThe idea here is quite simple.\\n- We first find the remaining sum, i.e. `unknownSum = (m + n) * mean - {sum of \\'m\\' rolls};`\\n- Post that, we find the average value of \\'n\\', which will be above sum / n;\\n- We also check if there is some offset, e.g., let\\'s say unknownSum = 23 and n = 5.\\n\\t- In this case, each of the remaining \\'n\\' rolls can have an average value of 4 with an offset of 3.\\n\\t- This offset is something we\\'ll have to adjust in the values, so we add the offset to each average value if it\\'s still greater than 1, and then reduce the offset.\\n\\nBelow is my accepted solution for above approach:\\n\\n```\\npublic int[] missingRolls(int[] rolls, int mean, int n) {\\n        int knownSum = 0;\\n        for (int roll : rolls)\\n            knownSum += roll;\\n        int unknownSum = (rolls.length + n) * mean - knownSum;\\n\\n        if (unknownSum < n || unknownSum > n*6)\\n            return new int[] {};\\n\\n        int[] result = new int[n];\\n\\n        int avgValue = unknownSum / n;\\n        int offset = unknownSum % n;\\n        for (int i=0; i<n ;i++) {\\n            result[i] = avgValue;\\n            if (offset > 0)\\n                result[i] += 1;\\n            offset--;\\n        }\\n        return result;\\n    }\\n```\\n\\nIf you like my solution, do upvote!\\nHappy Coding!!",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\npublic int[] missingRolls(int[] rolls, int mean, int n) {\\n        int knownRollsSum = 0;\\n        for (int roll : rolls)\\n            knownRollsSum += roll;\\n        int unknownRollsSum = (rolls.length + n) * mean - knownRollsSum;\\n\\n        if (unknownRollsSum > n*6)\\n            return new int[0];\\n\\n        List<Integer> missingRolls = findMissingRolls(n, unknownRollsSum, new ArrayList<Integer>());\\n        return missingRolls == null ? new int[0] : missingRolls.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n\\n    private List<Integer> findMissingRolls(int n, int sum, List<Integer> rolls) {\\n        if (n == 0 && sum == 0)\\n            return rolls;\\n        if (n == 0 || sum == 0) {\\n            return null;\\n        }\\n        for (int i=1; i<=6; i++) {\\n            rolls.add(i);\\n            List<Integer> resp = findMissingRolls(n-1, sum-i, rolls);\\n            if (resp != null)\\n                return rolls;\\n            rolls.remove(rolls.size()-1);\\n        }\\n        return null;\\n    }\\n```\n```\\npublic int[] missingRolls(int[] rolls, int mean, int n) {\\n        int knownSum = 0;\\n        for (int roll : rolls)\\n            knownSum += roll;\\n        int unknownSum = (rolls.length + n) * mean - knownSum;\\n\\n        if (unknownSum < n || unknownSum > n*6)\\n            return new int[] {};\\n\\n        int[] result = new int[n];\\n\\n        int avgValue = unknownSum / n;\\n        int offset = unknownSum % n;\\n        for (int i=0; i<n ;i++) {\\n            result[i] = avgValue;\\n            if (offset > 0)\\n                result[i] += 1;\\n            offset--;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2649408,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Math***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        int m = rolls.size();\\n        \\n        int sum = 0;\\n        \\n        for(auto x : rolls)\\n        {\\n            sum += x;\\n        }\\n        \\n        // rem_sum will be sum of n rolls\\n        \\n        int rem_sum = (mean * (n + m)) - sum;\\n        \\n        // if the rem_sum is not in range then the array is not possible\\n        \\n        if(rem_sum > 6 * n || rem_sum < n)\\n        {\\n            return {};\\n        }\\n        \\n        // find the sum of each part\\n        \\n        int each_part = rem_sum / n;\\n        \\n        // make a res array\\n        \\n        vector<int> res(n, each_part);\\n        \\n        // distribute the remainder between elements\\n        \\n        int remainder = rem_sum % n;\\n        \\n        int i = 0;\\n        \\n        while(remainder)\\n        {\\n            res[i] += 1;\\n            \\n            remainder--;\\n            \\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        int m = rolls.size();\\n        \\n        int sum = 0;\\n        \\n        for(auto x : rolls)\\n        {\\n            sum += x;\\n        }\\n        \\n        // rem_sum will be sum of n rolls\\n        \\n        int rem_sum = (mean * (n + m)) - sum;\\n        \\n        // if the rem_sum is not in range then the array is not possible\\n        \\n        if(rem_sum > 6 * n || rem_sum < n)\\n        {\\n            return {};\\n        }\\n        \\n        // find the sum of each part\\n        \\n        int each_part = rem_sum / n;\\n        \\n        // make a res array\\n        \\n        vector<int> res(n, each_part);\\n        \\n        // distribute the remainder between elements\\n        \\n        int remainder = rem_sum % n;\\n        \\n        int i = 0;\\n        \\n        while(remainder)\\n        {\\n            res[i] += 1;\\n            \\n            remainder--;\\n            \\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333139,
                "title": "c-math-80-faster-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=mean*(n+rolls.size());// total sum\\n        for(auto x:rolls)// substract the current rolls\\n            sum-=x;\\n        if(sum<n || sum>n*6) // if not possible to create one\\n            return {};\\n        \\n        int f=6;// start filling from the largest possible ( Greedy )\\n        vector<int> res;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=f;j>=1;j--)\\n            {\\n                if(sum>=j+i)\\n                {\\n                    f=j;\\n                    sum-=j;\\n                    res.push_back(j);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=mean*(n+rolls.size());// total sum\\n        for(auto x:rolls)// substract the current rolls\\n            sum-=x;\\n        if(sum<n || sum>n*6) // if not possible to create one\\n            return {};\\n        \\n        int f=6;// start filling from the largest possible ( Greedy )\\n        vector<int> res;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=f;j>=1;j--)\\n            {\\n                if(sum>=j+i)\\n                {\\n                    f=j;\\n                    sum-=j;\\n                    res.push_back(j);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702837,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m=rolls.size();\\n        int sum=0;\\n        sum=accumulate(rolls.begin(),rolls.end(),0);\\n        int req=(m+n)*mean;        \\n        req=req-sum;\\n        if(req> (6*n) || req<n)return {};\\n        \\n        \\n        vector<int> ans(n,req/n);\\n        req=req-((req/n)*n);\\n        int a=0;\\n        while(req >0){            \\n            if(ans[a]==6)\\n                a++;\\n            else{\\n                ans[a]++;\\n                req--;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m=rolls.size();\\n        int sum=0;\\n        sum=accumulate(rolls.begin(),rolls.end(),0);\\n        int req=(m+n)*mean;        \\n        req=req-sum;\\n        if(req> (6*n) || req<n)return {}",
                "codeTag": "Java"
            },
            {
                "id": 1506196,
                "title": "divmod-and-list-comprehension-96-speed",
                "content": "![image](https://assets.leetcode.com/users/images/1fd23420-ebcc-400f-8eb8-0224b156de80_1633514271.078775.png)\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        missing_val, rem = divmod(mean * (len(rolls) + n) - sum(rolls), n)\\n        if rem == 0:\\n            if 1 <= missing_val <= 6:\\n                return [missing_val] * n\\n        elif 1 <= missing_val < 6:\\n            return [missing_val + 1] * rem + [missing_val] * (n - rem)\\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        missing_val, rem = divmod(mean * (len(rolls) + n) - sum(rolls), n)\\n        if rem == 0:\\n            if 1 <= missing_val <= 6:\\n                return [missing_val] * n\\n        elif 1 <= missing_val < 6:\\n            return [missing_val + 1] * rem + [missing_val] * (n - rem)\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501349,
                "title": "java-clean-code-with-comments",
                "content": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        //calculate the total sum to get the expected mean\\n        int expectedSum = mean * (rolls.length + n);\\n        //calculate the sum of what we already have\\n        int currentSum = 0;\\n        for(int roll: rolls) currentSum += roll;\\n        //lets find whats the target sum, remaining sum to build.\\n        int targetSum = expectedSum - currentSum;\\n        \\n        //check edge cases\\n        //1. if the targetSum 3 and n is 4, we will never reach that. dice sides (1 to 6)\\n        //2. if the targetSum 13 and n is 2, we will never reach that either. dice sides (1 to 6)\\n        if(targetSum < n || targetSum > n * 6) return new int[]{};\\n        \\n        int[] result = new int[n];\\n        //finding the each roll\\n        int div = targetSum/n;\\n        //what is left?\\n        int remain = targetSum%n;\\n        \\n        for(int i = 0; i < n; i ++){\\n            //set the default roll\\n            result[i] = div;\\n            //if we are not out of boundary (6) and still have remainer, just keep adding.\\n            while(remain > 0 && result[i] < 6){\\n                result[i]++;\\n                remain--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        //calculate the total sum to get the expected mean\\n        int expectedSum = mean * (rolls.length + n);\\n        //calculate the sum of what we already have\\n        int currentSum = 0;\\n        for(int roll: rolls) currentSum += roll;\\n        //lets find whats the target sum, remaining sum to build.\\n        int targetSum = expectedSum - currentSum;\\n        \\n        //check edge cases\\n        //1. if the targetSum 3 and n is 4, we will never reach that. dice sides (1 to 6)\\n        //2. if the targetSum 13 and n is 2, we will never reach that either. dice sides (1 to 6)\\n        if(targetSum < n || targetSum > n * 6) return new int[]{};\\n        \\n        int[] result = new int[n];\\n        //finding the each roll\\n        int div = targetSum/n;\\n        //what is left?\\n        int remain = targetSum%n;\\n        \\n        for(int i = 0; i < n; i ++){\\n            //set the default roll\\n            result[i] = div;\\n            //if we are not out of boundary (6) and still have remainer, just keep adding.\\n            while(remain > 0 && result[i] < 6){\\n                result[i]++;\\n                remain--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500226,
                "title": "4-line-python-o-n-using-math",
                "content": "Let\\'s say we have `a1, a2, ..., am, b1, b2,..., bn` rolls and `A = a1 + a2 + ... + am` and `B = b1 + b2 + ... + bn`.\\nSo, `mean = (A + B)/(m + n)`\\nwhich gives us: `B = mean * (m+n) - A`\\nIn other words, we need to find `n` rolls which sum up to `B`. \\nFrom here onwards, it\\'s pretty self explanatory.\\n\\n```\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        target = mean * (len(rolls)+n) - sum(rolls)\\n        if target < n or target > 6*n: return []\\n        a, b = divmod(target, n)\\n        return [a]*(n-b) + [a+1]*b\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        target = mean * (len(rolls)+n) - sum(rolls)\\n        if target < n or target > 6*n: return []\\n        a, b = divmod(target, n)\\n        return [a]*(n-b) + [a+1]*b\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1500197,
                "title": "javascript-concise-5-line-o-n-solution",
                "content": "```javascript\\nvar missingRolls = function(rolls, mean, n) {\\n  const diff = mean * (rolls.length + n) - rolls.reduce((a, b) => a + b);\\n  if (diff < n) return []; // Cannot be covered even by case 1 1 1 ...\\n  if (diff > 6 * n) return []; // Cannot be covered even by case 6 6 6 ...\\n  return Array(n)\\n    .fill(Math.ceil(diff / n), 0, diff % n)\\n    .fill(Math.floor(diff / n), diff % n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar missingRolls = function(rolls, mean, n) {\\n  const diff = mean * (rolls.length + n) - rolls.reduce((a, b) => a + b);\\n  if (diff < n) return []; // Cannot be covered even by case 1 1 1 ...\\n  if (diff > 6 * n) return []; // Cannot be covered even by case 6 6 6 ...\\n  return Array(n)\\n    .fill(Math.ceil(diff / n), 0, diff % n)\\n    .fill(Math.floor(diff / n), diff % n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3720019,
                "title": "easy-to-understand-72-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sums = mean * (m+n) - sum(rolls)\\n\\n        if sums < n or not ( 1 <= sums / n <= 6):\\n            return list()\\n        if sums % n == 0:\\n            return [sums // n] * n\\n        else:\\n            k = sums % n\\n            res = [sums//n] * n\\n            for i in range(k):\\n                res[i] += 1\\n            return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sums = mean * (m+n) - sum(rolls)\\n\\n        if sums < n or not ( 1 <= sums / n <= 6):\\n            return list()\\n        if sums % n == 0:\\n            return [sums // n] * n\\n        else:\\n            k = sums % n\\n            res = [sums//n] * n\\n            for i in range(k):\\n                res[i] += 1\\n            return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713843,
                "title": "o-m-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the sum of missing n rolls\\nmissing sum = mean * (m + n) - sum of m rolls\\n\\nCheck if the missing sum can be distributed to n rolls. If yes, find the average (missing sum / n) and distribute it. Distribute the remainder also if left.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- compute target sum i.e mean * (m + n)\\n- compute the missing sum i.e target sum - sum of m rolls\\n- if the missing sum is less than n or more than n * 6, return [] because it can\\'t be distributed\\n- find the average n_avg and remainder n_mod\\n- create a result list of size n and give each n roll a distribution of n_avg\\n- distribute the remainder\\n- return the result list\\n\\n# Complexity\\n- Time complexity: O(sum of m rolls + missing sum average distribution + missing sum mod distribution) \\u2192 O(m + n + n) \\u2192 O(m + n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(result list) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        target_sum = (len(rolls) + n) * mean\\n        missing_sum = target_sum - sum(rolls)\\n        if missing_sum < n or missing_sum > n * 6:\\n            return []\\n        n_avg, n_mod = missing_sum // n, missing_sum % n\\n        res = [n_avg] * n\\n        for i in range(n_mod):\\n            res[i] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        target_sum = (len(rolls) + n) * mean\\n        missing_sum = target_sum - sum(rolls)\\n        if missing_sum < n or missing_sum > n * 6:\\n            return []\\n        n_avg, n_mod = missing_sum // n, missing_sum % n\\n        res = [n_avg] * n\\n        for i in range(n_mod):\\n            res[i] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661789,
                "title": "python-easy-solution-logic",
                "content": "# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        curSum=sum(rolls)\\n        obv=n+len(rolls)\\n        missSum=mean*obv-curSum\\n        if missSum>6*n or missSum<0 or missSum<n:\\n            return []\\n        x=missSum//n\\n        res=[x]*n\\n        remain=missSum-x*n\\n        if remain>0:\\n            more=6-x\\n            add=remain//more\\n            res=res[add:]+[6]*add\\n            final=remain%more\\n            res[0]+=final\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        curSum=sum(rolls)\\n        obv=n+len(rolls)\\n        missSum=mean*obv-curSum\\n        if missSum>6*n or missSum<0 or missSum<n:\\n            return []\\n        x=missSum//n\\n        res=[x]*n\\n        remain=missSum-x*n\\n        if remain>0:\\n            more=6-x\\n            add=remain//more\\n            res=res[add:]+[6]*add\\n            final=remain%more\\n            res[0]+=final\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461194,
                "title": "very-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) \\n    {\\n        int m=rolls.size();\\n\\n        int sum=0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            sum+=rolls[i];\\n        }\\n\\n        int tot=mean*(m+n);\\n\\n        tot=tot-sum;\\n\\n        int factor=tot/n;\\n\\n        int value=tot%n;\\n\\n        vector<int>sp(n,0);\\n\\n        if(factor>=1 && factor<=6)\\n        {\\n\\n      \\n\\n            for(int i=0;i<n-1;i++)\\n            {\\n                // cout<<factor<<\" \";\\n                sp[i]=factor;\\n            }\\n\\n            // cout<<(factor+value)<<\" \"<<endl;\\n            sp[n-1]=factor+value;\\n\\n        }\\n\\n\\n      int danger=factor+value;\\n\\n\\n\\n      if(danger>=1 && danger<=6)\\n      {\\n          cout<<\"safe\"<<endl;\\n          return sp;\\n      }\\n      else\\n      {\\n          sp[n-1]=factor;\\n\\n          int dj1=value;\\n          int dj2=value/n;\\n          int dj3=value%n;\\n\\n          cout<<value<<\" \"<<\"value\"<<endl;\\n          cout<<dj3<<\" \"<<\"dj3\"<<endl;\\n\\n          if(value<0)\\n          {\\n              return {};\\n          }\\n\\n          for(int i=0;i<n;i++)\\n          {\\n              sp[i]=sp[i]+dj2;\\n\\n              if(dj3)\\n              {\\n                  sp[i]=sp[i]+1;\\n                  dj3--;\\n              }\\n\\n           \\n          }\\n\\n        int z=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(sp[i]<=0 or sp[i]>=7)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        if(z>=1)\\n        {\\n            return {};\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<sp[i]<<\" \";\\n        }\\n\\n        cout<<endl;\\n\\n       \\n           return sp;\\n      \\n      }\\n\\n     return {};\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) \\n    {\\n        int m=rolls.size();\\n\\n        int sum=0;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            sum+=rolls[i];\\n        }\\n\\n        int tot=mean*(m+n);\\n\\n        tot=tot-sum;\\n\\n        int factor=tot/n;\\n\\n        int value=tot%n;\\n\\n        vector<int>sp(n,0);\\n\\n        if(factor>=1 && factor<=6)\\n        {\\n\\n      \\n\\n            for(int i=0;i<n-1;i++)\\n            {\\n                // cout<<factor<<\" \";\\n                sp[i]=factor;\\n            }\\n\\n            // cout<<(factor+value)<<\" \"<<endl;\\n            sp[n-1]=factor+value;\\n\\n        }\\n\\n\\n      int danger=factor+value;\\n\\n\\n\\n      if(danger>=1 && danger<=6)\\n      {\\n          cout<<\"safe\"<<endl;\\n          return sp;\\n      }\\n      else\\n      {\\n          sp[n-1]=factor;\\n\\n          int dj1=value;\\n          int dj2=value/n;\\n          int dj3=value%n;\\n\\n          cout<<value<<\" \"<<\"value\"<<endl;\\n          cout<<dj3<<\" \"<<\"dj3\"<<endl;\\n\\n          if(value<0)\\n          {\\n              return {};\\n          }\\n\\n          for(int i=0;i<n;i++)\\n          {\\n              sp[i]=sp[i]+dj2;\\n\\n              if(dj3)\\n              {\\n                  sp[i]=sp[i]+1;\\n                  dj3--;\\n              }\\n\\n           \\n          }\\n\\n        int z=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(sp[i]<=0 or sp[i]>=7)\\n            {\\n                z++;\\n            }\\n        }\\n\\n        if(z>=1)\\n        {\\n            return {};\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<sp[i]<<\" \";\\n        }\\n\\n        cout<<endl;\\n\\n       \\n           return sp;\\n      \\n      }\\n\\n     return {};\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3279707,
                "title": "c-solution-easy-math-approach-o-n-m-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given with the mean of n + m observations, so by applying some math we can find the sum of all numbers and then find the numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we find the sum of all elements let denote it with sum. Now we are given with m elements so we can find the sum of remaining n elements.\\nNow if the sum of these n elements is less than n (not possible as minimum value of dice roll is 1) or greater than 6*n (not possible as maximum value of dice roll is 6) we return empty array.\\n\\nAfter that we traverse through n and find by appropiate number by dividing sum by n.\\n\\n# Complexity\\n- Time complexity: $$O(n+m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        //find the sum of all elements\\n        long sum = 1L*mean*(n+m);\\n\\n        //remove m elements sum\\n        for(int i =0; i<m; i++){\\n            sum -= rolls[i];\\n        }\\n        vector<int> res; \\n        // if it is not possible to get sum return empty array\\n        if(sum < n || sum > 6*n) return res;\\n\\n        //find appropiate elements\\n        while(n > 0){\\n            int x = sum/n;\\n            sum -= x;\\n            res.push_back(x);\\n            n--;\\n        } \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        //find the sum of all elements\\n        long sum = 1L*mean*(n+m);\\n\\n        //remove m elements sum\\n        for(int i =0; i<m; i++){\\n            sum -= rolls[i];\\n        }\\n        vector<int> res; \\n        // if it is not possible to get sum return empty array\\n        if(sum < n || sum > 6*n) return res;\\n\\n        //find appropiate elements\\n        while(n > 0){\\n            int x = sum/n;\\n            sum -= x;\\n            res.push_back(x);\\n            n--;\\n        } \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173551,
                "title": "simple-explained-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int curSum = accumulate(rolls.begin(), rolls.end(), 0), m = rolls.size();\\n        int missingSum = mean * (n + m) - curSum;\\n        if (missingSum < n || missingSum > 6*n) return {};\\n        \\n        int part = missingSum / n, rem = missingSum % n;\\n        vector<int> ans(n, part);\\n        for (int i = 0; i < rem; ++i) \\n            ++ans[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ruby",
                    "Swift",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int curSum = accumulate(rolls.begin(), rolls.end(), 0), m = rolls.size();\\n        int missingSum = mean * (n + m) - curSum;\\n        if (missingSum < n || missingSum > 6*n) return {};\\n        \\n        int part = missingSum / n, rem = missingSum % n;\\n        vector<int> ans(n, part);\\n        for (int i = 0; i < rem; ++i) \\n            ++ans[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966580,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy's if you find this solution helpful 😊, PLEASE do UPVOTE. By doing that it motivate's me to create more better post like this ✍️***\n# Complexity\n- Time complexity:\nO(N)\n\n- Space complexity:\nO(N)\n\n# Code\n```\nclass Solution {\npublic:\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\n        vector<int>ans;\n        int sum=0;\n        for(int i=0;i<rolls.size();i++){\n            sum+=rolls[i];\n        }\n        int sum2=mean*(n+rolls.size());\n        int diff=sum2-sum;\n        if(diff>=n && diff<=6*n){\n            vector<int>ans;\n            int each=diff/n;\n            int rem=diff%n;\n            while(n--){\n                int extra=0;\n                if(rem>0){\n                    rem--;\n                    extra=1;\n             }\n             ans.push_back(each+extra);\n            }\n            return ans;\n        }\n\n    return {};\n    }\n    \n};\n\n\n```\n***Guy's if you find this solution helpful 😊, PLEASE do UPVOTE. By doing that it motivate's me to create more better post like this ✍️***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\nclass Solution {\npublic:\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\n        vector<int>ans;\n        int sum=0;\n        for(int i=0;i<rolls.size();i++){\n            sum+=rolls[i];\n        }\n        int sum2=mean*(n+rolls.size());\n        int diff=sum2-sum;\n        if(diff>=n && diff<=6*n){\n            vector<int>ans;\n            int each=diff/n;\n            int rem=diff%n;\n            while(n--){\n                int extra=0;\n                if(rem>0){\n                    rem--;\n                    extra=1;\n             }\n             ans.push_back(each+extra);\n            }\n            return ans;\n        }\n\n    return {};\n    }\n    \n};\n\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650482,
                "title": "find-missing-observations-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int remSum = ((m+n)*mean) - accumulate(rolls.begin(),rolls.end(),0);\\n        if(remSum > 6*n || remSum<n) return {};\\n        int eachpart = remSum/n,remainder = remSum%n;\\n        vector<int> ans(n,eachpart);\\n        int i=0;\\n        while(remainder--){\\n            ans[i++]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int remSum = ((m+n)*mean) - accumulate(rolls.begin(),rolls.end(),0);\\n        if(remSum > 6*n || remSum<n) return {};\\n        int eachpart = remSum/n,remainder = remSum%n;\\n        vector<int> ans(n,eachpart);\\n        int i=0;\\n        while(remainder--){\\n            ans[i++]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613714,
                "title": "python-greedy-math-easy-to-understand",
                "content": "1) Calculate remain using given rolls and mean\\n2) if remain out of range(ramain > 6 * n or remain < n), a vailid answer is inpossible\\n3) if n <= remain <= n * 6, then there must be at least an answer. Since we can return any of them, we can generate the answer in an intuitive way --- greedy\\na) Since the range for dice number is 1-6 inclusive, we can first generate a res array with all 1s\\nb) increment each number in res array up to at most 6, until remain reaches 0, return res\\n\\n\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = (len(rolls) + n) * mean\\n        remain = total - sum(rolls)\\n        if remain > n * 6 or remain < n:\\n            return []\\n        res = [1] * n\\n        remain -= n\\n\\t\\t# i is used as index in the res\\n        i = 0\\n        while remain > 0:\\n            while remain > 5:\\n                res[i] += 5\\n                remain -= 5\\n                i += 1\\n            res[i] += remain\\n            return res\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = (len(rolls) + n) * mean\\n        remain = total - sum(rolls)\\n        if remain > n * 6 or remain < n:\\n            return []\\n        res = [1] * n\\n        remain -= n\\n\\t\\t# i is used as index in the res\\n        i = 0\\n        while remain > 0:\\n            while remain > 5:\\n                res[i] += 5\\n                remain -= 5\\n                i += 1\\n            res[i] += remain\\n            return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293838,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        total = mean * (m + n)\\n        remain = total - sum(rolls)\\n        if remain < n or remain > 6 * n:\\n            return []\\n        quotient, remainder = divmod(remain, n)\\n        return [quotient + 1] * remainder + [quotient] * (n - remainder)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        total = mean * (m + n)\\n        remain = total - sum(rolls)\\n        if remain < n or remain > 6 * n:\\n            return []\\n        quotient, remainder = divmod(remain, n)\\n        return [quotient + 1] * remainder + [quotient] * (n - remainder)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119702,
                "title": "c-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m_sum = 0;\\n        for(int n:rolls)\\n            m_sum += n;\\n        int n_sum = (mean * (rolls.size() + n)) - (m_sum);\\n        if(n_sum > n * 6 or n_sum < n)\\n            return {};\\n        int rem = n_sum % n;\\n        vector<int> ans(n, n_sum/n);\\n        for(int i = 0;i<rem;i++)\\n            ans[i]++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m_sum = 0;\\n        for(int n:rolls)\\n            m_sum += n;\\n        int n_sum = (mean * (rolls.size() + n)) - (m_sum);\\n        if(n_sum > n * 6 or n_sum < n)\\n            return {};\\n        int rem = n_sum % n;\\n        vector<int> ans(n, n_sum/n);\\n        for(int i = 0;i<rem;i++)\\n            ans[i]++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067717,
                "title": "java-easiest-solution",
                "content": "Adding comments for explanation.\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        // Variable to store sum of M rolls\\n        int sumM = 0;\\n        // Variable to store sum of N rolls\\n        int sumN = 0;\\n        \\n        // find the sum of M rolls\\n        for(int a : rolls){\\n            sumM += a;\\n        }\\n        \\n        // total rolls * mean will given us total sum of all rolls\\n        // subtracting sum of M rolls from total sum will give us sum of N rolls\\n        sumN = (n + rolls.length) * mean - sumM;\\n        \\n        // dividing sum of N rolls by N rolls will give us the minimum value of the dice\\n        // that can be added to the aray. Since dice value can be betwen 1 and 6\\n        // so, values <1 or >6 will make it impossible to find N rolls. Return empty array in that case.\\n        if(sumN /(float) n > 6 || sumN / n < 1){\\n            return new int[]{};\\n        }\\n        \\n        // initialize array with size as n rolls.        \\n        int[] arr = new int[n];\\n        \\n        // To find the dice value of each roll, just follow the same method that we used above.\\n        // divide sum of N rolls by n rolls, then add the value to the array.\\n        // Subtract the added value from total sum and then repeat the process.\\n        for(int i=0; i<n; i++){\\n           arr[i] = sumN / (n-i); \\n            sumN -= arr[i];\\n        }\\n       \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        // Variable to store sum of M rolls\\n        int sumM = 0;\\n        // Variable to store sum of N rolls\\n        int sumN = 0;\\n        \\n        // find the sum of M rolls\\n        for(int a : rolls){\\n            sumM += a;\\n        }\\n        \\n        // total rolls * mean will given us total sum of all rolls\\n        // subtracting sum of M rolls from total sum will give us sum of N rolls\\n        sumN = (n + rolls.length) * mean - sumM;\\n        \\n        // dividing sum of N rolls by N rolls will give us the minimum value of the dice\\n        // that can be added to the aray. Since dice value can be betwen 1 and 6\\n        // so, values <1 or >6 will make it impossible to find N rolls. Return empty array in that case.\\n        if(sumN /(float) n > 6 || sumN / n < 1){\\n            return new int[]{};\\n        }\\n        \\n        // initialize array with size as n rolls.        \\n        int[] arr = new int[n];\\n        \\n        // To find the dice value of each roll, just follow the same method that we used above.\\n        // divide sum of N rolls by n rolls, then add the value to the array.\\n        // Subtract the added value from total sum and then repeat the process.\\n        for(int i=0; i<n; i++){\\n           arr[i] = sumN / (n-i); \\n            sumN -= arr[i];\\n        }\\n       \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045845,
                "title": "c-easy-clean-solution-with-proof-linear-equations-beats-90",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        //if we solve it using maths linear equation then -\\n        /*\\n        Given n , m and mean it is confirmed that-\\n        (sum of all rolls of m size + n*x(where x are the missing rolls))/(n+m) = mean\\n        For example - \\n        rolls = 3,2,4,3 mean = 4 and n = 2 then acc to the formula\\n        => (12+2x)/(2+4) = 4 => 12+2x = 24,\\n         => 2x = 12 , hence it is confirmed that the summation of missing rolls is always 12\\n        */\\n        int sum = accumulate(begin(rolls),end(rolls),0),total = n+rolls.size();\\n        int missing = total*mean - sum;\\n        vector<int> res;\\n        //edge case - In the worst case the total summation of rolls of size (n+m) = (n+m)*6 because of 6 sided dice,then if the (n+m)*6< missing then it is not possible.\\n        if(missing > n*6 or missing < n) return res;\\n        while(missing){\\n            int next = missing/n;//since we move top to bottom as we get the one missing \\n\\t\\t\\t//roll then we have to find only n - 1 missing rolls ,so search space also becomes less,\\n\\t\\t\\t//thats why i do n - 1 and missing-=next \\n\\t\\t\\t//because we get the value then we have to reduce it from the missing rolls(total).\\n            res.push_back(next);\\n            missing-=next;\\n            n-=1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**\\u2B06\\uFE0F Please Upvote If You Like the Explanation and Code \\u2B06\\uFE0F**\\n\\n**\\u2764\\uFE0FThank You For Reading \\u2764\\uFE0F**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        //if we solve it using maths linear equation then -\\n        /*\\n        Given n , m and mean it is confirmed that-\\n        (sum of all rolls of m size + n*x(where x are the missing rolls))/(n+m) = mean\\n        For example - \\n        rolls = 3,2,4,3 mean = 4 and n = 2 then acc to the formula\\n        => (12+2x)/(2+4) = 4 => 12+2x = 24,\\n         => 2x = 12 , hence it is confirmed that the summation of missing rolls is always 12\\n        */\\n        int sum = accumulate(begin(rolls),end(rolls),0),total = n+rolls.size();\\n        int missing = total*mean - sum;\\n        vector<int> res;\\n        //edge case - In the worst case the total summation of rolls of size (n+m) = (n+m)*6 because of 6 sided dice,then if the (n+m)*6< missing then it is not possible.\\n        if(missing > n*6 or missing < n) return res;\\n        while(missing){\\n            int next = missing/n;//since we move top to bottom as we get the one missing \\n\\t\\t\\t//roll then we have to find only n - 1 missing rolls ,so search space also becomes less,\\n\\t\\t\\t//thats why i do n - 1 and missing-=next \\n\\t\\t\\t//because we get the value then we have to reduce it from the missing rolls(total).\\n            res.push_back(next);\\n            missing-=next;\\n            n-=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007275,
                "title": "javascript-solution",
                "content": "```\\nvar missingRolls = function(rolls, mean, n) {\\n    const m = rolls.length;\\n    const observations = m + n;\\n\\n    let totSum = observations * mean;\\n    \\n    for (let i = 0; i < m; ++i) {\\n        const val = rolls[i];\\n        \\n        if (val > totSum) return [];\\n        totSum -= val;\\n    } \\n    \\n    if (totSum < n) return [];\\n   \\n    const res = [];\\n    \\n    totSum -= n;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const addVal = Math.min(5, totSum);\\n        res[i] = addVal + 1;\\n        totSum -= addVal;\\n    }\\n    \\n    return totSum != 0 ? [] : res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar missingRolls = function(rolls, mean, n) {\\n    const m = rolls.length;\\n    const observations = m + n;\\n\\n    let totSum = observations * mean;\\n    \\n    for (let i = 0; i < m; ++i) {\\n        const val = rolls[i];\\n        \\n        if (val > totSum) return [];\\n        totSum -= val;\\n    } \\n    \\n    if (totSum < n) return [];\\n   \\n    const res = [];\\n    \\n    totSum -= n;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const addVal = Math.min(5, totSum);\\n        res[i] = addVal + 1;\\n        totSum -= addVal;\\n    }\\n    \\n    return totSum != 0 ? [] : res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1989662,
                "title": "find-missing-observations-java",
                "content": "#### **Find Missing Observations**\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int sum = 0;\\n        for (int roll: rolls) sum = sum + roll;\\n        sum = (n + rolls.length) * mean - sum;\\n        if (sum<n || (double)sum / n > 6) {\\n            return new int[] {};\\n        } else {\\n            int[] result = new int[n];\\n            int val = (int) Math.floor((double)sum / n);\\n            Arrays.fill(result, val);\\n            if (sum % n != 0) {\\n                for (int i=0; i<sum%n; i++) result[i] = val+1;\\n            };\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int sum = 0;\\n        for (int roll: rolls) sum = sum + roll;\\n        sum = (n + rolls.length) * mean - sum;\\n        if (sum<n || (double)sum / n > 6) {\\n            return new int[] {};\\n        } else {\\n            int[] result = new int[n];\\n            int val = (int) Math.floor((double)sum / n);\\n            Arrays.fill(result, val);\\n            if (sum % n != 0) {\\n                for (int i=0; i<sum%n; i++) result[i] = val+1;\\n            };\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539507,
                "title": "python-no-need-loop",
                "content": "```\\n        num = (len(rolls) + n) * mean - sum(rolls)\\n        if num > n * 6 or num < n: return []\\n        if num % n <= 6:\\n            first = num // n\\n            last = num - first * (n-1)\\n            return [first] * (n - 1) + [last]\\n        else:\\n            carry = num - (num // n) * (n-1) - 6\\n            first = num // n\\n            middle = first + 1\\n            last = num - first * (n - 1 - carry) - middle * carry\\n            return [first] * (n - 1 - carry) + [middle] * carry + [last]\\n```",
                "solutionTags": [],
                "code": "```\\n        num = (len(rolls) + n) * mean - sum(rolls)\\n        if num > n * 6 or num < n: return []\\n        if num % n <= 6:\\n            first = num // n\\n            last = num - first * (n-1)\\n            return [first] * (n - 1) + [last]\\n        else:\\n            carry = num - (num // n) * (n-1) - 6\\n            first = num // n\\n            middle = first + 1\\n            last = num - first * (n - 1 - carry) - middle * carry\\n            return [first] * (n - 1 - carry) + [middle] * carry + [last]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532854,
                "title": "js",
                "content": "```\\n/**\\n * @param {number[]} rolls\\n * @param {number} mean\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar missingRolls = function(rolls, mean, n) {\\n    const sum = rolls.reduce((sum, val) => sum + val, 0)\\n    const total = mean * (rolls.length + n)\\n    const remaining = total - sum\\n    \\n    \\n    if (remaining < n || remaining > 6 * n)\\n        return []\\n        \\n        \\n    const remainder = remaining % n\\n    const quotient = (remaining - remainder) / n\\n    \\n    \\n    let result = new Array(n)\\n    for (const i of result.keys()) {\\n        let outcome = quotient\\n        if (i < remainder)\\n            outcome++\\n        \\n        result[i] = outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} rolls\\n * @param {number} mean\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar missingRolls = function(rolls, mean, n) {\\n    const sum = rolls.reduce((sum, val) => sum + val, 0)\\n    const total = mean * (rolls.length + n)\\n    const remaining = total - sum\\n    \\n    \\n    if (remaining < n || remaining > 6 * n)\\n        return []\\n        \\n        \\n    const remainder = remaining % n\\n    const quotient = (remaining - remainder) / n\\n    \\n    \\n    let result = new Array(n)\\n    for (const i of result.keys()) {\\n        let outcome = quotient\\n        if (i < remainder)\\n            outcome++\\n        \\n        result[i] = outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532525,
                "title": "c-easy-understandable-simple-math-concise-solution",
                "content": "**C++**\\n\\nI Tried This Question WithOut Looking At the Constraints Using Recurssion And And BackTracking And Got ***TLE***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    bool flag = false;\\n    void solve(int target, int n, int roll, int sum){\\n        if(roll == n){\\n            if(sum == target) flag = true;\\n            return;\\n        }\\n        for(int i = 1; i <= 6; i++){\\n            ans.push_back(i);\\n            solve(target, n, roll + 1, sum + i);\\n            if(flag == true){\\n                break;\\n            }else{\\n               ans.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int target = (mean * (n + m)) - sum;\\n        solve(target, n, 0, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\nThen Clearly Observing The Constraints, We Just Have to Find The Remainder And Add One Each One Of Them Until Remainder Becomes Zero..\\nAnd Yeah Handling Certain Edge Cases..\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int target = (mean * (n + m)) - sum;\\n        if(target < n || target > 6 * n) return {};\\n        if(n == 1) return {target};\\n        int rem = target%n;\\n        for(int i = 1; i <= n; i++){\\n            ans.push_back(target/n);\\n            if(rem > 0) {ans[i - 1] += 1; rem--;}\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    bool flag = false;\\n    void solve(int target, int n, int roll, int sum){\\n        if(roll == n){\\n            if(sum == target) flag = true;\\n            return;\\n        }\\n        for(int i = 1; i <= 6; i++){\\n            ans.push_back(i);\\n            solve(target, n, roll + 1, sum + i);\\n            if(flag == true){\\n                break;\\n            }else{\\n               ans.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int target = (mean * (n + m)) - sum;\\n        solve(target, n, 0, 0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int target = (mean * (n + m)) - sum;\\n        if(target < n || target > 6 * n) return {};\\n        if(n == 1) return {target};\\n        int rem = target%n;\\n        for(int i = 1; i <= n; i++){\\n            ans.push_back(target/n);\\n            if(rem > 0) {ans[i - 1] += 1; rem--;}\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505526,
                "title": "javascript-easy-to-understand-solution-81-76",
                "content": "Runtime: 376 ms, faster than 81.74% of JavaScript online submissions for Find Missing Observations.\\nMemory Usage: 66.2 MB, less than 76.52% of JavaScript online submissions for Find Missing Observations.\\n```\\nvar missingRolls = function(rolls, mean, n) {\\n    let res = [];\\n    let sum = ((n + rolls.length) * mean) - rolls.reduce((a,b)=>a+b);\\n    if(sum>6*n || sum<1*n) return res;\\n    let dec = sum % n;\\n    let num = Math.floor(sum / n);\\n    for(let i = 0; i < n; i++){\\n        if(dec) res.push(num+1), dec--;\\n        else res.push(num);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar missingRolls = function(rolls, mean, n) {\\n    let res = [];\\n    let sum = ((n + rolls.length) * mean) - rolls.reduce((a,b)=>a+b);\\n    if(sum>6*n || sum<1*n) return res;\\n    let dec = sum % n;\\n    let num = Math.floor(sum / n);\\n    for(let i = 0; i < n; i++){\\n        if(dec) res.push(num+1), dec--;\\n        else res.push(num);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505066,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = 0;\\n        for(int roll : rolls) sum+=roll;\\n        int res_sum = (mean*(m+n)) - sum;\\n        vector<int> res;\\n        if(res_sum<n) return res;\\n        if(res_sum%n==0){\\n            for(int i=0;i<n;i++){\\n                if(res_sum/n<=6) res.push_back(res_sum/n);\\n            }\\n        }else{\\n            int bft = n - (res_sum%n);\\n            int aft = res_sum/n;\\n            for(int i=0;i<n;i++){\\n                if(i>=bft && aft+1<=6) res.push_back(aft+1);\\n                else if(i<bft && aft<=6) res.push_back(aft);\\n            }\\n        }\\n        if(res.size()!=n) return {};\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = 0;\\n        for(int roll : rolls) sum+=roll;\\n        int res_sum = (mean*(m+n)) - sum;\\n        vector<int> res;\\n        if(res_sum<n) return res;\\n        if(res_sum%n==0){\\n            for(int i=0;i<n;i++){\\n                if(res_sum/n<=6) res.push_back(res_sum/n);\\n            }\\n        }else{\\n            int bft = n - (res_sum%n);\\n            int aft = res_sum/n;\\n            for(int i=0;i<n;i++){\\n                if(i>=bft && aft+1<=6) res.push_back(aft+1);\\n                else if(i<bft && aft<=6) res.push_back(aft);\\n            }\\n        }\\n        if(res.size()!=n) return {};\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503686,
                "title": "a-few-solutions",
                "content": "Find the missing total `x` which needs to be split into `N` dice values from `1..6` inclusive.  If `x` is too big or too small, then it is impossible to construct the array.  Otherwise, `take` the floor of `each` average value to initialize the answer `ans`.  Then evenly distribute the \"leftovers\" until we `have` the value `x` distributed amongst the the answer `ans`.\\n\\nI derived `x` during the contest via the following observation.  Let `K` be the input `mean` and `t` be the total sum of the rolls array `A`.  Then it follows that:\\n```\\n     t + x\\nK = --------\\n    |A| + N\\n\\n```\\nAnd thus:\\n```\\nx = (|A| + N) * K - t\\n```\\n\\nThat is: `x` is the total value we need to add onto the accumulated total `t` sum of the elements in `A` in order to acquire the mean `K` by appending `N` additional elements onto `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun missingRolls(A: IntArray, K: Int, N: Int): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var t = A.sum()\\n        var x = (A.size + N) * K - t\\n        var each = x.toDouble() / N.toDouble()\\n        if (each < 1 || 6 < each)\\n            return ans.toIntArray()\\n        var take = Math.floor(each).toInt()\\n        for (i in 0 until N)\\n            ans.add(take)\\n        var have = take * N\\n        for (i in 0 until ans.size) {\\n            var need = x - have\\n            if (need == 0)\\n                break\\n            ++ans[i]; ++have\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet missingRolls = (A, K, N) => {\\n    let t = A.reduce((a, b) => a + b);\\n    let x = (A.length + N) * K - t;\\n    let each = x / N;\\n    if (each < 1 || 6 < each)\\n        return [];\\n    let take = Math.floor(each);\\n    let ans = Array(N).fill(take);\\n    let have = take * N;\\n    for (let i = 0; i < ans.length; ++i) {\\n        let need = x - have;\\n        if (!need)\\n            break;\\n        ++ans[i], ++have;\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def missingRolls(self, A: List[int], K: int, N: int) -> List[int]:\\n        t = sum(A)\\n        x = (len(A) + N) * K - t\\n        each = x / N\\n        if each < 1 or 6 < each:\\n            return []\\n        take = int(each)\\n        ans = [take] * N\\n        have = take * N\\n        for i in range(N):\\n            need = x - have\\n            if not need:\\n                break\\n            ans[i] += 1; have += 1\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI missingRolls(VI& A, int K, int N) {\\n        auto t = accumulate(A.begin(), A.end(), 0),\\n             x = (int(A.size()) + N) * K - t;\\n        auto each = double(x) / N;\\n        if (each < 1 || 6 < each)\\n            return {};\\n        auto take = int(each);\\n        VI ans(N, take);\\n        auto have = take * N;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto need = x - have;\\n            if (!need)\\n                break;\\n            ++ans[i], ++have;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n     t + x\\nK = --------\\n    |A| + N\\n\\n```\n```\\nx = (|A| + N) * K - t\\n```\n```\\nclass Solution {\\n    fun missingRolls(A: IntArray, K: Int, N: Int): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var t = A.sum()\\n        var x = (A.size + N) * K - t\\n        var each = x.toDouble() / N.toDouble()\\n        if (each < 1 || 6 < each)\\n            return ans.toIntArray()\\n        var take = Math.floor(each).toInt()\\n        for (i in 0 until N)\\n            ans.add(take)\\n        var have = take * N\\n        for (i in 0 until ans.size) {\\n            var need = x - have\\n            if (need == 0)\\n                break\\n            ++ans[i]; ++have\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet missingRolls = (A, K, N) => {\\n    let t = A.reduce((a, b) => a + b);\\n    let x = (A.length + N) * K - t;\\n    let each = x / N;\\n    if (each < 1 || 6 < each)\\n        return [];\\n    let take = Math.floor(each);\\n    let ans = Array(N).fill(take);\\n    let have = take * N;\\n    for (let i = 0; i < ans.length; ++i) {\\n        let need = x - have;\\n        if (!need)\\n            break;\\n        ++ans[i], ++have;\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def missingRolls(self, A: List[int], K: int, N: int) -> List[int]:\\n        t = sum(A)\\n        x = (len(A) + N) * K - t\\n        each = x / N\\n        if each < 1 or 6 < each:\\n            return []\\n        take = int(each)\\n        ans = [take] * N\\n        have = take * N\\n        for i in range(N):\\n            need = x - have\\n            if not need:\\n                break\\n            ans[i] += 1; have += 1\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI missingRolls(VI& A, int K, int N) {\\n        auto t = accumulate(A.begin(), A.end(), 0),\\n             x = (int(A.size()) + N) * K - t;\\n        auto each = double(x) / N;\\n        if (each < 1 || 6 < each)\\n            return {};\\n        auto take = int(each);\\n        VI ans(N, take);\\n        auto have = take * N;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto need = x - have;\\n            if (!need)\\n                break;\\n            ++ans[i], ++have;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502186,
                "title": "golang-solution-with-explanation",
                "content": "This solution aims to find the missing sum and then distribute it among `n` values.\\n\\n***\\n\\nThe idea of the first part (Finding the missing sum) is first to find the sum of the `m` numbers given to us in `rolls`. \\n\\nThen since the mean will always be `mean = sum / (n + m)` (the sum of elements divided by the number of elements), we know that the number of elements will always be `n + m`. So the total number of elements will be `(n + m) * mean`. And the sum of the missing elements will be `(n + m) * mean - sum` (Works because of PEMDAS).\\n\\n***\\n\\nNow the part in-between is for returning an empty array.\\n\\nWe return an empty array if `missing > n * 6`. This checks whether there is a greater missing sum than `n * 6`. `n * 6` because `6` is the max number on a dice, and `n` is the max number of unobserved rolls.\\n\\nWe also return an empty array if `missing < n`. This is because there are not enough in the missing sum to fill up `n` dices. This is because a dice can only have values from `1` to `6`, meaning we can\\'t have dice with the value `0`.\\n\\n***\\n\\nNow to distribute `missing` between `n` values.\\n\\nSince we want at least `1` in each dice value, we can find the value of each dice by doing:\\n\\n```\\nres[i] = int(math.Min(float64(6), float64(missing - (n - 1 - i))))\\nmissing -= res[i]\\n```\\n\\nWe find the min between `6`, and `missing - (n - 1 - i)`. \\n\\nThe `6` is because it is the maximum value of dice. \\n\\nThe `(n - 1 - i)` in `missing - (n - 1 - i)` is for finding the max value we can have at `res[i]` so that we have at least `1` for `res[i + 1], res[i + 2], res[i + 3] ... res[n - 1]`. \\n\\n`i` is the current dice we are on. Since `i` is zero-indexed we can do `(n - (i + 1))`, but this simplifies to `n - i - 1` because of the distributive property. And since `n` is the number of total missing dice, if we do `n - i - 1`, we get the remaining number of dice, and with that a value of `1` per remaining dice.\\n\\nAnd if we do `missing - (n - 1 - i)`, we get the maximum value we can give to a dice.\\n\\nThen the `missing -= res[i]` part removes the missing value from `missing`.\\n\\n***\\n\\n``` go\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    res := make([]int, n)\\n    sum := 0\\n    \\n    for _, roll := range rolls { \\n        // finding sum\\n        sum += roll\\n    }\\n    \\n    missing := (len(rolls) + n) * mean - sum\\n    \\n    if missing > n * 6 || missing < n {\\n        // should return empty array\\n        return []int{}\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        // distribute the missing\\n        res[i] = int(math.Min(float64(6), float64(missing - (n - 1 - i))))\\n        missing -= res[i]\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nres[i] = int(math.Min(float64(6), float64(missing - (n - 1 - i))))\\nmissing -= res[i]\\n```\n``` go\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    res := make([]int, n)\\n    sum := 0\\n    \\n    for _, roll := range rolls { \\n        // finding sum\\n        sum += roll\\n    }\\n    \\n    missing := (len(rolls) + n) * mean - sum\\n    \\n    if missing > n * 6 || missing < n {\\n        // should return empty array\\n        return []int{}\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        // distribute the missing\\n        res[i] = int(math.Min(float64(6), float64(missing - (n - 1 - i))))\\n        missing -= res[i]\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502008,
                "title": "c-2028-find-missing-observations",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int total = mean * (n + rolls.size()) - accumulate(rolls.begin(), rolls.end(), 0); \\n        if (total < n || total > 6*n) return {}; \\n        vector<int> ans(n, total/n); \\n        for (int i = 0; i < total%n; ++i) ++ans[i]; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int total = mean * (n + rolls.size()) - accumulate(rolls.begin(), rolls.end(), 0); \\n        if (total < n || total > 6*n) return {}; \\n        vector<int> ans(n, total/n); \\n        for (int i = 0; i < total%n; ++i) ++ans[i]; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501981,
                "title": "o-n-easy",
                "content": "```\\nclass Solution {\\n    public int[] missingRolls(int[] r, int mn, int n) {\\n        int m = r.length;\\n        int[] ans = new int[n];\\n        int rs = 0; for(int x : r) rs+=x;\\n        int s = mn*(n+m) - rs; int sum = s;\\n        int v = (int) Math.floor(s/n);\\n        for(int i = 0; i < n; ++i)ans[i] = v;\\n        s -= v*n; int i = 0;\\n        while(s > 0 && i < n ){\\n            int x = 6 - ans[i];\\n            ans[i] += s > x ? x : s;\\n            s -= x;\\n            i++;\\n        }\\n        for(int y:ans) if(y < 1 || y > 6) return new int[]{};\\n        int ns = 0; for(int y : ans) ns+=y;\\n        return ns == sum ? ans : new int[]{};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] r, int mn, int n) {\\n        int m = r.length;\\n        int[] ans = new int[n];\\n        int rs = 0; for(int x : r) rs+=x;\\n        int s = mn*(n+m) - rs; int sum = s;\\n        int v = (int) Math.floor(s/n);\\n        for(int i = 0; i < n; ++i)ans[i] = v;\\n        s -= v*n; int i = 0;\\n        while(s > 0 && i < n ){\\n            int x = 6 - ans[i];\\n            ans[i] += s > x ? x : s;\\n            s -= x;\\n            i++;\\n        }\\n        for(int y:ans) if(y < 1 || y > 6) return new int[]{};\\n        int ns = 0; for(int y : ans) ns+=y;\\n        return ns == sum ? ans : new int[]{};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501783,
                "title": "python-100-faster-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        \\'\\'\\'\\n        \\n        \\n            1,5,6    n = 4\\n            \\n            7 * 3 = 21 \\n            \\n            \\n            21 - 12 = 9\\n            \\n            \\n            23/4\\n            \\n            5\\n            \\n            2   2   2   3\\n                 \\n            12*1 + 12\\n            \\n            -12 + x = 12\\n            \\n            \\n            x =  40*4\\n                 \\n                 \\n                 7 \\n                \\n            \\n            \\n        \\'\\'\\'\\n        \\n        tot_m = sum(rolls)\\n        len_m = len(rolls)\\n        \\n        tot_n = (len_m + n)*mean - tot_m\\n        \\'\\'\\' Checking upper bound where value of all n\\'s is 6 if not possible return [] \\'\\'\\'\\n        if tot_n/n > 6 or tot_n/n < 1 :\\n            return []\\n        else:\\n\\t\\t\\t\\'\\'\\' Get average of each value \\'\\'\\'\\n            each_val = tot_n//n\\n            \\'\\'\\' check the extra sum which you need to add i.e \\n\\t\\t\\tlets say you had to make a sum of 167 and you had 40 elements to make it \\n\\t\\t\\t\\n\\t\\t\\tThus , 167 / 40 = 4.something \\n\\t\\t\\t\\n\\t\\t\\tthus. 4 * 40 = 160 and now remaining are 7 \\n\\t\\t\\t\\n\\t\\t\\tyou need to add 1 seven times to every 4 to reach the required sum\\n\\t\\t\\t\\n\\t\\t\\tthus , [4, 4, 4, .....] 33 times and [5,5,5,5,5,5,5] = 167\\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\'\\n            rem_vals = tot_n - each_val*n\\n            if rem_vals == 0:\\n                return [each_val for _ in range(n)]\\n            else:\\n\\t\\t\\t\\t\\n                return [each_val for _ in range(n-rem_vals)] + [each_val+1 for _ in range(rem_vals)]\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        \\'\\'\\'\\n        \\n        \\n            1,5,6    n = 4\\n            \\n            7 * 3 = 21 \\n            \\n            \\n            21 - 12 = 9\\n            \\n            \\n            23/4\\n            \\n            5\\n            \\n            2   2   2   3\\n                 \\n            12*1 + 12\\n            \\n            -12 + x = 12\\n            \\n            \\n            x =  40*4\\n                 \\n                 \\n                 7 \\n                \\n            \\n            \\n        \\'\\'\\'\\n        \\n        tot_m = sum(rolls)\\n        len_m = len(rolls)\\n        \\n        tot_n = (len_m + n)*mean - tot_m\\n        \\'\\'\\' Checking upper bound where value of all n\\'s is 6 if not possible return [] \\'\\'\\'\\n        if tot_n/n > 6 or tot_n/n < 1 :\\n            return []\\n        else:\\n\\t\\t\\t\\'\\'\\' Get average of each value \\'\\'\\'\\n            each_val = tot_n//n\\n            \\'\\'\\' check the extra sum which you need to add i.e \\n\\t\\t\\tlets say you had to make a sum of 167 and you had 40 elements to make it \\n\\t\\t\\t\\n\\t\\t\\tThus , 167 / 40 = 4.something \\n\\t\\t\\t\\n\\t\\t\\tthus. 4 * 40 = 160 and now remaining are 7 \\n\\t\\t\\t\\n\\t\\t\\tyou need to add 1 seven times to every 4 to reach the required sum\\n\\t\\t\\t\\n\\t\\t\\tthus , [4, 4, 4, .....] 33 times and [5,5,5,5,5,5,5] = 167\\n\\t\\t\\t\\n\\t\\t\\t\\'\\'\\'\\n            rem_vals = tot_n - each_val*n\\n            if rem_vals == 0:\\n                return [each_val for _ in range(n)]\\n            else:\\n\\t\\t\\t\\t\\n                return [each_val for _ in range(n-rem_vals)] + [each_val+1 for _ in range(rem_vals)]\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501735,
                "title": "c-long-but-easy-solution-different-approach-use-100-fatser",
                "content": "```\\n// IF YOU HAVE ANY DOUBTS PLS COMMENT BELOW!!\\n// IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE !!\\n\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        int k=rolls.size();\\n        \\n        int g1;\\n        int qo;   //for quotient\\n        int rem;  // for remainder\\n        int t=0;\\n        int a=((k+n)*mean); // (total numbers * mean)\\n        int sum=0;\\n        for(int i=0;i<rolls.size();i++)\\n            sum =sum+rolls[i];// calculating sum of values in rools\\n        \\n        \\n        \\n        int g=(a-sum);//sum of unknown n number\\n        \\n        \\n        if((g>(6*n))||(g<0)||(g<n))// checking various condition \\n        {\\n            return {};\\n        \\n        }\\n        else\\n        {\\n             \\n  std::vector<int>q; // vector to store missing value\\n            \\n           \\n            \\n                \\n            \\n            qo=g/n; // calculating quotient\\n            \\n            rem=g%n; // calculating remainder\\n            \\n            q.insert(q.end(), n, qo); // inserting the value of quotient(qo) n times into the vector\\n            \\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                if((q[i]+rem)<=6) // checking if the sum of remainder and value of vector q less then 6 \\n                    q[i]=q[i]+rem;// increasing value by adding remainder \\n                break;\\n            }\\n            \\n                 if(rem>5) // if the value of remainder is greater then 5 lets remainder may be 6 so we can\\'t add it to q[i] because minimum value of q[i] can be 1 and q[i] can\\'t be greater then 6.\\n                   \\n                 {\\n                        for(int i=0;i<n;i++)\\n                        {\\n                           \\n                                if(q[i]+1<=6)\\n                                {\\n                                  t++; // to keep the count of  how many times value increment\\n                                \\n                                    q[i]=q[i]+1;// incrementing value of vector q by 1 ;\\n                                   \\n                                    if(t==rem)// checking if value of q[i] is increase rem times for eg if remainder is 7 then we will increment only 7 element of vector q by 1. \\n                                    { \\n                                        break;\\n                                    }\\n                                    \\n                            }\\n                        }\\n                    }\\n                \\n            return q;\\n            \\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        int k=rolls.size();\\n        \\n        int g1;\\n        int qo;   //for quotient\\n        int rem;  // for remainder\\n        int t=0;\\n        int a=((k+n)*mean); // (total numbers * mean)\\n        int sum=0;\\n        for(int i=0;i<rolls.size();i++)\\n            sum =sum+rolls[i];// calculating sum of values in rools\\n        \\n        \\n        \\n        int g=(a-sum);//sum of unknown n number\\n        \\n        \\n        if((g>(6*n))||(g<0)||(g<n))// checking various condition \\n        {\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 1501147,
                "title": "c-with-comments-simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    \\n    \\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=0;\\n        for(int i=0;i<rolls.size();i++){\\n            sum+=rolls[i];\\n        }\\n\\t\\t//this is total sum we needed to make mean of the rolls\\n        int total_sum=mean*(rolls.size()+n);\\n\\t\\t//we have to divide this rem to n numbers\\n        int rem=total_sum-sum;\\n\\t\\t//if n*6 is smaller then rem then it is not possible\\n        if(n*6<rem){\\n            return {};\\n        }\\n\\t\\t//if n is greater then rem then it is not possible\\n        if(n>rem){\\n            return {};\\n        }\\n        // findans(rem,n);\\n\\t\\t//we simply taking average of no\\n        int avr=rem/n;\\n\\t\\t//if there are rem we store it\\n        int rems=rem%n;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=avr;\\n            if(rems>0){\\n                ans[i]++;\\n                rems--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    \\n    \\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=0;\\n        for(int i=0;i<rolls.size();i++){\\n            sum+=rolls[i];\\n        }\\n\\t\\t//this is total sum we needed to make mean of the rolls\\n        int total_sum=mean*(rolls.size()+n);\\n\\t\\t//we have to divide this rem to n numbers\\n        int rem=total_sum-sum;\\n\\t\\t//if n*6 is smaller then rem then it is not possible\\n        if(n*6<rem){\\n            return {};\\n        }\\n\\t\\t//if n is greater then rem then it is not possible\\n        if(n>rem){\\n            return {};\\n        }\\n        // findans(rem,n);\\n\\t\\t//we simply taking average of no\\n        int avr=rem/n;\\n\\t\\t//if there are rem we store it\\n        int rems=rem%n;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=avr;\\n            if(rems>0){\\n                ans[i]++;\\n                rems--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500521,
                "title": "c-easy-to-understand-simple-for-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = 0;\\n        for(int i=0;i<rolls.size();i++)\\n            sum+=rolls[i];\\n        int m = rolls.size();\\n        int rem = (m+n)*mean - sum;\\n        int re = rem;\\n        int r = n;\\n        vector<int> v;\\n        cout<<rem<<\"\\\\n\";\\n        while(rem >= 0 && n>0){\\n            int curr = rem/n;\\n            if(curr>=1 && curr<=6){\\n                v.push_back(curr);\\n            }\\n            rem -= curr;\\n            n--;\\n        }\\n        int s = 0;\\n        for(int i=0;i<v.size();i++){\\n            s+=v[i];\\n        }\\n        if(v.size()==r && s==re){\\n            return v;\\n        }\\n        vector<int> v1;\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = 0;\\n        for(int i=0;i<rolls.size();i++)\\n            sum+=rolls[i];\\n        int m = rolls.size();\\n        int rem = (m+n)*mean - sum;\\n        int re = rem;\\n        int r = n;\\n        vector<int> v;\\n        cout<<rem<<\"\\\\n\";\\n        while(rem >= 0 && n>0){\\n            int curr = rem/n;\\n            if(curr>=1 && curr<=6){\\n                v.push_back(curr);\\n            }\\n            rem -= curr;\\n            n--;\\n        }\\n        int s = 0;\\n        for(int i=0;i<v.size();i++){\\n            s+=v[i];\\n        }\\n        if(v.size()==r && s==re){\\n            return v;\\n        }\\n        vector<int> v1;\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1500426,
                "title": "c-easy-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m=rolls.size();\\n        int mtotal=0;\\n        for(int i=0;i<m;i++){\\n            mtotal+=rolls[i];\\n        }\\n        int ntotal=(n+m)*mean-mtotal;\\n        vector<int>ans;\\n        int temp=0;\\n        if(ntotal<=0 or ntotal>n*6 or ntotal/n==0){\\n            return {};\\n        }\\n        cout<<n<<\" \"<<ntotal;\\n        while(ntotal){\\n            temp=ntotal/n;\\n            ans.push_back(temp);\\n            n--;\\n            ntotal=ntotal-temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m=rolls.size();\\n        int mtotal=0;\\n        for(int i=0;i<m;i++){\\n            mtotal+=rolls[i];\\n        }\\n        int ntotal=(n+m)*mean-mtotal;\\n        vector<int>ans;\\n        int temp=0;\\n        if(ntotal<=0 or ntotal>n*6 or ntotal/n==0){\\n            return {};\\n        }\\n        cout<<n<<\" \"<<ntotal;\\n        while(ntotal){\\n            temp=ntotal/n;\\n            ans.push_back(temp);\\n            n--;\\n            ntotal=ntotal-temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1500393,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) \\n    {\\n        int val = (rolls.size()+n)*mean - accumulate(rolls.begin(), rolls.end(), 0);\\n        if(val>n*6 || val<0 || val<n)\\n            return {};\\n        int rem = val%n;\\n        vector<int> res(n, val/n); \\n        for(int i=0; i<res.size(); i++)\\n        {\\n            if(rem != 0)\\n                res[i]+=1, rem--;\\n            else\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) \\n    {\\n        int val = (rolls.size()+n)*mean - accumulate(rolls.begin(), rolls.end(), 0);\\n        if(val>n*6 || val<0 || val<n)\\n            return {};\\n        int rem = val%n;\\n        vector<int> res(n, val/n); \\n        for(int i=0; i<res.size(); i++)\\n        {\\n            if(rem != 0)\\n                res[i]+=1, rem--;\\n            else\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500222,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = mean * (len(rolls) + n) - sum(rolls)\\n        if not n <= total <= 6*n: return []\\n        q, r = divmod(total, n)\\n        return [q]*(n-r) + [q+1]*r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = mean * (len(rolls) + n) - sum(rolls)\\n        if not n <= total <= 6*n: return []\\n        q, r = divmod(total, n)\\n        return [q]*(n-r) + [q+1]*r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500161,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        #finding the equal distribution of remaining sum\\n        temp = mean*(n+len(rolls)) - sum(rolls)\\n        each = temp//n\\n        rem = temp%n\\n        \\n        #return empty if out of dice range\\n        if (not (1<=(each + 1)<=6) and rem>0) or not (1<=each<=6):\\n            return []\\n        \\n        res = [each]*n\\n        i = 0\\n        #adding the remainder to each possible\\n        while rem > 0 and i<n:\\n            res[i] += 1\\n            rem -= 1\\n            i += 1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        #finding the equal distribution of remaining sum\\n        temp = mean*(n+len(rolls)) - sum(rolls)\\n        each = temp//n\\n        rem = temp%n\\n        \\n        #return empty if out of dice range\\n        if (not (1<=(each + 1)<=6) and rem>0) or not (1<=each<=6):\\n            return []\\n        \\n        res = [each]*n\\n        i = 0\\n        #adding the remainder to each possible\\n        while rem > 0 and i<n:\\n            res[i] += 1\\n            rem -= 1\\n            i += 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500151,
                "title": "python-numpy",
                "content": "```python\\nimport numpy as np\\nclass Solution:\\n    def missingRolls(self, rolls, mean, n):\\n        m = len(rolls)\\n        missing_sum = (n + m) * mean - sum(rolls)\\n        if missing_sum < n or missing_sum > 6 * n:\\n            return []\\n        \\n        npa = np.ones(n)\\n        while np.sum(npa) < missing_sum:\\n            l = int( min(n, missing_sum - np.sum(npa)) )\\n            npa[:l] += 1\\n        return [int(x) for x in npa]\\n```",
                "solutionTags": [],
                "code": "```python\\nimport numpy as np\\nclass Solution:\\n    def missingRolls(self, rolls, mean, n):\\n        m = len(rolls)\\n        missing_sum = (n + m) * mean - sum(rolls)\\n        if missing_sum < n or missing_sum > 6 * n:\\n            return []\\n        \\n        npa = np.ones(n)\\n        while np.sum(npa) < missing_sum:\\n            l = int( min(n, missing_sum - np.sum(npa)) )\\n            npa[:l] += 1\\n        return [int(x) for x in npa]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061420,
                "title": "7-line-javascript-typescript-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst missingRolls = (rolls: number[], mean: number, n: number): number[] => {\\n  let needed = mean * (rolls.length + n) - rolls.reduce((a, b) => a + b) - n;\\n  if (needed < 0 || needed > 5 * n) return [];\\n  return Array.from({ length: n }, () => {\\n    const num = Math.min(needed, 5);\\n    needed -= num;\\n    return num + 1;\\n  });\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst missingRolls = (rolls: number[], mean: number, n: number): number[] => {\\n  let needed = mean * (rolls.length + n) - rolls.reduce((a, b) => a + b) - n;\\n  if (needed < 0 || needed > 5 * n) return [];\\n  return Array.from({ length: n }, () => {\\n    const num = Math.min(needed, 5);\\n    needed -= num;\\n    return num + 1;\\n  });\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981424,
                "title": "c-easy-solution-math",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int total = n+rolls.size();\\n        total *= mean;\\n        total -= accumulate(begin(rolls),end(rolls),0);\\n        if(total>n*6|| total<n)return {};\\n        vector<int> ans(n,1);\\n        total -= n;\\n        for(int i=0;i<n;++i){\\n            if(total>5){\\n                ans[i] = 6;\\n                total -= 5;\\n            }\\n            else{\\n                ans[i] += total;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int total = n+rolls.size();\\n        total *= mean;\\n        total -= accumulate(begin(rolls),end(rolls),0);\\n        if(total>n*6|| total<n)return {};\\n        vector<int> ans(n,1);\\n        total -= n;\\n        for(int i=0;i<n;++i){\\n            if(total>5){\\n                ans[i] = 6;\\n                total -= 5;\\n            }\\n            else{\\n                ans[i] += total;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935788,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        s = sum(rolls)\\n        total = len(rolls) + n\\n        x = (total*mean) - s\\n\\n        if x >= 1*n and x <= 6*n:\\n            e = x // n\\n            ans = [e] * n\\n            left = x - (e * n)\\n            for i in range(left):\\n                ans[i] += 1\\n\\n            return ans\\n        else:\\n            return []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        s = sum(rolls)\\n        total = len(rolls) + n\\n        x = (total*mean) - s\\n\\n        if x >= 1*n and x <= 6*n:\\n            e = x // n\\n            ans = [e] * n\\n            left = x - (e * n)\\n            for i in range(left):\\n                ans[i] += 1\\n\\n            return ans\\n        else:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931075,
                "title": "easy-to-understand-simple-and-clean-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n        \\n        int sum = 0;\\n        for(int i = 0; i<rolls.length; i++){\\n            sum +=rolls[i];\\n        }\\n        int totalValue = mean*(rolls.length + n);\\n        int reqValue = totalValue - sum;\\n\\n        if( reqValue > 6*n || reqValue < 1*n){\\n            return new int[0];\\n        }\\n        int[] ans = new int[n];\\n        for(int i = 0; i<ans.length; i++){\\n            ans[i] = reqValue/n;\\n            reqValue -= ans[i];\\n            n--;\\n        }\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n        \\n        int sum = 0;\\n        for(int i = 0; i<rolls.length; i++){\\n            sum +=rolls[i];\\n        }\\n        int totalValue = mean*(rolls.length + n);\\n        int reqValue = totalValue - sum;\\n\\n        if( reqValue > 6*n || reqValue < 1*n){\\n            return new int[0];\\n        }\\n        int[] ans = new int[n];\\n        for(int i = 0; i<ans.length; i++){\\n            ans[i] = reqValue/n;\\n            reqValue -= ans[i];\\n            n--;\\n        }\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912751,
                "title": "simple-intutive",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void rec(vector<int>&ans, int n, int x, vector<int>&t){\\n        if(n==0 and x==0){\\n            ans=t;return;\\n        }\\n        if(n==0) return;\\n        for(int i=1;i<=6;i++){\\n            if(x-i>=0){\\n                t.push_back(i);\\n                rec(ans,n-1,x-i,t);\\n                t.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int s=accumulate(rolls.begin(),rolls.end(),0);\\n        int x=(n+rolls.size())*mean-s;\\n        cout<<x<<endl;\\n        vector<int>ans(n);\\n        if(n>x) return {};\\n        int y=x%n;int a=y;\\n        if((x-y)/n>6) return {};\\n        for(int i=0;i<n;i++){\\n            ans[i]=(x-y)/n;\\n            if(a){\\n                ans[i]++;\\n                a--;\\n            }\\n            if(ans[i]>6) return {};\\n        }\\n        // rec(ans,n,x,t);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(vector<int>&ans, int n, int x, vector<int>&t){\\n        if(n==0 and x==0){\\n            ans=t;return;\\n        }\\n        if(n==0) return;\\n        for(int i=1;i<=6;i++){\\n            if(x-i>=0){\\n                t.push_back(i);\\n                rec(ans,n-1,x-i,t);\\n                t.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int s=accumulate(rolls.begin(),rolls.end(),0);\\n        int x=(n+rolls.size())*mean-s;\\n        cout<<x<<endl;\\n        vector<int>ans(n);\\n        if(n>x) return {};\\n        int y=x%n;int a=y;\\n        if((x-y)/n>6) return {};\\n        for(int i=0;i<n;i++){\\n            ans[i]=(x-y)/n;\\n            if(a){\\n                ans[i]++;\\n                a--;\\n            }\\n            if(ans[i]>6) return {};\\n        }\\n        // rec(ans,n,x,t);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3893564,
                "title": "solution-using-ceil-and-floor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that sumOfMissingRolls = (m + n) * mean - sumOfKnownRolls.\\n\\nSo the average value of missing rolls will be in the range of [ciel(sumOfMissingRolls / n): floor(sumOfMissingRolls / n)]\\n\\nSo the question will not have the answer if and only if ciel or floor is less or equal then Zero; or greater than 6.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        vector<int> ans;\\n        int sumM = 0;\\n        for(auto &r: rolls) sumM += r;\\n\\n        int fullSize = rolls.size() + n;\\n        int sumN = fullSize * mean - sumM;\\n        int c = ceil(sumN/(n*1.0)), f = floor(sumN/(n*1.0));\\n        if(c > 6 || f > 6 || c <= 0 || f <= 0) return ans;\\n\\n        if(c == f) {\\n            while(n--) ans.push_back(c);\\n            return ans;\\n        }\\n\\n        else {\\n            while(sumN > 0) {\\n                if(sumN / (f*1.0) == (double)n) {\\n                    while(n--) ans.push_back(f);\\n                    return ans;\\n                }\\n                else if(sumN / (c*1.0) == (double)n) {\\n                    while(n--) ans.push_back(c);\\n                    return ans;\\n                }\\n                else {\\n                    ans.push_back(f);\\n                    sumN -= f;\\n                }\\n                n--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        vector<int> ans;\\n        int sumM = 0;\\n        for(auto &r: rolls) sumM += r;\\n\\n        int fullSize = rolls.size() + n;\\n        int sumN = fullSize * mean - sumM;\\n        int c = ceil(sumN/(n*1.0)), f = floor(sumN/(n*1.0));\\n        if(c > 6 || f > 6 || c <= 0 || f <= 0) return ans;\\n\\n        if(c == f) {\\n            while(n--) ans.push_back(c);\\n            return ans;\\n        }\\n\\n        else {\\n            while(sumN > 0) {\\n                if(sumN / (f*1.0) == (double)n) {\\n                    while(n--) ans.push_back(f);\\n                    return ans;\\n                }\\n                else if(sumN / (c*1.0) == (double)n) {\\n                    while(n--) ans.push_back(c);\\n                    return ans;\\n                }\\n                else {\\n                    ans.push_back(f);\\n                    sumN -= f;\\n                }\\n                n--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829918,
                "title": "easy-math-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n\\n       int m=rolls.size();\\n       int sum=accumulate(rolls.begin(),rolls.end(),0);\\n       sum=(m+n)*mean-sum;\\n       vector<int> ans;\\n       if(sum>6*n || sum<n)\\n       {\\n           return ans;\\n       } \\n\\n       int value=sum/n;\\n      \\n       vector<int> ans1(n,value);\\n       \\n       value=sum-n*value;\\n       int i=0;\\n       \\n       while(value>0)\\n       {\\n           \\n           sum=6-ans1[i];\\n           if(value>sum)\\n           {\\n               ans1[i++]+=sum;\\n               \\n           }\\n           else\\n           {\\n              \\n               ans1[i]+=value;\\n              \\n           }\\n           value-=sum;\\n       }\\n        \\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n\\n       int m=rolls.size();\\n       int sum=accumulate(rolls.begin(),rolls.end(),0);\\n       sum=(m+n)*mean-sum;\\n       vector<int> ans;\\n       if(sum>6*n || sum<n)\\n       {\\n           return ans;\\n       } \\n\\n       int value=sum/n;\\n      \\n       vector<int> ans1(n,value);\\n       \\n       value=sum-n*value;\\n       int i=0;\\n       \\n       while(value>0)\\n       {\\n           \\n           sum=6-ans1[i];\\n           if(value>sum)\\n           {\\n               ans1[i++]+=sum;\\n               \\n           }\\n           else\\n           {\\n              \\n               ans1[i]+=value;\\n              \\n           }\\n           value-=sum;\\n       }\\n        \\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788102,
                "title": "share-my-solution-using-leetcode-math-pattern",
                "content": "# Intuition\\n\\nJust use leetcode math pattern to do the math. Leetcode math pattern works this way.\\n\\n1. Convert question into equation.\\n2. Do one of following :-\\n2.1 Invert the equation (if greater then smaller)\\n2.2 Rearrange equations (move left or right) \\n2.3 Simplify the equation by adding brackets.\\n\\n# Approach\\n\\nhere, use math pattern this way :-\\n\\n```(mean)*(n+m) = sum(m) + sum(n)```\\n\\n# Complexity\\n- Time complexity:\\n\\nO(n)\\n\\n- Space complexity:\\n\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] nums, int mean, int n) {\\n\\n        int m = nums.length;\\n        int sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n        }\\n\\n        int remaining = mean*(m+n) - sum;\\n        if (remaining < n) {\\n            return new int[0];\\n        }\\n\\n        int[] ans = new int[n];\\n        for (int i=1; i<=6 && remaining >0; i++) {\\n            for (int j=0; j<n && remaining>0; j++) {\\n                ans[j]++;\\n                remaining--;\\n            }\\n        }\\n\\n        if (remaining > 0)\\n            return new int[0];\\n        else\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```(mean)*(n+m) = sum(m) + sum(n)```\n```\\nclass Solution {\\n    public int[] missingRolls(int[] nums, int mean, int n) {\\n\\n        int m = nums.length;\\n        int sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n        }\\n\\n        int remaining = mean*(m+n) - sum;\\n        if (remaining < n) {\\n            return new int[0];\\n        }\\n\\n        int[] ans = new int[n];\\n        for (int i=1; i<=6 && remaining >0; i++) {\\n            for (int j=0; j<n && remaining>0; j++) {\\n                ans[j]++;\\n                remaining--;\\n            }\\n        }\\n\\n        if (remaining > 0)\\n            return new int[0];\\n        else\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782189,
                "title": "simple-go-solution",
                "content": "# Intuition\\nFind the mean value of n rolls, with small adjustments for rounding\\n\\n# Approach\\n1. Find the total sum of all rolls\\n2. Subtract the sum of `m` rolls to get the sume of `n` rolls\\n3. Divide the sum of `n` by `n` to get the mean value of a roll in the `n` group\\n4. Ff the mean is greater than 6 or lower than 1, then there is no solution\\n5. Find the deficit between the sum of `n` to and the rounded `mean * n`\\n6. There are exactly `abs(deficit)` rolls that need to be added or subtracted by `1` depending if the deficit is positive or negative. The rest of the rolls are the rounded mean.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n+m)$$\\nWe iterate over `m` to sum it, and over `n` to create the result. The rest of the operations are time constant. \\n\\n- Space complexity:\\n$$O(n+m)$$\\n\\n# Code\\n```\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    m := len(rolls)\\n    k := n + m\\n    totalSum := mean * k\\n    sumM := sumArray(&rolls)\\n    sumN := totalSum - sumM\\n    var meanN int = sumN / n\\n    var res []int\\n    if meanN > 6 || meanN < 1 {\\n        return res\\n    }\\n    \\n    def := sumN - (meanN * n)\\n    if (def > 0 && meanN == 6) || (def < 0 && meanN == 1) {\\n        return res\\n    }\\n    absDef := int(math.Abs(float64(def)))\\n    change := 1\\n    if (def < 0) {\\n        change = -1\\n    }\\n    res = make([]int, n)\\n    for i, _ := range res {\\n        if i < absDef {\\n            res[i] = meanN + change\\n        } else {\\n            res[i] = meanN\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc sumArray(arr *[]int) int {\\n    sum := 0\\n    for _, item := range *arr {\\n        sum += item\\n    }\\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    m := len(rolls)\\n    k := n + m\\n    totalSum := mean * k\\n    sumM := sumArray(&rolls)\\n    sumN := totalSum - sumM\\n    var meanN int = sumN / n\\n    var res []int\\n    if meanN > 6 || meanN < 1 {\\n        return res\\n    }\\n    \\n    def := sumN - (meanN * n)\\n    if (def > 0 && meanN == 6) || (def < 0 && meanN == 1) {\\n        return res\\n    }\\n    absDef := int(math.Abs(float64(def)))\\n    change := 1\\n    if (def < 0) {\\n        change = -1\\n    }\\n    res = make([]int, n)\\n    for i, _ := range res {\\n        if i < absDef {\\n            res[i] = meanN + change\\n        } else {\\n            res[i] = meanN\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc sumArray(arr *[]int) int {\\n    sum := 0\\n    for _, item := range *arr {\\n        sum += item\\n    }\\n    return sum\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3744344,
                "title": "easy-linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m=len(rolls)\\n        nTotal=((m+n)*mean)-sum(rolls)\\n        res=[]\\n        if nTotal < n or nTotal > n*6 :\\n            return res\\n        while nTotal:\\n            dice=min((nTotal - n + 1 ),6)\\n            res.append(dice)\\n            nTotal-=dice\\n            n-=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m=len(rolls)\\n        nTotal=((m+n)*mean)-sum(rolls)\\n        res=[]\\n        if nTotal < n or nTotal > n*6 :\\n            return res\\n        while nTotal:\\n            dice=min((nTotal - n + 1 ),6)\\n            res.append(dice)\\n            nTotal-=dice\\n            n-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737326,
                "title": "my-stinky-solution-goodluck-reading-it-bless-u-rust-tm",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn missing_rolls(rolls: Vec<i32>, mean: i32, n: i32) -> Vec<i32> {\\n        // mean = (sum_arr_m + sum_arr_n) / (m+n)\\n        // mean (m+n) = (sum_arr_m+sum_arr_n)\\n        // find sum_n\\n        let m: i32 = rolls.len() as i32;\\n        let mut sum_m: i32 = 0;\\n        for num in rolls {\\n            sum_m += num;\\n        }\\n        let sum_n: i32 = ((m + n) * mean) - sum_m;\\n        // println!(\"sum_m:{}\\\\nsum_n:{}\", sum_m, sum_n);\\n        // if sum_n%n != 0 && sum_n/n > 6 {\\n        //     println!(\"!!!!!\");\\n        //     return vec![];\\n        // }\\n        // let mut two_one_vec: Vec<i32> = Self::generate_one_two_vec(sum_n);\\n        // let mut two_one_vec: Vec<i32> = Self::gen_nums_based_on_sum(sum_n, n, 1, 6);\\n        // println!(\"temp n vec:{:?}\", two_one_vec);\\n\\n        let mut result: Vec<i32> = Self::gen_nums_based_on_sum(sum_n, n, 1, 6);\\n        // println!(\"{:?}\", result);\\n        result\\n    }\\n    pub fn generate_one_two_vec(sum: i32) -> Vec<i32> {\\n        let mut result: Vec<i32> = vec![];\\n        let mut temp_sum = sum;\\n        if temp_sum % 2 != 0 {\\n            temp_sum -= 1;\\n            result.push(1);\\n        }\\n        for i in 0..(temp_sum / 2) {\\n            result.push(2);\\n        }\\n        result\\n    }\\n    pub fn gen_nums_based_on_sum(sum: i32, size: i32, min_num: i32, max_num: i32) -> Vec<i32> {\\n        // check can be generated\\n        if (sum % size > 0 && sum / size == 6)\\n            || sum / size > max_num\\n            || sum / size == 0\\n            || sum / size < min_num\\n        {\\n            return vec![];\\n        }\\n        // check can be generated\\n\\n        let mut result: Vec<i32> = vec![];\\n        let base_num: i32 = sum / size;\\n        let mut left_over: i32 = sum % size;\\n        for i in 0..size {\\n            result.push(base_num);\\n        }\\n        let mut idx: usize = 0;\\n        while idx < result.len() && left_over > 0 {\\n            if result[idx] >= 6 {\\n                idx += 1;\\n                continue;\\n            }\\n            result[idx] += 1;\\n            left_over -= 1;\\n        }\\n        result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn missing_rolls(rolls: Vec<i32>, mean: i32, n: i32) -> Vec<i32> {\\n        // mean = (sum_arr_m + sum_arr_n) / (m+n)\\n        // mean (m+n) = (sum_arr_m+sum_arr_n)\\n        // find sum_n\\n        let m: i32 = rolls.len() as i32;\\n        let mut sum_m: i32 = 0;\\n        for num in rolls {\\n            sum_m += num;\\n        }\\n        let sum_n: i32 = ((m + n) * mean) - sum_m;\\n        // println!(\"sum_m:{}\\\\nsum_n:{}\", sum_m, sum_n);\\n        // if sum_n%n != 0 && sum_n/n > 6 {\\n        //     println!(\"!!!!!\");\\n        //     return vec![];\\n        // }\\n        // let mut two_one_vec: Vec<i32> = Self::generate_one_two_vec(sum_n);\\n        // let mut two_one_vec: Vec<i32> = Self::gen_nums_based_on_sum(sum_n, n, 1, 6);\\n        // println!(\"temp n vec:{:?}\", two_one_vec);\\n\\n        let mut result: Vec<i32> = Self::gen_nums_based_on_sum(sum_n, n, 1, 6);\\n        // println!(\"{:?}\", result);\\n        result\\n    }\\n    pub fn generate_one_two_vec(sum: i32) -> Vec<i32> {\\n        let mut result: Vec<i32> = vec![];\\n        let mut temp_sum = sum;\\n        if temp_sum % 2 != 0 {\\n            temp_sum -= 1;\\n            result.push(1);\\n        }\\n        for i in 0..(temp_sum / 2) {\\n            result.push(2);\\n        }\\n        result\\n    }\\n    pub fn gen_nums_based_on_sum(sum: i32, size: i32, min_num: i32, max_num: i32) -> Vec<i32> {\\n        // check can be generated\\n        if (sum % size > 0 && sum / size == 6)\\n            || sum / size > max_num\\n            || sum / size == 0\\n            || sum / size < min_num\\n        {\\n            return vec![];\\n        }\\n        // check can be generated\\n\\n        let mut result: Vec<i32> = vec![];\\n        let base_num: i32 = sum / size;\\n        let mut left_over: i32 = sum % size;\\n        for i in 0..size {\\n            result.push(base_num);\\n        }\\n        let mut idx: usize = 0;\\n        while idx < result.len() && left_over > 0 {\\n            if result[idx] >= 6 {\\n                idx += 1;\\n                continue;\\n            }\\n            result[idx] += 1;\\n            left_over -= 1;\\n        }\\n        result\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3630517,
                "title": "c-easy-to-understand-brute-force-o-n-complexity",
                "content": "# Intuition\\nJust assigning values one by one using simple maths\\n\\n# Approach\\nSimple Maths, Brute Force.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n\\n        <!-- Sum of the known given numbers -->\\n        int sum=accumulate(rolls.begin(),rolls.end(),0);\\n\\n        // remaining total sum for the n elements\\n        int rem=(rolls.size()+n)*mean - sum;\\n\\n        vector<int> ans;\\n\\n        // condition for answer not possible\\n        if(rem>(6*n) || rem<n)return ans;\\n\\n        // remaining numnbers to assign\\n        int to=n;\\n        \\n        // assigning numbers one by one\\n        while(to != 1){\\n            int div=rem/6;\\n\\n            // checking the extreme condition of all remaining 6\\n            if(div==to){\\n                ans.push_back(6);\\n                rem-=6;\\n            }\\n            else{\\n                if(div==to-1){\\n                    ans.push_back((rem%6)+1);\\n                    // +1 to get rid of 0 remainder\\n                    rem-=(rem%6)+1;\\n                }\\n                else{\\n                    // just add 1 to the ans array in this case\\n                    ans.push_back(1);\\n                    rem-=1;\\n                }\\n            }\\n\\n            to--;\\n        }\\n\\n        // last one will be the remaining sum for given mean\\n        ans.push_back(rem);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n\\n        <!-- Sum of the known given numbers -->\\n        int sum=accumulate(rolls.begin(),rolls.end(),0);\\n\\n        // remaining total sum for the n elements\\n        int rem=(rolls.size()+n)*mean - sum;\\n\\n        vector<int> ans;\\n\\n        // condition for answer not possible\\n        if(rem>(6*n) || rem<n)return ans;\\n\\n        // remaining numnbers to assign\\n        int to=n;\\n        \\n        // assigning numbers one by one\\n        while(to != 1){\\n            int div=rem/6;\\n\\n            // checking the extreme condition of all remaining 6\\n            if(div==to){\\n                ans.push_back(6);\\n                rem-=6;\\n            }\\n            else{\\n                if(div==to-1){\\n                    ans.push_back((rem%6)+1);\\n                    // +1 to get rid of 0 remainder\\n                    rem-=(rem%6)+1;\\n                }\\n                else{\\n                    // just add 1 to the ans array in this case\\n                    ans.push_back(1);\\n                    rem-=1;\\n                }\\n            }\\n\\n            to--;\\n        }\\n\\n        // last one will be the remaining sum for given mean\\n        ans.push_back(rem);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615586,
                "title": "java-simple-and-readable-with-explanation",
                "content": "- finding the sum of array\\n- finding the missing rolls sum\\n- spreading the equal part (dividing missing rolls sum by number of missing rolls)\\n- spreading the rest among the lucky ones\\n- done :) \\n```\\npublic int[] missingRolls(int[] arr, int mean, int n) {\\n\\tvar sum = 0;\\n\\tfor (var num:arr) sum+=num;\\n\\n\\tvar mrs = mean*(arr.length+n)-sum; //missing rolls sum\\n\\tif (mrs<n||mrs>n*6) return new int[0]; \\n\\n\\tvar res = new int[n];\\n\\tvar equalPart = mrs/n;\\n\\tfor (int i=0;i<res.length;i++){ //spreading the equal part \\n\\t\\tres[i]=equalPart; mrs-=equalPart;\\n\\t}\\n\\tfor (int i=0;mrs!=0;i++){ //spreading the rest\\n\\t\\tres[i]++; mrs--;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] missingRolls(int[] arr, int mean, int n) {\\n\\tvar sum = 0;\\n\\tfor (var num:arr) sum+=num;\\n\\n\\tvar mrs = mean*(arr.length+n)-sum; //missing rolls sum\\n\\tif (mrs<n||mrs>n*6) return new int[0]; \\n\\n\\tvar res = new int[n];\\n\\tvar equalPart = mrs/n;\\n\\tfor (int i=0;i<res.length;i++){ //spreading the equal part \\n\\t\\tres[i]=equalPart; mrs-=equalPart;\\n\\t}\\n\\tfor (int i=0;mrs!=0;i++){ //spreading the rest\\n\\t\\tres[i]++; mrs--;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3613337,
                "title": "runtime-13-ms-beats-31-50-memory-59-3-mb-beats-45-87-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int ans[] = new int[n];\\n        int ans1[] = new int[0];\\n        int add = 0;\\n        for(int i =0;i<rolls.length;i++)\\n            add +=rolls[i];\\n        int x = (mean*(rolls.length+n))-add, y = n;\\n        if( n<=x && x<=6*n){\\n        for(int i =0;i<n;i++){\\n            ans[i] = (x/y);\\n            x -=(x/y);\\n            y--;\\n        }}\\n        else\\n            return ans1;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int ans[] = new int[n];\\n        int ans1[] = new int[0];\\n        int add = 0;\\n        for(int i =0;i<rolls.length;i++)\\n            add +=rolls[i];\\n        int x = (mean*(rolls.length+n))-add, y = n;\\n        if( n<=x && x<=6*n){\\n        for(int i =0;i<n;i++){\\n            ans[i] = (x/y);\\n            x -=(x/y);\\n            y--;\\n        }}\\n        else\\n            return ans1;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608663,
                "title": "simple-greedy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int> &rolls, int mean, int n)\\n{\\n    int target = (rolls.size() + n) * mean - accumulate(rolls.begin(), rolls.end(), 0);\\n    if (target < n or target > n * 6)\\n    {\\n        return {};\\n    }\\n\\n    vector<int> ans(n, 0);\\n    int index = 0;\\n    while (target > 0)\\n    {\\n        ans[index] += 1;\\n        index++;\\n        index %= n;\\n        target--;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int> &rolls, int mean, int n)\\n{\\n    int target = (rolls.size() + n) * mean - accumulate(rolls.begin(), rolls.end(), 0);\\n    if (target < n or target > n * 6)\\n    {\\n        return {};\\n    }\\n\\n    vector<int> ans(n, 0);\\n    int index = 0;\\n    while (target > 0)\\n    {\\n        ans[index] += 1;\\n        index++;\\n        index %= n;\\n        target--;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586566,
                "title": "simple-greedy-logic-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust put all the elements on dice as 1 and then keep on increasing\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& vec, int mean, int n) {\\n\\n        long long curr = accumulate(vec.begin(),vec.end(),0);\\n        long long req = mean*(n+vec.size()) - curr;\\n        if(req<n or req>(6*n)) return {};\\n        vector<int>ans(n,1);\\n        req-=n;\\n        int ind = 0;\\n        while(req>0){\\n            while(req>0 and ans[ind]<6){\\n                ans[ind]++;\\n                req--;\\n            }\\n            if(req>0){\\n                ind++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& vec, int mean, int n) {\\n\\n        long long curr = accumulate(vec.begin(),vec.end(),0);\\n        long long req = mean*(n+vec.size()) - curr;\\n        if(req<n or req>(6*n)) return {};\\n        vector<int>ans(n,1);\\n        req-=n;\\n        int ind = 0;\\n        while(req>0){\\n            while(req>0 and ans[ind]<6){\\n                ans[ind]++;\\n                req--;\\n            }\\n            if(req>0){\\n                ind++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560314,
                "title": "o-n-simple-math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. find target sum of `n` using given variables\\n2. use the largest number possible to get us close to our target using the given length\\n3. increment values by 1 until we have reached our target\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    m := 0\\n    length := len(rolls) + n\\n    // total is what the sum of n + m should be\\n    total := mean * length\\n\\n    // get the sum of rolls aka m\\n    for i := 0; i < len(rolls); i++ {\\n        m += rolls[i]\\n    }\\n\\n    // target is our target sum of n\\n    target := total - m\\n    part := target / n\\n    sum := 0\\n    ans := make([]int, n)\\n\\n    // if our fraction is smaller or larger than a die\\n    // its impossible\\n    if part < 1 || part > 6 {\\n        return []int{}\\n    }\\n\\n    for i := 0; i < len(ans); i++ {\\n        sum += part\\n        ans[i] = part\\n    }\\n\\n    i := 0\\n\\n    // increment dice by 1 until we reach our target n\\n    for sum < target {\\n        for i < len(ans) && ans[i] == 6 {\\n            i++\\n        }\\n\\n        if i == len(ans) {\\n            return []int{}\\n        }\\n\\n        ans[i]++\\n        sum++\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    m := 0\\n    length := len(rolls) + n\\n    // total is what the sum of n + m should be\\n    total := mean * length\\n\\n    // get the sum of rolls aka m\\n    for i := 0; i < len(rolls); i++ {\\n        m += rolls[i]\\n    }\\n\\n    // target is our target sum of n\\n    target := total - m\\n    part := target / n\\n    sum := 0\\n    ans := make([]int, n)\\n\\n    // if our fraction is smaller or larger than a die\\n    // its impossible\\n    if part < 1 || part > 6 {\\n        return []int{}\\n    }\\n\\n    for i := 0; i < len(ans); i++ {\\n        sum += part\\n        ans[i] = part\\n    }\\n\\n    i := 0\\n\\n    // increment dice by 1 until we reach our target n\\n    for sum < target {\\n        for i < len(ans) && ans[i] == 6 {\\n            i++\\n        }\\n\\n        if i == len(ans) {\\n            return []int{}\\n        }\\n\\n        ans[i]++\\n        sum++\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3551170,
                "title": "greedy-c-solution",
                "content": "```\\nint* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    \\n    int idx = 0;\\n    while(n){\\n        ans[idx++] = targetSum / n;\\n        targetSum -= ans[idx - 1];\\n        n--;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int* ans = (int*)calloc(n, sizeof(int));\\n    int sum = 0, targetSum = mean * (n + rollsSize);\\n    for(int i = 0; i < rollsSize; i++)\\n        sum += rolls[i];\\n    targetSum -= sum;\\n    \\n    *returnSize = n;\\n    if(targetSum < n || targetSum > 6*n){\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    \\n    int idx = 0;\\n    while(n){\\n        ans[idx++] = targetSum / n;\\n        targetSum -= ans[idx - 1];\\n        n--;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529668,
                "title": "100-faster-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int target = mean * (n + rolls.length); \\n        \\n        int sumOfRolls = 0;\\n        for (int i = 0; i < rolls.length; i++){\\n            sumOfRolls += rolls[i];\\n        }\\n        \\n        int diff = target - sumOfRolls;\\n        int divisor = diff / n;\\n        int leftOver = diff % n;\\n        \\n        if (divisor == 0 || diff < 0 || n * 6 < target - sumOfRolls){\\n            return new int[] {};\\n        }\\n        \\n        int[] res = new int[n];\\n        \\n        for (int i = 0; i < res.length; i++){\\n            res[i] = divisor;\\n\\t\\t\\tif (leftOver > 0){\\n\\t\\t\\t\\tres[i]++;\\n\\t\\t\\t\\tleftOver--;\\n\\t\\t\\t}\\n        }\\n    \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int target = mean * (n + rolls.length); \\n        \\n        int sumOfRolls = 0;\\n        for (int i = 0; i < rolls.length; i++){\\n            sumOfRolls += rolls[i];\\n        }\\n        \\n        int diff = target - sumOfRolls;\\n        int divisor = diff / n;\\n        int leftOver = diff % n;\\n        \\n        if (divisor == 0 || diff < 0 || n * 6 < target - sumOfRolls){\\n            return new int[] {};\\n        }\\n        \\n        int[] res = new int[n];\\n        \\n        for (int i = 0; i < res.length; i++){\\n            res[i] = divisor;\\n\\t\\t\\tif (leftOver > 0){\\n\\t\\t\\t\\tres[i]++;\\n\\t\\t\\t\\tleftOver--;\\n\\t\\t\\t}\\n        }\\n    \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481351,
                "title": "python",
                "content": "Spagetti Code\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sum_of_numbers = mean*(m+n)\\n        s = sum_of_numbers-sum(rolls)\\n\\n        res = []\\n        if s < n or s > n*6:\\n            return []\\n        o = [1, 2, 3, 4, 5, 6]\\n       \\n        for _ in range(n):\\n            if s == n:\\n                pass\\n            j = 5\\n            t = s-o[j]\\n            while t < n-1 :\\n                if j < 0:\\n                    return []\\n                j -= 1\\n                t = s-o[j]\\n\\n            res.append(o[j])\\n            s = t\\n            n -= 1                      \\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sum_of_numbers = mean*(m+n)\\n        s = sum_of_numbers-sum(rolls)\\n\\n        res = []\\n        if s < n or s > n*6:\\n            return []\\n        o = [1, 2, 3, 4, 5, 6]\\n       \\n        for _ in range(n):\\n            if s == n:\\n                pass\\n            j = 5\\n            t = s-o[j]\\n            while t < n-1 :\\n                if j < 0:\\n                    return []\\n                j -= 1\\n                t = s-o[j]\\n\\n            res.append(o[j])\\n            s = t\\n            n -= 1                      \\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475859,
                "title": "python3-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        \\n        m=len(rolls)\\n        sm=sum(rolls)\\n        count=m+n\\n        \\n        rem_sum = count*mean-sm\\n        \\n        if rem_sum<n or rem_sum>n*6:\\n            return []\\n        \\n        c=rem_sum//n\\n        r=rem_sum % n\\n        \\n        ans=[c]*n\\n        ind=0\\n        \\n        while r:\\n            ans[ind]+=1\\n            ind+=1\\n            r-=1\\n        \\n        return ans\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        \\n        m=len(rolls)\\n        sm=sum(rolls)\\n        count=m+n\\n        \\n        rem_sum = count*mean-sm\\n        \\n        if rem_sum<n or rem_sum>n*6:\\n            return []\\n        \\n        c=rem_sum//n\\n        r=rem_sum % n\\n        \\n        ans=[c]*n\\n        ind=0\\n        \\n        while r:\\n            ans[ind]+=1\\n            ind+=1\\n            r-=1\\n        \\n        return ans\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473834,
                "title": "simple-maths-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) \\n    {\\n        int m=rolls.size();\\n        int mSum=accumulate(rolls.begin(),rolls.end(),0);\\n        int nSum=(n+m)*mean-mSum;\\n        double nmean=(double)nSum/n;\\n        vector<int> ans;\\n        if(nmean<1 || nmean>6) return ans;\\n        int nMean=nmean;\\n        ans.resize(n,0);\\n        for(int x=0; x<n; x++) ans[x]=nMean;\\n        int rem=nSum-n*nMean;\\n        int i=0;\\n        while(rem)\\n        {\\n            if(ans[i]+rem<=6) \\n            {\\n                ans[i]+=rem;\\n                rem=0;\\n            }\\n            else\\n            {\\n                int diff=6-ans[i];\\n                ans[i]=6;\\n                rem-=diff;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) \\n    {\\n        int m=rolls.size();\\n        int mSum=accumulate(rolls.begin(),rolls.end(),0);\\n        int nSum=(n+m)*mean-mSum;\\n        double nmean=(double)nSum/n;\\n        vector<int> ans;\\n        if(nmean<1 || nmean>6) return ans;\\n        int nMean=nmean;\\n        ans.resize(n,0);\\n        for(int x=0; x<n; x++) ans[x]=nMean;\\n        int rem=nSum-n*nMean;\\n        int i=0;\\n        while(rem)\\n        {\\n            if(ans[i]+rem<=6) \\n            {\\n                ans[i]+=rem;\\n                rem=0;\\n            }\\n            else\\n            {\\n                int diff=6-ans[i];\\n                ans[i]=6;\\n                rem-=diff;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454000,
                "title": "simple-greedy-technique-c-solution",
                "content": "# Intuition\\n//Come to point total = mean(n+m)-sum;\\n\\n//The question is here distribute total in n people and range[1,6];\\na)So first we distribute maximum as every person total/n to each:\\nb)The calculate the rest amount is left and then distribute to each person:\\n\\n//rember base so amount distribution happen:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m=rolls.size();\\n        int sum=0;\\n        for(int i=0;i<rolls.size();i++){\\n            sum+=rolls[i];\\n        }\\n  \\n        int total = mean*(m+n)-sum;\\n        if(total>6*n || total<1*n){\\n            return {};\\n        }\\n\\n        //distribut total into n peple:\\n        int minicost = total/n;\\n        vector<int> ans(n,minicost);\\n        int rest = total%n;\\n        for(int i=1;i<=rest;i++){\\n              ans[i]+=1;\\n        }\\n     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m=rolls.size();\\n        int sum=0;\\n        for(int i=0;i<rolls.size();i++){\\n            sum+=rolls[i];\\n        }\\n  \\n        int total = mean*(m+n)-sum;\\n        if(total>6*n || total<1*n){\\n            return {};\\n        }\\n\\n        //distribut total into n peple:\\n        int minicost = total/n;\\n        vector<int> ans(n,minicost);\\n        int rest = total%n;\\n        for(int i=1;i<=rest;i++){\\n              ans[i]+=1;\\n        }\\n     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433218,
                "title": "simple-math",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\\n        int[] result = new int[n];\\n        int sumSoFar = rolls.Sum();\\n        int totalN = rolls.Length + n;\\n        int remainingSum = (mean * totalN) - sumSoFar;\\n\\n        if((remainingSum < n) || (remainingSum > 6*n))\\n            return new int[0];\\n\\n        int equalShare = remainingSum/n;\\n        int remainder = remainingSum%n;\\n        Array.Fill(result, equalShare);\\n\\n        for(int i = 0; i < remainder; i++)\\n            result[i] += 1;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\\n        int[] result = new int[n];\\n        int sumSoFar = rolls.Sum();\\n        int totalN = rolls.Length + n;\\n        int remainingSum = (mean * totalN) - sumSoFar;\\n\\n        if((remainingSum < n) || (remainingSum > 6*n))\\n            return new int[0];\\n\\n        int equalShare = remainingSum/n;\\n        int remainder = remainingSum%n;\\n        Array.Fill(result, equalShare);\\n\\n        for(int i = 0; i < remainder; i++)\\n            result[i] += 1;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418333,
                "title": "python-3-solution",
                "content": "Check the condition if is self-explanatory. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sum_n = mean * (m+n) - sum(rolls)\\n\\n        if sum_n < 0 or not (1 <= sum_n / n <= 6):\\n            return list()\\n\\n        if sum_n % n == 0:\\n            return [sum_n // n] * n\\n\\n        else:\\n            k = sum_n % n\\n            ret = [sum_n // n] * n\\n            for i in range(k):\\n                ret[i] += 1\\n\\n            return ret\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sum_n = mean * (m+n) - sum(rolls)\\n\\n        if sum_n < 0 or not (1 <= sum_n / n <= 6):\\n            return list()\\n\\n        if sum_n % n == 0:\\n            return [sum_n // n] * n\\n\\n        else:\\n            k = sum_n % n\\n            ret = [sum_n // n] * n\\n            for i in range(k):\\n                ret[i] += 1\\n\\n            return ret\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415919,
                "title": "c-easy-explanation-100-working-array-find-missing-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere if we just consider the formula of mean (mean = sum of k no. / k) and consider that the dice number is always between 1-6 then this problem can be solved easily.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Here we first find the sum of the required answer vector by formula:-\\nsum = (mean*(n+rolls.size())) - (sum of evry umbers of rolls vector).\\n* Then we just check the condition, if ,sum is less than n OR sum is greater than n*6 , then just return the empty vector.\\n* Check if the sum is perfectly divisible by n then just add it to the vector.\\n* And if Sum%n is not zero then after assigning Sum/nto every element we will left with Sum%n.So assign 1 to Sum%n elements of new array .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        vector<int> v;\\n        long long s=0;\\n        for(int i=0;i<rolls.size();i++){\\n            s = s + rolls[i];\\n        }\\n        long long size = n+rolls.size();\\n        long long sum = ((mean*size) - s);\\n\\n       if(sum>6*n || sum<n){\\n           return {};\\n       }else\\n       if(sum%n==0){\\n           for(int i=0;i<n;i++){\\n               v.push_back(sum/n);\\n           }\\n       }else{\\n           // if missingSum%n is not zero then after assigning missingSum/nto every element     we will left with missingSum%n.So assign 1 to missingSum%n elements of new array .\\n           int remaind=sum%n;\\n            for(int i=0;i<n;i++){\\n                v.push_back(sum/n);      \\n            }\\n            for(int i=0;i<remaind;i++){\\n                v[i] = v[i] + 1;           \\n            }\\n       }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        vector<int> v;\\n        long long s=0;\\n        for(int i=0;i<rolls.size();i++){\\n            s = s + rolls[i];\\n        }\\n        long long size = n+rolls.size();\\n        long long sum = ((mean*size) - s);\\n\\n       if(sum>6*n || sum<n){\\n           return {};\\n       }else\\n       if(sum%n==0){\\n           for(int i=0;i<n;i++){\\n               v.push_back(sum/n);\\n           }\\n       }else{\\n           // if missingSum%n is not zero then after assigning missingSum/nto every element     we will left with missingSum%n.So assign 1 to missingSum%n elements of new array .\\n           int remaind=sum%n;\\n            for(int i=0;i<n;i++){\\n                v.push_back(sum/n);      \\n            }\\n            for(int i=0;i<remaind;i++){\\n                v[i] = v[i] + 1;           \\n            }\\n       }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395497,
                "title": "easy-greedy-python-solution-beats-91-3-o-1",
                "content": "# Intuition\\nGet the n array\\'s total value and base number for each element. \\ngive as much as we can to the first few numbers as long as the total of n array not meet to the total value\\nHere, in order to get O(1). I just calulate how many elements need to be increased so that I can just combine them with the base elements together\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = sum(rolls)\\n        total_l = len(rolls)+n\\n        total = total_l*mean-total\\n        if total>6*n or total<n:\\n            return []\\n        base = total//n\\n        total -= base*n\\n        if base==6:\\n            res = [base]*n\\n        else:\\n            n1 = total//(6-base)\\n            res=[6]*n1+[total%(6-base)+base]+[base]*(n-n1-1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = sum(rolls)\\n        total_l = len(rolls)+n\\n        total = total_l*mean-total\\n        if total>6*n or total<n:\\n            return []\\n        base = total//n\\n        total -= base*n\\n        if base==6:\\n            res = [base]*n\\n        else:\\n            n1 = total//(6-base)\\n            res=[6]*n1+[total%(6-base)+base]+[base]*(n-n1-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395376,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int val = (rolls.size() + n) * mean - accumulate(rolls.begin(), rolls.end(), 0);\\n        if(val < n || val > 6 * n) return {};\\n        vector<int> ans(n);\\n        int k = val / n, l = val % n;\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = k + (i < l);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    var val int = (len(rolls) + n) * mean\\n    for _, r := range rolls {val -= r} \\n    if val < n || val > 6 * n {return []int{}}\\n    ans := make([]int, n)\\n    var k, l int = val / n, val % n\\n    for i := 0; i < n; i++ {\\n        ans[i] = k\\n        if i < l {ans[i]++}\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int val = (rolls.size() + n) * mean - accumulate(rolls.begin(), rolls.end(), 0);\\n        if(val < n || val > 6 * n) return {};\\n        vector<int> ans(n);\\n        int k = val / n, l = val % n;\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = k + (i < l);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    var val int = (len(rolls) + n) * mean\\n    for _, r := range rolls {val -= r} \\n    if val < n || val > 6 * n {return []int{}}\\n    ans := make([]int, n)\\n    var k, l int = val / n, val % n\\n    for i := 0; i < n; i++ {\\n        ans[i] = k\\n        if i < l {ans[i]++}\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358987,
                "title": "home-approach-fast-solution-cpp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        vector<int>ans;\\n        int m = rolls.size();\\n        int l = mean * (n+ m);\\n         int sum = 0;\\n         for(int i=0;i<rolls.size();i++){\\n             sum += rolls[i];\\n         }\\n\\n         int k = l-sum;\\n        //  cout<<k;\\n\\n         int p = k/n;\\n         float q = k/(float)n;\\n         cout<<q;\\n         if(q>6 || p<1)return ans;\\n         int rem = k%n;\\n\\n         for(int i=0;i<n;i++){\\n             ans.push_back(p);\\n         }\\n        int i=0;\\n         while(rem!=0 && i<n){\\n             while(ans[i] == 6)i++;\\n             ans[i]+=1;\\n            rem-=1;            \\n         }\\n         return ans;\\n    }\\n};\\n```\\nguys upvote it thats all :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        vector<int>ans;\\n        int m = rolls.size();\\n        int l = mean * (n+ m);\\n         int sum = 0;\\n         for(int i=0;i<rolls.size();i++){\\n             sum += rolls[i];\\n         }\\n\\n         int k = l-sum;\\n        //  cout<<k;\\n\\n         int p = k/n;\\n         float q = k/(float)n;\\n         cout<<q;\\n         if(q>6 || p<1)return ans;\\n         int rem = k%n;\\n\\n         for(int i=0;i<n;i++){\\n             ans.push_back(p);\\n         }\\n        int i=0;\\n         while(rem!=0 && i<n){\\n             while(ans[i] == 6)i++;\\n             ans[i]+=1;\\n            rem-=1;            \\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3332769,
                "title": "java-fast-easy",
                "content": "# Intuition\\nExplanation within inline comments\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n\\n        \\n        //calculate current total in rolls\\n        int total = 0;  \\n        for(int count = 0; count < rolls.length; count++)\\n            total += rolls[count]; \\n\\n        \\n        //calculate how much we have to add to the roll\\'s total to get to the target mean \\n            //logic: \\n                //(total + x)/(rolls.length + n) = mean \\n                //then simply isolate for x and use that expression as the number \"quantity\" to be added to the total\\n        int leftOver = (mean * (rolls.length + n)) - total; \\n\\n        //now we MUST place 1 in every position of subarray to be added (that is, each added dice roll must be at\\n        // least one so let\\'s account for that fact now by subtracting n from leftOver)\\n        leftOver -= n; \\n\\n        //create a new array of size n to represent the new rolls to be added \\n        int result[] = new int[n]; \\n\\n        //now start adding the leftOver in the new array adding at max 5 at anyone position and at minimum adding 0\\n        for(int count = 0; count < result.length; count++) {\\n\\n            //add the minimum dice roll accounted for earlier at every array position\\n            result[count] += 1; \\n\\n            if(leftOver != 0) {\\n                //add leftOver\\'s remainder in 5 to the current array position\\n                //if remainder in 5 == 0 \\n                if(leftOver % 5 == 0){\\n                    //then add 5 to the current position \\n                    result[count] += 5; \\n                    \\n                    //decrement leftOver by 5 \\n                    leftOver -= 5; \\n                }\\n                //otherwise remainder is between [1, 4] inclusively \\n                else {\\n                    //in that case we just add the remainder calculated to the current position \\n                    result[count] += (leftOver % 5); \\n\\n                    //and we decrement leftOver by remainder in 5 \\n                    leftOver -= (leftOver % 5); \\n\\n                }\\n        \\n            }\\n\\n        }\\n\\n        //deal with the case in which we weren\\'t able to reduce leftOver to zero \\n            //this occurs when the number of added rolls is not sufficient to increase the average to the target \\n            //average even when every newly added roll == 6 \\n\\n        if(leftOver != 0) {\\n            //return an empty array\\n            return new int[0];\\n        }\\n\\n        return result; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n\\n        \\n        //calculate current total in rolls\\n        int total = 0;  \\n        for(int count = 0; count < rolls.length; count++)\\n            total += rolls[count]; \\n\\n        \\n        //calculate how much we have to add to the roll\\'s total to get to the target mean \\n            //logic: \\n                //(total + x)/(rolls.length + n) = mean \\n                //then simply isolate for x and use that expression as the number \"quantity\" to be added to the total\\n        int leftOver = (mean * (rolls.length + n)) - total; \\n\\n        //now we MUST place 1 in every position of subarray to be added (that is, each added dice roll must be at\\n        // least one so let\\'s account for that fact now by subtracting n from leftOver)\\n        leftOver -= n; \\n\\n        //create a new array of size n to represent the new rolls to be added \\n        int result[] = new int[n]; \\n\\n        //now start adding the leftOver in the new array adding at max 5 at anyone position and at minimum adding 0\\n        for(int count = 0; count < result.length; count++) {\\n\\n            //add the minimum dice roll accounted for earlier at every array position\\n            result[count] += 1; \\n\\n            if(leftOver != 0) {\\n                //add leftOver\\'s remainder in 5 to the current array position\\n                //if remainder in 5 == 0 \\n                if(leftOver % 5 == 0){\\n                    //then add 5 to the current position \\n                    result[count] += 5; \\n                    \\n                    //decrement leftOver by 5 \\n                    leftOver -= 5; \\n                }\\n                //otherwise remainder is between [1, 4] inclusively \\n                else {\\n                    //in that case we just add the remainder calculated to the current position \\n                    result[count] += (leftOver % 5); \\n\\n                    //and we decrement leftOver by remainder in 5 \\n                    leftOver -= (leftOver % 5); \\n\\n                }\\n        \\n            }\\n\\n        }\\n\\n        //deal with the case in which we weren\\'t able to reduce leftOver to zero \\n            //this occurs when the number of added rolls is not sufficient to increase the average to the target \\n            //average even when every newly added roll == 6 \\n\\n        if(leftOver != 0) {\\n            //return an empty array\\n            return new int[0];\\n        }\\n\\n        return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287876,
                "title": "c-summation-no-dividing",
                "content": "```\\nclass Solution {\\npublic:\\n    // summation = easy\\n    // 6 * 10^5 is not overflow with int\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        vector<int> ans(n, 1);\\n        int total = mean * (rolls.size() + n);\\n        if (total < sum + ans.size()) return {};\\n        if (total > sum + 6 * ans.size()) return {};\\n        total -= sum + ans.size();\\n        for (int i = 0; i < ans.size() && total > 0; ++i){\\n            total -= 5;\\n            ans[i] = 6;\\n            if (total < 0) ans[i] += total, total = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // summation = easy\\n    // 6 * 10^5 is not overflow with int\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        vector<int> ans(n, 1);\\n        int total = mean * (rolls.size() + n);\\n        if (total < sum + ans.size()) return {};\\n        if (total > sum + 6 * ans.size()) return {};\\n        total -= sum + ans.size();\\n        for (int i = 0; i < ans.size() && total > 0; ++i){\\n            total -= 5;\\n            ans[i] = 6;\\n            if (total < 0) ans[i] += total, total = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284981,
                "title": "python-solution-easy",
                "content": "\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        \\n        m = len(rolls)\\n        sum_m = sum(rolls)\\n        sum_n = mean*(m+n) - sum_m\\n        if (sum_n) > n*6 or sum_n<=0:\\n            return []\\n        else:\\n            ans = []\\n            avg = math.floor(sum_n/n)\\n            if avg == 0:\\n                return []\\n            for i in range(n-1):\\n                ans.append(avg)\\n            curr_s = sum(ans)\\n            rem = sum_n - curr_s\\n\\n            if rem>6:\\n                how_great = rem - avg\\n                ans.append(avg)\\n                for i in range(n-1,n-how_great-1,-1):\\n                    ans[i] += 1\\n            else:\\n                ans.append(rem)\\n            return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        \\n        m = len(rolls)\\n        sum_m = sum(rolls)\\n        sum_n = mean*(m+n) - sum_m\\n        if (sum_n) > n*6 or sum_n<=0:\\n            return []\\n        else:\\n            ans = []\\n            avg = math.floor(sum_n/n)\\n            if avg == 0:\\n                return []\\n            for i in range(n-1):\\n                ans.append(avg)\\n            curr_s = sum(ans)\\n            rem = sum_n - curr_s\\n\\n            if rem>6:\\n                how_great = rem - avg\\n                ans.append(avg)\\n                for i in range(n-1,n-how_great-1,-1):\\n                    ans[i] += 1\\n            else:\\n                ans.append(rem)\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280017,
                "title": "java-hopefully-easy-i-dunno",
                "content": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int total = 0;\\n        int[] res = new int[n];\\n        for(int i : rolls){\\n            total+=i;\\n        }\\n        if(total+n > (rolls.length+n) * mean){\\n            return new int[]{};\\n        }\\n        // all array times mean \\n        // and assuming min 1 for each roll so (total+n)\\n        int remaining =  ((rolls.length+n) * mean) - (total + n);\\n        \\n        // if there are 3 places left and remaining after putting 1s is 16\\n        // 16/3 = like 5.12.. so it is not possible to place any way\\n        if((double) remaining / n > 5.0) return new int[]{};\\n        \\n        // calculated 1\\'s above before even filling the array\\n        Arrays.fill(res,1);\\n        int j= 0;\\n\\t\\t\\n        while(remaining >0){\\n            int inc = Math.min(5, remaining);\\n            res[j] +=inc;\\n            remaining -= inc;\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int total = 0;\\n        int[] res = new int[n];\\n        for(int i : rolls){\\n            total+=i;\\n        }\\n        if(total+n > (rolls.length+n) * mean){\\n            return new int[]{};\\n        }\\n        // all array times mean \\n        // and assuming min 1 for each roll so (total+n)\\n        int remaining =  ((rolls.length+n) * mean) - (total + n);\\n        \\n        // if there are 3 places left and remaining after putting 1s is 16\\n        // 16/3 = like 5.12.. so it is not possible to place any way\\n        if((double) remaining / n > 5.0) return new int[]{};\\n        \\n        // calculated 1\\'s above before even filling the array\\n        Arrays.fill(res,1);\\n        int j= 0;\\n\\t\\t\\n        while(remaining >0){\\n            int inc = Math.min(5, remaining);\\n            res[j] +=inc;\\n            remaining -= inc;\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274478,
                "title": "simple-c-solution-using-maths",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        // sum+x = (n+m)*mean;\\n        // x = ((n+m)*mean)-sum;\\n        int sum = 0;\\n        int m = rolls.size();\\n        sum = accumulate(rolls.begin() , rolls.end() , 0);\\n        int x = ((n+m)*mean)-sum;\\n        vector<int> arr(n , 1);\\n        x -= n;\\n        if(x<0){\\n            arr.resize(0);\\n            return arr;\\n        }\\n        \\n        \\n\\n        for(int i=0 ; i<n ; i++){\\n            if(x>=5){\\n                arr[i] += 5;\\n                x -= 5;\\n            }\\n            else{\\n                arr[i] += x;\\n                x = 0;\\n            }\\n            if(x==0){\\n                break;\\n            }\\n        }\\n\\n        int sum1 = sum;\\n        int sum2 = 0;\\n\\n        sum2 = accumulate(arr.begin()  , arr.end() , 0);\\n\\n        if(sum1+sum2!=(n+m)*mean){\\n            arr.resize(0);\\n        }\\n\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        // sum+x = (n+m)*mean;\\n        // x = ((n+m)*mean)-sum;\\n        int sum = 0;\\n        int m = rolls.size();\\n        sum = accumulate(rolls.begin() , rolls.end() , 0);\\n        int x = ((n+m)*mean)-sum;\\n        vector<int> arr(n , 1);\\n        x -= n;\\n        if(x<0){\\n            arr.resize(0);\\n            return arr;\\n        }\\n        \\n        \\n\\n        for(int i=0 ; i<n ; i++){\\n            if(x>=5){\\n                arr[i] += 5;\\n                x -= 5;\\n            }\\n            else{\\n                arr[i] += x;\\n                x = 0;\\n            }\\n            if(x==0){\\n                break;\\n            }\\n        }\\n\\n        int sum1 = sum;\\n        int sum2 = 0;\\n\\n        sum2 = accumulate(arr.begin()  , arr.end() , 0);\\n\\n        if(sum1+sum2!=(n+m)*mean){\\n            arr.resize(0);\\n        }\\n\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273128,
                "title": "simplest-and-easily-understood-able",
                "content": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int total = mean*(n+rolls.length);\\n        int present = 0;\\n        for(int i:rolls) present+=i;\\n        total -= present;\\n        int val = 0,data = 0,index = 0;\\n        for(int i=1;i<=6;i++) if(total/i>=n) { val = i;data=total-i*n; }\\n        if(val==0||(val==6&&data!=0)) return new int[]{};\\n        int output[] = new int[n];\\n        for(int i=0;i<n;i++) output[i] = val;\\n        while(data!=0) { output[index]+=1; index++; data--; index = index%n; }\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int total = mean*(n+rolls.length);\\n        int present = 0;\\n        for(int i:rolls) present+=i;\\n        total -= present;\\n        int val = 0,data = 0,index = 0;\\n        for(int i=1;i<=6;i++) if(total/i>=n) { val = i;data=total-i*n; }",
                "codeTag": "Java"
            },
            {
                "id": 3246309,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn missing_rolls(rolls: Vec<i32>, mean: i32, n: i32) -> Vec<i32> {\\n        let size = rolls.len();\\n        let sum = rolls.iter().sum::<i32>();\\n        let missing_sum = mean * (n + size as i32) - sum;\\n        if missing_sum < n || missing_sum > 6 * n {\\n            return vec![];\\n        }\\n        let rem = missing_sum % n;\\n        let mut ans = vec![missing_sum / n; n as usize];\\n        for i in 0..rem {\\n            ans[i as usize] += 1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn missing_rolls(rolls: Vec<i32>, mean: i32, n: i32) -> Vec<i32> {\\n        let size = rolls.len();\\n        let sum = rolls.iter().sum::<i32>();\\n        let missing_sum = mean * (n + size as i32) - sum;\\n        if missing_sum < n || missing_sum > 6 * n {\\n            return vec![];\\n        }\\n        let rem = missing_sum % n;\\n        let mut ans = vec![missing_sum / n; n as usize];\\n        for i in 0..rem {\\n            ans[i as usize] += 1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3210633,
                "title": "js-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} rolls\\n * @param {number} mean\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar missingRolls = function(rolls, mean, n) {\\n    const len = rolls.length;\\n\\n    let missVal = (len + n) * mean - rolls.reduce((prev, curr)=>prev+curr);\\n    let divender = Math.floor(missVal / n);\\n    let remainder = missVal % n;\\n    if ((divender >= 6 && remainder > 0) || divender < 1 || remainder < 0) return [];\\n    const res = [];\\n    while(remainder-- > 0){\\n        if(divender + 1 > 6) return [];\\n        res.push(divender + 1);\\n        n--;\\n    }\\n    while(n-- > 0){\\n        if(divender > 6) return [];\\n        res.push(divender);\\n    }\\n    return res; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} rolls\\n * @param {number} mean\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar missingRolls = function(rolls, mean, n) {\\n    const len = rolls.length;\\n\\n    let missVal = (len + n) * mean - rolls.reduce((prev, curr)=>prev+curr);\\n    let divender = Math.floor(missVal / n);\\n    let remainder = missVal % n;\\n    if ((divender >= 6 && remainder > 0) || divender < 1 || remainder < 0) return [];\\n    const res = [];\\n    while(remainder-- > 0){\\n        if(divender + 1 > 6) return [];\\n        res.push(divender + 1);\\n        n--;\\n    }\\n    while(n-- > 0){\\n        if(divender > 6) return [];\\n        res.push(divender);\\n    }\\n    return res; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209597,
                "title": "o-m-python-math-based-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the mean for n rolls\\n2. Assume n only consists of floor(n mean) rolls\\n3. Make up for the difference by replacing enough rolls with mean+1\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        total_sum = mean*(m+n)\\n        nsum = total_sum - sum(rolls)\\n        nmean = nsum/n\\n        \\n        # If n mean is more than 6, no amount of max roll(6) can make up for the mean\\n        # If n mean is less than 1, no amount of min roll(1) can make up for the mean \\n        if nmean > 6 or nmean < 1: return []\\n        \\n        fnmean = nsum//n\\n        fnsum = fnmean*n\\n        \\n        # Amount left if all of n were floored mean of n\\n        left = nsum - fnsum\\n       \\n        #Make up for the discrepency by topping up [left] amount with +1\\n        return left*[fnmean+1] + (n-left)*[fnmean]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        total_sum = mean*(m+n)\\n        nsum = total_sum - sum(rolls)\\n        nmean = nsum/n\\n        \\n        # If n mean is more than 6, no amount of max roll(6) can make up for the mean\\n        # If n mean is less than 1, no amount of min roll(1) can make up for the mean \\n        if nmean > 6 or nmean < 1: return []\\n        \\n        fnmean = nsum//n\\n        fnsum = fnmean*n\\n        \\n        # Amount left if all of n were floored mean of n\\n        left = nsum - fnsum\\n       \\n        #Make up for the discrepency by topping up [left] amount with +1\\n        return left*[fnmean+1] + (n-left)*[fnmean]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144637,
                "title": "greedy-easy-python-solution",
                "content": "# Approach\\n1) The sum of n missing rolls = mean * (m + n) - sum(arr_m)\\n2) Since a single roll is up to 6, we can go greedy picking the largest num first\\n\\n# Complexity\\n- Time complexity:\\nO(N + M)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sum_m = mean * (m + n) - sum(rolls)\\n        \\n        if sum_m < n or sum_m / n > 6:\\n            return []\\n\\n        res = []\\n        for i in range(n):\\n            num = min(6, sum_m - n + i + 1)\\n            res.append(num)\\n            sum_m -= num\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sum_m = mean * (m + n) - sum(rolls)\\n        \\n        if sum_m < n or sum_m / n > 6:\\n            return []\\n\\n        res = []\\n        for i in range(n):\\n            num = min(6, sum_m - n + i + 1)\\n            res.append(num)\\n            sum_m -= num\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140262,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    # def check(self,target,length):\\n    #     #this is a function to check wheather I can build an array of length is \"length\", and sum up to target, and array[i] between 1 and 6\\n    #     if(target < length or target > 6*length):\\n    #         return False\\n    #     return True \\n    # def find(self,target,length):\\n    #     #find a possible array of length \"length\" and sum up to target\\n    #     #base case\\n    #     if(length == 1):\\n    #         return [target]\\n    #     ##########\\n    #     head = -1\\n    #     for i in range(1,7):\\n    #         if(not((target-i)<(length-1) or (target-i)>(6*(length-1)))):\\n    #             head = i\\n    #             break\\n    #     return [head]+self.find(target-head,length-1)\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        #mean*(len(rolls)+n) = sum(rolls) + sum(res) //len(res) = n\\n        #the goal is to find an array of length n, which sum to mean*(len(rolls)+n) - sum(rolls)\\n        target = mean*(len(rolls)+n) - sum(rolls)\\n        if(target < n or target > n*6):\\n            return []\\n        #else there must be an answer\\n        ###length == n, sum == target,res[i] between 1 and 6\\n        \\n        res = [0]*n\\n        #finding res[i]\\n        for i in range(n):\\n            #can I set res[i] as j?\\n            for j in range(1,7):\\n                if(not(target-j < n-1-i or target-j > 6*(n-1-i))):\\n                    res[i] = j\\n                    target -= j\\n                    break\\n        return res\\n    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # def check(self,target,length):\\n    #     #this is a function to check wheather I can build an array of length is \"length\", and sum up to target, and array[i] between 1 and 6\\n    #     if(target < length or target > 6*length):\\n    #         return False\\n    #     return True \\n    # def find(self,target,length):\\n    #     #find a possible array of length \"length\" and sum up to target\\n    #     #base case\\n    #     if(length == 1):\\n    #         return [target]\\n    #     ##########\\n    #     head = -1\\n    #     for i in range(1,7):\\n    #         if(not((target-i)<(length-1) or (target-i)>(6*(length-1)))):\\n    #             head = i\\n    #             break\\n    #     return [head]+self.find(target-head,length-1)\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        #mean*(len(rolls)+n) = sum(rolls) + sum(res) //len(res) = n\\n        #the goal is to find an array of length n, which sum to mean*(len(rolls)+n) - sum(rolls)\\n        target = mean*(len(rolls)+n) - sum(rolls)\\n        if(target < n or target > n*6):\\n            return []\\n        #else there must be an answer\\n        ###length == n, sum == target,res[i] between 1 and 6\\n        \\n        res = [0]*n\\n        #finding res[i]\\n        for i in range(n):\\n            #can I set res[i] as j?\\n            for j in range(1,7):\\n                if(not(target-j < n-1-i or target-j > 6*(n-1-i))):\\n                    res[i] = j\\n                    target -= j\\n                    break\\n        return res\\n    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140066,
                "title": "time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        #mean*(len(rolls)+n) = sum(rolls) + sum(res) //len(res) = n\\n        #the goal is to find an array of length n, which sum to mean*(len(rolls)+n) - sum(rolls)\\n        target = mean*(len(rolls)+n) - sum(rolls)\\n        if(target < n or target > n*6):\\n            return []\\n        #else there must be an answer\\n        ###length == n, sum == target,res[i] between 1 and 6\\n        res = []\\n        for i in range(n):\\n            #decide res[i]\\n            for j in range(1,7):\\n                #can I choose j to be res[i]?\\n                if( (target-j)>=n-i-1 and (target-j)<=(n-i-1)*6 ):\\n                    res.append(j)\\n                    target -= j\\n                    break\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        #mean*(len(rolls)+n) = sum(rolls) + sum(res) //len(res) = n\\n        #the goal is to find an array of length n, which sum to mean*(len(rolls)+n) - sum(rolls)\\n        target = mean*(len(rolls)+n) - sum(rolls)\\n        if(target < n or target > n*6):\\n            return []\\n        #else there must be an answer\\n        ###length == n, sum == target,res[i] between 1 and 6\\n        res = []\\n        for i in range(n):\\n            #decide res[i]\\n            for j in range(1,7):\\n                #can I choose j to be res[i]?\\n                if( (target-j)>=n-i-1 and (target-j)<=(n-i-1)*6 ):\\n                    res.append(j)\\n                    target -= j\\n                    break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124465,
                "title": "intuitive-approach-using-simple-math",
                "content": "# Intuition\\nSolve the problem using basic math knowledge.\\nMean = sum(array1) + sum(array2)/array1.Length + array2.Length\\n\\n# Approach\\nWe know that mean = sum(nArr) + sum(mArr) / (nArr.Length + mArr.Length)\\nTherefore to get the sum(nArr) we just make it the subject of the above formula => (nArr.Length + mArr.Length) * mean - sum(mArr)\\nThen to get the values of nArr, we take the sum(nArr)/nArr.Length continuously while subtracting the value from it\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\\n        int sumM = rolls.Sum();\\n        int sumN =0;\\n        int totalLength = rolls.Length + n;\\n\\n        sumN = (totalLength * mean) - sumM;\\n        if(((decimal)sumN/n) > 6 || (sumN/n) < 1)\\n            return new int[]{};\\n        \\n        int[] nArr = new int[n];\\n        int nLength =n;\\n        for(int i=0; i<n; i++){\\n            nArr[i] = (int)sumN/nLength;\\n            sumN -= nArr[i];\\n            nLength -=1;\\n        }\\n        return nArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\\n        int sumM = rolls.Sum();\\n        int sumN =0;\\n        int totalLength = rolls.Length + n;\\n\\n        sumN = (totalLength * mean) - sumM;\\n        if(((decimal)sumN/n) > 6 || (sumN/n) < 1)\\n            return new int[]{};\\n        \\n        int[] nArr = new int[n];\\n        int nLength =n;\\n        for(int i=0; i<n; i++){\\n            nArr[i] = (int)sumN/nLength;\\n            sumN -= nArr[i];\\n            nLength -=1;\\n        }\\n        return nArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101859,
                "title": "simple-go-solution-with-clear-explanation",
                "content": "# Approach\\nFirst we find out the sum we need in order to achieve the given mean.\\n\\nSuppose;\\n```\\nGiven observations = rolls = len(rolls) = 3, sum(rolls) = 7\\nMissing observations = 3\\nMean = 4\\nTotal observations = 6\\n```\\n\\nNow; normally we calculate mean by;\\n\\n    sum(observations) / len(observations) \\n\\nWe use the same formula and apply here;\\n\\n    (sum(rolls) + sum(missing_rolls)) / observations_total = mean\\n\\ni.e \\n\\n    7 + sum(missing_rolls) / 6 = 4\\n\\n    sum(missing_rolls) = 6*4 - 7\\n    sum(missing_rolls) = 17\\n\\nnow with this we calculate the mean;\\n\\n    mean = sum(missing_rolls) / len(missing_rolls)\\n\\n\\nNow do some basic checks for checking the boundary of the rolls;\\n    \\n    if (mean) < 1 && mean > 6; return []\\n\\nafter these checks, we now just loop over the required elements array and keep on adding the ceiling of the mean;\\n\\n```\\nrequiredElements := make([]int, n)\\n\\nfor i, _ := range requiredElements {\\n    ceilMean := ceil(mean)\\n    requiredElements[i] = ceilMean\\n\\n    // we subtract the ceilMean from the required sum\\n    // and decrease the number of elements we require\\n    \\n    missing_rolls_sum -= ceilMean\\n    n-=1\\n    mean = missing_rolls_sum / n\\n} \\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    requiredSum := mean * (len(rolls) + n) - sum(rolls)\\n    var requiredMean float64 = float64(requiredSum) / float64(n)\\n\\n    if requiredMean > 6 || requiredMean < 1 {\\n        return []int{}\\n    }\\n\\n    requiredElements := make([]int, n)\\n\\n    for i, _ := range requiredElements {\\n        ceiledMean := int(math.Ceil(requiredMean))\\n        requiredElements[i] = ceiledMean\\n\\n        requiredSum -= ceiledMean\\n        n -= 1\\n        requiredMean = float64(requiredSum) / float64(n)\\n    }    \\n\\n    return requiredElements\\n}\\n\\nfunc sum(rolls []int) (result int) {\\n    for _, r := range rolls {\\n        result += r\\n    }\\n\\n    return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nGiven observations = rolls = len(rolls) = 3, sum(rolls) = 7\\nMissing observations = 3\\nMean = 4\\nTotal observations = 6\\n```\n```\\nrequiredElements := make([]int, n)\\n\\nfor i, _ := range requiredElements {\\n    ceilMean := ceil(mean)\\n    requiredElements[i] = ceilMean\\n\\n    // we subtract the ceilMean from the required sum\\n    // and decrease the number of elements we require\\n    \\n    missing_rolls_sum -= ceilMean\\n    n-=1\\n    mean = missing_rolls_sum / n\\n} \\n```\n```\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n    requiredSum := mean * (len(rolls) + n) - sum(rolls)\\n    var requiredMean float64 = float64(requiredSum) / float64(n)\\n\\n    if requiredMean > 6 || requiredMean < 1 {\\n        return []int{}\\n    }\\n\\n    requiredElements := make([]int, n)\\n\\n    for i, _ := range requiredElements {\\n        ceiledMean := int(math.Ceil(requiredMean))\\n        requiredElements[i] = ceiledMean\\n\\n        requiredSum -= ceiledMean\\n        n -= 1\\n        requiredMean = float64(requiredSum) / float64(n)\\n    }    \\n\\n    return requiredElements\\n}\\n\\nfunc sum(rolls []int) (result int) {\\n    for _, r := range rolls {\\n        result += r\\n    }\\n\\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083170,
                "title": "java-simple",
                "content": "# Intuition and approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can assign a minimum 1 to each element in array of size n. Find the total value we need to allocate to this array by using the mean and sum of elements in given array and calculating it as the ```\\ndiff = mean * (n + m) - sum(rolls)```. If this diff exceeds n * 6 or is less than n, we can\\'t create the required array, so return empty array. Otherwise, allocate 1 at each index in the answer array and distribute the remaining value as well.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N + M)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int diff = mean * (n + rolls.length);\\n        for(int i : rolls)\\n            diff -= i;\\n        if(diff <= 0)\\n        return new int[]{};\\n\\n        System.out.println(diff);\\n\\n        int avg = 1;\\n        if(diff > n * 6 || diff < n)\\n        return new int[]{};\\n\\n        diff -= n;\\n\\n        int[] ans = new int[n];\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = avg;\\n            if(diff > 0) {\\n                int val = Math.min(6 - ans[i], diff);\\n                diff -= val;\\n                ans[i] += val;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ndiff = mean * (n + m) - sum(rolls)```\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int diff = mean * (n + rolls.length);\\n        for(int i : rolls)\\n            diff -= i;\\n        if(diff <= 0)\\n        return new int[]{};\\n\\n        System.out.println(diff);\\n\\n        int avg = 1;\\n        if(diff > n * 6 || diff < n)\\n        return new int[]{};\\n\\n        diff -= n;\\n\\n        int[] ans = new int[n];\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = avg;\\n            if(diff > 0) {\\n                int val = Math.min(6 - ans[i], diff);\\n                diff -= val;\\n                ans[i] += val;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057842,
                "title": "find-missing-observations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n\\n        int len=rolls.length;\\n        int total=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            total=total+rolls[i];\\n        }\\n        int num=((len+n)*mean) -total; //9\\n        //int F=n;\\n        if(num>(6*n) || num<(n))\\n        {\\n            int res[]={};\\n            return res;\\n        }\\n        \\n        else\\n        { \\n            int res[]=new int [n];\\n            for(int m=0,F=n;F >= 1;F--)\\n            {\\n                for(int k=6;k>=1;k--)\\n                {\\n                    if((num-k)>=(F-1))\\n                    {\\n                        res[m]=k;\\n                        //System.out.println(res[m]);\\n                        m++;\\n                        num=num-k;\\n                        break;\\n                        //n--;\\n                    }\\n                   \\n                }\\n            \\n            }\\n            return res;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n\\n        int len=rolls.length;\\n        int total=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            total=total+rolls[i];\\n        }\\n        int num=((len+n)*mean) -total; //9\\n        //int F=n;\\n        if(num>(6*n) || num<(n))\\n        {\\n            int res[]={};\\n            return res;\\n        }\\n        \\n        else\\n        { \\n            int res[]=new int [n];\\n            for(int m=0,F=n;F >= 1;F--)\\n            {\\n                for(int k=6;k>=1;k--)\\n                {\\n                    if((num-k)>=(F-1))\\n                    {\\n                        res[m]=k;\\n                        //System.out.println(res[m]);\\n                        m++;\\n                        num=num-k;\\n                        break;\\n                        //n--;\\n                    }\\n                   \\n                }\\n            \\n            }\\n            return res;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057841,
                "title": "find-missing-observations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n\\n        int len=rolls.length;\\n        int total=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            total=total+rolls[i];\\n        }\\n        int num=((len+n)*mean) -total; //9\\n        //int F=n;\\n        if(num>(6*n) || num<(n))\\n        {\\n            int res[]={};\\n            return res;\\n        }\\n        \\n        else\\n        { \\n            int res[]=new int [n];\\n            for(int m=0,F=n;F >= 1;F--)\\n            {\\n                for(int k=6;k>=1;k--)\\n                {\\n                    if((num-k)>=(F-1))\\n                    {\\n                        res[m]=k;\\n                        //System.out.println(res[m]);\\n                        m++;\\n                        num=num-k;\\n                        break;\\n                        //n--;\\n                    }\\n                   \\n                }\\n            \\n            }\\n            return res;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n\\n        int len=rolls.length;\\n        int total=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            total=total+rolls[i];\\n        }\\n        int num=((len+n)*mean) -total; //9\\n        //int F=n;\\n        if(num>(6*n) || num<(n))\\n        {\\n            int res[]={};\\n            return res;\\n        }\\n        \\n        else\\n        { \\n            int res[]=new int [n];\\n            for(int m=0,F=n;F >= 1;F--)\\n            {\\n                for(int k=6;k>=1;k--)\\n                {\\n                    if((num-k)>=(F-1))\\n                    {\\n                        res[m]=k;\\n                        //System.out.println(res[m]);\\n                        m++;\\n                        num=num-k;\\n                        break;\\n                        //n--;\\n                    }\\n                   \\n                }\\n            \\n            }\\n            return res;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055748,
                "title": "python-greedy-o-n-m",
                "content": "# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        total = mean*(n+m) - sum(rolls)\\n        if total < n or total > 6*n: return []\\n        res = [1]*n\\n        total -= n\\n        i = 0\\n        while total > 0:\\n            res[i] += min(5, total)\\n            total -= min(5, total)\\n            i += 1\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        total = mean*(n+m) - sum(rolls)\\n        if total < n or total > 6*n: return []\\n        res = [1]*n\\n        total -= n\\n        i = 0\\n        while total > 0:\\n            res[i] += min(5, total)\\n            total -= min(5, total)\\n            i += 1\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030405,
                "title": "easy-c-solution-beats-95-o-n-time-complexity",
                "content": "# Approach\\n1) Initialize variable sum as 0 and add the elements of the vector rolls in the sum using for loop.\\n2) Initialize variable rem to what should be thetotal sum of the missing elements\\n3) If the rem is less than no of elements that mean a missing element should be less than 1 which is not possible and if rem is greater than 6 * no of elements that means a missing element should be greater than 6 which is not possible so in both cases return empty vector\\n4) Next declare a variable avg to be equal to the amount remaininf by no of missing elements and change rem to rem modulo n\\n5) Then initialize a vector res to be of size n and have value avg\\n6) Then apply for loop and increment res[i]\\n7) Then return res\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=0;\\n        for(int i=0;i<rolls.size();i++){\\n            sum+=rolls[i];\\n        }\\n        int rem = (rolls.size() + n) * mean - sum;\\n        if(rem<n || rem>n * 6) return {};\\n        \\n        int avg= rem/n;\\n        rem =rem%n;\\n        vector<int> res(n,avg);\\n        \\n        for(int i=0;i<rem;i++) res[i]++;\\n        return res;\\n        \\n    }\\n};\\n//Upvote if the answer was helpful..Thank You\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=0;\\n        for(int i=0;i<rolls.size();i++){\\n            sum+=rolls[i];\\n        }\\n        int rem = (rolls.size() + n) * mean - sum;\\n        if(rem<n || rem>n * 6) return {};\\n        \\n        int avg= rem/n;\\n        rem =rem%n;\\n        vector<int> res(n,avg);\\n        \\n        for(int i=0;i<rem;i++) res[i]++;\\n        return res;\\n        \\n    }\\n};\\n//Upvote if the answer was helpful..Thank You\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006532,
                "title": "java-most-easy-to-understand-solution-self-explanatory",
                "content": "\\n```\\nclass Solution {\\n    // time O(m + n)\\n    // space O(1)\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int m = rolls.length;\\n        int rollsSum = 0;\\n        for (int i = 0; i < m; i++) {\\n            rollsSum += rolls[i];\\n        }\\n\\n        int totalSum = mean * (m + n);\\n        int nSum = totalSum - rollsSum;\\n        if (nSum < 0) return new int[]{}; // [-2, -2] case \\n\\n        int avg = nSum / n;\\n        int rest = nSum % n;\\n        if (avg > 6 || avg < 1) return new int[]{}; // [7, 7] or [0, 0] case\\n        if (rest > 0 && avg + 1 > 6) return new int[]{}; // [6, 7] case\\n        \\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = avg;\\n            if (rest-- > 0) res[i] += 1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // time O(m + n)\\n    // space O(1)\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int m = rolls.length;\\n        int rollsSum = 0;\\n        for (int i = 0; i < m; i++) {\\n            rollsSum += rolls[i];\\n        }\\n\\n        int totalSum = mean * (m + n);\\n        int nSum = totalSum - rollsSum;\\n        if (nSum < 0) return new int[]{}; // [-2, -2] case \\n\\n        int avg = nSum / n;\\n        int rest = nSum % n;\\n        if (avg > 6 || avg < 1) return new int[]{}; // [7, 7] or [0, 0] case\\n        if (rest > 0 && avg + 1 > 6) return new int[]{}; // [6, 7] case\\n        \\n        int[] res = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] = avg;\\n            if (rest-- > 0) res[i] += 1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986916,
                "title": "python-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, A: List[int], M: int, F: int) -> List[int]:\\n        sum_A = 0\\n        for c in A:\\n            sum_A += c\\n        \\n        target = int((len(A) + F) * M - sum_A)\\n        if target == F:\\n            return [1] * F\\n        elif (target > F): \\n            if (int(1 + (target - F) / F) == 1 + (target - F) / F):\\n                if 1 + (target - F) / F <= 6:\\n                    return [int(1 + (target - F) / F)] * F\\n                else:\\n                    return []\\n            else:\\n                output = [1] * F\\n                to_add = target - F\\n                if int(target - F + 1) <= 6:\\n                    output[-1] = int(target - F + 1)\\n                    return output\\n                else:\\n                    x = int(target - F)\\n                    index = 0\\n                    while (x > 5) & (index < F):\\n                        output[index] += 5\\n                        x = int(x - 5)\\n                        index += 1\\n                    if (x <= 5) and (index < F):\\n                        output[index] += x\\n            sum_ = 0\\n            for c in output:\\n                sum_ += c\\n            if sum_ + sum_A != M * (len(A) + F):\\n                return []\\n            else:\\n                return output\\n        else:\\n            return []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, A: List[int], M: int, F: int) -> List[int]:\\n        sum_A = 0\\n        for c in A:\\n            sum_A += c\\n        \\n        target = int((len(A) + F) * M - sum_A)\\n        if target == F:\\n            return [1] * F\\n        elif (target > F): \\n            if (int(1 + (target - F) / F) == 1 + (target - F) / F):\\n                if 1 + (target - F) / F <= 6:\\n                    return [int(1 + (target - F) / F)] * F\\n                else:\\n                    return []\\n            else:\\n                output = [1] * F\\n                to_add = target - F\\n                if int(target - F + 1) <= 6:\\n                    output[-1] = int(target - F + 1)\\n                    return output\\n                else:\\n                    x = int(target - F)\\n                    index = 0\\n                    while (x > 5) & (index < F):\\n                        output[index] += 5\\n                        x = int(x - 5)\\n                        index += 1\\n                    if (x <= 5) and (index < F):\\n                        output[index] += x\\n            sum_ = 0\\n            for c in output:\\n                sum_ += c\\n            if sum_ + sum_A != M * (len(A) + F):\\n                return []\\n            else:\\n                return output\\n        else:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960320,
                "title": "python-straightforward-solution-beats-93",
                "content": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = mean * (len(rolls) + n)\\n        remaining = total - sum(rolls)\\n\\n        round = remaining // n\\n        if round > 6 or round < 1:\\n            return []\\n        \\n        remaining %= n\\n        if remaining > 0 and round == 6:\\n            return []\\n\\n        res = [round] * n\\n        i = 0\\n        while remaining > 0:\\n            res[i] += 1\\n            remaining -= 1\\n            i += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total = mean * (len(rolls) + n)\\n        remaining = total - sum(rolls)\\n\\n        round = remaining // n\\n        if round > 6 or round < 1:\\n            return []\\n        \\n        remaining %= n\\n        if remaining > 0 and round == 6:\\n            return []\\n\\n        res = [round] * n\\n        i = 0\\n        while remaining > 0:\\n            res[i] += 1\\n            remaining -= 1\\n            i += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938079,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n       int totalSum = (rolls.length+n)*mean;\\n        int rollSum = IntStream.of(rolls).sum();\\n        int missingRollsSum = totalSum-rollSum;\\n        if(missingRollsSum < n || missingRollsSum > n*6) return new int[0];\\n        int missingRollValue = missingRollsSum/n, addOn = missingRollsSum%n;\\n        int[] arr = new int[n];\\n        for(int i = 0; i<n; i++){\\n            int temp = addOn;\\n            if(missingRollValue + temp > 6){\\n                temp = 6-missingRollValue;\\n            }\\n            arr[i] = missingRollValue + temp;\\n            addOn -=temp; \\n        }\\n        \\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        \\n       int totalSum = (rolls.length+n)*mean;\\n        int rollSum = IntStream.of(rolls).sum();\\n        int missingRollsSum = totalSum-rollSum;\\n        if(missingRollsSum < n || missingRollsSum > n*6) return new int[0];\\n        int missingRollValue = missingRollsSum/n, addOn = missingRollsSum%n;\\n        int[] arr = new int[n];\\n        for(int i = 0; i<n; i++){\\n            int temp = addOn;\\n            if(missingRollValue + temp > 6){\\n                temp = 6-missingRollValue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2907220,
                "title": "c-easy-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        // find the present sum of dice rolls\\n        int present_roll_sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        // find the remaining sum of dice rolls\\n        int rem_sum = mean*(n+rolls.size()) - present_roll_sum;\\n        \\n        // preliminary check. Straight away we get to know\\n        // if we can\\'t find such a dice roll\\n        // return an empty array\\n        if(rem_sum < n or rem_sum > 6*n) return {};\\n\\n        // fill the rolls with threshold\\n        // increment the remaining number of elements by 1\\n        // such that sum satisfies\\n        int thresh = rem_sum/n;\\n        vector<int> nrolls(n, thresh);\\n        for(int i = 0 ; i < rem_sum%n ; i++) nrolls[i]++;\\n        \\n        // return the possible dice roll.\\n        return nrolls;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        // find the present sum of dice rolls\\n        int present_roll_sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        // find the remaining sum of dice rolls\\n        int rem_sum = mean*(n+rolls.size()) - present_roll_sum;\\n        \\n        // preliminary check. Straight away we get to know\\n        // if we can\\'t find such a dice roll\\n        // return an empty array\\n        if(rem_sum < n or rem_sum > 6*n) return {};\\n\\n        // fill the rolls with threshold\\n        // increment the remaining number of elements by 1\\n        // such that sum satisfies\\n        int thresh = rem_sum/n;\\n        vector<int> nrolls(n, thresh);\\n        for(int i = 0 ; i < rem_sum%n ; i++) nrolls[i]++;\\n        \\n        // return the possible dice roll.\\n        return nrolls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891978,
                "title": "c-intuition-explained-simple-and-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nto get a sum from n numbers, the best number would e it\\'s average, like, from 4 numbers make 13, *13 / 4 is 3*, with an offest of 1 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the sum of missing observation,that is = `(mean * (n + rolls.size())) - sum(rolls)`.\\n2. If `toFindSum < n or toFindSum > 6 * n` then it\\'s not possible, so return an empty array.\\n3. After this we only have to distribute missingSum to n elements. So i used below method:-\\n - Assign `guess` i.e. `toFindSum / n` to every element of new array.\\n4. for offset, if `extra` i.e. `toFindSum % n` is not zero then, add 1 to number of guess times to every element of `missing`.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ , output array is not considered\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int toFindSum = (mean * (n + rolls.size())) - sum;\\n        \\n        if(toFindSum > 6 * n || toFindSum < n)\\n            return {};\\n\\n        int guess = toFindSum / n;\\n        vector<int> missing(n, guess);\\n        int extra = toFindSum % n;\\n       \\n        for(int i = 0; i < extra; ++i)\\n            missing[i] += 1;\\n\\n        return missing;   \\n    }\\n};\\n```\\n**Please UpVote** \\uD83D\\uDD3C , if it *Helped* :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int toFindSum = (mean * (n + rolls.size())) - sum;\\n        \\n        if(toFindSum > 6 * n || toFindSum < n)\\n            return {};\\n\\n        int guess = toFindSum / n;\\n        vector<int> missing(n, guess);\\n        int extra = toFindSum % n;\\n       \\n        for(int i = 0; i < extra; ++i)\\n            missing[i] += 1;\\n\\n        return missing;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877238,
                "title": "go-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nfunc min(a int, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n\\tsum := 0\\n\\tfor _, r := range rolls {\\n\\t\\tsum += r\\n\\t}\\n\\n\\trest := ((len(rolls)+n) * mean) - sum\\n\\tif rest < n || rest > n*6 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tres := []int{}\\n\\tfor n > 0 {\\n\\t\\tt := min(rest/n, 6)\\n\\t\\tres = append(res, t)\\n\\t\\trest -= t\\n\\t\\tn--\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nfunc min(a int, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc missingRolls(rolls []int, mean int, n int) []int {\\n\\tsum := 0\\n\\tfor _, r := range rolls {\\n\\t\\tsum += r\\n\\t}\\n\\n\\trest := ((len(rolls)+n) * mean) - sum\\n\\tif rest < n || rest > n*6 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tres := []int{}\\n\\tfor n > 0 {\\n\\t\\tt := min(rest/n, 6)\\n\\t\\tres = append(res, t)\\n\\t\\trest -= t\\n\\t\\tn--\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2867815,
                "title": "python-with-math-method",
                "content": "# Intuition\\nUse math to calculate the amount left to be provided with the n dices.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total_m = sum(rolls)\\n        m = len(rolls)\\n        total_required = mean * (m+n)\\n        total_left = total_required - total_m\\n        if total_left < n or total_left > 6 * n:\\n            return []\\n        \\n        result = [total_left // n] * n\\n        total_n = (total_left // n) * n\\n        for i in range(total_left - total_n):\\n            result[i] += 1\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        total_m = sum(rolls)\\n        m = len(rolls)\\n        total_required = mean * (m+n)\\n        total_left = total_required - total_m\\n        if total_left < n or total_left > 6 * n:\\n            return []\\n        \\n        result = [total_left // n] * n\\n        total_n = (total_left // n) * n\\n        for i in range(total_left - total_n):\\n            result[i] += 1\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867026,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGreedy\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) //Depends on nTotal\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\\n        int m = rolls.Length;\\n        int nTotal = (mean * (m+n)) - rolls.Sum();\\n\\n        if( nTotal < n || nTotal > n*6)\\n            return new int[]{};\\n        \\n        List<int> result = new();\\n        while(nTotal > 0)\\n        {\\n            int diceRoll = Math.Min(nTotal -n+1,6);\\n            result.Add(diceRoll);\\n            nTotal -= diceRoll;\\n            n-=1;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\\n        int m = rolls.Length;\\n        int nTotal = (mean * (m+n)) - rolls.Sum();\\n\\n        if( nTotal < n || nTotal > n*6)\\n            return new int[]{};\\n        \\n        List<int> result = new();\\n        while(nTotal > 0)\\n        {\\n            int diceRoll = Math.Min(nTotal -n+1,6);\\n            result.Add(diceRoll);\\n            nTotal -= diceRoll;\\n            n-=1;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867025,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGreedy\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) //Depends on nTotal\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\\n        int m = rolls.Length;\\n        int nTotal = (mean * (m+n)) - rolls.Sum();\\n\\n        if( nTotal < n || nTotal > n*6)\\n            return new int[]{};\\n        \\n        List<int> result = new();\\n        while(nTotal > 0)\\n        {\\n            int diceRoll = Math.Min(nTotal -n+1,6);\\n            result.Add(diceRoll);\\n            nTotal -= diceRoll;\\n            n-=1;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\\n        int m = rolls.Length;\\n        int nTotal = (mean * (m+n)) - rolls.Sum();\\n\\n        if( nTotal < n || nTotal > n*6)\\n            return new int[]{};\\n        \\n        List<int> result = new();\\n        while(nTotal > 0)\\n        {\\n            int diceRoll = Math.Min(nTotal -n+1,6);\\n            result.Add(diceRoll);\\n            nTotal -= diceRoll;\\n            n-=1;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856981,
                "title": "java-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(k), where k is the larger of the length of `rolls` and `n`\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        /** \\n        *   the sum of the missing dice rolls  = total - sum of known dice rolls\\n        *   total = mean * total number of dice rolls (n + rolls.length)\\n        *   \\n        **/\\n        int m = rolls.length;\\n        int total = mean * (m + n);\\n        int sum = 0;\\n        for(int i : rolls) {\\n            sum += i;\\n        }\\n        int missingSum = total - sum;\\n\\n        /**\\n        *   get the average value for each missing dice roll\\n        *   if missingSum > 6n (largest possible sum) OR\\n        *   if missingSum < 0 OR\\n        *   if missingSum is not big enough to have an integer value for each missing dice roll\\n        *   return empty array\\n        **/\\n        int avg = missingSum / n;\\n        int excess = missingSum - avg*n;\\n        if(missingSum > n * 6 || missingSum < 0 || excess == missingSum) return new int[]{};\\n\\n        int[] res = new int[n];\\n        for(int i=0; i<n; i++) {\\n            res[i] = avg;\\n        }\\n\\n        for(int i=0; i<n && excess > 0; i++) {\\n            res[i] += 1;\\n            excess--;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        /** \\n        *   the sum of the missing dice rolls  = total - sum of known dice rolls\\n        *   total = mean * total number of dice rolls (n + rolls.length)\\n        *   \\n        **/\\n        int m = rolls.length;\\n        int total = mean * (m + n);\\n        int sum = 0;\\n        for(int i : rolls) {\\n            sum += i;\\n        }\\n        int missingSum = total - sum;\\n\\n        /**\\n        *   get the average value for each missing dice roll\\n        *   if missingSum > 6n (largest possible sum) OR\\n        *   if missingSum < 0 OR\\n        *   if missingSum is not big enough to have an integer value for each missing dice roll\\n        *   return empty array\\n        **/\\n        int avg = missingSum / n;\\n        int excess = missingSum - avg*n;\\n        if(missingSum > n * 6 || missingSum < 0 || excess == missingSum) return new int[]{};\\n\\n        int[] res = new int[n];\\n        for(int i=0; i<n; i++) {\\n            res[i] = avg;\\n        }\\n\\n        for(int i=0; i<n && excess > 0; i++) {\\n            res[i] += 1;\\n            excess--;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847703,
                "title": "2028-find-missing-observations",
                "content": "```\\npublic static int[] missingRolls(int[] rolls, int mean, int n) {\\n        int[] ans = new int[n];\\n        int sum = 0;\\n        int length = n + rolls.length;\\n        for (int i = 0; i < rolls.length; i++) {\\n            sum += rolls[i];\\n        }\\n        int target = (mean * length) - sum;\\n        if (target < n || target > 6 * n) {\\n            return new int[]{};\\n        }\\n        if (n == 1) {\\n            return new int[]{target};\\n        }\\n        int rem = target % n;\\n        for (int i = 1; i <= n; i++) {\\n            ans[i - 1] = target / n;\\n            if (rem > 0) {\\n                ans[i - 1] += 1;\\n                rem--;\\n            }\\n        }\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int[] missingRolls(int[] rolls, int mean, int n) {\\n        int[] ans = new int[n];\\n        int sum = 0;\\n        int length = n + rolls.length;\\n        for (int i = 0; i < rolls.length; i++) {\\n            sum += rolls[i];\\n        }\\n        int target = (mean * length) - sum;\\n        if (target < n || target > 6 * n) {\\n            return new int[]{};\\n        }\\n        if (n == 1) {\\n            return new int[]{target};\\n        }\\n        int rem = target % n;\\n        for (int i = 1; i <= n; i++) {\\n            ans[i - 1] = target / n;\\n            if (rem > 0) {\\n                ans[i - 1] += 1;\\n                rem--;\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839750,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m=len(rolls)\\n        s=mean*(m+n)-sum(rolls)\\n        if s/n>6 or s/n<1:return []\\n        else:\\n            ret=[]\\n            for i in range(n):\\n                avg=s//n\\n                ret.append(avg)\\n                s-=avg\\n                n-=1\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m=len(rolls)\\n        s=mean*(m+n)-sum(rolls)\\n        if s/n>6 or s/n<1:return []\\n        else:\\n            ret=[]\\n            for i in range(n):\\n                avg=s//n\\n                ret.append(avg)\\n                s-=avg\\n                n-=1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820752,
                "title": "python-no-loops-solutions",
                "content": "# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls, mean, n):\\n        m = len(rolls)\\n        sum_target = mean * (n + m)\\n        sum_current = sum(rolls)\\n        sum_remaining = sum_target - sum_current\\n        if not (n <= sum_remaining <= 6*n):\\n            return []\\n        \\n        remaining_rolls = [sum_remaining // n]*(n - sum_remaining % n) + [sum_remaining // n + 1]*(sum_remaining % n)\\n    \\n        return remaining_rolls\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls, mean, n):\\n        m = len(rolls)\\n        sum_target = mean * (n + m)\\n        sum_current = sum(rolls)\\n        sum_remaining = sum_target - sum_current\\n        if not (n <= sum_remaining <= 6*n):\\n            return []\\n        \\n        remaining_rolls = [sum_remaining // n]*(n - sum_remaining % n) + [sum_remaining // n + 1]*(sum_remaining % n)\\n    \\n        return remaining_rolls\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803027,
                "title": "easy-to-understand-python-with-comments-faster-than-90",
                "content": "def missingRolls(self, rolls, mean, n):\\n\\n        total = (len(rolls) + n) * mean\\n        sum_in_N = total - sum(rolls)\\n        \\n        # check if possible\\n\\t\\t# each value in the array has to be > 1 and < 7\\n        if sum_in_N > 6*n or sum_in_N <1*n:\\n            return []\\n        \\n        # build N\\n        mod = sum_in_N % n\\n        if not mod:\\n            return [sum_in_N // n] * n\\n        else:\\n            # mod is between 1 and 5\\n            res = [sum_in_N // n] * n\\n            for count in range(mod):\\n                res[count] +=1\\n            return res",
                "solutionTags": [],
                "code": "def missingRolls(self, rolls, mean, n):\\n\\n        total = (len(rolls) + n) * mean\\n        sum_in_N = total - sum(rolls)\\n        \\n        # check if possible\\n\\t\\t# each value in the array has to be > 1 and < 7\\n        if sum_in_N > 6*n or sum_in_N <1*n:\\n            return []\\n        \\n        # build N\\n        mod = sum_in_N % n\\n        if not mod:\\n            return [sum_in_N // n] * n\\n        else:\\n            # mod is between 1 and 5\\n            res = [sum_in_N // n] * n\\n            for count in range(mod):\\n                res[count] +=1\\n            return res",
                "codeTag": "Python3"
            },
            {
                "id": 2728852,
                "title": "easy-mathematical-solution-python",
                "content": "# Intuition\\nAt first I tried a recursive solution that tries to build the missing rolls array by starting with an array of all 1\\'s and incrementing them one by one till we reach the mean, and if the mean is not reachable I return an empty array.\\nIt worked but threw a TLE as expected, so I switched to a mathematical solution where I use the mean to get the sum required, divide that sum over n elements, and then add the remainder to a subset of those elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def missingRolls(self, rolls, mean, n):\\n        \"\"\"\\n        :type rolls: List[int]\\n        :type mean: int\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # return self.get_missing_rolls(rolls, [1]*n, mean)\\n        sum_missing_rolls = self.get_sum_of_missing_rolls(rolls, mean, n)\\n\\n        # one way to divide this sum over n numbers is by dividing it over n equal numbers\\n        # and taking the floor value\\n        # the remainder will be divided as +1 for x elements where x = remainder\\n        avg_value_of_missing_roll = sum_missing_rolls // n\\n        remainder = sum_missing_rolls % n\\n\\n        # if all n values are 6 and we still have a remainder, a solution is not possible\\n        if avg_value_of_missing_roll == 6 and remainder != 0:\\n            return []\\n        # if the values are outside the range or the remainder cannot be equally divided over less than n elements\\n        # a solution is not possible\\n        elif avg_value_of_missing_roll <= 0 or avg_value_of_missing_roll > 6 or remainder > n:\\n            return []\\n        else:\\n            answer = [avg_value_of_missing_roll + 1 if x < remainder else avg_value_of_missing_roll for x in range(n)]\\n            return answer\\n\\n\\n    def get_sum_of_missing_rolls(self, rolls, mean, n):\\n        # since we know that (sum(rolls) + sum(missing_rolls)) / (len(rolls) + n) == mean,\\n        # we can reverse this expression to get sum(missing_rolls)\\n        return mean * (len(rolls) + n) - sum(rolls)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def missingRolls(self, rolls, mean, n):\\n        \"\"\"\\n        :type rolls: List[int]\\n        :type mean: int\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # return self.get_missing_rolls(rolls, [1]*n, mean)\\n        sum_missing_rolls = self.get_sum_of_missing_rolls(rolls, mean, n)\\n\\n        # one way to divide this sum over n numbers is by dividing it over n equal numbers\\n        # and taking the floor value\\n        # the remainder will be divided as +1 for x elements where x = remainder\\n        avg_value_of_missing_roll = sum_missing_rolls // n\\n        remainder = sum_missing_rolls % n\\n\\n        # if all n values are 6 and we still have a remainder, a solution is not possible\\n        if avg_value_of_missing_roll == 6 and remainder != 0:\\n            return []\\n        # if the values are outside the range or the remainder cannot be equally divided over less than n elements\\n        # a solution is not possible\\n        elif avg_value_of_missing_roll <= 0 or avg_value_of_missing_roll > 6 or remainder > n:\\n            return []\\n        else:\\n            answer = [avg_value_of_missing_roll + 1 if x < remainder else avg_value_of_missing_roll for x in range(n)]\\n            return answer\\n\\n\\n    def get_sum_of_missing_rolls(self, rolls, mean, n):\\n        # since we know that (sum(rolls) + sum(missing_rolls)) / (len(rolls) + n) == mean,\\n        # we can reverse this expression to get sum(missing_rolls)\\n        return mean * (len(rolls) + n) - sum(rolls)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721279,
                "title": "my-notes-photo-with-code",
                "content": "![image](https://assets.leetcode.com/users/images/4ee2f3f9-d6ed-420e-b687-1c08c84ac009_1666168172.5691922.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size() , total = 0;\\n        for(auto x:rolls)\\n            total+=x;\\n        \\n        int remain = mean*(m+n) - total;\\n        \\n        // chq whether its possible or not\\n        if(remain > 6 * n || remain < n ) {return {};}\\n        \\n        //now it has to  be possible\\n        vector<int> ans(n , remain/n);\\n        \\n        remain = remain%n ; // that\\'s carry over left\\n        \\n        // distribute carry over everyone\\n        // take care if you dont allocate more than 6 number to any array element\\n        for(int i=0;i<n;i++){\\n            int cap = 6 - ans[i];\\n            if(remain<=0) return ans;\\n            ans[i] += min(cap , remain);\\n            remain = max(remain - cap , 0 );\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size() , total = 0;\\n        for(auto x:rolls)\\n            total+=x;\\n        \\n        int remain = mean*(m+n) - total;\\n        \\n        // chq whether its possible or not\\n        if(remain > 6 * n || remain < n ) {return {};}\\n        \\n        //now it has to  be possible\\n        vector<int> ans(n , remain/n);\\n        \\n        remain = remain%n ; // that\\'s carry over left\\n        \\n        // distribute carry over everyone\\n        // take care if you dont allocate more than 6 number to any array element\\n        for(int i=0;i<n;i++){\\n            int cap = 6 - ans[i];\\n            if(remain<=0) return ans;\\n            ans[i] += min(cap , remain);\\n            remain = max(remain - cap , 0 );\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703844,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int total = mean * (m + n);\\n        int missing = total - sum;\\n        if (missing < n || missing > 6 * n) {\\n            return {};\\n        }\\n        vector<int> res(n, 1);\\n        missing -= n;\\n        for (int i = 0; i < n; ++i) {\\n            int add = min(5, missing);\\n            res[i] += add;\\n            missing -= add;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int total = mean * (m + n);\\n        int missing = total - sum;\\n        if (missing < n || missing > 6 * n) {\\n            return {};\\n        }\\n        vector<int> res(n, 1);\\n        missing -= n;\\n        for (int i = 0; i < n; ++i) {\\n            int add = min(5, missing);\\n            res[i] += add;\\n            missing -= add;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684041,
                "title": "easy-o-n-java-solution",
                "content": "**Java Code:**\\n\\n```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int sum=0, m=rolls.length; for(int i:rolls) sum+=i;\\n        int remsum = mean*(m+n) - sum, resArr[] = new int[n];\\n        if(remsum<n || remsum>6*n) return new int[0];\\n        int valPerElement = remsum/n;\\n        for(int i=0; i<n; ++i) resArr[i] = valPerElement;\\n        remsum -= valPerElement*n;\\n        for(int i=0; i<n && remsum>0; ++i) {\\n            int temp=Math.min(6-resArr[i], remsum);\\n            resArr[i] += temp;\\n            remsum -= temp;\\n        }\\n        return resArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int sum=0, m=rolls.length; for(int i:rolls) sum+=i;\\n        int remsum = mean*(m+n) - sum, resArr[] = new int[n];\\n        if(remsum<n || remsum>6*n) return new int[0];\\n        int valPerElement = remsum/n;\\n        for(int i=0; i<n; ++i) resArr[i] = valPerElement;\\n        remsum -= valPerElement*n;\\n        for(int i=0; i<n && remsum>0; ++i) {\\n            int temp=Math.min(6-resArr[i], remsum);\\n            resArr[i] += temp;\\n            remsum -= temp;\\n        }\\n        return resArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675684,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n\\t\\t\\tm = len(rolls)\\n\\t\\t\\tsum_rolls = sum(rolls)\\n\\t\\t\\ttarget = mean * (m + n) - sum_rolls\\n\\n\\t\\t\\tq = target // n\\n\\t\\t\\tr = target % n\\n\\t\\t\\tif q > 6 or q < 1 or (q == 6 and r > 0):\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tans = [q] * n\\n\\n\\t\\t\\t# Optimization: just use r for the index!\\n\\t\\t\\twhile r > 0:\\n\\t\\t\\t\\tans[r] += 1\\n\\t\\t\\t\\tr -= 1\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n\\t\\t\\tm = len(rolls)\\n\\t\\t\\tsum_rolls = sum(rolls)\\n\\t\\t\\ttarget = mean * (m + n) - sum_rolls\\n\\n\\t\\t\\tq = target // n\\n\\t\\t\\tr = target % n\\n\\t\\t\\tif q > 6 or q < 1 or (q == 6 and r > 0):\\n\\t\\t\\t\\treturn []\\n\\n\\t\\t\\tans = [q] * n\\n\\n\\t\\t\\t# Optimization: just use r for the index!\\n\\t\\t\\twhile r > 0:\\n\\t\\t\\t\\tans[r] += 1\\n\\t\\t\\t\\tr -= 1\\n\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2669271,
                "title": "python-simple-maths",
                "content": "# Approach\\nLet the mean be $$\\\\mu$$, the sum of the *known* dice rolls be $$S$$, and also let the values of the $$n$$ unknown dice rolls be $$x_i$$ where $$1 \\\\le i \\\\le n$$. From the given conditions, we must have $$\\\\frac{S + \\\\sum_{i=1}^n x_i}{m + n} = \\\\mu$$\\n\\nRearranging this equation gives:\\n\\n$$\\\\sum_{i=1}^n x_i = (m + n)\\\\mu - S$$\\n\\nCall the quantity on the right-hand side $$T$$. Because each die roll must be between 1 and 6, the equation will have a solution for each $$x_i$$ provided that $$1 \\\\le T / n \\\\le 6$$. In other words, the minimum sum of $$n$$ die rolls is $$n$$ and the maximum is $$6n$$.\\n\\nTo produce the answer in the code below (when one exists), we give each die roll a value of $$\\\\lfloor(T/n)\\\\rfloor$$ and equally distribute the remainder of $$T/n$$ among the $$n$$ dice, if needed. This is always possible, since the remainder is less than $$n$$.\\n\\n# Complexity\\n- Time complexity:\\nO(n + m)\\n\\n- Space complexity:\\nO(1) (ignoring the space for the answer)\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sum_rolls = sum(rolls)\\n        target = mean * (m + n) - sum_rolls\\n\\n        q = target // n\\n        r = target % n\\n        if q > 6 or q < 1 or (q == 6 and r > 0):\\n            return []\\n\\n        ans = [q] * n\\n\\n        # Optimization: just use r for the index!\\n        while r > 0:\\n            ans[r] += 1\\n            r -= 1\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sum_rolls = sum(rolls)\\n        target = mean * (m + n) - sum_rolls\\n\\n        q = target // n\\n        r = target % n\\n        if q > 6 or q < 1 or (q == 6 and r > 0):\\n            return []\\n\\n        ans = [q] * n\\n\\n        # Optimization: just use r for the index!\\n        while r > 0:\\n            ans[r] += 1\\n            r -= 1\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660249,
                "title": "c-math",
                "content": "* mean=sum/size\\n* mean=(sum+x)/(m+n)\\n* x=(mean*(m+n))-sum\\n* if x/n > 6 return empty vector as question says there is only six sided dice.\\n* so if x is not divisible by n then take mod and start adding to each element in res vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=accumulate(rolls.begin(),rolls.end(),0);\\n        int si=rolls.size()+n;\\n        int num=(si*mean)-sum;\\n        int rem=num%n;\\n        int ans=num/n;\\n        if(ans>6 || ans<=0) return {};\\n        vector<int>res(n,ans);\\n        for(int i=0;i<n && rem;i++,rem--){\\n            res[i]++;\\n            if(res[i]>6) return {};\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum=accumulate(rolls.begin(),rolls.end(),0);\\n        int si=rolls.size()+n;\\n        int num=(si*mean)-sum;\\n        int rem=num%n;\\n        int ans=num/n;\\n        if(ans>6 || ans<=0) return {};\\n        vector<int>res(n,ans);\\n        for(int i=0;i<n && rem;i++,rem--){\\n            res[i]++;\\n            if(res[i]>6) return {};\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650024,
                "title": "python-o-n-mathematical-solution-explained",
                "content": "This is very interesting Mathematical problem \\nlet me explain:\\nrolls = [1,5,6], mean = 3, n = 4\\n\\nTotal_Rolls = [ 1, 5, 6, x1, x2, x3, x4 ]\\nso we need to find [ x1, x2, x3, x4]\\n\\nlets solve: \\n\\nwe have,\\nmean = ( sum(rolls)-missing_sum ) /  ( len(rolls)+n )\\n\\n( len(rolls)+n ) - > Total Number of Elements\\n\\nmissing_sum = mean*(  len(rolls)+n  ) - sum(rolls)\\n\\nso our target is to find missing_sum which is above calculated \\nokey so lets discuss what is mean\\n\\nmean is a equal distribution of the number means\\n if mean is 8 then we can break this mean into 4 Equal parts (n=4) which is [2,2,2,2]\\n \\n and if mean is odd like 9 then we can not divide 4 parts so we can divide into 3 equal part and one part is the greater then other \\n \\n part = mean/n\\n ans = [ part,part,part,part]\\n \\n rem = mean % n \\n\\nloop 1 to rem:\\n\\t\\t\\t\\tans[i]+=1 \\n\\n```\\n\\t\\tres=[]\\n        \\n        target = mean*(len(rolls)+n)-sum(rolls)\\n        \\n        if target<n or target>6*n: return res\\n        \\n        part,rem = target//n,target%n\\n        \\n        res=[part]*n\\n        \\n        while rem>0:\\n            rem-=1\\n            res[rem]+=1\\n        \\n        return res\\n```\\n\\n \\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n\\t\\tres=[]\\n        \\n        target = mean*(len(rolls)+n)-sum(rolls)\\n        \\n        if target<n or target>6*n: return res\\n        \\n        part,rem = target//n,target%n\\n        \\n        res=[part]*n\\n        \\n        while rem>0:\\n            rem-=1\\n            res[rem]+=1\\n        \\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2649321,
                "title": "c",
                "content": "Runtime: 850 ms, faster than 100.00% of C online submissions for Find Missing Observations.\\nMemory Usage: 88.2 MB, less than 60.00% of C online submissions for Find Missing Observations.\\n```\\nint* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int sum = 0;\\n    for(int i = 0; i < rollsSize; i++){\\n        sum += rolls[i];\\n    }\\n    \\n    int target = mean *(rollsSize + n);\\n    int diff = target - sum;\\n    if( diff < n || diff > 6*n ){\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    \\n    int* ans = malloc(n * sizeof(int));\\n    *returnSize = n;\\n    for(int i = 0; i < n; i++){\\n        ans[i] = diff/n;\\n    }\\n    diff -= n* (diff/n);\\n    \\n    int pos = 0;\\n    while(diff > 0){\\n        if(diff > (6 - ans[pos]) ){\\n            diff -= ( 6 - ans[pos] );\\n            ans[pos] = 6;            \\n        }\\n        else{\\n            ans[pos] += diff;\\n            diff = 0;\\n        }\\n        pos++;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize){\\n    int sum = 0;\\n    for(int i = 0; i < rollsSize; i++){\\n        sum += rolls[i];\\n    }\\n    \\n    int target = mean *(rollsSize + n);\\n    int diff = target - sum;\\n    if( diff < n || diff > 6*n ){\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    \\n    int* ans = malloc(n * sizeof(int));\\n    *returnSize = n;\\n    for(int i = 0; i < n; i++){\\n        ans[i] = diff/n;\\n    }\\n    diff -= n* (diff/n);\\n    \\n    int pos = 0;\\n    while(diff > 0){\\n        if(diff > (6 - ans[pos]) ){\\n            diff -= ( 6 - ans[pos] );\\n            ans[pos] = 6;            \\n        }\\n        else{\\n            ans[pos] += diff;\\n            diff = 0;\\n        }\\n        pos++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2649223,
                "title": "c-efficient-solution",
                "content": "\\n    We are given  that\\n\\tn+m is the size of the array\\n\\tn digits are  mising and m array values are given \\n    \\n    rolls= [1,5,6] = m digits, n=4 missing, mean= 3\\n\\t\\n    m1+m2+m3+n1+n2+n3+n4/ m+n= mean=(3)\\n    \\n    sumof all digits + missingSum/ n+m = mean\\n    12+ missingSum/ 7= 3\\n\\t\\n    missingSum= 3*7- Sum of all digits\\n    \\n    missin sum/ n= parts \\n    reminder= tells us the numbers that needs to be added in parts. \\n    \\n    parts= 9/4= 2\\n    vector<int> ans= [2,2,2,2]\\n    rem= 9%4= 1 = needs to be added in any of the digits to make it a whole mean \\n    \\n    vector<int> ans= [ 3,2,2,2]\\n    \\n    resultant vector= [1,5,6,3,2,2,2]= 21/ 7= 3= mean \\n\\n\\n\\t```\\n\\t    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int curSum = accumulate(rolls.begin(), rolls.end(), 0), m = rolls.size();\\n        \\n        int missingSum = mean * (n + m) - curSum;\\n        if (missingSum < n || missingSum > 6*n) return {};\\n        \\n        int part = missingSum / n, rem = missingSum % n;\\n        vector<int> ans(n, part);\\n        for (int i = 0; i < rem; ++i) \\n            ++ans[i];\\n        return ans;\\n    }\\n\\t\\n**Please upvote!**",
                "solutionTags": [],
                "code": "\\n    We are given  that\\n\\tn+m is the size of the array\\n\\tn digits are  mising and m array values are given \\n    \\n    rolls= [1,5,6] = m digits, n=4 missing, mean= 3\\n\\t\\n    m1+m2+m3+n1+n2+n3+n4/ m+n= mean=(3)\\n    \\n    sumof all digits + missingSum/ n+m = mean\\n    12+ missingSum/ 7= 3\\n\\t\\n    missingSum= 3*7- Sum of all digits\\n    \\n    missin sum/ n= parts \\n    reminder= tells us the numbers that needs to be added in parts. \\n    \\n    parts= 9/4= 2\\n    vector<int> ans= [2,2,2,2]\\n    rem= 9%4= 1 = needs to be added in any of the digits to make it a whole mean \\n    \\n    vector<int> ans= [ 3,2,2,2]\\n    \\n    resultant vector= [1,5,6,3,2,2,2]= 21/ 7= 3= mean \\n\\n\\n\\t```\\n\\t    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int curSum = accumulate(rolls.begin(), rolls.end(), 0), m = rolls.size();\\n        \\n        int missingSum = mean * (n + m) - curSum;\\n        if (missingSum < n || missingSum > 6*n) return {};\\n        \\n        int part = missingSum / n, rem = missingSum % n;\\n        vector<int> ans(n, part);\\n        for (int i = 0; i < rem; ++i) \\n            ++ans[i];\\n        return ans;\\n    }\\n\\t\\n**Please upvote!**",
                "codeTag": "Unknown"
            },
            {
                "id": 2648554,
                "title": "python-clean-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        remaining_sum = mean * (m + n) - sum(rolls)\\n\\n        if not n <= remaining_sum <= 6 * n:\\n            return []\\n\\n        # return self.generate_array_for_given_sum_method1(remaining_sum, n)\\n        return self.generate_array_for_given_sum_method2(remaining_sum, n)\\n\\n    @staticmethod\\n    def generate_array_for_given_sum_method1(s: int, n: int) -> List[int]:\\n        dice_val, output = 6, []\\n\\n        while s > 0:\\n            if s - dice_val >= n - 1:\\n                output.append(dice_val)\\n\\n                s -= dice_val\\n                n -= 1\\n            else:\\n                dice_val -= 1\\n\\n        return output\\n\\n    @staticmethod\\n    def generate_array_for_given_sum_method2(s: int, n: int) -> List[int]:\\n        q, r = divmod(s, n)  # s = q * n + r\\n\\n        output = [q] * n\\n\\n        # since sum(output) = q * n so adding rest of \"r\" in output\\n        for i in range(r):\\n            output[i] += 1\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        remaining_sum = mean * (m + n) - sum(rolls)\\n\\n        if not n <= remaining_sum <= 6 * n:\\n            return []\\n\\n        # return self.generate_array_for_given_sum_method1(remaining_sum, n)\\n        return self.generate_array_for_given_sum_method2(remaining_sum, n)\\n\\n    @staticmethod\\n    def generate_array_for_given_sum_method1(s: int, n: int) -> List[int]:\\n        dice_val, output = 6, []\\n\\n        while s > 0:\\n            if s - dice_val >= n - 1:\\n                output.append(dice_val)\\n\\n                s -= dice_val\\n                n -= 1\\n            else:\\n                dice_val -= 1\\n\\n        return output\\n\\n    @staticmethod\\n    def generate_array_for_given_sum_method2(s: int, n: int) -> List[int]:\\n        q, r = divmod(s, n)  # s = q * n + r\\n\\n        output = [q] * n\\n\\n        # since sum(output) = q * n so adding rest of \"r\" in output\\n        for i in range(r):\\n            output[i] += 1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648481,
                "title": "equally-distribute-remaining-sum",
                "content": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        total = mean * (m + n)\\n        rem = total - sum(rolls)\\n        res = [rem // n] * n\\n        k = rem % n\\n        for i in range(k):\\n            res[i] += 1\\n        if max(res) > 6 or min(res) < 1:\\n            return []\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        total = mean * (m + n)\\n        rem = total - sum(rolls)\\n        res = [rem // n] * n\\n        k = rem % n\\n        for i in range(k):\\n            res[i] += 1\\n        if max(res) > 6 or min(res) < 1:\\n            return []\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640131,
                "title": "java-greedy-approach-tc-o-n-m",
                "content": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int m = rolls.length ;\\n        int sum = mean*(n+m) ;\\n        int[] result = new int [n] ;\\n        \\n        for (int i = 0; i < m; i++)\\n            sum -= rolls[i] ;\\n        \\n        int x = sum/n ;\\n        int r = sum % n ;\\n        if (x <= 0 || x > 6 || (x == 6 && r != 0)) return new int[0] ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            result[i] = x ;\\n            if (r-- > 0) result[i]++ ;\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int m = rolls.length ;\\n        int sum = mean*(n+m) ;\\n        int[] result = new int [n] ;\\n        \\n        for (int i = 0; i < m; i++)\\n            sum -= rolls[i] ;\\n        \\n        int x = sum/n ;\\n        int r = sum % n ;\\n        if (x <= 0 || x > 6 || (x == 6 && r != 0)) return new int[0] ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            result[i] = x ;\\n            if (r-- > 0) result[i]++ ;\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601656,
                "title": "cpp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n\\t\\t\\tint s = accumulate(rolls.begin(),rolls.end(),0);\\n\\t\\t\\tint a = (rolls.size() + n)*mean;\\n\\t\\t\\tvector<int> aa;\\n\\t\\t\\twhile(n){\\n\\t\\t\\t\\tint x = (a-s)/n;\\n\\t\\t\\t\\tif(x>6 || x<1) return {};\\n\\t\\t\\t\\taa.push_back(x);\\n\\t\\t\\t\\ts+=x;\\n\\t\\t\\t\\tn--;\\n\\t\\t\\t}\\n\\t\\t\\treturn aa;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n\\t\\t\\tint s = accumulate(rolls.begin(),rolls.end(),0);\\n\\t\\t\\tint a = (rolls.size() + n)*mean;\\n\\t\\t\\tvector<int> aa;\\n\\t\\t\\twhile(n){\\n\\t\\t\\t\\tint x = (a-s)/n;\\n\\t\\t\\t\\tif(x>6 || x<1) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2601011,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        desiredCount = len(rolls) + n\\n        currentSum, targetSum, res = sum(rolls), mean * desiredCount, []\\n        leftSum = targetSum - currentSum\\n        leftAverage = leftSum // n\\n        if leftAverage == 6 and leftAverage * n < leftSum:\\n            return res\\n        if leftAverage > 6:\\n            return res\\n        if leftAverage <= 0:\\n            return res\\n        for i in range(n - 1):\\n            res.append(leftAverage)\\n        c = leftSum - (leftAverage * (n - 1))\\n        if c > 6:\\n            d = c - leftAverage\\n            for i in range(1, d):\\n                res.pop()\\n            for i in range(1, d + 1):\\n                res.append(leftAverage + 1)\\n        else:\\n            res.append(c)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        desiredCount = len(rolls) + n\\n        currentSum, targetSum, res = sum(rolls), mean * desiredCount, []\\n        leftSum = targetSum - currentSum\\n        leftAverage = leftSum // n\\n        if leftAverage == 6 and leftAverage * n < leftSum:\\n            return res\\n        if leftAverage > 6:\\n            return res\\n        if leftAverage <= 0:\\n            return res\\n        for i in range(n - 1):\\n            res.append(leftAverage)\\n        c = leftSum - (leftAverage * (n - 1))\\n        if c > 6:\\n            d = c - leftAverage\\n            for i in range(1, d):\\n                res.pop()\\n            for i in range(1, d + 1):\\n                res.append(leftAverage + 1)\\n        else:\\n            res.append(c)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551400,
                "title": "java-dynamic-programing",
                "content": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int sumM = 0;\\n        for (int i=0; i<rolls.length; i++) {\\n            sumM+=rolls[i];\\n        }\\n        int x = (mean * (n + rolls.length)) - sumM;\\n        int[] ans = new int[n];\\n        int curr = 0;\\n        if (x > 6 * n) {\\n            return new int[0];\\n        }\\n        for (int i=0; i<n; i++) {\\n            ans[i] = 1;\\n            curr++;\\n        }\\n        if (curr == x) {\\n            return ans;\\n        }\\n        if (curr > x) {\\n            return new int[0];\\n        }\\n        int index = 0;\\n        while (true) {\\n            if (ans[index] >= 6) {\\n                index++;\\n            }\\n            ans[index]++;\\n            curr++;\\n            if (curr == x) {\\n                return ans;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int sumM = 0;\\n        for (int i=0; i<rolls.length; i++) {\\n            sumM+=rolls[i];\\n        }\\n        int x = (mean * (n + rolls.length)) - sumM;\\n        int[] ans = new int[n];\\n        int curr = 0;\\n        if (x > 6 * n) {\\n            return new int[0];\\n        }\\n        for (int i=0; i<n; i++) {\\n            ans[i] = 1;\\n            curr++;\\n        }\\n        if (curr == x) {\\n            return ans;\\n        }\\n        if (curr > x) {\\n            return new int[0];\\n        }\\n        int index = 0;\\n        while (true) {\\n            if (ans[index] >= 6) {\\n                index++;\\n            }\\n            ans[index]++;\\n            curr++;\\n            if (curr == x) {\\n                return ans;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498827,
                "title": "easy-solution-c",
                "content": "![image](https://assets.leetcode.com/users/images/54e1e2f7-4d86-46bc-b240-6d42b4920fd0_1661757636.8655279.png)\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/54e1e2f7-4d86-46bc-b240-6d42b4920fd0_1661757636.8655279.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2489489,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int sum=0;\\n        for(int i=0;i<rolls.length;i++){\\n            sum+=rolls[i];\\n        }\\n        int total = (rolls.length+n)*mean - sum;\\n        if(total<n||total>n*6)\\n            return new int[0];\\n        int[] arr = new int[n];\\n        if(total%n==0)\\n        {\\n            int k=total/n;\\n            for(int i=0;i<n;i++)\\n                arr[i]=k;\\n            return arr;\\n        }\\n        int j=0;\\n        for(int i=1;i<=7;i++){\\n            if(i*n>total){\\n                int k=total/(i-1);\\n                if(k>=n&&n*(i-1)!=total)\\n                 {   k=n-1;\\n                    while((n-k)*6<(total-k*(i-1))) //check for how much k values can we put in the array\\n                        k--;\\n                 }\\n                for(int m=0;m<k;m++) //add i in the array\\n                    arr[j+m]=i-1;\\n                j+=k;\\n                n-=k;\\n                total-=(k*(i-1));             //updating total and the value of n to be put after addition\\n                \\n            }\\n            if(total==0)\\n                break;\\n        }\\n        return arr;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] missingRolls(int[] rolls, int mean, int n) {\\n        int sum=0;\\n        for(int i=0;i<rolls.length;i++){\\n            sum+=rolls[i];\\n        }\\n        int total = (rolls.length+n)*mean - sum;\\n        if(total<n||total>n*6)\\n            return new int[0];\\n        int[] arr = new int[n];\\n        if(total%n==0)\\n        {\\n            int k=total/n;\\n            for(int i=0;i<n;i++)\\n                arr[i]=k;\\n            return arr;\\n        }\\n        int j=0;\\n        for(int i=1;i<=7;i++){\\n            if(i*n>total){\\n                int k=total/(i-1);\\n                if(k>=n&&n*(i-1)!=total)\\n                 {   k=n-1;\\n                    while((n-k)*6<(total-k*(i-1))) //check for how much k values can we put in the array\\n                        k--;\\n                 }\\n                for(int m=0;m<k;m++) //add i in the array\\n                    arr[j+m]=i-1;\\n                j+=k;\\n                n-=k;\\n                total-=(k*(i-1));             //updating total and the value of n to be put after addition\\n                \\n            }\\n            if(total==0)\\n                break;\\n        }\\n        return arr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437892,
                "title": "python-solution",
                "content": "```\\ndef missingRolls(self, rolls: List[int], avg: int, n: int) -> List[int]:\\n\\tm, ans = len(rolls), []\\n\\ts = avg*(m+n) - sum(rolls)\\n\\tif s>6*n or s<n:\\n\\t\\treturn ans\\n\\tk, mod = divmod(s, n)\\n\\treturn [k+1]*mod+[k]*(n-mod)\\n```",
                "solutionTags": [],
                "code": "```\\ndef missingRolls(self, rolls: List[int], avg: int, n: int) -> List[int]:\\n\\tm, ans = len(rolls), []\\n\\ts = avg*(m+n) - sum(rolls)\\n\\tif s>6*n or s<n:\\n\\t\\treturn ans\\n\\tk, mod = divmod(s, n)\\n\\treturn [k+1]*mod+[k]*(n-mod)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2399059,
                "title": "typescript-100",
                "content": "```\\nfunction missingRolls(rolls: number[], mean: number, n: number): number[] {\\n    \\n    let sum = 0;\\n    for(let r of rolls) {\\n        sum += r;\\n    }\\n    \\n    let expectedSum = mean * (rolls.length + n);\\n    let diff = expectedSum - sum;\\n    \\n    let expectedMean = diff/n;\\n    \\n    if(expectedMean > 6 || expectedMean < 1) {\\n        return [];\\n    }\\n    \\n    let result = [];\\n    let remaining = diff;\\n        \\n    for(let i=0; i<n; i++) {\\n        let closest = Math.round(remaining/(n-i));\\n        result.push(closest);\\n        remaining = remaining - closest;\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/3ae9ba3b-18f1-4bce-ad40-8e7d74b2e499_1659982189.6353436.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction missingRolls(rolls: number[], mean: number, n: number): number[] {\\n    \\n    let sum = 0;\\n    for(let r of rolls) {\\n        sum += r;\\n    }\\n    \\n    let expectedSum = mean * (rolls.length + n);\\n    let diff = expectedSum - sum;\\n    \\n    let expectedMean = diff/n;\\n    \\n    if(expectedMean > 6 || expectedMean < 1) {\\n        return [];\\n    }\\n    \\n    let result = [];\\n    let remaining = diff;\\n        \\n    for(let i=0; i<n; i++) {\\n        let closest = Math.round(remaining/(n-i));\\n        result.push(closest);\\n        remaining = remaining - closest;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394887,
                "title": "c",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        long long sum = mean*(m+n);\\n        for(auto it : rolls){\\n            sum -= it;\\n        }\\n        vector<int> ans;\\n        int num = 6;\\n        while(n){\\n            if(sum-num>=n-1){\\n                ans.push_back(num);\\n                sum -= num;\\n                n--;\\n            }\\n            else{\\n                num--;\\n            }\\n        }\\n        if(sum!=0) return {};\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int m = rolls.size();\\n        long long sum = mean*(m+n);\\n        for(auto it : rolls){\\n            sum -= it;\\n        }\\n        vector<int> ans;\\n        int num = 6;\\n        while(n){\\n            if(sum-num>=n-1){\\n                ans.push_back(num);\\n                sum -= num;\\n                n--;\\n            }\\n            else{\\n                num--;\\n            }\\n        }\\n        if(sum!=0) return {};\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337727,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        vector<int> ans;\\n        \\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int num = (mean*(rolls.size()+n))-sum;\\n        if(num<n || num>6*n)\\n            return ans;\\n        \\n        int i=6;\\n        while(num>0)\\n        {\\n            num -= i;\\n            \\n            if(num>=(n-1))\\n            {\\n                ans.push_back(i);\\n                n--;\\n            }\\n            else\\n            {\\n                num += i;\\n                i--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        vector<int> ans;\\n        \\n        int sum = accumulate(rolls.begin(), rolls.end(), 0);\\n        int num = (mean*(rolls.size()+n))-sum;\\n        if(num<n || num>6*n)\\n            return ans;\\n        \\n        int i=6;\\n        while(num>0)\\n        {\\n            num -= i;\\n            \\n            if(num>=(n-1))\\n            {\\n                ans.push_back(i);\\n                n--;\\n            }\\n            else\\n            {\\n                num += i;\\n                i--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317368,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = 0;\\n        for(auto i : rolls) sum += i;\\n        \\n        sum = mean*(rolls.size() + n) - sum;\\n        // cout<<sum<<endl;\\n        if(sum <= 0) return {};\\n        if(n * 6 < sum || sum < n) return {};\\n        \\n        int x = sum/n;\\n        \\n        for(int i = 0; i < n; i++) {\\n            res.push_back(x);\\n        }\\n        \\n        int re = sum%n;\\n        \\n        int i = 0;\\n        \\n        while(re--){\\n            res[i] += 1;\\n            i++;\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        int sum = 0;\\n        for(auto i : rolls) sum += i;\\n        \\n        sum = mean*(rolls.size() + n) - sum;\\n        // cout<<sum<<endl;\\n        if(sum <= 0) return {};\\n        if(n * 6 < sum || sum < n) return {};\\n        \\n        int x = sum/n;\\n        \\n        for(int i = 0; i < n; i++) {\\n            res.push_back(x);\\n        }\\n        \\n        int re = sum%n;\\n        \\n        int i = 0;\\n        \\n        while(re--){\\n            res[i] += 1;\\n            i++;\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2298798,
                "title": "intuitive-math-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        int roll_num = rolls.size() + n;\\n        int total_sum = mean * roll_num;\\n        int left = total_sum - accumulate(rolls.begin(), rolls.end(), 0);\\n        \\n        if (left < n or n * 6 < left)\\n            return {};\\n        \\n        int mean_left = left / n;\\n        vector<int> res(n, mean_left);\\n        left %= n;\\n        for (auto& n : res) {\\n            if (left > 0) {\\n                auto diff = min(left, 6 - n);\\n                n += diff;\\n                left -= diff;\\n            } else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n        \\n        int roll_num = rolls.size() + n;\\n        int total_sum = mean * roll_num;\\n        int left = total_sum - accumulate(rolls.begin(), rolls.end(), 0);\\n        \\n        if (left < n or n * 6 < left)\\n            return {};\\n        \\n        int mean_left = left / n;\\n        vector<int> res(n, mean_left);\\n        left %= n;\\n        for (auto& n : res) {\\n            if (left > 0) {\\n                auto diff = min(left, 6 - n);\\n                n += diff;\\n                left -= diff;\\n            } else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207655,
                "title": "c-easy-soln-faster-than-90-08-c-submissions",
                "content": "```\\nC++  Easy Soln | Faster than 90.08% C++ submissions \\n\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n     \\n        \\n        int m = rolls.size();\\n        \\n        int p_sum(0);\\n        \\n        for (int i :rolls){\\n            p_sum+=i;\\n        }\\n        int sum = (m+n)*mean - p_sum;\\n        \\n        if (sum<n || sum> 6*n) return {};\\n        \\n        int a = sum/n;\\n        \\n        sum -=(a*n);\\n        \\n        vector<int> v(n,a);\\n        \\n        for (int i=0;i<sum;i++){\\n            v[i]++;\\n        }\\n        return v;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nC++  Easy Soln | Faster than 90.08% C++ submissions \\n\\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\\n     \\n        \\n        int m = rolls.size();\\n        \\n        int p_sum(0);\\n        \\n        for (int i :rolls){\\n            p_sum+=i;\\n        }\\n        int sum = (m+n)*mean - p_sum;\\n        \\n        if (sum<n || sum> 6*n) return {};\\n        \\n        int a = sum/n;\\n        \\n        sum -=(a*n);\\n        \\n        vector<int> v(n,a);\\n        \\n        for (int i=0;i<sum;i++){\\n            v[i]++;\\n        }\\n        return v;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2183952,
                "title": "c-short-and-clean",
                "content": "```\\n        public int[] MissingRolls(int[] rolls, int mean, int n)\\n        {\\n            int diff= (rolls.Length + n) * mean - rolls.Sum();//sum of n dices\\n            if (diff > 6 * n || diff < n) return new int[0];//impossible\\n            int mod = diff % n;//diff/n is the base value, and diff%n count of elements need add 1\\n            int[] res = Enumerable.Repeat(diff / n, n).ToArray();\\n            for (int i = 0; i < mod; i++)\\n                res[i]++;\\n            return res;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int[] MissingRolls(int[] rolls, int mean, int n)\\n        {\\n            int diff= (rolls.Length + n) * mean - rolls.Sum();//sum of n dices\\n            if (diff > 6 * n || diff < n) return new int[0];//impossible\\n            int mod = diff % n;//diff/n is the base value, and diff%n count of elements need add 1\\n            int[] res = Enumerable.Repeat(diff / n, n).ToArray();\\n            for (int i = 0; i < mod; i++)\\n                res[i]++;\\n            return res;\\n        }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1701271,
                "content": [
                    {
                        "username": "PhilipSmith",
                        "content": "Should probably be marked Easy."
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "My code fails this test case\\n[6,3,4,3,5,3]"
                    }
                ]
            },
            {
                "id": 1645324,
                "content": [
                    {
                        "username": "PhilipSmith",
                        "content": "Should probably be marked Easy."
                    },
                    {
                        "username": "Shubham_ssr",
                        "content": "My code fails this test case\\n[6,3,4,3,5,3]"
                    }
                ]
            }
        ]
    }
]