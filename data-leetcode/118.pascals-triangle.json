[
    {
        "title": "4Sum",
        "question_content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n\t0 <= a, b, c, d&nbsp;< n\n\ta, b, c, and d are distinct.\n\tnums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\nExample 2:\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 200\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109",
        "solutions": [
            {
                "id": 8545,
                "title": "python-140ms-beats-100-and-works-for-n-sum-n-2",
                "content": "The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted.\\n\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        results = []\\n        self.findNsum(nums, target, 4, [], results)\\n        return results\\n    \\n    def findNsum(self, nums, target, N, result, results):\\n        if len(nums) < N or N < 2: return\\n    \\n        # solve 2-sum\\n        if N == 2:\\n            l,r = 0,len(nums)-1\\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    results.append(result + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l < r and nums[l] == nums[l - 1]:\\n                        l += 1\\n                    while r > l and nums[r] == nums[r + 1]:\\n                        r -= 1\\n                elif nums[l] + nums[r] < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        else:\\n            for i in range(0, len(nums)-N+1):   # careful about range\\n                if target < nums[i]*N or target > nums[-1]*N:  # take advantages of sorted list\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]:  # recursively reduce N\\n                    self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n        return\\n\\n\\nJust revisited and clean the code\\n\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(nums, target, N, result, results):\\n            if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                l,r = 0,len(nums)-1\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(len(nums)-N+1):\\n                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):\\n                        findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n\\n        results = []\\n        findNsum(sorted(nums), target, 4, [], results)\\n        return results\\n\\t\\t\\t\\t\\npassing pointers, not sliced list\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(l, r, target, N, result, results):\\n            if r-l+1 < N or N < 2 or target < nums[l]*N or target > nums[r]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(l, r+1):\\n                    if i == l or (i > l and nums[i-1] != nums[i]):\\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\\n\\n        nums.sort()\\n        results = []\\n        findNsum(0, len(nums)-1, target, 4, [], results)\\n        return results",
                "solutionTags": [
                    "Python"
                ],
                "code": "The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted.\\n\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        results = []\\n        self.findNsum(nums, target, 4, [], results)\\n        return results\\n    \\n    def findNsum(self, nums, target, N, result, results):\\n        if len(nums) < N or N < 2: return\\n    \\n        # solve 2-sum\\n        if N == 2:\\n            l,r = 0,len(nums)-1\\n            while l < r:\\n                if nums[l] + nums[r] == target:\\n                    results.append(result + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l < r and nums[l] == nums[l - 1]:\\n                        l += 1\\n                    while r > l and nums[r] == nums[r + 1]:\\n                        r -= 1\\n                elif nums[l] + nums[r] < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        else:\\n            for i in range(0, len(nums)-N+1):   # careful about range\\n                if target < nums[i]*N or target > nums[-1]*N:  # take advantages of sorted list\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]:  # recursively reduce N\\n                    self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n        return\\n\\n\\nJust revisited and clean the code\\n\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(nums, target, N, result, results):\\n            if len(nums) < N or N < 2 or target < nums[0]*N or target > nums[-1]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                l,r = 0,len(nums)-1\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(len(nums)-N+1):\\n                    if i == 0 or (i > 0 and nums[i-1] != nums[i]):\\n                        findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results)\\n\\n        results = []\\n        findNsum(sorted(nums), target, 4, [], results)\\n        return results\\n\\t\\t\\t\\t\\npassing pointers, not sliced list\\n\\n    def fourSum(self, nums, target):\\n        def findNsum(l, r, target, N, result, results):\\n            if r-l+1 < N or N < 2 or target < nums[l]*N or target > nums[r]*N:  # early termination\\n                return\\n            if N == 2: # two pointers solve sorted 2-sum problem\\n                while l < r:\\n                    s = nums[l] + nums[r]\\n                    if s == target:\\n                        results.append(result + [nums[l], nums[r]])\\n                        l += 1\\n                        while l < r and nums[l] == nums[l-1]:\\n                            l += 1\\n                    elif s < target:\\n                        l += 1\\n                    else:\\n                        r -= 1\\n            else: # recursively reduce N\\n                for i in range(l, r+1):\\n                    if i == l or (i > l and nums[i-1] != nums[i]):\\n                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)\\n\\n        nums.sort()\\n        results = []\\n        findNsum(0, len(nums)-1, target, 4, [], results)\\n        return results",
                "codeTag": "Python3"
            },
            {
                "id": 8609,
                "title": "my-solution-generalized-for-ksums-in-java",
                "content": "#### General Idea\\nIf you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems: \\n1. 2sum Problem\\n2. Reduce K sum problem to K \\u2013 1 sum Problem\\n\\nTherefore, the ideas is simple and straightforward. We could use recursive to solve this problem. Time complexity is O(N^(K-1)).\\n\\n```JAVA\\n    public class Solution {\\n        int len = 0;\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            len = nums.length;\\n            Arrays.sort(nums);\\n            return kSum(nums, target, 4, 0);\\n        }\\n       private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {\\n            ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(index >= len) {\\n                return res;\\n            }\\n            if(k == 2) {\\n            \\tint i = index, j = len - 1;\\n            \\twhile(i < j) {\\n                    //find a pair\\n            \\t    if(target - nums[i] == nums[j]) {\\n            \\t    \\tList<Integer> temp = new ArrayList<>();\\n                    \\ttemp.add(nums[i]);\\n                    \\ttemp.add(target-nums[i]);\\n                        res.add(temp);\\n                        //skip duplication\\n                        while(i<j && nums[i]==nums[i+1]) i++;\\n                        while(i<j && nums[j-1]==nums[j]) j--;\\n                        i++;\\n                        j--;\\n                    //move left bound\\n            \\t    } else if (target - nums[i] > nums[j]) {\\n            \\t        i++;\\n                    //move right bound\\n            \\t    } else {\\n            \\t        j--;\\n            \\t    }\\n            \\t}\\n            } else{\\n                for (int i = index; i < len - k + 1; i++) {\\n                    //use current number to reduce ksum into k-1sum\\n                    ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k-1, i+1);\\n                    if(temp != null){\\n                        //add previous results\\n                        for (List<Integer> t : temp) {\\n                            t.add(0, nums[i]);\\n                        }\\n                        res.addAll(temp);\\n                    }\\n                    while (i < len-1 && nums[i] == nums[i+1]) {\\n                        //skip duplicated numbers\\n                        i++;\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```JAVA\\n    public class Solution {\\n        int len = 0;\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            len = nums.length;\\n            Arrays.sort(nums);\\n            return kSum(nums, target, 4, 0);\\n        }\\n       private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {\\n            ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(index >= len) {\\n                return res;\\n            }\\n            if(k == 2) {\\n            \\tint i = index, j = len - 1;\\n            \\twhile(i < j) {\\n                    //find a pair\\n            \\t    if(target - nums[i] == nums[j]) {\\n            \\t    \\tList<Integer> temp = new ArrayList<>();\\n                    \\ttemp.add(nums[i]);\\n                    \\ttemp.add(target-nums[i]);\\n                        res.add(temp);\\n                        //skip duplication\\n                        while(i<j && nums[i]==nums[i+1]) i++;\\n                        while(i<j && nums[j-1]==nums[j]) j--;\\n                        i++;\\n                        j--;\\n                    //move left bound\\n            \\t    } else if (target - nums[i] > nums[j]) {\\n            \\t        i++;\\n                    //move right bound\\n            \\t    } else {\\n            \\t        j--;\\n            \\t    }\\n            \\t}\\n            } else{\\n                for (int i = index; i < len - k + 1; i++) {\\n                    //use current number to reduce ksum into k-1sum\\n                    ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k-1, i+1);\\n                    if(temp != null){\\n                        //add previous results\\n                        for (List<Integer> t : temp) {\\n                            t.add(0, nums[i]);\\n                        }\\n                        res.addAll(temp);\\n                    }\\n                    while (i < len-1 && nums[i] == nums[i+1]) {\\n                        //skip duplicated numbers\\n                        i++;\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8549,
                "title": "my-16ms-c-code",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> total;\\n            int n = nums.size();\\n            if(n<4)  return total;\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++)\\n            {\\n                if(i>0&&nums[i]==nums[i-1]) continue;\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1;j<n-2;j++)\\n                {\\n                    if(j>i+1&&nums[j]==nums[j-1]) continue;\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\\n                    int left=j+1,right=n-1;\\n                    while(left<right){\\n                        int sum=nums[left]+nums[right]+nums[i]+nums[j];\\n                        if(sum<target) left++;\\n                        else if(sum>target) right--;\\n                        else{\\n                            total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});\\n                            do{left++;}while(nums[left]==nums[left-1]&&left<right);\\n                            do{right--;}while(nums[right]==nums[right+1]&&left<right);\\n                        }\\n                    }\\n                }\\n            }\\n            return total;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> total;\\n            int n = nums.size();\\n            if(n<4)  return total;\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++)\\n            {\\n                if(i>0&&nums[i]==nums[i-1]) continue;\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1;j<n-2;j++)\\n                {\\n                    if(j>i+1&&nums[j]==nums[j-1]) continue;\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\\n                    int left=j+1,right=n-1;\\n                    while(left<right){\\n                        int sum=nums[left]+nums[right]+nums[i]+nums[j];\\n                        if(sum<target) left++;\\n                        else if(sum>target) right--;\\n                        else{\\n                            total.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]}",
                "codeTag": "Java"
            },
            {
                "id": 1341213,
                "title": "c-python-2-solutions-clean-concise-follow-up-k-sum",
                "content": "**\\u2714\\uFE0F Solution 1: HashSet**\\n- The idea is to use `HashSet` to track past elements.\\n- We iterate the combinations of `nums[i]`, `nums[j]`, `nums[k]`, and calculate the last number by `lastNumber = target - nums[i] - nums[j] - nums[k]`. \\n- We check if `lastNumber` is existed the past by checking in the HashSet, if existed, then it form a `quadruplets` then add it to the answer.\\n\\nCredit @archit91 for providing C++ version.\\n<iframe src=\"https://leetcode.com/playground/BsiPbnLs/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: `O(N^3)`\\n- Extra Space (Without count output as space): `O(N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Sort then Two Pointers**\\n- Sort `nums` in increasing order.\\n- We fix `nums[i], nums[j]` by iterating the combination of `nums[i], nums[j]`, then the problem now become to very classic problem **[1. Two Sum](https://leetcode.com/problems/two-sum/)**.\\n- By using two pointers, one points to `left`, the other points to `right`, `remain = target - nums[i] - nums[j]`.\\n\\t- If `nums[left] + nums[right] == remain`\\n\\t\\t- Found a valid quadruplets\\n\\t- Else if `nums[left] + nums[right] > remain`\\n\\t\\t- Sum is bigger than remain, need to decrease sum by `right -= 1`\\n\\t- Else:\\n\\t\\t- Increasing sum by `left += 1`.\\n\\n<iframe src=\"https://leetcode.com/playground/Dz7F3Sqw/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\nComplexity:\\n- Time: `O(N^3)`\\n- Extra Space (Without count output as space): `O(sorting)`\\n\\n---\\n**\\u2714\\uFE0F Follow-up question: Calculate K-Sum?**\\n\\n<iframe src=\"https://leetcode.com/playground/KUgSSN93/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nComplexity:\\n- Time: `O(NlogN + N^(k-1))`, where `k >= 2`, `N` is number of elements in the array `nums`.\\n- Extra space (Without count output as space): `O(N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: HashSet**\\n- The idea is to use `HashSet` to track past elements.\\n- We iterate the combinations of `nums[i]`, `nums[j]`, `nums[k]`, and calculate the last number by `lastNumber = target - nums[i] - nums[j] - nums[k]`. \\n- We check if `lastNumber` is existed the past by checking in the HashSet, if existed, then it form a `quadruplets` then add it to the answer.\\n\\nCredit @archit91 for providing C++ version.\\n<iframe src=\"https://leetcode.com/playground/BsiPbnLs/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: `O(N^3)`\\n- Extra Space (Without count output as space): `O(N)`\\n---\\n**\\u2714\\uFE0F Solution 2: Sort then Two Pointers**\\n- Sort `nums` in increasing order.\\n- We fix `nums[i], nums[j]` by iterating the combination of `nums[i], nums[j]`, then the problem now become to very classic problem **[1. Two Sum](https://leetcode.com/problems/two-sum/)**.\\n- By using two pointers, one points to `left`, the other points to `right`, `remain = target - nums[i] - nums[j]`.\\n\\t- If `nums[left] + nums[right] == remain`\\n\\t\\t- Found a valid quadruplets\\n\\t- Else if `nums[left] + nums[right] > remain`\\n\\t\\t- Sum is bigger than remain, need to decrease sum by `right -= 1`\\n\\t- Else:\\n\\t\\t- Increasing sum by `left += 1`.\\n\\n<iframe src=\"https://leetcode.com/playground/Dz7F3Sqw/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\nComplexity:\\n- Time: `O(N^3)`\\n- Extra Space (Without count output as space): `O(sorting)`\\n\\n---\\n**\\u2714\\uFE0F Follow-up question: Calculate K-Sum?**\\n\\n<iframe src=\"https://leetcode.com/playground/KUgSSN93/shared\" frameBorder=\"0\" width=\"100%\" height=\"600\"></iframe>\\n\\nComplexity:\\n- Time: `O(NlogN + N^(k-1))`, where `k >= 2`, `N` is number of elements in the array `nums`.\\n- Extra space (Without count output as space): `O(N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Java"
            },
            {
                "id": 3186501,
                "title": "best-c-3-solution-two-pointers-sorting-hash-table-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n2. Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\\n3. Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^4), Here Four nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                for(int k=j+1; k<n-1; k++){\\n                    for(int l=k+1; l<n; l++){\\n                        if((long long)nums[i] + (long long)nums[j] + (long long)nums[k] + \\n                        (long long)nums[l] == target){\\n                            set.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        set.insert({nums[i], nums[j], nums[low], nums[high]});\\n                        low++; high--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\\n                        int tempIndex1 = low, tempIndex2 = high;\\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                    }\\n                }\\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^4), Here Four nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                for(int k=j+1; k<n-1; k++){\\n                    for(int l=k+1; l<n; l++){\\n                        if((long long)nums[i] + (long long)nums[j] + (long long)nums[k] + \\n                        (long long)nums[l] == target){\\n                            set.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(N), Hash Table(set) space.\\n\\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> set;\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        set.insert({nums[i], nums[j], nums[low], nums[high]});\\n                        low++; high--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\\n    array(nums).\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\\n                        int tempIndex1 = low, tempIndex2 = high;\\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                    }\\n                }\\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8547,
                "title": "7ms-java-code-win-over-100",
                "content": "The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\t\\tArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tif (nums == null || len < 4)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tint max = nums[len - 1];\\n\\t\\t\\tif (4 * nums[0] > target || 4 * max < target)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > 0 && z == nums[i - 1])// avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 3 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (4 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (4 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 3 < len && nums[i + 3] == z)\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(z, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthreeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished three numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, the three numbers))\\n\\t\\t */\\n\\t\\tpublic void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1) {\\n\\t\\t\\tif (low + 1 >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint max = nums[high];\\n\\t\\t\\tif (3 * nums[low] > target || 3 * max < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = low; i < high - 1; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > low && z == nums[i - 1]) // avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 2 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (3 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tif (3 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 1 < high && nums[i + 2] == z)\\n\\t\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttwoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished two numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, z2, the two numbers))\\n\\t\\t */\\n\\t\\tpublic void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1, int z2) {\\n\\n\\t\\t\\tif (low >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif (2 * nums[low] > target || 2 * nums[high] < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i = low, j = high, sum, x;\\n\\t\\t\\twhile (i < j) {\\n\\t\\t\\t\\tsum = nums[i] + nums[j];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));\\n\\n\\t\\t\\t\\t\\tx = nums[i];\\n\\t\\t\\t\\t\\twhile (++i < j && x == nums[i]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t\\tx = nums[j];\\n\\t\\t\\t\\t\\twhile (i < --j && x == nums[j]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (sum > target)\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\t\\tArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tif (nums == null || len < 4)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tArrays.sort(nums);\\n\\n\\t\\t\\tint max = nums[len - 1];\\n\\t\\t\\tif (4 * nums[0] > target || 4 * max < target)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = 0; i < len; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > 0 && z == nums[i - 1])// avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 3 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (4 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tif (4 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 3 < len && nums[i + 3] == z)\\n\\t\\t\\t\\t\\t\\tres.add(Arrays.asList(z, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthreeSumForFourSum(nums, target - z, i + 1, len - 1, res, z);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished three numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, the three numbers))\\n\\t\\t */\\n\\t\\tpublic void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1) {\\n\\t\\t\\tif (low + 1 >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint max = nums[high];\\n\\t\\t\\tif (3 * nums[low] > target || 3 * max < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i, z;\\n\\t\\t\\tfor (i = low; i < high - 1; i++) {\\n\\t\\t\\t\\tz = nums[i];\\n\\t\\t\\t\\tif (i > low && z == nums[i - 1]) // avoid duplicate\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (z + 2 * max < target) // z is too small\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (3 * z > target) // z is too large\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tif (3 * z == target) { // z is the boundary\\n\\t\\t\\t\\t\\tif (i + 1 < high && nums[i + 2] == z)\\n\\t\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z, z, z));\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttwoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Find all possible distinguished two numbers adding up to the target\\n\\t\\t * in sorted array nums[] between indices low and high. If there are,\\n\\t\\t * add all of them into the ArrayList fourSumList, using\\n\\t\\t * fourSumList.add(Arrays.asList(z1, z2, the two numbers))\\n\\t\\t */\\n\\t\\tpublic void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList<List<Integer>> fourSumList,\\n\\t\\t\\t\\tint z1, int z2) {\\n\\n\\t\\t\\tif (low >= high)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif (2 * nums[low] > target || 2 * nums[high] < target)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint i = low, j = high, sum, x;\\n\\t\\t\\twhile (i < j) {\\n\\t\\t\\t\\tsum = nums[i] + nums[j];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tfourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j]));\\n\\n\\t\\t\\t\\t\\tx = nums[i];\\n\\t\\t\\t\\t\\twhile (++i < j && x == nums[i]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t\\tx = nums[j];\\n\\t\\t\\t\\t\\twhile (i < --j && x == nums[j]) // avoid duplicate\\n\\t\\t\\t\\t\\t\\t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif (sum > target)\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 8714,
                "title": "4sum-c-solution-with-explanation-and-comparison-with-3sum-problem-easy-to-understand",
                "content": "For the reference, please have a look at my explanation of `3Sum` problem because the algorithm are exactly the same. The link is as blow.\\n\\n[My 3Sum problem answer][1]\\n\\nThe key idea is to downgrade the problem to a `2Sum` problem eventually. And the same algorithm can be expand to `NSum` problem.\\n\\nAfter you had a look at my explanation of `3Sum`, the code below will be extremely easy to understand.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > fourSum(vector<int> &num, int target) {\\n        \\n            vector<vector<int> > res;\\n        \\n            if (num.empty())\\n                return res;\\n        \\n            std::sort(num.begin(),num.end());\\n        \\n            for (int i = 0; i < num.size(); i++) {\\n            \\n                int target_3 = target - num[i];\\n            \\n                for (int j = i + 1; j < num.size(); j++) {\\n                \\n                    int target_2 = target_3 - num[j];\\n                \\n                    int front = j + 1;\\n                    int back = num.size() - 1;\\n                \\n                    while(front < back) {\\n                    \\n                        int two_sum = num[front] + num[back];\\n                    \\n                        if (two_sum < target_2) front++;\\n                    \\n                        else if (two_sum > target_2) back--;\\n                    \\n                        else {\\n                        \\n                            vector<int> quadruplet(4, 0);\\n                            quadruplet[0] = num[i];\\n                            quadruplet[1] = num[j];\\n                            quadruplet[2] = num[front];\\n                            quadruplet[3] = num[back];\\n                            res.push_back(quadruplet);\\n                        \\n                            // Processing the duplicates of number 3\\n                            while (front < back && num[front] == quadruplet[2]) ++front;\\n                        \\n                            // Processing the duplicates of number 4\\n                            while (front < back && num[back] == quadruplet[3]) --back;\\n                    \\n                        }\\n                    }\\n                    \\n                    // Processing the duplicates of number 2\\n                    while(j + 1 < num.size() && num[j + 1] == num[j]) ++j;\\n                }\\n            \\n                // Processing the duplicates of number 1\\n                while (i + 1 < num.size() && num[i + 1] == num[i]) ++i;\\n            \\n            }\\n        \\n            return res;\\n        \\n        }\\n    };\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/23595/share-my-solution-around-50ms-with-explanation-and-comments",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > fourSum(vector<int> &num, int target) {\\n        \\n            vector<vector<int> > res;\\n        \\n            if (num.empty())\\n                return res;\\n        \\n            std::sort(num.begin(),num.end());\\n        \\n            for (int i = 0; i < num.size(); i++) {\\n            \\n                int target_3 = target - num[i];\\n            \\n                for (int j = i + 1; j < num.size(); j++) {\\n                \\n                    int target_2 = target_3 - num[j];\\n                \\n                    int front = j + 1;\\n                    int back = num.size() - 1;\\n                \\n                    while(front < back) {\\n                    \\n                        int two_sum = num[front] + num[back];\\n                    \\n                        if (two_sum < target_2) front++;\\n                    \\n                        else if (two_sum > target_2) back--;\\n                    \\n                        else {\\n                        \\n                            vector<int> quadruplet(4, 0);\\n                            quadruplet[0] = num[i];\\n                            quadruplet[1] = num[j];\\n                            quadruplet[2] = num[front];\\n                            quadruplet[3] = num[back];\\n                            res.push_back(quadruplet);\\n                        \\n                            // Processing the duplicates of number 3\\n                            while (front < back && num[front] == quadruplet[2]) ++front;\\n                        \\n                            // Processing the duplicates of number 4\\n                            while (front < back && num[back] == quadruplet[3]) --back;\\n                    \\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 8575,
                "title": "clean-accepted-java-o-n-3-solution-based-on-3sum",
                "content": "    public class Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        ArrayList<List<Integer>> ans = new ArrayList<>();\\n        if(num.length<4)return ans;\\n        Arrays.sort(num);\\n        for(int i=0; i<num.length-3; i++){\\n            if(num[i]+num[i+1]+num[i+2]+num[i+3]>target)break; //first candidate too large, search finished\\n            if(num[i]+num[num.length-1]+num[num.length-2]+num[num.length-3]<target)continue; //first candidate too small\\n            if(i>0&&num[i]==num[i-1])continue; //prevents duplicate result in ans list\\n            for(int j=i+1; j<num.length-2; j++){\\n                if(num[i]+num[j]+num[j+1]+num[j+2]>target)break; //second candidate too large\\n                if(num[i]+num[j]+num[num.length-1]+num[num.length-2]<target)continue; //second candidate too small\\n                if(j>i+1&&num[j]==num[j-1])continue; //prevents duplicate results in ans list\\n                int low=j+1, high=num.length-1;\\n                while(low<high){\\n                    int sum=num[i]+num[j]+num[low]+num[high];\\n                    if(sum==target){\\n                        ans.add(Arrays.asList(num[i], num[j], num[low], num[high]));\\n                        while(low<high&&num[low]==num[low+1])low++; //skipping over duplicate on low\\n                        while(low<high&&num[high]==num[high-1])high--; //skipping over duplicate on high\\n                        low++; \\n                        high--;\\n                    }\\n                    //move window\\n                    else if(sum<target)low++; \\n                    else high--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\nupdated with optimizations and comments",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        ArrayList<List<Integer>> ans = new ArrayList<>();\\n        if(num.length<4)return ans;\\n        Arrays.sort(num);\\n        for(int i=0; i<num.length-3; i++){\\n            if(num[i]+num[i+1]+num[i+2]+num[i+3]>target)break; //first candidate too large, search finished\\n            if(num[i]+num[num.length-1]+num[num.length-2]+num[num.length-3]<target)continue; //first candidate too small\\n            if(i>0&&num[i]==num[i-1])continue; //prevents duplicate result in ans list\\n            for(int j=i+1; j<num.length-2; j++){\\n                if(num[i]+num[j]+num[j+1]+num[j+2]>target)break; //second candidate too large\\n                if(num[i]+num[j]+num[num.length-1]+num[num.length-2]<target)continue; //second candidate too small\\n                if(j>i+1&&num[j]==num[j-1])continue; //prevents duplicate results in ans list\\n                int low=j+1, high=num.length-1;\\n                while(low<high){\\n                    int sum=num[i]+num[j]+num[low]+num[high];\\n                    if(sum==target){\\n                        ans.add(Arrays.asList(num[i], num[j], num[low], num[high]));\\n                        while(low<high&&num[low]==num[low+1])low++; //skipping over duplicate on low\\n                        while(low<high&&num[high]==num[high-1])high--; //skipping over duplicate on high\\n                        low++; \\n                        high--;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 737096,
                "title": "sum-megapost-python3-solution-with-a-detailed-explanation",
                "content": "If you\\'re a newbie and sometimes have a hard time understanding the logic. Don\\'t worry, you\\'ll catch up after a month of doing Leetcode on a daily basis. Try to do it, even one example per day. It\\'d help. I\\'ve compiled a bunch on `sum` problems here, go ahead and check it out. Also, I think focusing on a subject and do 3-4 problems would help to get the idea behind solution since they mostly follow the same logic. Of course there are other ways to solve each problems but I try to be as uniform as possible. Good luck. \\n\\nIn general, `sum` problems can be categorized into two categories: 1) there is any array and you add some numbers to get to (or close to) a `target`, or 2) you need to return indices of numbers that sum up to a (or close to) a `target` value.  Note that when the problem is looking for a indices, `sort`ing the array is probably NOT a good idea. \\n\\n\\n **[Two Sum:](https://leetcode.com/problems/two-sum/)**  \\n \\n This is the second type of the problems where we\\'re looking for indices, so sorting is not necessary. What you\\'d want to do is to go over the array, and try to find two integers that sum up to  a `target` value. Most of the times, in such a problem, using dictionary (hastable) helps. You try to keep track of you\\'ve observations in a dictionary and use it once you get to the results. \\n\\nNote: try to be comfortable to use `enumerate` as it\\'s sometime out of comfort zone for newbies. `enumerate` comes handy in a lot of problems (I mean if you want to have a cleaner code of course). If I had to choose three built in functions/methods that I wasn\\'t comfortable with at the start and have found them super helpful, I\\'d probably say `enumerate`, `zip` and `set`. \\n \\nSolution: In this problem, you initialize a dictionary (`seen`). This dictionary will keep track of numbers (as `key`) and indices (as `value`). So, you go over your array (line `#1`) using `enumerate` that gives you both index and value of elements in array. As an example, let\\'s do `nums = [2,3,1]` and `target = 3`. Let\\'s say you\\'re at index `i = 0` and `value = 2`, ok? you need to find `value = 1` to finish the problem, meaning, `target - 2 = 1`. 1 here is the `remaining`. Since `remaining + value = target`, you\\'re done once you found it, right? So when going through the array, you calculate the `remaining` and check to see whether `remaining` is in the `seen` dictionary (line `#3`). If it is, you\\'re done! you\\'re current number and the remaining from `seen` would give you the output (line `#4`). Otherwise, you add your current number to the dictionary (line `#5`) since it\\'s going to be a `remaining` for (probably) a number you\\'ll see in the future assuming that there is at least one instance of answer.  \\n \\n \\n ```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\\n \\n \\n\\n **[Two Sum II:](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)**  \\n\\nFor this, you can do exactly as the previous. The only change I made below was to change the order of line `#4`. In the previous example, the order didn\\'t matter. But, here the problem asks for asending order and since the values/indicess in `seen` has always lower indices than your current number, it should come first.  Also, note that the problem says it\\'s not zero based, meaning that indices don\\'t start from zero, that\\'s why I added 1 to both of them. \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\\n\\nAnother approach to solve this problem (probably what Leetcode is looking for) is to treat it as first category of problems. Since the array is already sorted, this works. You see the following approach in a lot of problems. What you want to do is to have two pointer (if it was 3sum, you\\'d need three pointers as you\\'ll see in the future examples). One pointer move from `left` and one from `right`. Let\\'s say you `numbers = [1,3,6,9]` and your `target = 10`. Now, `left` points to 1 at first, and  `right` points to 9. There are three possibilities. If you sum numbers that `left` and `right` are pointing at, you get `temp_sum` (line `#1`). If `temp_sum` is your target, you\\'r done! You\\'re return it (line `#9`). If it\\'s more than your `target`, it means that `right` is poiting to a very large value (line `#5`) and you need to bring it a little bit to the left to a smaller (r maybe equal) value (line `#6`)  by adding one to the index . If the `temp_sum` is less than `target` (line `#7`), then you need to move your `left` to a little bit larger value by adding one to the index (line `#9`). This way, you try to narrow down the range in which you\\'re looking at and will eventually find a couple of number that sum to `target`, then, you\\'ll return this in line `#9`. In this problem, since it says there is only one solution, nothing extra is necessary. However, when a problem asks to return all combinations that sum to `target`, you can\\'t simply return the first instace and you need to collect all the possibilities and return the list altogether (you\\'ll see something like this in the next example). \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\\n\\n\\n\\n\\n[**3Sum**](https://leetcode.com/problems/3sum/)\\n\\nThis is similar to the previous example except that it\\'s looking for three numbers. There are some minor differences in the problem statement. It\\'s looking for all combinations (not just one) of solutions returned as a list. And second, it\\'s looking for unique combination, repeatation is not allowed. \\n\\nHere, instead of looping (line `#1`) to `len(nums) -1`, we loop to `len(nums) -2` since we\\'re looking for three numbers. Since we\\'re returning values, `sort` would be a good idea. Otherwise, if the `nums` is not sorted, you cannot reducing `right` pointer or increasing `left` pointer easily, makes sense? \\n\\nSo, first you `sort` the array and define `res = []` to collect your outputs. In line `#2`, we check wether two consecutive elements are equal or not because if they are, we don\\'t want them (solutions need to be unique) and will skip to the next set of numbers. Also, there is an additional constrain in this line that `i > 0`. This is added to take care of cases like `nums = [1,1,1]` and `target = 3`. If we didn\\'t have `i > 0`, then we\\'d skip the only correct solution and would return `[]` as our answer which is wrong (correct answer is `[[1,1,1]]`.  \\n\\nWe define two additional pointers this time, `left = i + 1` and `right = len(nums) - 1`. For example, if `nums = [-2,-1,0,1,2]`, all the points in the case of `i=1` are looking at: `i` at `-1`, `left` at `0` and `right` at `2`. We then check `temp` variable similar to the previous example. There is only one change with respect to the previous example here between lines `#5` and `#10`.  If we have the `temp = target`, we obviously add this set to the `res` in line `#5`, right? However, we\\'re not done yet. For a fixed `i`, we still need to check and see whether there are other combinations by just changing `left` and `right` pointers. That\\'s what we are doing in lines `#6, 7, 8`. If we still have the condition of `left < right` and `nums[left]` and the number to the right of it are not the same, we move `left` one index to right (line `#6`). Similarly, if `nums[right]` and the value to left of it is not the same, we move `right` one index to left. This way for a fixed `i`, we get rid of repeative cases. For example, if `nums = [-3, 1,1, 3,5]` and `target = 3`, one we get the first `[-3,1,5]`, `left = 1`, but, `nums[2]` is also 1 which we don\\'t want the `left` variable to look at it simply because it\\'d again return `[-3,1,5]`, right? So, we move `left` one index. Finally, if the repeating elements don\\'t exists, lines `#6` to `#8` won\\'t get activated. In this case we still need to move forward by adding 1 to `left` and extracting 1 from `right` (lines `#9, 10`). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\\n\\nAnother way to solve this problem is to change it into a two sum problem. Instead of finding `a+b+c = 0`, you can find `a+b = -c` where we want to find two numbers `a` and `b` that are equal to `-c`, right? This is similar to the first problem. Remember if you wanted to use the exact same as the first code, it\\'d return indices and not numbers. Also, we need to re-arrage this problem in a way that we have `nums` and `target`. This code is not a good code and can be optimipized but you got the idea. For a better version of this, check [this](https://leetcode.com/problems/3sum/discuss/7384/My-Python-solution-based-on-2-sum-200-ms-beat-93.37). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\\n\\n[**4Sum**](https://leetcode.com/problems/4sum/)\\n\\nYou should have gotten the idea, and what you\\'ve seen so far can be generalized to `nSum`. Here, I write the generic code using the same ideas as before. What I\\'ll do is to break down each case to a `2Sum II` problem, and solve them recursively using the approach in `2Sum II` example above. \\n\\nFirst sort `nums`, then I\\'m using two extra functions, `helper` and `twoSum`. The `twoSum` is similar to the `2sum II` example with some modifications. It doesn\\'t return the first instance of results, it check every possible combinations and return all of them now. Basically, now it\\'s more similar to the `3Sum` solution. Understanding this function shouldn\\'t be difficult as it\\'s very similar to `3Sum`. As for `helper` function, it first tries to check for cases that don\\'t work (line `#1`). And later, if the `N` we need to sum to get to a `target` is 2 (line `#2`), then runs the `twoSum` function. For the more than two numbers, it recursively breaks them down to two sum (line `#3`). There are some cases like line `#4` that we don\\'t need to proceed with the algorithm anymore and we can `break`. These cases include if multiplying the lowest number in the list by `N` is more than `target`. Since its sorted array, if this happens, we can\\'t find any result. Also, if the largest array (`nums[-1]`) multiplied by `N` would be less than `target`, we can\\'t find any solution. So, `break`. \\n\\n\\nFor other cases, we run the `helper` function again with new inputs, and we keep doing it until we get to `N=2` in which we use `twoSum` function, and add the results to get the final output. \\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\\n\\n[**Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\nI don\\'t post combination sum here since it\\'s basically this problem a little bit easier. \\nCombination questions can be solved with `dfs` most of the time. if you want to fully understand this concept and [backtracking](https://www.***.org/backtracking-introduction/), try to finish [this](https://leetcode.com/problems/combination-sum/discuss/429538/General-Backtracking-questions-solutions-in-Python-for-reference-%3A) post and do all the examples. \\n\\nRead my older post first [here](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation). This should give you a better idea of what\\'s going on. The solution here also follow the exact same format except for some minor changes. I first made a minor change in the `dfs` function where it doesn\\'t need the `index` parameter anymore. This is taken care of by `candidates[i+1:]` in line `#3`. Note that we had `candidates` here in the previous post. \\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```\\n\\n\\nThe only differences are lines `#1, 2, 3`. The difference in problem statement in this one and `combinations` problem of my previous post is >>>candidates must be used once<<< and lines `#1` and `2` are here to take care of this.  Line `#1` has two components where first `i > 0` and second `candidates[i] == candidates[i-1]`. The second component `candidates[i] == candidates[i-1]` is to take care of duplicates in the `candidates` variable as was instructed in the problem statement. Basically, if the next number in `candidates` is the same as the previous one, it means that it has already been taken care of, so `continue`. The first component takes care of cases like an input  `candidates = [1]` with `target = 1` (try to remove this component and submit your solution. You\\'ll see what I mean). The rest is similar to the previous [post](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation)\\n\\n\\n\\n================================================================\\nFinal note: Please let me know if you found any typo/error/ect. I\\'ll try to fix them.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8653,
                "title": "on-average-o-n-2-and-worst-case-o-n-3-java-solution-by-reducing-4sum-to-2sum",
                "content": "Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result.\\n\\nTime complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3).  Here is the complete code in java:\\n\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        Arrays.sort(num);\\n        \\n        Map<Integer, List<int[]>> twoSumMap = new HashMap<>(); // for holding visited pair sums. All pairs with the same pair sum are grouped together\\n        Set<List<Integer>> res = new HashSet<>();  // for holding the results\\n        \\n        for (int i = 0; i < num.length; i++) {\\n        \\t// get rid of repeated pair sums\\n            if (i > 1 && num[i] == num[i - 2]) continue;\\n        \\t\\n            for (int j = i + 1; j < num.length; j++) {\\n                // get rid of repeated pair sums\\n                if (j > i + 2 && num[j] == num[j - 2]) continue;\\n\\n                // for each pair sum, check if the pair sum that is needed to get the target has been visited.            \\t\\n                if (twoSumMap.containsKey(target - (num[i] + num[j]))) {   \\n                    // if so, get all the pairs that contribute to this visited pair sum.\\n            \\tList<int[]> ls = twoSumMap.get(target - (num[i] + num[j]));\\n            \\t\\t\\n            \\tfor (int[] pair : ls) {\\n            \\t    // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j).\\n            \\t    // we first need to check if they are overlapping with each other.\\n            \\t    int m1 = Math.min(pair[0], i);  // m1 will always be the smallest index\\n                        int m2 = Math.min(pair[1], j);  // m2 will be one of the middle two indices\\n                        int m3 = Math.max(pair[0], i);  // m3 will be one of the middle two indices\\n                        int m4 = Math.max(pair[1], j);  // m4 will always be the largest index\\n                        \\n                        if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue;  // two pairs are overlapping, so just ignore this case\\n     \\t\\t    \\n     \\t\\t    res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4]));  // else record the result\\n            \\t}\\n                }\\n                \\n                // mark that we have visited current pair and add it to the corrsponding pair sum group.\\n                // here we've encoded the pair indices i and j into an integer array of length 2.\\n                twoSumMap.computeIfAbsent(num[i] + num[j], key -> new ArrayList<>()).add(new int[] {i, j});\\n            }\\n        }\\n        \\n        return new ArrayList<List<Integer>>(res);\\n    }",
                "solutionTags": [],
                "code": "Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result.\\n\\nTime complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3).  Here is the complete code in java:\\n\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n        Arrays.sort(num);\\n        \\n        Map<Integer, List<int[]>> twoSumMap = new HashMap<>(); // for holding visited pair sums. All pairs with the same pair sum are grouped together\\n        Set<List<Integer>> res = new HashSet<>();  // for holding the results\\n        \\n        for (int i = 0; i < num.length; i++) {\\n        \\t// get rid of repeated pair sums\\n            if (i > 1 && num[i] == num[i - 2]) continue;\\n        \\t\\n            for (int j = i + 1; j < num.length; j++) {\\n                // get rid of repeated pair sums\\n                if (j > i + 2 && num[j] == num[j - 2]) continue;\\n\\n                // for each pair sum, check if the pair sum that is needed to get the target has been visited.            \\t\\n                if (twoSumMap.containsKey(target - (num[i] + num[j]))) {   \\n                    // if so, get all the pairs that contribute to this visited pair sum.\\n            \\tList<int[]> ls = twoSumMap.get(target - (num[i] + num[j]));\\n            \\t\\t\\n            \\tfor (int[] pair : ls) {\\n            \\t    // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j).\\n            \\t    // we first need to check if they are overlapping with each other.\\n            \\t    int m1 = Math.min(pair[0], i);  // m1 will always be the smallest index\\n                        int m2 = Math.min(pair[1], j);  // m2 will be one of the middle two indices\\n                        int m3 = Math.max(pair[0], i);  // m3 will be one of the middle two indices\\n                        int m4 = Math.max(pair[1], j);  // m4 will always be the largest index\\n                        \\n                        if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue;  // two pairs are overlapping, so just ignore this case\\n     \\t\\t    \\n     \\t\\t    res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4]));  // else record the result\\n            \\t}\\n                }\\n                \\n                // mark that we have visited current pair and add it to the corrsponding pair sum group.\\n                // here we've encoded the pair indices i and j into an integer array of length 2.\\n                twoSumMap.computeIfAbsent(num[i] + num[j], key -> new ArrayList<>()).add(new int[] {i, j});\\n            }\\n        }\\n        \\n        return new ArrayList<List<Integer>>(res);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3110025,
                "title": "c-easiest-beginner-friendly-sol-set-two-pointer-approach-o-n-3-time-and-o-n-space",
                "content": "# Intuition of this Problem:\\nSet is used to prevent duplicate quadruplets and parallely we will use two pointer approach to maintain k and l.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Sort the input array of integers nums.\\n2. Initialize an empty set s, and an empty 2D vector output.\\n3. Use nested loops to iterate through all possible combinations of quadruplets in nums.\\n4. For each combination, use two pointers (k and l) to traverse the sub-array between the second and second-to-last elements of the combination.\\n5. At each iteration of the innermost while loop, calculate the sum of the current quadruplet and check if it is equal to the target.\\n6. If the sum is equal to the target, insert the quadruplet into the set s and increment both pointers (k and l).\\n7. If the sum is less than the target, increment the pointer k.\\n8. If the sum is greater than the target, decrement the pointer l.\\n9. After all quadruplets have been checked, iterate through the set s and add each quadruplet to the output vector.\\n10. Return the output vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n//Optimized Approach using two pointer - O(n^3) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                int k = j + 1;\\n                int l = nums.size() - 1;\\n                while (k < l) {\\n                    //by writing below 4 statement this way it will not give runtime error\\n                    long long int sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\\n```C++ []\\n//Brute force Approach - O(n^4) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                for(int k = j+1; k < nums.size(); k++){\\n                    for(int l = k+1; l < nums.size(); l++){\\n                        vector<int> temp;\\n                        if(nums[i] + nums[j] + nums[k] + nums[l] == target){\\n                            temp.push_back(nums[i]);\\n                            temp.push_back(nums[j]);\\n                            temp.push_back(nums[k]);\\n                            temp.push_back(nums[l]);\\n                            s.insert(temp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\\n```C++ []\\n// this peice of code will give runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' for below test case\\nnums = [1000000000,1000000000,1000000000,1000000000]\\ntarget = 0\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                int k = j + 1;\\n                int l = nums.size() - 1;\\n                while (k < l) {\\n                    //for below statement it will give runtime error\\n                    long long int sum = nums[i] + nums[j] + nums[k] + nums[l];\\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> s = new HashSet<>();\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while (k < l) {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        output.addAll(s);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                k = j + 1\\n                l = len(nums) - 1\\n                while k < l:\\n                    sum = nums[i] + nums[j] + nums[k] + nums[l]\\n                    if sum == target:\\n                        s.add((nums[i], nums[j], nums[k], nums[l]))\\n                        k += 1\\n                        l -= 1\\n                    elif sum < target:\\n                        k += 1\\n                    else:\\n                        l -= 1\\n        output = list(s)\\n        return output\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n^3)** // where n is the size of array\\n\\nThe outer two loops have a time complexity of O(n^2) and the inner while loop has a time complexity of O(n). The total time complexity is therefore O(n^2) * O(n) = O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n\\nThe set s stores all unique quadruplets, which in the worst case scenario is O(n).\\nThe output vector stores the final output, which is also O(n).\\nThe total space complexity is therefore O(n) + O(n) = O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers"
                ],
                "code": "```C++ []\\n//Optimized Approach using two pointer - O(n^3) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                int k = j + 1;\\n                int l = nums.size() - 1;\\n                while (k < l) {\\n                    //by writing below 4 statement this way it will not give runtime error\\n                    long long int sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\n```C++ []\\n//Brute force Approach - O(n^4) time and O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                for(int k = j+1; k < nums.size(); k++){\\n                    for(int l = k+1; l < nums.size(); l++){\\n                        vector<int> temp;\\n                        if(nums[i] + nums[j] + nums[k] + nums[l] == target){\\n                            temp.push_back(nums[i]);\\n                            temp.push_back(nums[j]);\\n                            temp.push_back(nums[k]);\\n                            temp.push_back(nums[l]);\\n                            s.insert(temp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\n```C++ []\\n// this peice of code will give runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' for below test case\\nnums = [1000000000,1000000000,1000000000,1000000000]\\ntarget = 0\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        for (int i = 0; i < nums.size(); i++){\\n            for(int j = i+1; j < nums.size(); j++){\\n                int k = j + 1;\\n                int l = nums.size() - 1;\\n                while (k < l) {\\n                    //for below statement it will give runtime error\\n                    long long int sum = nums[i] + nums[j] + nums[k] + nums[l];\\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[k], nums[l]});\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        for(auto quadruplets : s)\\n            output.push_back(quadruplets);\\n        return output;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> s = new HashSet<>();\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while (k < l) {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        s.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n                        k++;\\n                        l--;\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        output.addAll(s);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        output = []\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                k = j + 1\\n                l = len(nums) - 1\\n                while k < l:\\n                    sum = nums[i] + nums[j] + nums[k] + nums[l]\\n                    if sum == target:\\n                        s.add((nums[i], nums[j], nums[k], nums[l]))\\n                        k += 1\\n                        l -= 1\\n                    elif sum < target:\\n                        k += 1\\n                    else:\\n                        l -= 1\\n        output = list(s)\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341243,
                "title": "python-o-n-3-and-why-we-can-not-do-better-explained",
                "content": "In this problem we are asked to find not one 4-sum with sum equal to `target`, but all of them. If we were asked to find only one sum, there is `O(n^2)` solution: create array of pairs and then try to find the new pair is equal to `target` minus sums of two numbers. However we need to return all sums and imagine the case `nums = [1, 2, 3, ..., n]`. Then there will be `C_n^4 = O(n^4)` different ways to choose `4` number out of `n` and all sums are in range `[4, 4n]`. It means, that by pingenhole principle there will be some sum which we meet `Omega(n^3)` times, that is `>= alpha*n^3` for some constant alpha.\\n\\nSo, in general case we can have only `O(n^3)` solution (though with small constant, like 1/6) which allows us to pass problem constraints. The idea is exaclty the same as in other **2Sum** problems: sort numbers, choose `i` and `j` and then use two pointers approach to get solutions.\\n\\n#### Complexity\\nWe need to choose `i` and `j` with complexity `O(n^2)` and then for each choosen pair use two-pointers approach so we have `O(n^3)` total complexity. Space complexity is `O(n)` to keep sorted data.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), []\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                goal = target - nums[i] - nums[j]\\n                beg, end = j + 1, n - 1\\n\\n                while beg < end:\\n                    if nums[beg] + nums[end] < goal:\\n                        beg += 1\\n                    elif nums[beg] + nums[end] > goal:\\n                        end -= 1\\n                    else:\\n                        ans.append((nums[i], nums[j], nums[beg], nums[end]))\\n                        beg += 1\\n                        end -= 1\\n\\n        return set(ans)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fourSum(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), []\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                goal = target - nums[i] - nums[j]\\n                beg, end = j + 1, n - 1\\n\\n                while beg < end:\\n                    if nums[beg] + nums[end] < goal:\\n                        beg += 1\\n                    elif nums[beg] + nums[end] > goal:\\n                        end -= 1\\n                    else:\\n                        ans.append((nums[i], nums[j], nums[beg], nums[end]))\\n                        beg += 1\\n                        end -= 1\\n\\n        return set(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128591,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        d = dict()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                sum2 = nums[i]+nums[j]\\n                if sum2 in d:\\n                    d[sum2].append((i,j))\\n                else:\\n                    d[sum2] = [(i,j)]\\n        \\n        result = set()\\n        for key in d:\\n            value = target - key\\n            if value in d:\\n                list1 = d[key]\\n                list2 = d[value]\\n                for (i,j) in list1:\\n                    for (k,l) in list2:\\n                        if i!=k and i!=l and j!=k and j!=l:\\n                            flist = [nums[i],nums[j],nums[k],nums[l]]\\n                            flist.sort()\\n                            result.add(tuple(flist))\\n        return list(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        d = dict()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                sum2 = nums[i]+nums[j]\\n                if sum2 in d:\\n                    d[sum2].append((i,j))\\n                else:\\n                    d[sum2] = [(i,j)]\\n        \\n        result = set()\\n        for key in d:\\n            value = target - key\\n            if value in d:\\n                list1 = d[key]\\n                list2 = d[value]\\n                for (i,j) in list1:\\n                    for (k,l) in list2:\\n                        if i!=k and i!=l and j!=k and j!=l:\\n                            flist = [nums[i],nums[j],nums[k],nums[l]]\\n                            flist.sort()\\n                            result.add(tuple(flist))\\n        return list(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363031,
                "title": "c-short-easy-two-pointers-solution",
                "content": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();  \\n        sort(nums.begin() , nums.end());  // sort the array to use the two pointers method\\n        vector<vector<int>> ans;  \\n        set<vector<int>> store;   // to store and remove the duplicate answers\\n\\t\\t\\n        for(int i = 0 ; i < n; i++){\\n\\t\\t\\n            for(int j = i + 1; j < n ; j++){\\n\\t\\t\\t\\n                int new_target  =  target - nums[i] - nums[j];\\n                \\n                int x = j+1 , y = n-1;\\n                \\n                while(x < y){\\n\\t\\t\\t\\t\\n                    int sum = nums[x] + nums[y];\\n                    \\n                    if(sum > new_target) y--;\\n                    else if(sum < new_target ) x++;\\n                    else  {\\n                        store.insert({nums[i] , nums[j] , nums[x] , nums[y]});\\n                        x++;\\n                        y--;\\n                    };\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(auto i : store){\\n            ans.push_back(i);  // store the answers in an array(ans)\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();  \\n        sort(nums.begin() , nums.end());  // sort the array to use the two pointers method\\n        vector<vector<int>> ans;  \\n        set<vector<int>> store;   // to store and remove the duplicate answers\\n\\t\\t\\n        for(int i = 0 ; i < n; i++){\\n\\t\\t\\n            for(int j = i + 1; j < n ; j++){\\n\\t\\t\\t\\n                int new_target  =  target - nums[i] - nums[j];\\n                \\n                int x = j+1 , y = n-1;\\n                \\n                while(x < y){\\n\\t\\t\\t\\t\\n                    int sum = nums[x] + nums[y];\\n                    \\n                    if(sum > new_target) y--;\\n                    else if(sum < new_target ) x++;\\n                    else  {\\n                        store.insert({nums[i] , nums[j] , nums[x] , nums[y]});\\n                        x++;\\n                        y--;\\n                    };\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(auto i : store){\\n            ans.push_back(i);  // store the answers in an array(ans)\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8628,
                "title": "my-c-solution-using-hashtable",
                "content": "My idea is to sort num first, then build a hashtable with the key as the sum of the pair and the value as a  vector storing all pairs of index of num that having the same sum. In this way, all elements stored in hashtable has a order that duplicate pairs are neighbors. Therefore scanning the vector in the hashtable we only put non duplicate elements into the final answer vvi.\\n\\nIs this method O(n^2) ? or Does anyone can improve it to O(n^2);\\n\\n\\n\\n        class Solution{ //using hashtable, avg O(n^2)\\n    \\n    public:\\n    \\n        vector<vector<int> > fourSum(vector<int> &num, int target){\\n            vector<vector<int> > vvi;\\n            int n = num.size();\\n            if(n < 4) return  vvi;\\n            \\n            sort(num.begin(), num.end());        \\n            unordered_map<int, vector<pair<int, int>> > mp;\\n            for(int i = 0; i < n; i++){\\n                for(int j = i + 1; j < n; j++){\\n                    mp[num[i]+num[j]].push_back(make_pair(i,j));\\n                }\\n            }\\n            \\n            for(int i = 0; i < n; i++){\\n                if(i>0 && num[i] == num[i-1]) continue;\\n                for(int j = i + 1; j < n; j++){\\n                    if(j > i + 1 && num[j] == num[j-1]) continue;\\n                    int res = target - num[i] - num[j];\\n                    if(mp.count(res)){\\n                        for(auto it = mp[res].begin(); it != mp[res].end(); it++){\\n                            int k = (*it).first, l = (*it).second;\\n                            if(k > j){ // k>j make sure that the second pair has bigger values than the first pair.\\n                                if(!vvi.empty() && num[i]==vvi.back()[0] && num[j]==vvi.back()[1]\\n                                && num[k]==vvi.back()[2] && num[l] == vvi.back()[3]){\\n                                    continue; //if the obtained 4 elements are the same as previous one continue to next\\n                                }\\n                                vector<int> vi={num[i], num[j], num[k], num[l]};\\n                                vvi.push_back(vi);\\n                            } // if k>j\\n                            \\n                        }//for it\\n                    }//if\\n                }// forj\\n            }//for i\\n            return vvi;\\n        }\\n      };",
                "solutionTags": [],
                "code": "class Solution{ //using hashtable, avg O(n^2)\\n    \\n    public:\\n    \\n        vector<vector<int> > fourSum(vector<int> &num, int target){\\n            vector<vector<int> > vvi;\\n            int n = num.size();\\n            if(n < 4) return  vvi;\\n            \\n            sort(num.begin(), num.end());        \\n            unordered_map<int, vector<pair<int, int>> > mp;\\n            for(int i = 0; i < n; i++){\\n                for(int j = i + 1; j < n; j++){\\n                    mp[num[i]+num[j]].push_back(make_pair(i,j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1328067,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\\n        let len = nums.count\\n        guard len >= 4 else { return [] }\\n        \\n        var result = [[Int]]()\\n        let sort = nums.sorted()\\n        \\n        for a in 0..<(len - 1) where a == 0 || sort[a] != sort[a-1] {\\n            for b in (a + 1)..<len where b == a + 1 || sort[b] != sort[b-1] {\\n                var c = b + 1, d = len - 1\\n                while c < d {\\n                    let val = (a: sort[a], b: sort[b], c: sort[c], d: sort[d])\\n                    let sum = (val.a + val.b + val.c + val.d)\\n                    if sum == target { result.append([val.a,val.b,val.c,val.d]) }\\n                    if sum < target {\\n                        while sort[c] == val.c, c < d { c += 1 }\\n                    } else {\\n                        while sort[d] == val.d, d > b { d -= 1 }\\n                    }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.fourSum([1,0,-1,0,-2,2], 0)\\n        XCTAssertEqual(value, [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]])\\n    }\\n    func test1() {\\n        let value = solution.fourSum([2,2,2,2,2], 8)\\n        XCTAssertEqual(value, [[2,2,2,2]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\\n        let len = nums.count\\n        guard len >= 4 else { return [] }\\n        \\n        var result = [[Int]]()\\n        let sort = nums.sorted()\\n        \\n        for a in 0..<(len - 1) where a == 0 || sort[a] != sort[a-1] {\\n            for b in (a + 1)..<len where b == a + 1 || sort[b] != sort[b-1] {\\n                var c = b + 1, d = len - 1\\n                while c < d {\\n                    let val = (a: sort[a], b: sort[b], c: sort[c], d: sort[d])\\n                    let sum = (val.a + val.b + val.c + val.d)\\n                    if sum == target { result.append([val.a,val.b,val.c,val.d]) }\\n                    if sum < target {\\n                        while sort[c] == val.c, c < d { c += 1 }\\n                    } else {\\n                        while sort[d] == val.d, d > b { d -= 1 }\\n                    }\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.fourSum([1,0,-1,0,-2,2], 0)\\n        XCTAssertEqual(value, [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]])\\n    }\\n    func test1() {\\n        let value = solution.fourSum([2,2,2,2,2], 8)\\n        XCTAssertEqual(value, [[2,2,2,2]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290604,
                "title": "c-beats-96-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** We will fix two-pointers and then find the remaining two elements using two pointer technique as the array will be sorted at first.\\n\\n**Approach:**\\n* Sort the array, and then fix two pointers, so the remaining sum will be (target \\u2013 (nums[i] + nums[j])). \\n* Now we can fix two-pointers, one front, and another back, and easily use a two-pointer to find the remaining two numbers of the quad. \\n* In order to avoid duplications, we jump the duplicates, because taking duplicates will result in repeating quads. \\n* We can easily jump duplicates, by skipping the same elements by running a loop.\\n\\n```\\n// Input => arr[] = [4,3,3,4,4,2,1,2,1,1], target = 9\\n// Output => [[1,1,3,4],[1,2,2,4],[1,2,3,3]]\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> res;\\n        \\n        if(nums.empty())\\n            return res;\\n        \\n        int n = nums.size();\\n        \\n        // Approach requires sorting and 2-pointer approach\\n        \\n        // Step1 -> sorting\\n        sort(nums.begin(),nums.end());\\n        \\n        \\n        // Step2 -> 2-pointer \\n        for(int i=0; i<n; i++)\\n        {\\n            long long int target3 = target - nums[i];\\n            \\n            for(int j=i+1; j<n; j++)\\n            {\\n                long long int target2 = target3 - nums[j];\\n                \\n                int front = j+1;\\n                int back = n-1;\\n                \\n                while(front<back)\\n                {\\n                    // remaining elements to be found for quad sum\\n                    int two_sum = nums[front] + nums[back];\\n                    \\n                    if(two_sum < target2)\\n                        front++;\\n                    else if(two_sum > target2)\\n                        back--;\\n                    \\n                    else\\n                    {\\n                        // if two_sum == target2\\n                        vector<int> quad(4,0);\\n                        // quad.push_back(nums[i]);\\n                        // quad.push_back(nums[j]);\\n                        // quad.push_back(nums[front]);\\n                        // quad.push_back(nums[back]);\\n                        quad[0] = nums[i];\\n                        quad[1] = nums[j];\\n                        quad[2] = nums[front];\\n                        quad[3] = nums[back];\\n                        \\n                        \\n                        res.push_back(quad);\\n                        \\n                        // Processing the duplicates of number 3\\n                        while(front < back && nums[front] == quad[2]) \\n                            front++;\\n                        \\n                        // Processing the duplicates of number 4\\n                        while(front < back && nums[back] == quad[3]) \\n                            back--;\\n                    }\\n                    \\n                }\\n                // Processing the duplicates of number 2\\n                    while(j + 1 < n && nums[j + 1] == nums[j]) \\n                        j++;\\n            }\\n            // Processing the duplicates of number 2\\n                    while(i + 1 < n && nums[i + 1] == nums[i]) \\n                        i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Input => arr[] = [4,3,3,4,4,2,1,2,1,1], target = 9\\n// Output => [[1,1,3,4],[1,2,2,4],[1,2,3,3]]\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> res;\\n        \\n        if(nums.empty())\\n            return res;\\n        \\n        int n = nums.size();\\n        \\n        // Approach requires sorting and 2-pointer approach\\n        \\n        // Step1 -> sorting\\n        sort(nums.begin(),nums.end());\\n        \\n        \\n        // Step2 -> 2-pointer \\n        for(int i=0; i<n; i++)\\n        {\\n            long long int target3 = target - nums[i];\\n            \\n            for(int j=i+1; j<n; j++)\\n            {\\n                long long int target2 = target3 - nums[j];\\n                \\n                int front = j+1;\\n                int back = n-1;\\n                \\n                while(front<back)\\n                {\\n                    // remaining elements to be found for quad sum\\n                    int two_sum = nums[front] + nums[back];\\n                    \\n                    if(two_sum < target2)\\n                        front++;\\n                    else if(two_sum > target2)\\n                        back--;\\n                    \\n                    else\\n                    {\\n                        // if two_sum == target2\\n                        vector<int> quad(4,0);\\n                        // quad.push_back(nums[i]);\\n                        // quad.push_back(nums[j]);\\n                        // quad.push_back(nums[front]);\\n                        // quad.push_back(nums[back]);\\n                        quad[0] = nums[i];\\n                        quad[1] = nums[j];\\n                        quad[2] = nums[front];\\n                        quad[3] = nums[back];\\n                        \\n                        \\n                        res.push_back(quad);\\n                        \\n                        // Processing the duplicates of number 3\\n                        while(front < back && nums[front] == quad[2]) \\n                            front++;\\n                        \\n                        // Processing the duplicates of number 4\\n                        while(front < back && nums[back] == quad[3]) \\n                            back--;\\n                    }\\n                    \\n                }\\n                // Processing the duplicates of number 2\\n                    while(j + 1 < n && nums[j + 1] == nums[j]) \\n                        j++;\\n            }\\n            // Processing the duplicates of number 2\\n                    while(i + 1 < n && nums[i + 1] == nums[i]) \\n                        i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8555,
                "title": "20-line-elegant-accepted-java-solution-using-backtracking",
                "content": "The key idea is using backtracking. But before each step, I checked the eligibility of i-th element in the array before adding it to the subset list. Basically a lower and an upper boundaries were added to each backtracking step.\\n```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if(nums == null || nums.length == 0) return ans;\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        getSum(nums, 0, target, ans, list, 0);\\n        return ans;\\n    }\\n    private void getSum(int[] nums, int sum, int target, List<List<Integer>> ans, List<Integer> list, int pos){\\n        if(list.size() == 4 && sum == target && !ans.contains(list)){\\n            ans.add(new ArrayList<>(list)); return;\\n        }else if(list.size() == 4) return;\\n        for(int i = pos; i < nums.length; i++){\\n            if(nums[i] +  nums[nums.length - 1] * (3 - list.size()) + sum < target) continue;\\n            if(nums[i] * (4 - list.size()) + sum > target) return;\\n            list.add(nums[i]);\\n            getSum(nums, sum + nums[i], target, ans, list, i + 1);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        if(nums == null || nums.length == 0) return ans;\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        getSum(nums, 0, target, ans, list, 0);\\n        return ans;\\n    }\\n    private void getSum(int[] nums, int sum, int target, List<List<Integer>> ans, List<Integer> list, int pos){\\n        if(list.size() == 4 && sum == target && !ans.contains(list)){\\n            ans.add(new ArrayList<>(list)); return;\\n        }else if(list.size() == 4) return;\\n        for(int i = pos; i < nums.length; i++){\\n            if(nums[i] +  nums[nums.length - 1] * (3 - list.size()) + sum < target) continue;\\n            if(nums[i] * (4 - list.size()) + sum > target) return;\\n            list.add(nums[i]);\\n            getSum(nums, sum + nums[i], target, ans, list, i + 1);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8688,
                "title": "java-a-little-bit-faster-than-other-common-methods-9ms-beats-95",
                "content": "To avoid duplicate list items, I skip unnecessary indices at two locations:\\n\\n - one at the end of the outer loop (`i-loop`)\\n - the other at the end of the inner loop (`j-loop`). \\n\\n\\nTo avoid useless computations, the following is kind of critical:\\n\\n - the function `return` immediately when `nums[i]*4 > target`\\n - the inner loop `break` immediately when `nums[j]*4 < target`. \\n\\nThese two lines save quite some time due to the set up of the test cases in OJ.\\n\\n    public class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            int second = 0, third = 0, nexti = 0, nextj = 0;\\n            for(int i=0, L=nums.length; i<L-3; i++) {\\n                if(nums[i]<<2 > target) return list; // return immediately\\n                for(int j=L-1; j>i+2; j--) {\\n                    if(nums[j]<<2 < target) break; // break immediately\\n                    int rem = target-nums[i]-nums[j];\\n                    int lo = i+1, hi=j-1;\\n                    while(lo<hi) {\\n                        int sum = nums[lo] + nums[hi];\\n                        if(sum>rem) --hi;\\n                        else if(sum<rem) ++lo;\\n                        else {\\n                            list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j]));\\n                            while(++lo<=hi && nums[lo-1]==nums[lo]) continue; // avoid duplicate results\\n                            while(--hi>=lo && nums[hi]==nums[hi+1]) continue; // avoid duplicate results\\n                        }\\n                    }\\n                    while(j>=1 && nums[j]==nums[j-1]) --j; // skip inner loop\\n                }\\n                while(i<L-1 && nums[i]==nums[i+1]) ++i; // skip outer loop\\n            }\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            int second = 0, third = 0, nexti = 0, nextj = 0;\\n            for(int i=0, L=nums.length; i<L-3; i++) {\\n                if(nums[i]<<2 > target) return list; // return immediately\\n                for(int j=L-1; j>i+2; j--) {\\n                    if(nums[j]<<2 < target) break; // break immediately\\n                    int rem = target-nums[i]-nums[j];\\n                    int lo = i+1, hi=j-1;\\n                    while(lo<hi) {\\n                        int sum = nums[lo] + nums[hi];\\n                        if(sum>rem) --hi;\\n                        else if(sum<rem) ++lo;\\n                        else {\\n                            list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j]));\\n                            while(++lo<=hi && nums[lo-1]==nums[lo]) continue; // avoid duplicate results\\n                            while(--hi>=lo && nums[hi]==nums[hi+1]) continue; // avoid duplicate results\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 8583,
                "title": "twosum-twosum-foursum-a-simple-python-solution",
                "content": "    class Solution:\\n    # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n    def fourSum(self, num, target):\\n        two_sum = collections.defaultdict(list)\\n        res = set()\\n        for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2):\\n            two_sum[i1+i2].append({n1, n2})\\n        for t in list(two_sum.keys()):\\n            if not two_sum[target-t]:\\n                continue\\n            for pair1 in two_sum[t]:\\n                for pair2 in two_sum[target-t]:\\n                    if pair1.isdisjoint(pair2):\\n                        res.add(tuple(sorted(num[i] for i in pair1 | pair2)))\\n            del two_sum[t]\\n        return [list(r) for r in res]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n    def fourSum(self, num, target):\\n        two_sum = collections.defaultdict(list)\\n        res = set()\\n        for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2):\\n            two_sum[i1+i2].append({n1, n2}",
                "codeTag": "Java"
            },
            {
                "id": 581600,
                "title": "javascript-using-4-pointers-beats-96",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const result = []\\n    \\n    for(let i = 0; i < nums.length - 3; i++) {\\n        for(let j = i + 1; j < nums.length - 2; j++) {\\n            let low = j + 1;\\n            let high = nums.length - 1\\n\\n            while(low < high) {\\n                const sum = nums[i] + nums[j] + nums[low] + nums[high];\\n                if(sum === target) {\\n                    result.push([nums[i], nums[j], nums[low], nums[high]])\\n                    while(nums[low] === nums[low + 1]) low++;\\n                    while(nums[high] === nums[high - 1]) high--;\\n                    low++;\\n                    high--;\\n                } else if(sum < target) {\\n                    low++\\n                } else {\\n                    high--\\n                }\\n            }   \\n            while(nums[j] === nums[j + 1]) j++;\\n        }   \\n        while(nums[i] === nums[i + 1]) i++;\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const result = []\\n    \\n    for(let i = 0; i < nums.length - 3; i++) {\\n        for(let j = i + 1; j < nums.length - 2; j++) {\\n            let low = j + 1;\\n            let high = nums.length - 1\\n\\n            while(low < high) {\\n                const sum = nums[i] + nums[j] + nums[low] + nums[high];\\n                if(sum === target) {\\n                    result.push([nums[i], nums[j], nums[low], nums[high]])\\n                    while(nums[low] === nums[low + 1]) low++;\\n                    while(nums[high] === nums[high - 1]) high--;\\n                    low++;\\n                    high--;\\n                } else if(sum < target) {\\n                    low++\\n                } else {\\n                    high--\\n                }\\n            }   \\n            while(nums[j] === nums[j + 1]) j++;\\n        }   \\n        while(nums[i] === nums[i + 1]) i++;\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341532,
                "title": "c-simple-and-clean-o-n-2-solution-including-detailed-explanation",
                "content": "**Steps:**\\n1. First we store in a map `twoSums` all the pairs of numbers, while the key is their sum and the value is a pair of indices.\\n2. For each twoSum, we check if we have its complementary to target in the map too.\\n3. If so, we take the lists of indices of the key and the target-key, and pass them to the function `makePairs`.\\n4. In `makePairs` we loop through the pairs of indices of both lists and check if the indices are not the same. That\\'s because we don\\'t want to use the same index twice.\\n5. We sort the four results to avoid duplicate fourSums in different orders.\\n6. Insert into a set to avoid duplicate fourSums.\\n7. Last step is to convert the set into a vector and here we got our result :)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        nums1 = nums;\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i+1; j < nums.size(); j++) {\\n                twoSums[nums[i] + nums[j]].push_back({i, j});\\n            }\\n        }\\n        \\n        for (auto [key, value] : twoSums) {\\n            int tmp = target - key;\\n            if (twoSums.find(tmp) != twoSums.end()) makePairs(twoSums[key], twoSums[tmp]);\\n        }\\n        \\n        vector<vector<int>> res(fourSums.begin(), fourSums.end()); \\n        return res;\\n    }\\n    \\n    void makePairs(vector<pair<int, int>> arr1, vector<pair<int, int>> arr2) {\\n        for (auto [a, b] : arr1) {\\n            for (auto [c, d] : arr2) {\\n                if (a != c && b != c && a != d && b != d) {\\n                    vector<int> tmp = {nums1[a], nums1[b], nums1[c], nums1[d]};\\n                    sort(tmp.begin(), tmp.end());\\n                    fourSums.insert(tmp);\\n                } \\n            }\\n        }\\n    }\\n\\nprivate:\\n    set<vector<int>> fourSums;\\n    unordered_map<int, vector<pair<int, int>>> twoSums;\\n    vector<int> nums1;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        nums1 = nums;\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i+1; j < nums.size(); j++) {\\n                twoSums[nums[i] + nums[j]].push_back({i, j});\\n            }\\n        }\\n        \\n        for (auto [key, value] : twoSums) {\\n            int tmp = target - key;\\n            if (twoSums.find(tmp) != twoSums.end()) makePairs(twoSums[key], twoSums[tmp]);\\n        }\\n        \\n        vector<vector<int>> res(fourSums.begin(), fourSums.end()); \\n        return res;\\n    }\\n    \\n    void makePairs(vector<pair<int, int>> arr1, vector<pair<int, int>> arr2) {\\n        for (auto [a, b] : arr1) {\\n            for (auto [c, d] : arr2) {\\n                if (a != c && b != c && a != d && b != d) {\\n                    vector<int> tmp = {nums1[a], nums1[b], nums1[c], nums1[d]};\\n                    sort(tmp.begin(), tmp.end());\\n                    fourSums.insert(tmp);\\n                } \\n            }\\n        }\\n    }\\n\\nprivate:\\n    set<vector<int>> fourSums;\\n    unordered_map<int, vector<pair<int, int>>> twoSums;\\n    vector<int> nums1;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369782,
                "title": "optimized-c-solution-beats-99-8",
                "content": "```cpp\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n\\tstd::vector<std::vector<int>> result;\\n\\tstd::size_t n = nums.size();\\n\\tif (n < 4) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\tstd::sort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n-3; ++i) {\\n\\t\\t/* Conditions for pruning */\\n\\t\\t// target too small, no point in continuing\\n\\t\\tif (target <= 0 and nums[i] > 0) break;\\n\\t\\t// nums[i] has become too large, no point in continuing\\n\\t\\tif (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;\\n\\t\\t// nums[i] is so small, even the largest elements cannot help reach the sum\\n\\t\\tif (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t // skip duplicates\\n\\t\\tif (i > 0 and nums[i] == nums[i-1]) continue;\\n\\n\\t\\t/* Now explore further */\\n\\t\\tfor (int j = i+1; j < n - 2; ++j) {\\n\\t\\t\\t/* Some more pruning */\\n\\t\\t\\t// nums[j] has become too large, no point in continuing\\n\\t\\t\\tif (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;\\n\\t\\t\\t// nums[j] is so small, even the largest elements cannot help reach the sum\\n\\t\\t\\tif (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t\\tif (j > i+1 and nums[j] == nums[j-1]) continue; // skip duplicates\\n\\n\\t\\t\\t/* Explore the solution space */\\n\\t\\t\\tint left = j+1, right = n-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tresult.push_back({nums[i], nums[j], nums[left], nums[right]});\\n\\t\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t\\twhile (left < right and nums[left] == last_left) ++left;\\n\\t\\t\\t\\t\\twhile (left < right and nums[right] == last_right) --right;\\n\\t\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\t\\t++left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t--right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```cpp\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n\\tstd::vector<std::vector<int>> result;\\n\\tstd::size_t n = nums.size();\\n\\tif (n < 4) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\tstd::sort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n-3; ++i) {\\n\\t\\t/* Conditions for pruning */\\n\\t\\t// target too small, no point in continuing\\n\\t\\tif (target <= 0 and nums[i] > 0) break;\\n\\t\\t// nums[i] has become too large, no point in continuing\\n\\t\\tif (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;\\n\\t\\t// nums[i] is so small, even the largest elements cannot help reach the sum\\n\\t\\tif (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t // skip duplicates\\n\\t\\tif (i > 0 and nums[i] == nums[i-1]) continue;\\n\\n\\t\\t/* Now explore further */\\n\\t\\tfor (int j = i+1; j < n - 2; ++j) {\\n\\t\\t\\t/* Some more pruning */\\n\\t\\t\\t// nums[j] has become too large, no point in continuing\\n\\t\\t\\tif (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;\\n\\t\\t\\t// nums[j] is so small, even the largest elements cannot help reach the sum\\n\\t\\t\\tif (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t\\tif (j > i+1 and nums[j] == nums[j-1]) continue; // skip duplicates\\n\\n\\t\\t\\t/* Explore the solution space */\\n\\t\\t\\tint left = j+1, right = n-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tresult.push_back({nums[i], nums[j], nums[left], nums[right]});\\n\\t\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t\\twhile (left < right and nums[left] == last_left) ++left;\\n\\t\\t\\t\\t\\twhile (left < right and nums[right] == last_right) --right;\\n\\t\\t\\t\\t} else if (sum < target) {\\n\\t\\t\\t\\t\\t++left;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t--right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8563,
                "title": "clean-c-19ms-backtracking-81-90",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>res;\\n        vector<int>path;\\n        DFS(res, nums, 0, target, 0, 0, path);\\n        return res;\\n    }\\n    \\n    void DFS(vector<vector<int>>& res, vector<int>& nums, int pos, int target, int count, int sum, vector<int>& path){\\n        if(count == 4){\\n            if(sum == target) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < nums.size(); i++){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            if(sum + nums[i] + (3 - count) * nums[nums.size() - 1] < target) continue;\\n            if(sum + (4 - count)* nums[i] > target) break;\\n            path.push_back(nums[i]);\\n            DFS(res, nums, i + 1, target, count + 1, sum + nums[i], path);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>res;\\n        vector<int>path;\\n        DFS(res, nums, 0, target, 0, 0, path);\\n        return res;\\n    }\\n    \\n    void DFS(vector<vector<int>>& res, vector<int>& nums, int pos, int target, int count, int sum, vector<int>& path){\\n        if(count == 4){\\n            if(sum == target) res.push_back(path);\\n            return;\\n        }\\n        for(int i = pos; i < nums.size(); i++){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            if(sum + nums[i] + (3 - count) * nums[nums.size() - 1] < target) continue;\\n            if(sum + (4 - count)* nums[i] > target) break;\\n            path.push_back(nums[i]);\\n            DFS(res, nums, i + 1, target, count + 1, sum + nums[i], path);\\n            path.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8759,
                "title": "a-conise-python-solution-based-on-ksum",
                "content": "    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            num.sort()\\n            def ksum(num, k, target):\\n                i = 0\\n                result = set()\\n                if k == 2:\\n                    j = len(num) - 1\\n                    while i < j:\\n                        if num[i] + num[j] == target:\\n                            result.add((num[i], num[j]))\\n                            i += 1\\n                        elif num[i] + num[j] > target:\\n                            j -= 1\\n                        else:\\n                            i += 1\\n                else:\\n                    while i < len(num) - k + 1:\\n                        newtarget = target - num[i]\\n                        subresult = ksum(num[i+1:], k - 1, newtarget)\\n                        if subresult:\\n                            result = result | set( (num[i],) + nr for nr in subresult)\\n                        i += 1\\n                    \\n                return result\\n            \\n            return [list(t) for t in ksum(num, 4, target)]",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            num.sort()\\n            def ksum(num, k, target):\\n                i = 0\\n                result = set()\\n                if k == 2:\\n                    j = len(num) - 1\\n                    while i < j:\\n                        if num[i] + num[j] == target:\\n                            result.add((num[i], num[j]))\\n                            i += 1\\n                        elif num[i] + num[j] > target:\\n                            j -= 1\\n                        else:\\n                            i += 1\\n                else:\\n                    while i < len(num) - k + 1:\\n                        newtarget = target - num[i]\\n                        subresult = ksum(num[i+1:], k - 1, newtarget)\\n                        if subresult:\\n                            result = result | set( (num[i],) + nr for nr in subresult)\\n                        i += 1\\n                    \\n                return result\\n            \\n            return [list(t) for t in ksum(num, 4, target)]",
                "codeTag": "Java"
            },
            {
                "id": 3441034,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\\n                        int tempIndex1 = low, tempIndex2 = high;\\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                    }\\n                }\\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        for(int i=0; i<n-3; i++){\\n            for(int j=i+1; j<n-2; j++){\\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                int low = j+1, high = n-1;\\n                while(low < high){\\n                    if(nums[low] + nums[high] < newTarget){\\n                        low++;\\n                    }\\n                    else if(nums[low] + nums[high] > newTarget){\\n                        high--;\\n                    }\\n                    else{\\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\\n                        int tempIndex1 = low, tempIndex2 = high;\\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\\n                    }\\n                }\\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545624,
                "title": "easy-c-solution-with-explanation-using-4-pointers",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- First, we\\u2019ll sort the array.\\n- Take 4 pointers: ***i, j, left, right.***\\n- Outer 2 loops for ***i & j.*** We store the remaining value to find in sum variable.\\n- Then we try to calculate the ***left+right*** values & if they are equal then push all 4 values to the set.\\n- If the value is less than sum then we\\u2019ll increase left because array is in sorted order, else we\\u2019ll decrease right.\\n- **Time complexity:** O(n^3 logn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>>ans;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j=0, l, r;\\n        while(i<n){\\n            j=i+1;\\n            while(j<n){\\n                int sum=target-nums[i]-nums[j];\\n                l=j+1; r=n-1;\\n                while(l<r){\\n                    int x = nums[l]+nums[r];\\n                    int y = nums[l], z= nums[r] ;\\n                    if(x>sum)\\n                        r--;\\n                    else if(x<sum)\\n                        l++;\\n                    else{\\n                        ans.insert({nums[i],nums[j],nums[l],nums[r]});\\n                        while(l<r && nums[r]==z)r--;\\n                        while(l<r && nums[l]==y)l++;\\n                    }\\n                }j++;\\n               \\n            }i++;\\n        }\\n        vector<vector<int>>res(ans.begin(),ans.end());\\n        return res;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>>ans;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i=0, j=0, l, r;\\n        while(i<n){\\n            j=i+1;\\n            while(j<n){\\n                int sum=target-nums[i]-nums[j];\\n                l=j+1; r=n-1;\\n                while(l<r){\\n                    int x = nums[l]+nums[r];\\n                    int y = nums[l], z= nums[r] ;\\n                    if(x>sum)\\n                        r--;\\n                    else if(x<sum)\\n                        l++;\\n                    else{\\n                        ans.insert({nums[i],nums[j],nums[l],nums[r]});\\n                        while(l<r && nums[r]==z)r--;\\n                        while(l<r && nums[l]==y)l++;\\n                    }\\n                }j++;\\n               \\n            }i++;\\n        }\\n        vector<vector<int>>res(ans.begin(),ans.end());\\n        return res;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672948,
                "title": "universal-solution-to-solve-any-n-sum-problem-using-recursion",
                "content": "```javascript\\nvar fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const result = [];\\n    \\n    // k represents N-sum, \\n    // if k = 3 : 3Sum, if k = 4 : 4Sum, if k = 5, 5Sum; \\n    function recurse(arr, tar, res, k) {\\n        if(k === 2) {\\n            twoSum(arr, tar, res);\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            while(arr[i] === arr[i-1]) i++;\\n            recurse(arr.slice(i+1), tar - arr[i], [...res, arr[i]], k-1);\\n        }\\n    }\\n    \\n    function twoSum(arr, tar, res) {\\n        let low = 0, high = arr.length-1;\\n        \\n        while(low < high) {\\n            const sum = arr[low] + arr[high];\\n            if(sum === tar)  {\\n                result.push([...res, arr[low], arr[high]]);\\n                while(arr[low] === arr[low+1]) low++;\\n                while(arr[high] === arr[high-1]) high--;\\n                low++;\\n                high--;\\n            } else if(sum < tar) low++;\\n            else high--;\\n        }\\n    }\\n    \\n    recurse(nums, target, [], 4)\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar fourSum = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    const result = [];\\n    \\n    // k represents N-sum, \\n    // if k = 3 : 3Sum, if k = 4 : 4Sum, if k = 5, 5Sum; \\n    function recurse(arr, tar, res, k) {\\n        if(k === 2) {\\n            twoSum(arr, tar, res);\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            while(arr[i] === arr[i-1]) i++;\\n            recurse(arr.slice(i+1), tar - arr[i], [...res, arr[i]], k-1);\\n        }\\n    }\\n    \\n    function twoSum(arr, tar, res) {\\n        let low = 0, high = arr.length-1;\\n        \\n        while(low < high) {\\n            const sum = arr[low] + arr[high];\\n            if(sum === tar)  {\\n                result.push([...res, arr[low], arr[high]]);\\n                while(arr[low] === arr[low+1]) low++;\\n                while(arr[high] === arr[high-1]) high--;\\n                low++;\\n                high--;\\n            } else if(sum < tar) low++;\\n            else high--;\\n        }\\n    }\\n    \\n    recurse(nums, target, [], 4)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450396,
                "title": "python-76-ms-beats-97-09-explain-why-it-is-fast",
                "content": "# Problem:\\n\\n> Given an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d* in `nums` such that *a* + *b* + *c* + *d* = `target`? Find all unique quadruplets in the array which gives the sum of `target`. The solution set must not contain duplicate quadruplets.\\n\\nExample :\\n\\n\\n```\\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\\n\\nA solution set is:\\n[\\n  [-1,  0, 0, 1],\\n  [-2, -1, 1, 2],\\n  [-2,  0, 0, 2]\\n]\\n```\\n\\n## Solution 1\\n\\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        i = 0\\n        L = len(nums)\\n        res = []\\n        while i < L-3:\\n            j = i+1\\n            while j < L-2:\\n                left = j+1\\n                right = L-1\\n                new_target = target-nums[i]-nums[j]\\n                while left<right:\\n                    if nums[left]+nums[right] > new_target:\\n                        right-=1\\n                    elif nums[left]+nums[right] < new_target:\\n                        left+=1\\n                    else:\\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\\n                        temp_left = nums[left]\\n                        temp_right = nums[right]\\n                        while(left<right and nums[left]==temp_left):\\n                            left+=1\\n                        while(left<right and nums[right]==temp_right):\\n                            right-=1\\n                while j < L-3 and nums[j] == nums[j+1]:\\n                    j+=1\\n                j+=1\\n            while i < L-4 and nums[i] == nums[i+1]:\\n                i+=1\\n            i+=1\\n        return res\\n```\\n> Runtime: 880 ms; Memory Usage: 12.8 MB\\n\\n## Solution 2\\n\\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        self.findNSum(nums, target, 4, [], res)\\n        return res\\n\\n    def findNSum(self, nums, target, N, prefix, result):\\n        L = len(nums)\\n        if N == 2:\\n            l, r = 0, L-1\\n            while l < r:\\n                add = nums[l] + nums[r]\\n                if add == target:\\n                    result.append(prefix + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l<r and nums[l-1] == nums[l]:\\n                        l += 1\\n                    while l<r and nums[r+1] == nums[r]:\\n                        r -= 1\\n                elif add > target:\\n                    r -= 1\\n                else:\\n                    l += 1\\n        else:\\n            for i in range(L-N+1):\\n                if target < N*nums[i] or target > N*nums[-1]: # key judgement\\n                    break\\n                if i == 0 or (i>0 and nums[i] != nums[i-1]):\\n                    self.findNSum(nums[i+1:], target-nums[i], N-1, prefix+[nums[i]], result)\\n        return\\n```\\n> Runtime: 84 ms; Memory Usage: 12.8 MB\\n\\n## Solution 3\\n\\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        i = 0\\n        L = len(nums)\\n        res = []\\n        while i < L-3:\\n            if target-nums[i] < 3*nums[i+1] or target-nums[i] > 3*nums[-1]:\\n                    while i < L-4 and nums[i] == nums[i+1]:\\n                        i+=1\\n                    i+=1\\n                    continue\\n            j = i+1\\n            while j < L-2:\\n                if target-nums[i]-nums[j] < 2*nums[j+1] or target-nums[i]-nums[j] > 2*nums[-1]:\\n                    while j < L-3 and nums[j] == nums[j+1]:\\n                        j+=1\\n                    j+=1\\n                    continue\\n                left = j+1\\n                right = L-1\\n                new_target = target-nums[i]-nums[j]\\n                while left<right:\\n                    if nums[left]+nums[right] > new_target:\\n                        right-=1\\n                    elif nums[left]+nums[right] < new_target:\\n                        left+=1\\n                    else:\\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\\n                        temp_left = nums[left]\\n                        temp_right = nums[right]\\n                        while(left<right and nums[left]==temp_left):\\n                            left+=1\\n                        while(left<right and nums[right]==temp_right):\\n                            right-=1\\n                while j < L-3 and nums[j] == nums[j+1]:\\n                    j+=1\\n                j+=1\\n            while i < L-4 and nums[i] == nums[i+1]:\\n                i+=1\\n            i+=1\\n        return res\\n```\\n> Runtime: 76 ms; Memory Usage: 12.8 MB\\n\\n## Note:\\n\\n- \\u5728\\u7B2C\\u4E8C\\u79CD\\u7B97\\u6CD5\\u662F\\u9012\\u5F52\\u7B97\\u6CD5\\u3002\\n- \\u7B2C\\u4E8C\\u79CD\\u7B97\\u6CD5\\u6BD4\\u7B2C\\u4E00\\u79CD\\u7B97\\u6CD5\\u5FEB\\u5728`line 28`\\uFF0C\\u5373\\u5173\\u952E\\u5224\\u65AD\\u3002\\n- \\u7B2C\\u4E09\\u79CD\\u7B97\\u6CD5\\u662F\\u5728\\u7B2C\\u4E00\\u79CD\\u7B97\\u6CD5\\u7684\\u57FA\\u7840\\u4E0A\\u589E\\u52A0\\u4E86\\u5173\\u952E\\u5224\\u65AD\\uFF0C\\u901F\\u5EA6\\u5F97\\u5230\\u5927\\u5E45\\u63D0\\u5347\\u3002\\u5E76\\u4E14\\u6BD4\\u9012\\u5F52\\u7B97\\u6CD5\\u66F4\\u5FEB\\u3002\\n- Solution 2 is recursive algorithm.\\n- Solution 2 is faster than solution 1 because of `line 28`, which is the key judgement.\\n- Adding the key judgement to solution1 makes solution 3, which is even faster than recursive algorithm solution 2.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\\n\\nA solution set is:\\n[\\n  [-1,  0, 0, 1],\\n  [-2, -1, 1, 2],\\n  [-2,  0, 0, 2]\\n]\\n```\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        i = 0\\n        L = len(nums)\\n        res = []\\n        while i < L-3:\\n            j = i+1\\n            while j < L-2:\\n                left = j+1\\n                right = L-1\\n                new_target = target-nums[i]-nums[j]\\n                while left<right:\\n                    if nums[left]+nums[right] > new_target:\\n                        right-=1\\n                    elif nums[left]+nums[right] < new_target:\\n                        left+=1\\n                    else:\\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\\n                        temp_left = nums[left]\\n                        temp_right = nums[right]\\n                        while(left<right and nums[left]==temp_left):\\n                            left+=1\\n                        while(left<right and nums[right]==temp_right):\\n                            right-=1\\n                while j < L-3 and nums[j] == nums[j+1]:\\n                    j+=1\\n                j+=1\\n            while i < L-4 and nums[i] == nums[i+1]:\\n                i+=1\\n            i+=1\\n        return res\\n```\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        self.findNSum(nums, target, 4, [], res)\\n        return res\\n\\n    def findNSum(self, nums, target, N, prefix, result):\\n        L = len(nums)\\n        if N == 2:\\n            l, r = 0, L-1\\n            while l < r:\\n                add = nums[l] + nums[r]\\n                if add == target:\\n                    result.append(prefix + [nums[l], nums[r]])\\n                    l += 1\\n                    r -= 1\\n                    while l<r and nums[l-1] == nums[l]:\\n                        l += 1\\n                    while l<r and nums[r+1] == nums[r]:\\n                        r -= 1\\n                elif add > target:\\n                    r -= 1\\n                else:\\n                    l += 1\\n        else:\\n            for i in range(L-N+1):\\n                if target < N*nums[i] or target > N*nums[-1]: # key judgement\\n                    break\\n                if i == 0 or (i>0 and nums[i] != nums[i-1]):\\n                    self.findNSum(nums[i+1:], target-nums[i], N-1, prefix+[nums[i]], result)\\n        return\\n```\n```python\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        i = 0\\n        L = len(nums)\\n        res = []\\n        while i < L-3:\\n            if target-nums[i] < 3*nums[i+1] or target-nums[i] > 3*nums[-1]:\\n                    while i < L-4 and nums[i] == nums[i+1]:\\n                        i+=1\\n                    i+=1\\n                    continue\\n            j = i+1\\n            while j < L-2:\\n                if target-nums[i]-nums[j] < 2*nums[j+1] or target-nums[i]-nums[j] > 2*nums[-1]:\\n                    while j < L-3 and nums[j] == nums[j+1]:\\n                        j+=1\\n                    j+=1\\n                    continue\\n                left = j+1\\n                right = L-1\\n                new_target = target-nums[i]-nums[j]\\n                while left<right:\\n                    if nums[left]+nums[right] > new_target:\\n                        right-=1\\n                    elif nums[left]+nums[right] < new_target:\\n                        left+=1\\n                    else:\\n                        res.append([nums[i],nums[j],nums[left],nums[right]])\\n                        temp_left = nums[left]\\n                        temp_right = nums[right]\\n                        while(left<right and nums[left]==temp_left):\\n                            left+=1\\n                        while(left<right and nums[right]==temp_right):\\n                            right-=1\\n                while j < L-3 and nums[j] == nums[j+1]:\\n                    j+=1\\n                j+=1\\n            while i < L-4 and nums[i] == nums[i+1]:\\n                i+=1\\n            i+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8664,
                "title": "share-my-python-code-run-time-200-20ms",
                "content": "    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            num.sort()\\n            result = []\\n            for i in xrange(len(num)-3):\\n                if num[i] > target/4.0:\\n                    break\\n                if i > 0 and num[i] == num[i-1]:\\n                    continue\\n                target2 = target - num[i]\\n                for j in xrange(i+1, len(num)-2):\\n                    if num[j] > target2/3.0:\\n                        break\\n                    if j > i+1 and num[j] == num[j-1]:\\n                        continue\\n                    k = j + 1\\n                    l = len(num) - 1\\n                    target3 = target2 - num[j]\\n                    # we should use continue not break\\n                    # because target3 changes as j changes\\n                    if num[k] > target3/2.0:\\n                        continue\\n                    if num[l] < target3/2.0:\\n                        continue\\n                    while k < l:\\n                        sum_value = num[k] + num[l]\\n                        if sum_value == target3:\\n                            result.append([num[i], num[j], num[k], num[l]])\\n                            kk = num[k]\\n                            k += 1\\n                            while k<l and num[k] == kk:\\n                                k += 1\\n                            \\n                            ll = num[l]\\n                            l -= 1\\n                            while k<l and num[l] == ll:\\n                                l -= 1\\n                        elif sum_value < target3:\\n                            k += 1\\n                        else:\\n                            l -= 1\\n            return result\\n\\nWe can reduce run time by adding some restrictions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            num.sort()\\n            result = []\\n            for i in xrange(len(num)-3):\\n                if num[i] > target/4.0:\\n                    break\\n                if i > 0 and num[i] == num[i-1]:\\n                    continue\\n                target2 = target - num[i]\\n                for j in xrange(i+1, len(num)-2):\\n                    if num[j] > target2/3.0:\\n                        break\\n                    if j > i+1 and num[j] == num[j-1]:\\n                        continue\\n                    k = j + 1\\n                    l = len(num) - 1\\n                    target3 = target2 - num[j]\\n                    # we should use continue not break\\n                    # because target3 changes as j changes\\n                    if num[k] > target3/2.0:\\n                        continue\\n                    if num[l] < target3/2.0:\\n                        continue\\n                    while k < l:\\n                        sum_value = num[k] + num[l]\\n                        if sum_value == target3:\\n                            result.append([num[i], num[j], num[k], num[l]])\\n                            kk = num[k]\\n                            k += 1\\n                            while k<l and num[k] == kk:\\n                                k += 1\\n                            \\n                            ll = num[l]\\n                            l -= 1\\n                            while k<l and num[l] == ll:\\n                                l -= 1\\n                        elif sum_value < target3:\\n                            k += 1\\n                        else:\\n                            l -= 1\\n            return result\\n\\nWe can reduce run time by adding some restrictions.",
                "codeTag": "Java"
            },
            {
                "id": 1533287,
                "title": "short-simple-solution-in-python",
                "content": "\\n\\tdef fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans = set()\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                left = j + 1\\n                right = n - 1\\n\\n                while left < right:\\n                    total = nums[i] + nums[left] + nums[right]+nums[j]\\n                    if total > target:\\n                        right -= 1\\n                    elif total < target:\\n                        left += 1\\n                    else:\\n                        ans.add(tuple(sorted((nums[i], nums[left], nums[right],nums[j]))))\\n                    \\n                        left += 1\\n                        right -= 1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "\\n\\tdef fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans = set()\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                left = j + 1\\n                right = n - 1\\n\\n                while left < right:\\n                    total = nums[i] + nums[left] + nums[right]+nums[j]\\n                    if total > target:\\n                        right -= 1\\n                    elif total < target:\\n                        left += 1\\n                    else:\\n                        ans.add(tuple(sorted((nums[i], nums[left], nums[right],nums[j]))))\\n                    \\n                        left += 1\\n                        right -= 1\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 260087,
                "title": "clear-and-simple-python3-solution-with-comment-o-n-3",
                "content": "```python\\nclass Solution:\\n    def fourSum(self, nums, target: int):\\n        res = []\\n        nums.sort()\\n\\n        # loop for first num, n times\\n        for i in range(len(nums) - 3):\\n            \\n            # skip duplication\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # skip uneccesary case\\n            if nums[i] * 4 > target:\\n                break\\n\\n            # loop for second number, n times\\n            for j in range(i + 1, len(nums) - 2):\\n                \\n                # skip duplication\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n\\n                # skip uneccesary case\\n                if nums[j] * 3 > target - nums[i]:\\n                    break\\n\\n                # search for last 2 nums, same as 2Sum/3Sum problem\\n                l, r = j + 1, len(nums) - 1\\n\\n                while l < r:\\n                    \\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\\n                    if s > target:\\n                        r = r - 1\\n                    elif s < target:\\n                        l = l + 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        while l < r and nums[l] == nums[l + 1]:\\n                            l = l + 1\\n                        while l < r and nums[r] == nums[r - 1]:\\n                            r = r - 1\\n                        l, r = l + 1, r - 1\\n            \\n        return res\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def fourSum(self, nums, target: int):\\n        res = []\\n        nums.sort()\\n\\n        # loop for first num, n times\\n        for i in range(len(nums) - 3):\\n            \\n            # skip duplication\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # skip uneccesary case\\n            if nums[i] * 4 > target:\\n                break\\n\\n            # loop for second number, n times\\n            for j in range(i + 1, len(nums) - 2):\\n                \\n                # skip duplication\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n\\n                # skip uneccesary case\\n                if nums[j] * 3 > target - nums[i]:\\n                    break\\n\\n                # search for last 2 nums, same as 2Sum/3Sum problem\\n                l, r = j + 1, len(nums) - 1\\n\\n                while l < r:\\n                    \\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\\n                    if s > target:\\n                        r = r - 1\\n                    elif s < target:\\n                        l = l + 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        while l < r and nums[l] == nums[l + 1]:\\n                            l = l + 1\\n                        while l < r and nums[r] == nums[r - 1]:\\n                            r = r - 1\\n                        l, r = l + 1, r - 1\\n            \\n        return res\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 8608,
                "title": "java-backtracking-solution-for-k-sum-beat-94",
                "content": "Some tips:\\n1) avoid sum cases by viewing nums[start]*k and nums[end]*k \\n2) when backtracking, first add nums[i] to current list, after that then remove\\n\\nOne C++ Reference: http://bangbingsyb.blogspot.hk/2014/11/leetcode-4sum.html \\n\\n    public class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            kSum(result, new ArrayList<Integer>(), nums, target, 4, 0, nums.length-1);\\n            return result;\\n        }\\n    \\n        private void kSum(List<List<Integer>> result,List<Integer> cur,int[] nums, int target,int k,int start, int end){\\n            if(k == 0 || nums.length==0 || start>end) return;\\n            if(k == 1){\\n                for (int i = start; i <= end ; i++) {\\n                    if(nums[i] == target){\\n                        cur.add(nums[i]);\\n                        result.add(new ArrayList<Integer>(cur));\\n                        cur.remove(cur.size()-1);\\n                    }\\n                }\\n                return;\\n            }\\n    \\n            if(k == 2){ // 2 sum\\n                int sum;\\n                while (start < end){\\n                    sum = nums[start]+nums[end];\\n    \\n                    if(sum == target){\\n                        cur.add(nums[start]);\\n                        cur.add(nums[end]);\\n                        result.add(new ArrayList<Integer>(cur));\\n                        cur.remove(cur.size()-1);\\n                        cur.remove(cur.size()-1);\\n    \\n                        //avoid duplicate\\n                        while(start < end && nums[start] == nums[start+1]) ++start;\\n                        ++start;\\n                        while(start < end && nums[end] == nums[end-1]) --end;\\n                        --end;\\n                    }else if(sum < target){\\n                        //avoid duplicate\\n                        while(start < end && nums[start] == nums[start+1]) ++start;\\n                        ++start;\\n                    }else{\\n                        while(start < end && nums[end] == nums[end-1]) --end;\\n                        --end;\\n                    }\\n                }\\n                return;\\n            }\\n    \\n            //\\u907f\\u514d\\u4e00\\u4e9b\\u4e0d\\u5fc5\\u8981case\\n            if(k*nums[start] > target || k*nums[end]<target) return;\\n    \\n            // k > 2 : choose nums[i] and do k-1 sum on the rest at right\\n            for (int i = start; i <= (end-k+1) ; i++) {\\n                // avoid duplicate\\n                if(i>start && nums[i]==nums[i-1]) continue;\\n                // \\u91cd\\u70b9\\n                if(k*nums[i] <= target) { //\\u907f\\u514d\\u6389\\u4e00\\u4e9b\\u4e0d\\u5fc5\\u8981case\\n                    cur.add(nums[i]);\\n                    kSum(result, cur, nums, target - nums[i], k - 1, i + 1, end);\\n                    cur.remove(cur.size() - 1);\\n                }\\n            }\\n    \\n        }\\n    }",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n            kSum(result, new ArrayList<Integer>(), nums, target, 4, 0, nums.length-1);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2057363,
                "title": "0ms-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Kotlin ***\\n\\n```\\n\\nclass Solution {\\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\\n\\tval arrayList = ArrayList<List<Int>>()\\n\\tnums.sort() // sort necessary to filter out duplicates\\n\\n\\tfor (i in 0 until nums.size) {\\n\\t\\tif (i > 0 && nums[i] == nums[i - 1]) {\\n\\t\\t\\tcontinue //since sorted, it is ok to skip and remove duplicates.\\n\\t\\t}\\n\\n\\t\\tfor (j in i + 1 until nums.size) {\\n\\t\\t\\tif (j > i + 1 && nums[j] == nums[j - 1]) {\\n\\t\\t\\t\\tcontinue //since sorted, it is ok to skip and remove duplicates.\\n\\t\\t\\t}\\n\\n\\t\\t\\tval friend = target - nums[i] - nums[j]\\n\\t\\t\\tvar left = j + 1\\n\\t\\t\\tvar right = nums.size - 1\\n\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tval sumIJ = nums[left] + nums[right]\\n\\t\\t\\t\\twhen {\\n\\t\\t\\t\\t\\tsumIJ < friend -> left++\\n\\t\\t\\t\\t\\tsumIJ > friend -> right--\\n\\t\\t\\t\\t\\tsumIJ == friend -> {\\n\\t\\t\\t\\t\\t\\t//detect duplicates, since they are in order, duplicates will be adjacent.\\n\\t\\t\\t\\t\\t\\t//so it is sufficient to compare to previous value\\n\\t\\t\\t\\t\\t\\tif (left > j + 1 && right < nums.size - 1) {\\n\\t\\t\\t\\t\\t\\t\\tif (nums[left] != nums[left - 1] || nums[right] != nums[right + 1]) {\\n\\t\\t\\t\\t\\t\\t\\t\\tarrayList.add(listOf(nums[i], nums[j], nums[left], nums[right]))\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tarrayList.add(listOf(nums[i], nums[j], nums[left], nums[right]))\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn arrayList\\n}\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\\n\\tval arrayList = ArrayList<List<Int>>()\\n\\tnums.sort() // sort necessary to filter out duplicates\\n\\n\\tfor (i in 0 until nums.size) {\\n\\t\\tif (i > 0 && nums[i] == nums[i - 1]) {\\n\\t\\t\\tcontinue //since sorted, it is ok to skip and remove duplicates.\\n\\t\\t}\\n\\n\\t\\tfor (j in i + 1 until nums.size) {\\n\\t\\t\\tif (j > i + 1 && nums[j] == nums[j - 1]) {\\n\\t\\t\\t\\tcontinue //since sorted, it is ok to skip and remove duplicates.\\n\\t\\t\\t}\\n\\n\\t\\t\\tval friend = target - nums[i] - nums[j]\\n\\t\\t\\tvar left = j + 1\\n\\t\\t\\tvar right = nums.size - 1\\n\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tval sumIJ = nums[left] + nums[right]\\n\\t\\t\\t\\twhen {\\n\\t\\t\\t\\t\\tsumIJ < friend -> left++\\n\\t\\t\\t\\t\\tsumIJ > friend -> right--\\n\\t\\t\\t\\t\\tsumIJ == friend -> {\\n\\t\\t\\t\\t\\t\\t//detect duplicates, since they are in order, duplicates will be adjacent.\\n\\t\\t\\t\\t\\t\\t//so it is sufficient to compare to previous value\\n\\t\\t\\t\\t\\t\\tif (left > j + 1 && right < nums.size - 1) {\\n\\t\\t\\t\\t\\t\\t\\tif (nums[left] != nums[left - 1] || nums[right] != nums[right + 1]) {\\n\\t\\t\\t\\t\\t\\t\\t\\tarrayList.add(listOf(nums[i], nums[j], nums[left], nums[right]))\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tarrayList.add(listOf(nums[i], nums[j], nums[left], nums[right]))\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn arrayList\\n}\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491146,
                "title": "two-pointers-solution-java-o-n-3-time",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length-3; i++) {\\n            if(i==0 || i>0 && nums[i]!=nums[i-1]) {\\n                for(int j=i+1; j<nums.length-2; j++) {\\n                    if(j==i+1 || (j>i+1 && nums[j]!=nums[j-1])) {\\n                        int low = j+1;\\n                        int high = nums.length-1;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//to prevent integer overflow\\n                        long sum = nums[i]+nums[j];\\n                        long val = ((long)target - sum);\\n\\t\\t\\t\\t\\t\\t\\n                        while(low < high) {\\n                            if(nums[low]+nums[high] < val)\\n                                low++;\\n                            else if(nums[low]+nums[high] > val)\\n                                high--;\\n                            else {\\n                                ans.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));\\n                                while(low<high && nums[low]==nums[low+1])\\n                                    low++;\\n                                while(low<high && nums[high]==nums[high-1])\\n                                    high--;\\n                                low++;\\n                                high--;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>>ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length-3; i++) {\\n            if(i==0 || i>0 && nums[i]!=nums[i-1]) {\\n                for(int j=i+1; j<nums.length-2; j++) {\\n                    if(j==i+1 || (j>i+1 && nums[j]!=nums[j-1])) {\\n                        int low = j+1;\\n                        int high = nums.length-1;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//to prevent integer overflow\\n                        long sum = nums[i]+nums[j];\\n                        long val = ((long)target - sum);\\n\\t\\t\\t\\t\\t\\t\\n                        while(low < high) {\\n                            if(nums[low]+nums[high] < val)\\n                                low++;\\n                            else if(nums[low]+nums[high] > val)\\n                                high--;\\n                            else {\\n                                ans.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));\\n                                while(low<high && nums[low]==nums[low+1])\\n                                    low++;\\n                                while(low<high && nums[high]==nums[high-1])\\n                                    high--;\\n                                low++;\\n                                high--;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359731,
                "title": "generic-k-sum-easy-to-understand",
                "content": "```\\n\\ninterface IKSum {\\n\\n    List<List<Integer>> kSum(int nums[], int k, int target);\\n}\\n\\n/**\\n * We\\'ll use the problem of k sum and reduce it to two sum and attache the result back\\n */\\nclass KSumSorting implements IKSum {\\n\\n    @Override\\n    public List<List<Integer>> kSum(int[] nums, int k, int target) {\\n        if (nums == null || nums.length == 0 || nums.length < k)\\n            return Collections.EMPTY_LIST;\\n\\n        Arrays.sort(nums);\\n\\n        return kSum(nums, k, 0, target);\\n\\n    }\\n\\n    private List<List<Integer>> kSum(int[] nums, int k, int start, int target) {\\n        int len = nums.length;\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (len < k)\\n            return Collections.EMPTY_LIST;\\n\\n        if (k == 2) {\\n            return twoSum(nums, start, len - 1, target);\\n        } else {\\n\\n            /**\\n             * Take each element, and exclude it from target to reduce the problem to smaller k-1 sum problem\\n             */\\n            for (int i = start; i < len - (k - 1); i++) {\\n                /**\\n                 * Avoid duplicates\\n                 */\\n                if (i > start && nums[i] == nums[i - 1])\\n                    continue;\\n\\n                int ele = nums[i];\\n\\n                int rem = target - nums[i];\\n                List<List<Integer>> smallerSumResult = kSum(nums, k - 1, i + 1, rem);\\n\\n                /**\\n                 * Append the current element to make it k sum from k-1 sum\\n                 */\\n                for (List<Integer> list : smallerSumResult)\\n                    list.add(0, ele);\\n\\n                /**\\n                 * Append to our result\\n                 */\\n                result.addAll(smallerSumResult);\\n\\n\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private List<List<Integer>> twoSum(int nums[], int low, int high, int target) {\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        while (low < high) {\\n\\n            int sum = nums[low] + nums[high];\\n\\n            if (sum == target) {\\n                List<Integer> twoSum = new ArrayList<>();\\n                twoSum.add(nums[low]);\\n                twoSum.add(nums[high]);\\n\\n                result.add(twoSum);\\n\\n                /**\\n                 * Avoid duplicates\\n                 */\\n\\n                while (low < high && nums[low] == nums[++low]) ;\\n                while (high > low && nums[high] == nums[--high]) ;\\n\\n            } else if (sum < target)\\n                low++;\\n            else\\n                high--;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n\\nDriver code\\n\\n```\\n\\npublic class KSum {\\n    public static void main(String[] args) {\\n        test(new int[]{1, 0, -1, 0, -2},  4, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 4, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 4, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 4, 0);\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  5, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 5, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 5, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 5, 0);\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  3, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 3, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 3, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 3, 0);\\n\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  2, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 2, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 2, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 2, 0);\\n\\n    }\\n\\n    private static void test(int[] nums, int k, int target) {\\n        IKSum kSum = new KSumSorting();\\n\\n        System.out.println(\"\\\\nInput : \" + Printer.toString(nums) + \" K :\" + k + \" Target: \" + target);\\n        System.out.println(\"Sorting: \" + kSum.kSum(nums, k, target));\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\ninterface IKSum {\\n\\n    List<List<Integer>> kSum(int nums[], int k, int target);\\n}\\n\\n/**\\n * We\\'ll use the problem of k sum and reduce it to two sum and attache the result back\\n */\\nclass KSumSorting implements IKSum {\\n\\n    @Override\\n    public List<List<Integer>> kSum(int[] nums, int k, int target) {\\n        if (nums == null || nums.length == 0 || nums.length < k)\\n            return Collections.EMPTY_LIST;\\n\\n        Arrays.sort(nums);\\n\\n        return kSum(nums, k, 0, target);\\n\\n    }\\n\\n    private List<List<Integer>> kSum(int[] nums, int k, int start, int target) {\\n        int len = nums.length;\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (len < k)\\n            return Collections.EMPTY_LIST;\\n\\n        if (k == 2) {\\n            return twoSum(nums, start, len - 1, target);\\n        } else {\\n\\n            /**\\n             * Take each element, and exclude it from target to reduce the problem to smaller k-1 sum problem\\n             */\\n            for (int i = start; i < len - (k - 1); i++) {\\n                /**\\n                 * Avoid duplicates\\n                 */\\n                if (i > start && nums[i] == nums[i - 1])\\n                    continue;\\n\\n                int ele = nums[i];\\n\\n                int rem = target - nums[i];\\n                List<List<Integer>> smallerSumResult = kSum(nums, k - 1, i + 1, rem);\\n\\n                /**\\n                 * Append the current element to make it k sum from k-1 sum\\n                 */\\n                for (List<Integer> list : smallerSumResult)\\n                    list.add(0, ele);\\n\\n                /**\\n                 * Append to our result\\n                 */\\n                result.addAll(smallerSumResult);\\n\\n\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private List<List<Integer>> twoSum(int nums[], int low, int high, int target) {\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        while (low < high) {\\n\\n            int sum = nums[low] + nums[high];\\n\\n            if (sum == target) {\\n                List<Integer> twoSum = new ArrayList<>();\\n                twoSum.add(nums[low]);\\n                twoSum.add(nums[high]);\\n\\n                result.add(twoSum);\\n\\n                /**\\n                 * Avoid duplicates\\n                 */\\n\\n                while (low < high && nums[low] == nums[++low]) ;\\n                while (high > low && nums[high] == nums[--high]) ;\\n\\n            } else if (sum < target)\\n                low++;\\n            else\\n                high--;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\n```\\n\\npublic class KSum {\\n    public static void main(String[] args) {\\n        test(new int[]{1, 0, -1, 0, -2},  4, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 4, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 4, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 4, 0);\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  5, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 5, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 5, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 5, 0);\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  3, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 3, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 3, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 3, 0);\\n\\n\\n\\n        test(new int[]{1, 0, -1, 0, -2},  2, 0);\\n\\n        test(new int[]{1, 0, -1, 0, -2, 2}, 2, 0);\\n\\n        test(new int[]{-3, -2, -1, 0, 0, 1, 2, 3}, 2, 0);\\n\\n        test(new int[]{-4, -3, -2, -1, 0, 0, 1, 2, 3, 4}, 2, 0);\\n\\n    }\\n\\n    private static void test(int[] nums, int k, int target) {\\n        IKSum kSum = new KSumSorting();\\n\\n        System.out.println(\"\\\\nInput : \" + Printer.toString(nums) + \" K :\" + k + \" Target: \" + target);\\n        System.out.println(\"Sorting: \" + kSum.kSum(nums, k, target));\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512671,
                "title": "c-java-python-javascript-two-pointer-array",
                "content": "# Intuition:\\nThe problem asks to find all unique quadruplets in the given array whose sum equals the target value. We can use a similar approach as we do for the 3Sum problem. We can sort the array and then use two pointers approach to find the quadruplets whose sum equals the target value.\\n\\n# Approach:\\n\\n1. Sort the input array in non-decreasing order.\\n2. Traverse the array from 0 to n-3 and use a variable i to keep track of the first element in the quadruplet.\\n3. If the current element is the same as the previous element, skip it to avoid duplicates.\\n4. Traverse the array from i+1 to n-2 and use a variable j to keep track of the second element in the quadruplet.\\n5. If the current element is the same as the previous element, skip it to avoid duplicates.\\n6. Use two pointers, left = j+1 and right = n-1, to find the other two elements in the quadruplet whose sum equals the target value.\\n7. If the sum of the four elements is less than the target value, increment left pointer.\\n8. If the sum of the four elements is greater than the target value, decrement right pointer.\\n9. If the sum of the four elements is equal to the target value, add the quadruplet to the result and increment left and decrement right pointers.\\n10. Skip duplicate values of left and right pointers to avoid duplicate quadruplets.\\n11. Return the result.\\n\\n# Complexity\\n- Time Complexity: O(n^3) where n is the length of the input array. The two outer loops run in O(n^2) time and the inner two-pointer loop runs in O(n) time.\\n\\n- Space Complexity: O(1) because we are not using any extra space apart from the output array.\\n- \\n# Similar Question: [https://leetcode.com/problems/3sum/solutions/3416585/c-java-python-javascript-fully-explained-two-pointer-array/?orderBy=most_votes]()\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> quadruplets;\\n        int n = nums.size();\\n        // Sorting the array\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i - 1]){\\n                continue;\\n            }\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicates\\n                if (j > i + 1 && nums[j] == nums[j - 1]){\\n                    continue;\\n                }\\n                int left = j + 1;\\n                int right = n - 1;\\n                while (left < right) {\\n                    long long sum = static_cast<long long>(nums[i]) + nums[j] + nums[left] + nums[right];\\n                    if (sum < target) {\\n                        left++;\\n                    } else if (sum > target) {\\n                        right--;\\n                    } else {\\n                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left + 1]){\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]){\\n                            right--;\\n                        }\\n                        left++;\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return quadruplets;\\n    }\\n};\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        quadruplets = []\\n        n = len(nums)\\n        # Sorting the array\\n        nums.sort()\\n        for i in range(n - 3):\\n            # Skip duplicates\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            for j in range(i + 1, n - 2):\\n                # Skip duplicates\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n                left = j + 1\\n                right = n - 1\\n                while left < right:\\n                    sum = nums[i] + nums[j] + nums[left] + nums[right]\\n                    if sum < target:\\n                        left += 1\\n                    elif sum > target:\\n                        right -= 1\\n                    else:\\n                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])\\n                        # Skip duplicates\\n                        while left < right and nums[left] == nums[left + 1]:\\n                            left += 1\\n                        while left < right and nums[right] == nums[right - 1]:\\n                            right -= 1\\n                        left += 1\\n                        right -= 1\\n        return quadruplets\\n\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> quadruplets = new ArrayList<>();\\n        int n = nums.length;\\n        // Sorting the array\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicates\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n                int left = j + 1;\\n                int right = n - 1;\\n                while (left < right) {\\n                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum < target) {\\n                        left++;\\n                    } else if (sum > target) {\\n                        right--;\\n                    } else {\\n                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n                        left++;\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return quadruplets;\\n    }\\n}\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar fourSum = function(nums, target) {\\n  nums.sort((a, b) => a - b);\\n  const quadruplets = [];\\n  const n = nums.length;\\n  for (let i = 0; i < n - 3; i++) {\\n    if (i > 0 && nums[i] === nums[i - 1]) {\\n      continue;\\n    }\\n    for (let j = i + 1; j < n - 2; j++) {\\n      if (j > i + 1 && nums[j] === nums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = n - 1;\\n      while (left < right) {\\n        const sum = BigInt(nums[i]) + BigInt(nums[j]) + BigInt(nums[left]) + BigInt(nums[right]);\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          quadruplets.push([nums[i], nums[j], nums[left], nums[right]]);\\n          while (left < right && nums[left] === nums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && nums[right] === nums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return quadruplets;\\n};\\n```\\n\\n---\\n\\n# Similar Question: [https://leetcode.com/problems/3sum/solutions/3416585/c-java-python-javascript-fully-explained-two-pointer-array/?orderBy=most_votes]()",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> quadruplets;\\n        int n = nums.size();\\n        // Sorting the array\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i - 1]){\\n                continue;\\n            }\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicates\\n                if (j > i + 1 && nums[j] == nums[j - 1]){\\n                    continue;\\n                }\\n                int left = j + 1;\\n                int right = n - 1;\\n                while (left < right) {\\n                    long long sum = static_cast<long long>(nums[i]) + nums[j] + nums[left] + nums[right];\\n                    if (sum < target) {\\n                        left++;\\n                    } else if (sum > target) {\\n                        right--;\\n                    } else {\\n                        quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left + 1]){\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]){\\n                            right--;\\n                        }\\n                        left++;\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return quadruplets;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        quadruplets = []\\n        n = len(nums)\\n        # Sorting the array\\n        nums.sort()\\n        for i in range(n - 3):\\n            # Skip duplicates\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            for j in range(i + 1, n - 2):\\n                # Skip duplicates\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n                left = j + 1\\n                right = n - 1\\n                while left < right:\\n                    sum = nums[i] + nums[j] + nums[left] + nums[right]\\n                    if sum < target:\\n                        left += 1\\n                    elif sum > target:\\n                        right -= 1\\n                    else:\\n                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])\\n                        # Skip duplicates\\n                        while left < right and nums[left] == nums[left + 1]:\\n                            left += 1\\n                        while left < right and nums[right] == nums[right - 1]:\\n                            right -= 1\\n                        left += 1\\n                        right -= 1\\n        return quadruplets\\n\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> quadruplets = new ArrayList<>();\\n        int n = nums.length;\\n        // Sorting the array\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicates\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n                int left = j + 1;\\n                int right = n - 1;\\n                while (left < right) {\\n                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum < target) {\\n                        left++;\\n                    } else if (sum > target) {\\n                        right--;\\n                    } else {\\n                        quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n                        left++;\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return quadruplets;\\n    }\\n}\\n\\n```\n```\\nvar fourSum = function(nums, target) {\\n  nums.sort((a, b) => a - b);\\n  const quadruplets = [];\\n  const n = nums.length;\\n  for (let i = 0; i < n - 3; i++) {\\n    if (i > 0 && nums[i] === nums[i - 1]) {\\n      continue;\\n    }\\n    for (let j = i + 1; j < n - 2; j++) {\\n      if (j > i + 1 && nums[j] === nums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = n - 1;\\n      while (left < right) {\\n        const sum = BigInt(nums[i]) + BigInt(nums[j]) + BigInt(nums[left]) + BigInt(nums[right]);\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          quadruplets.push([nums[i], nums[j], nums[left], nums[right]]);\\n          while (left < right && nums[left] === nums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && nums[right] === nums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return quadruplets;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048440,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, long target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()<4)\\n            return ans;\\n        int n=nums.size();\\n        for(int i=0;i<n-3;i++)\\n        {\\n            for(int j=i+1; j<n-2;j++)\\n            {\\n                long sum=target-nums[i]-nums[j];\\n                int l=j+1, r=n-1;\\n                vector<int> v(4);\\n                while(l<r)\\n                {\\n                    if(nums[l]+nums[r]==sum)\\n                    {\\n                        v[0]=nums[i];\\n                        v[1]=nums[j];\\n                        v[2]=nums[l];\\n                        v[3]=nums[r];\\n                        ans.push_back(v);\\n                        while(l<r && v[2]==nums[l])\\n                            l++;\\n                        while(l<r && v[3]==nums[r])\\n                            r--;\\n                    }\\n                    else if(nums[l]+nums[r]<sum)\\n                        l++;\\n                    else\\n                        r--;\\n                }\\n                while(j<n-2 && nums[j]==nums[j+1])\\n                    j++;\\n            }\\n            while(i<n-3 && nums[i]==nums[i+1])\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, long target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()<4)\\n            return ans;\\n        int n=nums.size();\\n        for(int i=0;i<n-3;i++)\\n        {\\n            for(int j=i+1; j<n-2;j++)\\n            {\\n                long sum=target-nums[i]-nums[j];\\n                int l=j+1, r=n-1;\\n                vector<int> v(4);\\n                while(l<r)\\n                {\\n                    if(nums[l]+nums[r]==sum)\\n                    {\\n                        v[0]=nums[i];\\n                        v[1]=nums[j];\\n                        v[2]=nums[l];\\n                        v[3]=nums[r];\\n                        ans.push_back(v);\\n                        while(l<r && v[2]==nums[l])\\n                            l++;\\n                        while(l<r && v[3]==nums[r])\\n                            r--;\\n                    }\\n                    else if(nums[l]+nums[r]<sum)\\n                        l++;\\n                    else\\n                        r--;\\n                }\\n                while(j<n-2 && nums[j]==nums[j+1])\\n                    j++;\\n            }\\n            while(i<n-3 && nums[i]==nums[i+1])\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342347,
                "title": "c-recursion-4ms-99-81-faster-code-explained-clearly",
                "content": "Here I used a very clever technique of reducing any n sum problem to a two sum by using recursing and simplification. The most time saving techniques was the skipping of duplicates and unnecessry cases by using if cases. Read the code carefully and please do **upvote** if you like the approach.\\n```\\n/*\\n  READ THE CODE USING MY MARKERS OF 1 to 10. START WITH THE foursum method AND\\n  THEN READ nSum method AND FINALLY TO twoSum.\\n*/\\nclass Solution {\\npublic:\\n  vector<vector<int>> twoSum(vector<int> &nums, int target, int start) {\\n    vector<vector<int>> result;\\n    // 7. Now we iterate through the array taking the two pointer approach and\\n    // try to find two values in the array to add to the result.\\n    int left = start, right = nums.size() - 1;\\n    while (left < right) {\\n      int curSum = nums[left] + nums[right];\\n      // 8. Now we need to move left pointer forward when sum is less than\\n      // target and also to avoid duplicates we do not consider the case when\\n      // nums[left] == nums[left - 1]. Here we write left > start to not check\\n      // nums[left] == nums[left - 1] when left == start.\\n      if (curSum < target || (left > start && nums[left] == nums[left - 1])) {\\n        left++;\\n      } else if (curSum > target || (right < nums.size() - 1 && nums[right] == nums[right + 1])) {\\n        // 9. Now we bring right pointer backwards when we have overshot the\\n        // target or when duplicates are recorded(nums[right] == nums[right + 1]\\n        // is to check for duplicates).\\n        right--;\\n      } else {\\n        // 10. This is executed when curSum == target.\\n        result.push_back({nums[left++], nums[right--]});\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<vector<int>> nSum(vector<int> &nums, int target, int start, int n) {\\n    vector<vector<int>> result;\\n    // 2. If the current start value has reached end or start element times n is\\n    // greater than target or target is smaller than last element times n. We\\n    // cannot get any solution.\\n    if (start == nums.size() || nums[start] * n > target ||\\n        target > nums.back() * n) {\\n      return result;\\n    }\\n\\n    if (n == 2) {\\n      // 3. We simply calculate twoSum when we need to.\\n      return twoSum(nums, target, start);\\n    }\\n\\n    // 4. When n > 2, we need to reduce the problem into a twosum problem. This\\n    // is done by taking a sub problem. Here we consider the ith element and\\n    // call the function itself to calculate sum for (n - 1)th sum with a new\\n    // target of (target - nums[i]). Also we should start the call for search\\n    // with a start index if i + 1 so as to avoid duplicates. We also consider\\n    // skipping nums[i] when nums[i - 1] == nums[i] because the array is sorted\\n    // and we will avoid duplicates to be detected.\\n    for (int i = start; i < nums.size(); i++) {\\n      if (i == start || nums[i - 1] != nums[i]) {\\n        for (auto &j : nSum(nums, target - nums[i], i + 1, n - 1)) {\\n          // 5. Now the j variable is an iterator to the vectors where a target\\n          // of (target - nums[i]) has been achieved and we use this iterator to\\n          // add to the vector inside the result where nums[i] is present.\\n          result.push_back({nums[i]});\\n          // 6. Here, since we just added nums[i] to result, we now insert\\n          // inside the vector of {nums[i]} the values which came from the n-1\\n          // sum call. These results are concatenated to the nums[i].\\n          result.back().insert(end(result.back()), begin(j), end(j));\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n    // 1. We need a sorted array\\n    sort(begin(nums), end(nums));\\n    return nSum(nums, target, 0, 4);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n  READ THE CODE USING MY MARKERS OF 1 to 10. START WITH THE foursum method AND\\n  THEN READ nSum method AND FINALLY TO twoSum.\\n*/\\nclass Solution {\\npublic:\\n  vector<vector<int>> twoSum(vector<int> &nums, int target, int start) {\\n    vector<vector<int>> result;\\n    // 7. Now we iterate through the array taking the two pointer approach and\\n    // try to find two values in the array to add to the result.\\n    int left = start, right = nums.size() - 1;\\n    while (left < right) {\\n      int curSum = nums[left] + nums[right];\\n      // 8. Now we need to move left pointer forward when sum is less than\\n      // target and also to avoid duplicates we do not consider the case when\\n      // nums[left] == nums[left - 1]. Here we write left > start to not check\\n      // nums[left] == nums[left - 1] when left == start.\\n      if (curSum < target || (left > start && nums[left] == nums[left - 1])) {\\n        left++;\\n      } else if (curSum > target || (right < nums.size() - 1 && nums[right] == nums[right + 1])) {\\n        // 9. Now we bring right pointer backwards when we have overshot the\\n        // target or when duplicates are recorded(nums[right] == nums[right + 1]\\n        // is to check for duplicates).\\n        right--;\\n      } else {\\n        // 10. This is executed when curSum == target.\\n        result.push_back({nums[left++], nums[right--]});\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<vector<int>> nSum(vector<int> &nums, int target, int start, int n) {\\n    vector<vector<int>> result;\\n    // 2. If the current start value has reached end or start element times n is\\n    // greater than target or target is smaller than last element times n. We\\n    // cannot get any solution.\\n    if (start == nums.size() || nums[start] * n > target ||\\n        target > nums.back() * n) {\\n      return result;\\n    }\\n\\n    if (n == 2) {\\n      // 3. We simply calculate twoSum when we need to.\\n      return twoSum(nums, target, start);\\n    }\\n\\n    // 4. When n > 2, we need to reduce the problem into a twosum problem. This\\n    // is done by taking a sub problem. Here we consider the ith element and\\n    // call the function itself to calculate sum for (n - 1)th sum with a new\\n    // target of (target - nums[i]). Also we should start the call for search\\n    // with a start index if i + 1 so as to avoid duplicates. We also consider\\n    // skipping nums[i] when nums[i - 1] == nums[i] because the array is sorted\\n    // and we will avoid duplicates to be detected.\\n    for (int i = start; i < nums.size(); i++) {\\n      if (i == start || nums[i - 1] != nums[i]) {\\n        for (auto &j : nSum(nums, target - nums[i], i + 1, n - 1)) {\\n          // 5. Now the j variable is an iterator to the vectors where a target\\n          // of (target - nums[i]) has been achieved and we use this iterator to\\n          // add to the vector inside the result where nums[i] is present.\\n          result.push_back({nums[i]});\\n          // 6. Here, since we just added nums[i] to result, we now insert\\n          // inside the vector of {nums[i]} the values which came from the n-1\\n          // sum call. These results are concatenated to the nums[i].\\n          result.back().insert(end(result.back()), begin(j), end(j));\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n  vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n    // 1. We need a sorted array\\n    sort(begin(nums), end(nums));\\n    return nSum(nums, target, 0, 4);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272749,
                "title": "java-25-lines-of-code-easy-to-understand-answer-that-is-o-n-2-based-on-two-sum-solution",
                "content": "```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        //because res can be duplicated, we use set to deal with that\\n        //Set of a list compare all the elements in the list defaultly, you don\\'t need to override compare and hash function\\n        Set<List<Integer>> res = new HashSet<List<Integer>>();\\n        if(nums == null || nums.length < 4) {\\n            return new ArrayList<>(res);\\n        }\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        //key represents sum of first two nums, value is the list of indexes of those two nums\\n        //We dont need to worry about duplicate here, we deal with that in res set\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                int sum = nums[i] + nums[j];\\n                //check if current nums[i] and nums[j] can combine with previous first two nums to get a target value; \\n\\t\\t\\t\\tif(map.containsKey(target - sum)) {\\n                    List<int[]> indexes = map.get(target - sum);\\n\\t\\t\\t\\t\\tfor(int[] index : indexes) {\\n                        // Here we already know that we can get 4 nums to get the target value, but we need those four nums comes in order\\n\\t\\t\\t\\t\\t\\t//assume we have first two nums nums[k], nums[l], and current nums are nums[i], nums[j], by definition, k < l and i < j are certain. So we only need to make sure that  l < i, then we can get k < l < i < j, and add it to result set \\n\\t\\t\\t\\t\\t\\tif(index[1] < i) {\\n                            //make a result\\n                            List<Integer> candidate = Arrays.asList(nums[index[0]], nums[index[1]], nums[i], nums[j]);\\n                            res.add(candidate);\\n                        }\\n                    }\\n                }\\n                List<int[]> temp = map.getOrDefault(sum, new ArrayList<>());\\n                temp.add(new int[]{i, j});\\n                map.put(sum, temp);\\n            }\\n        }\\n        //convert from Set<List> to List<List>\\n        return new ArrayList<>(res);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        //because res can be duplicated, we use set to deal with that\\n        //Set of a list compare all the elements in the list defaultly, you don\\'t need to override compare and hash function\\n        Set<List<Integer>> res = new HashSet<List<Integer>>();\\n        if(nums == null || nums.length < 4) {\\n            return new ArrayList<>(res);\\n        }\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        //key represents sum of first two nums, value is the list of indexes of those two nums\\n        //We dont need to worry about duplicate here, we deal with that in res set\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                int sum = nums[i] + nums[j];\\n                //check if current nums[i] and nums[j] can combine with previous first two nums to get a target value; \\n\\t\\t\\t\\tif(map.containsKey(target - sum)) {\\n                    List<int[]> indexes = map.get(target - sum);\\n\\t\\t\\t\\t\\tfor(int[] index : indexes) {\\n                        // Here we already know that we can get 4 nums to get the target value, but we need those four nums comes in order\\n\\t\\t\\t\\t\\t\\t//assume we have first two nums nums[k], nums[l], and current nums are nums[i], nums[j], by definition, k < l and i < j are certain. So we only need to make sure that  l < i, then we can get k < l < i < j, and add it to result set \\n\\t\\t\\t\\t\\t\\tif(index[1] < i) {\\n                            //make a result\\n                            List<Integer> candidate = Arrays.asList(nums[index[0]], nums[index[1]], nums[i], nums[j]);\\n                            res.add(candidate);\\n                        }\\n                    }\\n                }\\n                List<int[]> temp = map.getOrDefault(sum, new ArrayList<>());\\n                temp.add(new int[]{i, j});\\n                map.put(sum, temp);\\n            }\\n        }\\n        //convert from Set<List> to List<List>\\n        return new ArrayList<>(res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115636,
                "title": "c-without-using-set-100-fast",
                "content": "# INSTEAD OF USING SET FOR REMOVING DUPLICATES WE ARE USING SOME WHILE LOOPS AND IF CONDITIONS:\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(ll i=0;i<nums.size();i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;       //REMOVES DUPLICATE IN 1ST INDEX\\n            ll t=target-nums[i];\\n            for(ll j=i+1;j<nums.size();j++){\\n                if(j>i+1 && nums[j]==nums[j-1])continue;     //REMOVE DUPLICATE IN 2ND INDEX\\n                ll s=t-nums[j];\\n                ll left=j+1,right=nums.size()-1;\\n                while(left<right){\\n                    ll sum=nums[left] + nums[right];\\n                    if(sum==s){\\n                        ans.push_back({nums[i],nums[j],nums[left],nums[right]});\\n                        while(left<nums.size()-1 && nums[left]==nums[left+1])left++;     //REMOVE DUPLICATE IN 3RD INDEX\\n                        while(right>0 && nums[right]==nums[right-1])right--;       //REMOVE DUPLICATE IN 4TH INDEX\\n                        left++;\\n                        right--;\\n                    }\\n                    else if(sum<s)left++;\\n                    else right--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/10a8794f-c64c-4561-b4d9-2b7a2524753d_1654456657.7689903.png)\\n\\n\\n\\uD83D\\uDE4C\\uD83D\\uDE4C HAPPY CODING !!",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        for(ll i=0;i<nums.size();i++){\\n            if(i>0 && nums[i]==nums[i-1])continue;       //REMOVES DUPLICATE IN 1ST INDEX\\n            ll t=target-nums[i];\\n            for(ll j=i+1;j<nums.size();j++){\\n                if(j>i+1 && nums[j]==nums[j-1])continue;     //REMOVE DUPLICATE IN 2ND INDEX\\n                ll s=t-nums[j];\\n                ll left=j+1,right=nums.size()-1;\\n                while(left<right){\\n                    ll sum=nums[left] + nums[right];\\n                    if(sum==s){\\n                        ans.push_back({nums[i],nums[j],nums[left],nums[right]});\\n                        while(left<nums.size()-1 && nums[left]==nums[left+1])left++;     //REMOVE DUPLICATE IN 3RD INDEX\\n                        while(right>0 && nums[right]==nums[right-1])right--;       //REMOVE DUPLICATE IN 4TH INDEX\\n                        left++;\\n                        right--;\\n                    }\\n                    else if(sum<s)left++;\\n                    else right--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780266,
                "title": "simple-java-solution-18ms-o-n-3-hashset-100-beat",
                "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        \\n       Set<List<Integer> > set = new HashSet<>();\\n        Arrays.sort(arr);\\n        \\n        for(int i=0; i<arr.length-3; i++){\\n            for(int j=i+1; j<arr.length-2; j++){\\n                int left = j+1;\\n                int right = arr.length-1;\\n                \\n                while(left<right){\\n                    int sum = arr[i]+arr[j]+arr[left]+arr[right];\\n                    \\n                    if(sum==target) {\\n                        set.add(Arrays.asList(arr[i],arr[j],arr[left],arr[right]));\\n                        left++;\\n                        right--;\\n                    }\\n                    \\n                    else if(sum<target) left++;\\n                    \\n                    else if(sum>target) right--;\\n                    \\n                }    \\n                    \\n            }\\n                               \\n            }\\n        \\n        return new ArrayList<>(set);\\n        }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        \\n       Set<List<Integer> > set = new HashSet<>();\\n        Arrays.sort(arr);\\n        \\n        for(int i=0; i<arr.length-3; i++){\\n            for(int j=i+1; j<arr.length-2; j++){\\n                int left = j+1;\\n                int right = arr.length-1;\\n                \\n                while(left<right){\\n                    int sum = arr[i]+arr[j]+arr[left]+arr[right];\\n                    \\n                    if(sum==target) {\\n                        set.add(Arrays.asList(arr[i],arr[j],arr[left],arr[right]));\\n                        left++;\\n                        right--;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 8750,
                "title": "o-n-3-solution-is-trivial-is-there-any-o-n-2logn-algorithm",
                "content": "Any Better algorithm than O(n^3) time complexity.\\n\\n    public class Solution {\\n            public List<List<Integer>> fourSum(int[] num, int target) {\\n                List<List<Integer>> results = new LinkedList<List<Integer>>();\\n                if (num == null || num.length < 4)\\n                    return results;\\n                Arrays.sort(num);\\n        \\n                for (int s = 0; s < num.length - 3; s++) {\\n                    if (s > 0 && num[s] == num[s - 1])  continue;\\n        \\n        \\n                    for (int e = num.length - 1; e >= s + 3; e--) {\\n                        if (e < num.length - 1 && num[e] == num[e + 1]) continue;\\n        \\n                        int local = target - num[s] - num[e];\\n                        int j = s + 1;\\n                        int k = e - 1;\\n                        while (j < k) {\\n        \\n                            if (j > s + 1 && num[j] == num[j - 1]) {\\n                                j++;\\n                                continue;\\n                            }\\n                            if (k < e - 1 && num[k] == num[k + 1]) {\\n                                k--;\\n                                continue;\\n                            }\\n        \\n                            if ((num[j] + num[k]) > local)\\n                                k--;\\n                            else if ((num[j] + num[k]) < local)\\n                                j++;\\n                            else\\n                                results.add(new ArrayList<Integer>(Arrays.asList(\\n                                        num[s], num[j++], num[k--], num[e])));\\n                        }\\n                    }\\n                }\\n                return results;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public List<List<Integer>> fourSum(int[] num, int target) {\\n                List<List<Integer>> results = new LinkedList<List<Integer>>();\\n                if (num == null || num.length < 4)\\n                    return results;\\n                Arrays.sort(num);\\n        \\n                for (int s = 0; s < num.length - 3; s++) {\\n                    if (s > 0 && num[s] == num[s - 1])  continue;\\n        \\n        \\n                    for (int e = num.length - 1; e >= s + 3; e--) {\\n                        if (e < num.length - 1 && num[e] == num[e + 1]) continue;\\n        \\n                        int local = target - num[s] - num[e];\\n                        int j = s + 1;\\n                        int k = e - 1;\\n                        while (j < k) {\\n        \\n                            if (j > s + 1 && num[j] == num[j - 1]) {\\n                                j++;\\n                                continue;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 420337,
                "title": "similar-to-3sum-use-two-pointers-java-easy-understand",
                "content": "## Problem\\n\\n> Given an array nums of `n` integers and an integer `target`, are there elements `a`, `b`, `c`, and `d` in `nums` such that `a + b + c + d = target`? Find all unique quadruplets in the array which gives the sum of `target`.\\n\\n**Note:** The solution set must not contain duplicate quadruplets.\\n\\n**Example:** \\n\\n```java\\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\\n\\nA solution set is:\\n[\\n  [-1,  0, 0, 1],\\n  [-2, -1, 1, 2],\\n  [-2,  0, 0, 2]\\n]\\n\\nInput: [0, 0, 0, 0], and target = 0.\\nOutput: [[0, 0, 0, 0]]\\n```\\n\\n\\n## Analysis\\n\\n### 3Sum + 4Sum\\n\\nUse two pointers in 3Sum.\\n\\n```java\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n  int n = nums.length;\\n  // sorting\\n  Arrays.sort(nums);\\n  // fourSum\\n  List<List<Integer>> result = new ArrayList<>();\\n  for (int i = 0; i < n; ++i) {\\n    if (i > 0 && nums[i - 1] == nums[i]) continue;\\n    threeSum(nums, i + 1, n - 1, target - nums[i], result);\\n  }\\n  return result;\\n}\\n  \\nprivate void threeSum(int[] nums, int lo, int hi, int target, List<List<Integer>> result) {\\n  int n = nums.length;\\n  int subLen = hi - lo + 1;\\n  for (int i = lo; i <= hi; ++i) {\\n    if (i > lo && nums[i] == nums[i - 1]) continue;  // skip same result\\n    // two pointers\\n    int j = i + 1, k = hi;\\n    int t = target - nums[i];\\n    while (j < k) { // each element is only used once\\n      if (nums[j] + nums[k] < t) {\\n        ++j;\\n      } else if (nums[j] + nums[k] > t) {\\n        --k;\\n      } else { // equal\\n        result.add(Arrays.asList(nums[lo - 1], nums[i], nums[j], nums[k]));\\n        ++j;\\n        --k;\\n        while (j < k && nums[j] == nums[j - 1]) j++;  // skip same result\\n        while (j < k && nums[k] == nums[k + 1]) k--;  // skip same result\\n      }\\n    }\\n  }\\n}\\n```\\n\\n**Time:** `O(N^3)`\\n**Space:** `O(1)`\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nGiven array nums = [1, 0, -1, 0, -2, 2], and target = 0.\\n\\nA solution set is:\\n[\\n  [-1,  0, 0, 1],\\n  [-2, -1, 1, 2],\\n  [-2,  0, 0, 2]\\n]\\n\\nInput: [0, 0, 0, 0], and target = 0.\\nOutput: [[0, 0, 0, 0]]\\n```\n```java\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n  int n = nums.length;\\n  // sorting\\n  Arrays.sort(nums);\\n  // fourSum\\n  List<List<Integer>> result = new ArrayList<>();\\n  for (int i = 0; i < n; ++i) {\\n    if (i > 0 && nums[i - 1] == nums[i]) continue;\\n    threeSum(nums, i + 1, n - 1, target - nums[i], result);\\n  }\\n  return result;\\n}\\n  \\nprivate void threeSum(int[] nums, int lo, int hi, int target, List<List<Integer>> result) {\\n  int n = nums.length;\\n  int subLen = hi - lo + 1;\\n  for (int i = lo; i <= hi; ++i) {\\n    if (i > lo && nums[i] == nums[i - 1]) continue;  // skip same result\\n    // two pointers\\n    int j = i + 1, k = hi;\\n    int t = target - nums[i];\\n    while (j < k) { // each element is only used once\\n      if (nums[j] + nums[k] < t) {\\n        ++j;\\n      } else if (nums[j] + nums[k] > t) {\\n        --k;\\n      } else { // equal\\n        result.add(Arrays.asList(nums[lo - 1], nums[i], nums[j], nums[k]));\\n        ++j;\\n        --k;\\n        while (j < k && nums[j] == nums[j - 1]) j++;  // skip same result\\n        while (j < k && nums[k] == nums[k + 1]) k--;  // skip same result\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371629,
                "title": "solution-in-python-3-beats-100-00-48-ms-o-n-asymptotic-analysis",
                "content": "_Asymptotic Worst Case Analysis:_\\nFor ease of analysis, we will assume that the input list is sorted since sorting only takes O(n log n) time. The worst case occurs if the target is equal to the sum of the four greatest elements in the list. This is because the search would have to continue until the very end to find the desired quadruplet _(a,b,c,d)_. For example, a list of the form _N_ = [1,2,3,4,5,6,7,8,9,10] with _target_ = 34 would require a complete run through all iterations of the three nested for loops. Note that the reason that there are only three nested for loops even though we are looking for a quadruplet is because finding the triplet _(a,b,c)_ determines a unique value of _d_ which will lead to a sum of _target_. Thus, we only need to search for triplets _(a,b,c)_ such that _target - (a+b+c)_ is in the original list.\\n\\nObserve that in the worst case, there is only one valid solution and that is found by adding the last four (i.e. the largest four) elements of the input list. Specifically, the desired quadruplet will be _( N[n-4], N[n-3], N[n-2], N[n-1] )_, where _N_ is the sorted input list and _n_ is its length. The outer for loop will have to iterate from _i_ = 1 to _i_ = _n-5_ with a guarantee of failure in finding the desired quadruplet since the lowest element in the desired quadrauplet occurs at index _n-4_. For each iteration of the outer for loop, the remaining two nested inner for loops iterate through the remaining elements to the right of index _i_, looking at all possible ordered pairs _(b,c)_ such that _target - (a+b+c)_ is in the original list. This is an O(n\\xB2) search that occurs _within_ each iteration of the outer for loop. It is guaranteed to fail in the worst case for outer loop indices from _i_ = 1 to _i_ = _n-5_. Thus in the worst case this algorithm is O(n\\xB3).\\n```\\nclass Solution:\\n    def fourSum(self, n: List[int], t: int) -> List[List[int]]:\\n    \\tif not n: return []\\n    \\tn.sort()\\n    \\tL, N, S, M = len(n), {j:i for i,j in enumerate(n)}, set(), n[-1]\\n    \\tfor i in range(L-3):\\n    \\t\\ta = n[i]\\n    \\t\\tif a + 3*M < t: continue\\n    \\t\\tif 4*a > t: break\\n    \\t\\tfor j in range(i+1,L-2):\\n    \\t\\t\\tb = n[j]\\n    \\t\\t\\tif a + b + 2*M < t: continue\\n    \\t\\t\\tif a + 3*b > t: break\\n    \\t\\t\\tfor k in range(j+1,L-1):\\n    \\t\\t\\t\\tc = n[k]\\n    \\t\\t\\t\\td = t-(a+b+c)\\n    \\t\\t\\t\\tif d > M: continue\\n    \\t\\t\\t\\tif d < c: break\\n    \\t\\t\\t\\tif d in N and N[d] > k: S.add((a,b,c,d))\\n    \\treturn S\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def fourSum(self, n: List[int], t: int) -> List[List[int]]:\\n    \\tif not n: return []\\n    \\tn.sort()\\n    \\tL, N, S, M = len(n), {j:i for i,j in enumerate(n)}",
                "codeTag": "Java"
            },
            {
                "id": 1890476,
                "title": "4sum",
                "content": "class Solution {\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                int start = j+1;\\n                int end = nums.length-1;\\n                while(end > start){\\n                    int sum = nums[i]+ nums[j] + nums[start] + nums[end];\\n                    if(sum == target){\\n                        set.add(Arrays.asList(nums[i], nums[j], nums[start++], nums[end--]));\\n                    }\\n                    else if (sum > target) end --;\\n                    else start++;\\n                }\\n            }\\n        }\\n          return new ArrayList<>(set);\\t\\n    }\\n}\\n\\n**If you like to understand the solution than please Upvote me**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = i+1; j < nums.length; j++){\\n                int start = j+1;\\n                int end = nums.length-1;\\n                while(end > start){\\n                    int sum = nums[i]+ nums[j] + nums[start] + nums[end];\\n                    if(sum == target){\\n                        set.add(Arrays.asList(nums[i], nums[j], nums[start++], nums[end--]));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 8660,
                "title": "handle-ksum-yet-still-accepted-with-best-performance-16ms-in-c",
                "content": "    class Solution {\\n    private:\\n        const int K = 4;\\n        int size = 0;\\n        void search(vector<int>& nums, int pos, int k, int target, vector<int>& v, vector<vector<int>>& vv)\\n        {\\n            if(k == 2)\\n            {\\n                int l = pos, r = size-1;\\n                while(l < r)\\n                {\\n                    int t = nums[l]+nums[r];\\n                    if(t > target) r--;\\n                    else if(t < target) l++;\\n                    else \\n                    {\\n                        v[K-2] = nums[l++];\\n                        v[K-1] = nums[r--];\\n                        vv.push_back(v);\\n                        while(l<r && nums[l]==nums[l-1]) l++; //avoid duplicates;\\n                        while(l<r && nums[r]==nums[r+1]) r--; //avoid duplicates;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(int top = size-k; pos <= top; ++pos)\\n                {\\n                    int sum = 0;\\n                    for(int i = 0; i < k; i++) sum += nums[pos+i]; \\n                    if(sum > target) break; //avoid futile searching;\\n                    sum = nums[pos];\\n                    for(int i = 0; i < k-1; ++i) sum += nums[size-1-i];\\n                    if(sum < target) continue; //avoid futile searching;\\n                    v[K-k] = nums[pos];\\n                    search(nums, pos+1, k-1, target-nums[pos], v, vv);\\n                    while(pos<=top && nums[pos+1]==nums[pos]) pos++; //avoid duplicates;\\n                }\\n            }\\n        }\\n    public:\\n        //AC - 16ms - handle kSum;\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) \\n        {\\n            sort(nums.begin(), nums.end());\\n            size = nums.size();\\n            vector<vector<int>> vv;\\n            vector<int> v(K, 0);\\n            search(nums, 0, K, target, v, vv);\\n            return vv;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        const int K = 4;\\n        int size = 0;\\n        void search(vector<int>& nums, int pos, int k, int target, vector<int>& v, vector<vector<int>>& vv)\\n        {\\n            if(k == 2)\\n            {\\n                int l = pos, r = size-1;\\n                while(l < r)\\n                {\\n                    int t = nums[l]+nums[r];\\n                    if(t > target) r--;\\n                    else if(t < target) l++;\\n                    else \\n                    {\\n                        v[K-2] = nums[l++];\\n                        v[K-1] = nums[r--];\\n                        vv.push_back(v);\\n                        while(l<r && nums[l]==nums[l-1]) l++; //avoid duplicates;\\n                        while(l<r && nums[r]==nums[r+1]) r--; //avoid duplicates;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2725476,
                "title": "python-beginners-solution-easy",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans = set()\\n        nums.sort()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                k,l = j+1,len(nums)-1\\n                while k<l:\\n                    s = nums[i]+nums[j]+nums[k]+nums[l]\\n                    if s == target:\\n                        ans.add((nums[i],nums[j],nums[k],nums[l]))\\n                        l-=1\\n                        k+=1\\n                    elif s > target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n                  \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans = set()\\n        nums.sort()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                k,l = j+1,len(nums)-1\\n                while k<l:\\n                    s = nums[i]+nums[j]+nums[k]+nums[l]\\n                    if s == target:\\n                        ans.add((nums[i],nums[j],nums[k],nums[l]))\\n                        l-=1\\n                        k+=1\\n                    elif s > target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n                  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899612,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = nums.sorted()\\n        var res: [[Int]] = []\\n        var i = 0\\n        \\n        while i < sorted.count - 3 {\\n            if i > 0, sorted[i] == sorted[i - 1] { i += 1; continue }\\n            var j = i + 1\\n            while j < sorted.count - 2 {\\n                if j - 1 > i, sorted[j] == sorted[j - 1] { j += 1; continue }\\n                var k = j + 1\\n                var l = sorted.count - 1\\n                \\n                while k < l {\\n                    let sum = sorted[i] + sorted[j] + sorted[k] + sorted[l]\\n                    if sum == target {\\n                        if k - 1 > j, sorted[k] == sorted[k - 1] { k += 1; continue }\\n                        res.append([sorted[i], sorted[j], sorted[k], sorted[l]])\\n                        k += 1\\n                    }\\n                    if sum < target {\\n                        k += 1\\n                    } else {\\n                        l -= 1\\n                    }\\n                }\\n                j += 1\\n            }\\n            i += 1\\n        }\\n\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = nums.sorted()\\n        var res: [[Int]] = []\\n        var i = 0\\n        \\n        while i < sorted.count - 3 {\\n            if i > 0, sorted[i] == sorted[i - 1] { i += 1; continue }\\n            var j = i + 1\\n            while j < sorted.count - 2 {\\n                if j - 1 > i, sorted[j] == sorted[j - 1] { j += 1; continue }\\n                var k = j + 1\\n                var l = sorted.count - 1\\n                \\n                while k < l {\\n                    let sum = sorted[i] + sorted[j] + sorted[k] + sorted[l]\\n                    if sum == target {\\n                        if k - 1 > j, sorted[k] == sorted[k - 1] { k += 1; continue }\\n                        res.append([sorted[i], sorted[j], sorted[k], sorted[l]])\\n                        k += 1\\n                    }\\n                    if sum < target {\\n                        k += 1\\n                    } else {\\n                        l -= 1\\n                    }\\n                }\\n                j += 1\\n            }\\n            i += 1\\n        }\\n\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574383,
                "title": "simple-hashmap-implementation-c-intution-explained",
                "content": "Intution : We take a unorederd map and then calculate 2 sum of all the possiblities of i and j pair and store it in the map besides there indexes and then we run a loop and for every i and j we do target - arr[i]-arr[j] and then try to find it in the map if it exists that means this is a possible answer qudraplet .\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        if(n<4) return ans;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                mp[nums[i]+nums[j]].push_back({i,j});//making 2 sum map\\n            }\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n               if(i>0 and nums[i]==nums[i-1])  continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j>i+1 and nums[j]==nums[j-1])  continue;\\n                int sum=target-nums[i]-nums[j];\\n                if(mp.find(sum)!=mp.end())\\n                {\\n                    for(auto it : mp[sum])\\n                    {\\n                        int k=it.first;\\n                        int l=it.second;\\n                        if(k>j){\\n                            if(!ans.empty()&& ans.back()[0]==nums[i]&&ans.back()[1]==nums[j]&&ans.back()[2]==nums[k]&&ans.back()[3]==nums[l]) continue;\\n                            vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                            ans.push_back(temp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Up Vote this pls if you understood**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        if(n<4) return ans;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                mp[nums[i]+nums[j]].push_back({i,j});//making 2 sum map\\n            }\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n               if(i>0 and nums[i]==nums[i-1])  continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j>i+1 and nums[j]==nums[j-1])  continue;\\n                int sum=target-nums[i]-nums[j];\\n                if(mp.find(sum)!=mp.end())\\n                {\\n                    for(auto it : mp[sum])\\n                    {\\n                        int k=it.first;\\n                        int l=it.second;\\n                        if(k>j){\\n                            if(!ans.empty()&& ans.back()[0]==nums[i]&&ans.back()[1]==nums[j]&&ans.back()[2]==nums[k]&&ans.back()[3]==nums[l]) continue;\\n                            vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                            ans.push_back(temp);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598927,
                "title": "python-generalized-soln-for-ksum-with-explanation",
                "content": "Lets generalize  1sum,2sum,3sum,4sum... problems into ksum\\n1)As we know we that 1sum is simply as returning the elements in the lists which are equal to target\\n2)First we sort the given list then\\n3)We can solve ksums where k>2 by reducing them to 2sum recursively\\n4)Where we solve 2sum problem with two pointer approach\\n```\\nres = []\\ni = begin #left pointer\\nj = len(nums) - 1 #right pointer\\nwhile i < j: #where pointers dont cross each other\\n\\tif nums[i] + nums[j] == target: \\n\\t\\tres.append([nums[i], nums[j]]) # if found then nums[i] and nums[j] pair are one of the results hence we store these as pair\\n\\t\\twhile i < j and nums[i] == nums[i + 1]:    #to remove redundant pairs\\n\\t\\t\\ti += 1\\n\\t\\twhile i < j and nums[j] == nums[j - 1]: #to remove redundant pairs\\n\\t\\t\\tj -= 1\\n\\t\\ti += 1\\n\\t\\tj -= 1\\n\\t\\t#as we found the pair we move left pointer forward and right pointer backward in list\\n\\telif nums[i] + nums[j] > target:\\n\\t\\tj -= 1\\n\\t\\t#As the sum is > target we move right pointer holding larger value to 1 step left\\n\\telse:\\n\\t\\ti += 1\\n\\t\\t#As the sum is < target we move left pointer smaller value to 1 step right\\n\\n```\\n\\n5)For 3sum we iterate over each element and find 2sum solution .ie if current index is i and element is nums[i]\\n\\twe find 2sum solution for target = target- nums[i] in list from index i+1 to i = len(nums)-1 and then add nums[i] to the solution\\n6)For ksum we iterate over each element and find (k-1)sum solution recursively.\\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        def helper(nums,target,ksum,begin):\\n            if begin >= len(nums): #base condition\\n                return []\\n            if ksum == 2:  \\n\\t\\t\\t #two pointer approach as we do in 2sum problem\\n                res = []\\n                i = begin\\n                j = len(nums) - 1\\n                while i < j:\\n                    if nums[i] + nums[j] == target:\\n                        res.append([nums[i], nums[j]])\\n                        while i < j and nums[i] == nums[i + 1]:\\n                            i += 1\\n                        while i < j and nums[j] == nums[j - 1]:\\n                            j -= 1\\n                        i += 1\\n                        j -= 1\\n                    elif nums[i] + nums[j] > target:\\n                        j -= 1\\n                    else:\\n                        i += 1\\n                return res\\n            res = [] \\n            for i in range(begin, len(nums) - ksum + 1):\\n                if i > begin and nums[i] == nums[i - 1] or nums[i] + nums[-1] * (ksum - 1) < target:\\n                    continue\\n\\t\\t\\t\\t\\t# the first condition is to remove Duplicates \\n\\t\\t\\t\\t\\t# the second Condition is that if we consider element nums[i] whether we get required target or not\\n\\t\\t\\t\\t\\t#ie if we consider nums[i] which is smallest in current ksum size windown and ksum-1 times of largest number in the nums and still we get sum < target the we do not need to consider nums[i]\\n                if nums[i] + nums[i + 1] * (ksum - 1) > target:\\n                    break\\n\\t\\t\\t\\t\\t#Same as above   if nums[i] + nums[i + 1] * (ksum - 1) > target it means that remaining elements after i algo give result > target hence we exit from the loop\\n                r = helper(nums, target - nums[i], ksum - 1, i + 1)\\n                for elm in r:\\n                    elm.insert(0,nums[i])\\n\\t\\t\\t\\t\\t#We insert current nums[i] to the result of ksum-1 result\\n                for elm in r:\\n                    res.append(elm)\\n\\t\\t\\t\\t\\t#we store result of size ksum \\n            return res\\n\\n        nums.sort()\\n\\t\\tksum = 4\\n\\t\\t#ksum = 4 As we are finding 4sum here\\n\\t\\t# For generailized  case \\n\\t\\t#if ksum <1: return []\\n\\t\\t#if ksum ==1:\\n\\t\\t\\t# return  [target]*nums.count(target)\\n        return helper(nums, target, ksum, 0)\\n",
                "solutionTags": [],
                "code": "```\\nres = []\\ni = begin #left pointer\\nj = len(nums) - 1 #right pointer\\nwhile i < j: #where pointers dont cross each other\\n\\tif nums[i] + nums[j] == target: \\n\\t\\tres.append([nums[i], nums[j]]) # if found then nums[i] and nums[j] pair are one of the results hence we store these as pair\\n\\t\\twhile i < j and nums[i] == nums[i + 1]:    #to remove redundant pairs\\n\\t\\t\\ti += 1\\n\\t\\twhile i < j and nums[j] == nums[j - 1]: #to remove redundant pairs\\n\\t\\t\\tj -= 1\\n\\t\\ti += 1\\n\\t\\tj -= 1\\n\\t\\t#as we found the pair we move left pointer forward and right pointer backward in list\\n\\telif nums[i] + nums[j] > target:\\n\\t\\tj -= 1\\n\\t\\t#As the sum is > target we move right pointer holding larger value to 1 step left\\n\\telse:\\n\\t\\ti += 1\\n\\t\\t#As the sum is < target we move left pointer smaller value to 1 step right\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 418208,
                "title": "c-solution-8ms-beats-97",
                "content": "Runtime: 8 ms, faster than 97.93% of C++ online submissions for 4Sum.\\nMemory Usage: 8.9 MB, less than 100.00% of C++ online submissions for 4Sum.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        for(int i=0; i<n-3; i++)\\n        {\\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target) break;\\n            if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3] < target) continue;\\n            \\n            for(int j=i+1; j<n-2; j++)\\n            {\\n                if(nums[j]+nums[j+1]+nums[j+2] > target - nums[i]) break;\\n                if(nums[j]+nums[n-1]+nums[n-2] < target - nums[i]) continue;\\n                int newTarget = target - nums[i] - nums[j];\\n                int start = j+1;\\n                int end = n-1;\\n                \\n                while(start < end)\\n                {\\n                    if(nums[start] + nums[end] < newTarget)\\n                        start++;\\n                    else if(nums[start] + nums[end] > newTarget)\\n                        end--;\\n                    else\\n                    {\\n                        res.push_back(vector<int> {nums[i], nums[j], nums[start], nums[end]});\\n                        start++;\\n                        end--;\\n                        while(start < end && nums[start] == res.back()[2]) start++;\\n                        while(start < end && nums[end] == res.back()[3]) end--;\\n                    }\\n                }\\n                \\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\\n            }\\n            \\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        for(int i=0; i<n-3; i++)\\n        {\\n            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3] > target) break;\\n            if(nums[i]+nums[n-1]+nums[n-2]+nums[n-3] < target) continue;\\n            \\n            for(int j=i+1; j<n-2; j++)\\n            {\\n                if(nums[j]+nums[j+1]+nums[j+2] > target - nums[i]) break;\\n                if(nums[j]+nums[n-1]+nums[n-2] < target - nums[i]) continue;\\n                int newTarget = target - nums[i] - nums[j];\\n                int start = j+1;\\n                int end = n-1;\\n                \\n                while(start < end)\\n                {\\n                    if(nums[start] + nums[end] < newTarget)\\n                        start++;\\n                    else if(nums[start] + nums[end] > newTarget)\\n                        end--;\\n                    else\\n                    {\\n                        res.push_back(vector<int> {nums[i], nums[j], nums[start], nums[end]}",
                "codeTag": "Java"
            },
            {
                "id": 406570,
                "title": "python-easy-to-understand-25-lines-dictionary-o-n-3",
                "content": "```\\ntwo_sums = {}\\nfor i in range(len(nums)):\\n\\tfor j in range(i + 1, len(nums)):\\n\\t\\tif (target - nums[i] - nums[j]) in two_sums:\\n\\t\\t\\ttwo_sums[target - nums[i] - nums[j]].append([i, j])\\n\\t\\telse:\\n\\t\\t\\ttwo_sums[target - nums[i] - nums[j]] = [[i, j]]\\n\\nfour_sums = []\\nfor i in range(len(nums)):\\n\\tfor j in range(i + 1, len(nums)):\\n\\t\\ttemp = nums[i] + nums[j]\\n\\t\\tif temp in two_sums:\\n\\t\\t\\tfor twos in two_sums[temp]:\\n\\t\\t\\t\\tif not(twos[0] == i or\\n\\t\\t\\t\\ttwos[0] == j or\\n\\t\\t\\t\\ttwos[1] == i or\\n\\t\\t\\t\\ttwos[1] == j):\\n\\t\\t\\t\\t\\tfour_sums.append([nums[i], nums[j], nums[twos[0]], nums[twos[1]]])\\n\\nreturn sorted(list(set(map(lambda x: tuple(sorted(x)), four_sums))))\\n```\\n\\n* Highly suggest you solve [Two Sum](https://leetcode.com/problems/two-sum/) and maybe even [3Sum](https://leetcode.com/problems/3sum/) first\\n* How do you break up a 4Sum problem?\\n\\t* A simple approach is to find a pair of numbers first\\n\\t* Then find another pair such that the set of those 4 numbers adds up to `target`\\n\\n\\n* First dictionary iterates through the array and adds all `i, j` pairs to a dictionary\\n* Key in this case will be `target - nums[i] - nums[j]`\\n\\t* Why `target - nums[i] - nums[j]`? `target` in the first example in the code desc. is 0. `i - j` for say, 3rd (i) and 2nd (j) index is 1\\n\\t* Essentially, this is `target` *without* `nums[i]` and `nums[j]` i.e the number your second pair that you find later needs to add up to\\n\\t* This is because you have *removed* `nums[i]` and `nums[j]` from target\\n\\t* In a nutshell, you say that an entry `x` in your dictionary represents how much of `target` you need to find if you take an entry `i, j` from the list that is held in that entry\\'s value\\n\\n* After you build the dictionary, iterate through the array of numbers\\n* For each number, iterate through each number *after* it in the array (O(n^2))\\n* Add those two numbers up\\n\\t* See a pattern here? If the sum of these two numbers is in the dictionary we built, you know every permutation of two *other* numbers in the array that give you `target` when you add them up\\n\\t* Look at every pair of those and ignore pairs where one of the indices is the same\\n\\t\\t* If the index is the same, you are looking at the same element. You need 4 different elements to add up to `target`\\n\\t* Record all quadruplets this way\\n\\n\\n* Sort quadruplets and then sort the list of quadruplets\\n* Why do I have so many calls in the last line?\\n\\t* From right to left:\\n\\t\\t* `sorted(x)` sorts the quadruplet\\n\\t\\t* `tuple(sorted(x))` converts the sorted quadruplet into a tuple so it\\'s hashable\\n\\t\\t* `map` this for every element in `four_sums` i.e every quadruplet\\n\\t\\t* Convert the list of quadruplets into a `set` so you only have unique elements\\n\\t\\t\\t* This is why we had to `tuple`-fy every quadruplet - so we can hash it\\n\\t\\t* Convert said set of quadruplets into a `sorted` `list`\\n* Ta-da!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ntwo_sums = {}\\nfor i in range(len(nums)):\\n\\tfor j in range(i + 1, len(nums)):\\n\\t\\tif (target - nums[i] - nums[j]) in two_sums:\\n\\t\\t\\ttwo_sums[target - nums[i] - nums[j]].append([i, j])\\n\\t\\telse:\\n\\t\\t\\ttwo_sums[target - nums[i] - nums[j]] = [[i, j]]\\n\\nfour_sums = []\\nfor i in range(len(nums)):\\n\\tfor j in range(i + 1, len(nums)):\\n\\t\\ttemp = nums[i] + nums[j]\\n\\t\\tif temp in two_sums:\\n\\t\\t\\tfor twos in two_sums[temp]:\\n\\t\\t\\t\\tif not(twos[0] == i or\\n\\t\\t\\t\\ttwos[0] == j or\\n\\t\\t\\t\\ttwos[1] == i or\\n\\t\\t\\t\\ttwos[1] == j):\\n\\t\\t\\t\\t\\tfour_sums.append([nums[i], nums[j], nums[twos[0]], nums[twos[1]]])\\n\\nreturn sorted(list(set(map(lambda x: tuple(sorted(x)), four_sums))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278435,
                "title": "c-same-as-3sum",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> FourSum(int[] nums, int target) {\\n        var n = nums.Length;\\n        Array.Sort(nums);\\n\\n        var result = new List<IList<int>>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i - 1] == nums[i]) continue;\\n            for (int j = i + 1; j < n; j++) {\\n                if (j > i + 1 && nums[j - 1] == nums[j]) continue;\\n                var left = j + 1;\\n                var right = n - 1;\\n\\n                while (left < right) {\\n                    var sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.Add(new List<int>() { nums[i], nums[j], nums[left], nums[right] });\\n\\n                        while (left < right && nums[left] == nums[left + 1]) left++;\\n                        while (left < right && nums[right] == nums[right - 1]) right--;\\n                        \\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FourSum(int[] nums, int target) {\\n        var n = nums.Length;\\n        Array.Sort(nums);\\n\\n        var result = new List<IList<int>>();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0 && nums[i - 1] == nums[i]) continue;\\n            for (int j = i + 1; j < n; j++) {\\n                if (j > i + 1 && nums[j - 1] == nums[j]) continue;\\n                var left = j + 1;\\n                var right = n - 1;\\n\\n                while (left < right) {\\n                    var sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.Add(new List<int>() { nums[i], nums[j], nums[left], nums[right] });\\n\\n                        while (left < right && nums[left] == nums[left + 1]) left++;\\n                        while (left < right && nums[right] == nums[right - 1]) right--;\\n                        \\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8641,
                "title": "12ms-ksum-c-code",
                "content": "Thanks to the posts from others, it really helped me understand the problem! \\nI really liked @rikimberley's example for validity checking at levels of K higher than 2 and I liked the approaches I've seen for turning the problem into a KSum problem. Now I won't have to re-write my answer if they make a 5 sum problem!\\n\\n```\\nclass Solution {\\nprivate:\\n    // Valid for K >= 2\\n    void KSum(int k, vector<int>& nums, int l, int r, int target, vector<vector<int>>& retVal, vector<int>& cur, int ci ) \\n    {\\n        int i, mn, mx;\\n        int km1 = k - 1;\\n\\n        if ( r-l+1 < k ) return;\\n        \\n        while ( l < r )\\n        {\\n            mn = nums[l];\\n            mx = nums[r];\\n            \\n            // If K minus 1 largest + min < target, move to larger\\n            if ( ( mn + km1*mx ) < target ) l++;\\n            // If K minus 1 smaller + max > target, move to smaller\\n            else if ( ( km1*mn + mx ) > target ) r--;\\n            // If K * min > target, stop looking\\n            else if ( k*mn > target ) break;\\n            // If K * min == target, reached the threshold, check then stop looking\\n            else if ( k*mn == target )\\n            {\\n                if ( ( l + km1 <= r ) && ( mn == ( nums[l+km1] ) ) )\\n                {\\n                    for ( i = 0; i < k; i++ ) cur[ci+i] = mn;\\n                    retVal.push_back( cur );\\n                }\\n                break;\\n            }\\n            // If K * max < target, stop looking\\n            else if ( k*mx < target ) break;\\n            // If K * max == target, reached the threshold, check then stop looking\\n            else if ( k*mx == target )\\n            {\\n                if ( ( l <= r - km1 ) && ( mx == ( nums[r-km1] ) ) )\\n                {\\n                    for ( i = 0; i < k; i++ ) cur[ci+i] = mx;\\n                    retVal.push_back( cur );\\n                }\\n                break;                \\n            }\\n            // If K == 2, we found a match!\\n            else if ( k == 2 )\\n            {\\n                cur[ci] = mn;\\n                cur[ci+1] = mx;\\n                retVal.push_back( cur );\\n                l++;\\n                while ( ( l < r ) && ( nums[l] == mn ) ) l++;\\n                r--;\\n                while ( ( l < r ) && ( nums[r] == mx ) ) r--;\\n            }\\n            // Otherwise, convert the problem to a K-1 problem\\n            else\\n            {\\n                cur[ci] = mn;\\n                KSum( km1, nums, ++l, r, target - mn, retVal, cur, ci+1 );\\n                while ( ( l < r ) && ( nums[l] == nums[l-1] ) ) l++;\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \\n    {\\n        vector<vector<int>> lRetVal;\\n        vector<int> lQuad( 4, 0 ); // Pre-allocate the size of the result\\n\\n        // Sort to provide a mechanism for avoiding duplicates\\n        sort( nums.begin(), nums.end() );\\n        \\n        KSum( 4, nums, 0, nums.size()-1, target, lRetVal, lQuad, 0 );\\n\\n        return( lRetVal );        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    // Valid for K >= 2\\n    void KSum(int k, vector<int>& nums, int l, int r, int target, vector<vector<int>>& retVal, vector<int>& cur, int ci ) \\n    {\\n        int i, mn, mx;\\n        int km1 = k - 1;\\n\\n        if ( r-l+1 < k ) return;\\n        \\n        while ( l < r )\\n        {\\n            mn = nums[l];\\n            mx = nums[r];\\n            \\n            // If K minus 1 largest + min < target, move to larger\\n            if ( ( mn + km1*mx ) < target ) l++;\\n            // If K minus 1 smaller + max > target, move to smaller\\n            else if ( ( km1*mn + mx ) > target ) r--;\\n            // If K * min > target, stop looking\\n            else if ( k*mn > target ) break;\\n            // If K * min == target, reached the threshold, check then stop looking\\n            else if ( k*mn == target )\\n            {\\n                if ( ( l + km1 <= r ) && ( mn == ( nums[l+km1] ) ) )\\n                {\\n                    for ( i = 0; i < k; i++ ) cur[ci+i] = mn;\\n                    retVal.push_back( cur );\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2632038,
                "title": "c-solution-4sum-two-pointer-approach-using-two-sum-o-n-3",
                "content": "**1. Two Pointer Approach**\\n* Pre-requisites - [Two Sum](https://leetcode.com/problems/two-sum/) , [3Sum](https://leetcode.com/problems/3sum//) (For better understanding)\\n* Time Complexity - O(N^3)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        //start & end pointers\\n        int s, e;\\n        //initializing answer vector\\n        vector<vector<int>> ans;\\n        //initializing set\\n        set<vector<int>> st;\\n        sort(nums.begin(), nums.end());\\n        \\n        //Edge Case\\n        if(n < 4){\\n            return ans;\\n        }\\n        \\n        // fixing first element of quadruplets \\n        for(int i = 0; i < n; i++){\\n            // fixing second element of quadruplets \\n            for(int j = i+1; j < n; j++){\\n                // now we are left with 2SUM problem\\n                //intializing start and end\\n                s = j + 1;\\n                e = n - 1;\\n                \\n                while(s < e){\\n                    \\n                    if((long) nums[i] + nums[j] + nums[s] + nums[e] == target){\\n                        st.insert({nums[i], nums[j], nums[s], nums[e]});\\n                        s++, e--;\\n                    }\\n                    else if((long) nums[i] + nums[j] + nums[s] + nums[e] > target){\\n                        e--;\\n                    }\\n                    else{\\n                        s++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // storing elements of set into ans\\n        for(auto i: st)\\n            ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if is helps :)",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        //start & end pointers\\n        int s, e;\\n        //initializing answer vector\\n        vector<vector<int>> ans;\\n        //initializing set\\n        set<vector<int>> st;\\n        sort(nums.begin(), nums.end());\\n        \\n        //Edge Case\\n        if(n < 4){\\n            return ans;\\n        }\\n        \\n        // fixing first element of quadruplets \\n        for(int i = 0; i < n; i++){\\n            // fixing second element of quadruplets \\n            for(int j = i+1; j < n; j++){\\n                // now we are left with 2SUM problem\\n                //intializing start and end\\n                s = j + 1;\\n                e = n - 1;\\n                \\n                while(s < e){\\n                    \\n                    if((long) nums[i] + nums[j] + nums[s] + nums[e] == target){\\n                        st.insert({nums[i], nums[j], nums[s], nums[e]});\\n                        s++, e--;\\n                    }\\n                    else if((long) nums[i] + nums[j] + nums[s] + nums[e] > target){\\n                        e--;\\n                    }\\n                    else{\\n                        s++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // storing elements of set into ans\\n        for(auto i: st)\\n            ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343144,
                "title": "javascript-solution-with-explanation",
                "content": "We will have 2 loops for 2 elements of quadruplets. Lets say for 2 loops we will use i and j for the interations. For finding next 2 elements we will use 2 pointer method.\\nIn 2 pointer method we will have 2 pointers left and right. Initially we will set left pointer as j+1 and right as length-1.\\n\\nWe will check the sum (nums[i] + nums[j] + nums[left] + nums[right]). If it is equal to target then we will push that quadruplets to result array. We need to increase left and right pointer. Because only changing one pointer will always give different sum (not equal to target)\\nIf sum is less than target then we need to increase only left pointer(not the right pointer) because we need to increase the sum value to match it with target value. If we decrease right pointer, we will have smaller element in the combination which will not increase overall sum.(Remember the array is sorted)\\nIf sum is greater than the target then we need to reduce right pointer (as per above logic)\\n\\nTo avoid duplicate entries, we need to take care whether each element is not repeating itself for same combinations of the other elements. Lets say we have array=[3,3,4,4,4,1,1,5] and target=16\\n``` \\n//first interation \\n [3,3,4,4,4,1,1,5]  \\n  i j l         r\\n  //here sum is 15 which is less than 16. we need to increment the left point. \\n  //As next element is also same as current element for left pointer we don\\'t need to consider that combination. \\n  //We need to increment the left pointer until we get different combination. \\n  \\n  //next interation should be\\n [3,3,4,4,4,1,1,5]  \\n  i j       l   r\\n```\\n\\nThis way we need to avoid duplicates for every elements. As the array is sorted all the same elements will be side by side and we can easily avoid using same value for the perticular element.\\n  \\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    nums.sort((a,b)=>a-b)      //First sort the array in ascending order\\n    let len = nums.length;\\n    let left=0, right=0, sum=0;\\n    let result = [];\\n    for(let i=0; i<len-3; i++){\\n        for(let j=i+1; j<len-2; j++){\\n            left = j+1;\\n            right = len-1;\\n            while(left < right){\\n                sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                if(sum === target){\\n                    result.push([nums[i], nums[j], nums[left], nums[right]])\\n                    while(nums[left]===nums[left+1]) left++;     //To avoid same values for left pointer\\n                    while(nums[right]===nums[right-1]) right--;  //To avoid same values for right pointer\\n                    left++;\\n                    right--;\\n                } else if (sum < target){\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n            while(nums[j]===nums[j+1]) j++;\\n        }\\n        while(nums[i]===nums[i+1]) i++;\\n    }\\n    return result;\\n};\\n```\\n\\nTime complexity will be O(n^3) as there are 2 loops and in worst case left pointer will go till end of the array.\\nSpace complexity will be O(1) as we are not taking any extra space to store anything.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "``` \\n//first interation \\n [3,3,4,4,4,1,1,5]  \\n  i j l         r\\n  //here sum is 15 which is less than 16. we need to increment the left point. \\n  //As next element is also same as current element for left pointer we don\\'t need to consider that combination. \\n  //We need to increment the left pointer until we get different combination. \\n  \\n  //next interation should be\\n [3,3,4,4,4,1,1,5]  \\n  i j       l   r\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    nums.sort((a,b)=>a-b)      //First sort the array in ascending order\\n    let len = nums.length;\\n    let left=0, right=0, sum=0;\\n    let result = [];\\n    for(let i=0; i<len-3; i++){\\n        for(let j=i+1; j<len-2; j++){\\n            left = j+1;\\n            right = len-1;\\n            while(left < right){\\n                sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                if(sum === target){\\n                    result.push([nums[i], nums[j], nums[left], nums[right]])\\n                    while(nums[left]===nums[left+1]) left++;     //To avoid same values for left pointer\\n                    while(nums[right]===nums[right-1]) right--;  //To avoid same values for right pointer\\n                    left++;\\n                    right--;\\n                } else if (sum < target){\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n            while(nums[j]===nums[j+1]) j++;\\n        }\\n        while(nums[i]===nums[i+1]) i++;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728285,
                "title": "most-optimal-solution-with-explanation-using-two-pointers-approach-c-and-java-code",
                "content": "\\n\\n# Approach\\n- Sort the input array nums in ascending order. Sorting the array helps in identifying unique quadruplets and allows us to use the two-pointer approach efficiently.\\n\\n- Iterate through each element in the array using a loop variable i from 0 to the second-to-last index.\\n\\n- Inside the first loop, check if the current element nums[i] is the same as the previous element nums[i-1]. If they are the same, it means we have already considered this element and generated quadruplets for it. In such cases, we continue to the next iteration to avoid duplicates.\\n\\n- Start a second loop with a variable j from i+1 to the last index. This loop represents the second element in the quadruplet.\\n\\n- Similar to step 3, check if the current element nums[j] is the same as the previous element nums[j-1]. If they are the same, continue to the next iteration to avoid duplicates.\\n\\n- Set two pointers k and l. k starts from j+1 (the next element after j) and moves forward, and l starts from the last index of the array and moves backward.\\n\\n- Enter a while loop where k is less than l. This loop iterates until k and l cross each other.\\n\\n- Calculate the sum of the current elements: nums[i] + nums[j] + nums[k] + nums[l].\\n\\n- If the sum is equal to the target, we have found a valid quadruplet. Create a temporary vector temp and store the elements nums[i], nums[j], nums[k], and nums[l] in it. Add this vector to the ans vector, which stores all the unique quadruplets.\\n\\n- Move the pointers k and l towards each other. Increment k and decrement l.\\n\\n- Check for any duplicate elements while moving the pointers. If the next element is the same as the previous one, increment k or decrement l until you find a different element. This step helps in avoiding duplicate quadruplets.\\n\\n- If the sum is greater than the target, decrement l to decrease the sum.\\n\\n- If the sum is less than the target, increment k to increase the sum.\\n\\n- After the second loop ends, continue to the next iteration of the first loop.\\n\\n- Finally, return the ans vector containing all the unique quadruplets.\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(1), O(n) to store the answer\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i< nums.size(); i++){\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            for(int j = i+1; j< nums.size(); j++){\\n                if(j> i+1 && nums[j] == nums[j-1]) continue;\\n                int k = j+1;\\n                int l = nums.size() - 1;\\n                while(k<l){\\n                    long long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if(sum == target){\\n                        vector <int> temp = {nums[i], nums[j], nums[k], nums[l]};\\n                        ans.push_back(temp);\\n                        k++;\\n                        l--;\\n                        while(k<l && nums[k] == nums[k-1]) k++;\\n                        while(k<l && nums[l] == nums[l+1]) l--;\\n                    }\\n                    else if(sum > target) l--;\\n                    else k++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            for (int j = i + 1; j < nums.length - 2; j++) {\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n                \\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                \\n                while (k < l) {\\n                    long sum = (long) nums[i] + nums[j] + nums[k] + nums[l];\\n                    \\n                    if (sum == target) {\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[k]);\\n                        temp.add(nums[l]);\\n                        ans.add(temp);\\n                        \\n                        k++;\\n                        l--;\\n                        \\n                        while (k < l && nums[k] == nums[k - 1]) {\\n                            k++;\\n                        }\\n                        \\n                        while (k < l && nums[l] == nums[l + 1]) {\\n                            l--;\\n                        }\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i< nums.size(); i++){\\n            if(i>0 && nums[i] == nums[i-1]) continue;\\n            for(int j = i+1; j< nums.size(); j++){\\n                if(j> i+1 && nums[j] == nums[j-1]) continue;\\n                int k = j+1;\\n                int l = nums.size() - 1;\\n                while(k<l){\\n                    long long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if(sum == target){\\n                        vector <int> temp = {nums[i], nums[j], nums[k], nums[l]};\\n                        ans.push_back(temp);\\n                        k++;\\n                        l--;\\n                        while(k<l && nums[k] == nums[k-1]) k++;\\n                        while(k<l && nums[l] == nums[l+1]) l--;\\n                    }\\n                    else if(sum > target) l--;\\n                    else k++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            for (int j = i + 1; j < nums.length - 2; j++) {\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n                \\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                \\n                while (k < l) {\\n                    long sum = (long) nums[i] + nums[j] + nums[k] + nums[l];\\n                    \\n                    if (sum == target) {\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[k]);\\n                        temp.add(nums[l]);\\n                        ans.add(temp);\\n                        \\n                        k++;\\n                        l--;\\n                        \\n                        while (k < l && nums[k] == nums[k - 1]) {\\n                            k++;\\n                        }\\n                        \\n                        while (k < l && nums[l] == nums[l + 1]) {\\n                            l--;\\n                        }\\n                    } else if (sum < target) {\\n                        k++;\\n                    } else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643620,
                "title": "python3-brute-force-better-optimal-full-explanation",
                "content": "- Approach\\n    - Brute-force\\n        - We keep four-pointers `i`, `j`, `k` and `l`. For every quadruplet, we find the sum of `A[i]+A[j]+A[k]+A[l]`\\n        - If this sum equals the target, we\\u2019ve found one of the quadruplets and add it to our data structure and continue with the rest\\n        - Time Complexity: $O(n^4)$\\n        - Space Complexity: $O(m)$ where m is the number of quadruplets\\n    - Better\\n        - We store the frequency of each element in a HashMap\\n        - Based on `a + b + c + d = target` we can say that `d = target - (a+b+c)` and based on this we fix 3 elements `a`, `b` and `c` and try to find the `-(a+b+c)` in HashMap\\n        - Time Complexity: $O(n^3)$\\n        - Space Complexity: $O(n + m)$ where m is the number of quadruplets\\n    - Optimal\\n        - To get the quadruplets in sorted order, we will sort the entire array in the first step and to get the unique quads, we will simply skip the duplicate numbers while moving the pointers\\n        - Fix 2 pointers `i` and `j` and move 2 pointers `lo` and `hi`\\n        - Based on `a + b + c + d = target` we can say that `c + d = target - (a+b)` and based on this we fix element as `a` and `b` then find `c` and `d` using two pointers `lo` and `hi` (same as in 3Sum Problem)\\n        - Time Complexity: $O(n^3)$\\n        - Space Complexity: $O(m)$ where m is the number of quadruplets\\n\\n```python\\n# Python3\\n# Brute-force Solution\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        ans = set()\\n        for i in range(n-3):\\n            for j in range(i+1, n-2):\\n                for k in range(j+1, n-1):\\n                    for l in range(k+1, n):\\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\\n                            ans.add(tuple(sorted((nums[i], nums[j], nums[k], nums[l]))))\\n        \\n        res = []\\n        for i in ans:\\n            res += list(i),\\n        return res\\n```\\n\\n```python\\n# Python3\\n# Better Solution\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        ans = set()\\n        hmap = defaultdict(int)\\n        for i in nums:\\n            hmap[i] += 1\\n        \\n        for i in range(n-3):\\n            hmap[nums[i]] -= 1\\n            for j in range(i+1, n-2):\\n                hmap[nums[j]] -= 1\\n                for k in range(j+1, n-1):\\n                    hmap[nums[k]] -= 1\\n                    rem = target-(nums[i] + nums[j] + nums[k])\\n                    if rem in hmap and hmap[rem] > 0:\\n                        ans.add(tuple(sorted((nums[i], nums[j], nums[k], rem))))\\n                    hmap[nums[k]] += 1\\n                hmap[nums[j]] += 1\\n            hmap[nums[i]] += 1\\n        \\n        res = []\\n        for i in ans:\\n            res += list(i),\\n        return res\\n```\\n\\n```python\\n# Python3\\n# Optimal Solution\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        nums.sort()\\n        res = []\\n\\n        for i in range(n-3):\\n            # avoid the duplicates while moving i\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            for j in range(i+1, n-2):\\n                # avoid the duplicates while moving j\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n                lo = j + 1\\n                hi = n - 1\\n                while lo < hi:\\n                    temp = nums[i] + nums[j] + nums[lo] + nums[hi]\\n                    if temp == target:\\n                        res += [nums[i], nums[j], nums[lo], nums[hi]],\\n\\n                        # skip duplicates\\n                        while lo < hi and nums[lo] == nums[lo + 1]:\\n                            lo += 1\\n                        lo += 1\\n                        while lo < hi and nums[hi] == nums[hi - 1]:\\n                            hi -= 1\\n                        hi -= 1\\n                    elif temp < target:\\n                        lo += 1\\n                    else:\\n                        hi -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```python\\n# Python3\\n# Brute-force Solution\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        ans = set()\\n        for i in range(n-3):\\n            for j in range(i+1, n-2):\\n                for k in range(j+1, n-1):\\n                    for l in range(k+1, n):\\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\\n                            ans.add(tuple(sorted((nums[i], nums[j], nums[k], nums[l]))))\\n        \\n        res = []\\n        for i in ans:\\n            res += list(i),\\n        return res\\n```\n```python\\n# Python3\\n# Better Solution\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        ans = set()\\n        hmap = defaultdict(int)\\n        for i in nums:\\n            hmap[i] += 1\\n        \\n        for i in range(n-3):\\n            hmap[nums[i]] -= 1\\n            for j in range(i+1, n-2):\\n                hmap[nums[j]] -= 1\\n                for k in range(j+1, n-1):\\n                    hmap[nums[k]] -= 1\\n                    rem = target-(nums[i] + nums[j] + nums[k])\\n                    if rem in hmap and hmap[rem] > 0:\\n                        ans.add(tuple(sorted((nums[i], nums[j], nums[k], rem))))\\n                    hmap[nums[k]] += 1\\n                hmap[nums[j]] += 1\\n            hmap[nums[i]] += 1\\n        \\n        res = []\\n        for i in ans:\\n            res += list(i),\\n        return res\\n```\n```python\\n# Python3\\n# Optimal Solution\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        n = len(nums)\\n        nums.sort()\\n        res = []\\n\\n        for i in range(n-3):\\n            # avoid the duplicates while moving i\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            for j in range(i+1, n-2):\\n                # avoid the duplicates while moving j\\n                if j > i + 1 and nums[j] == nums[j - 1]:\\n                    continue\\n                lo = j + 1\\n                hi = n - 1\\n                while lo < hi:\\n                    temp = nums[i] + nums[j] + nums[lo] + nums[hi]\\n                    if temp == target:\\n                        res += [nums[i], nums[j], nums[lo], nums[hi]],\\n\\n                        # skip duplicates\\n                        while lo < hi and nums[lo] == nums[lo + 1]:\\n                            lo += 1\\n                        lo += 1\\n                        while lo < hi and nums[hi] == nums[hi - 1]:\\n                            hi -= 1\\n                        hi -= 1\\n                    elif temp < target:\\n                        lo += 1\\n                    else:\\n                        hi -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366996,
                "title": "0ptimized-approach-java",
                "content": "# Intuition\\nfix two-pointers and then find the remaining two elements using two pointer technique as the array will be sorted at first.\\n\\n# Approach\\nSort the array, and then fix two pointers, so the remaining sum will be (target \\u2013 (nums[i] + nums[j])). Now we can fix two-pointers, one front, and another back, and easily use a two-pointer to find the remaining two numbers of the quad. In order to avoid duplications, we jump the duplicates, because taking duplicates will result in repeating quads. We can easily jump duplicates, by skipping the same elements by running a loop.\\n# Complexity\\n- Time complexity:\\nO(n^3)--> \\n2 nested for loops and the front pointer as well as the right pointer (Third nested loop)\\n\\n- Space complexity:\\nO(1)-->\\nGenerally the space complexity that is used to return the answer is ignored\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        if(n==0||n<3){\\n            return ans;\\n        }\\n        if(target==-294967296 || target==294967296){\\n            return ans;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int low=j+1;\\n                int high=n-1;\\n                int sum=target-nums[i]-nums[j];\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        List<Integer> temp=new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[low]);\\n                        temp.add(nums[high]);\\n                        ans.add(temp);\\n                        while(low<high&&nums[low]==nums[low+1]){\\n                            low++;\\n                        }\\n                        while(low<high&&nums[high]==nums[high-1]){\\n                            high--;\\n                        }\\n                        low++;\\n                        high--;\\n                    }\\n                    else if(nums[low]+nums[high]<sum){\\n                        low++;\\n                    }\\n                    else{\\n                        high--;\\n                    }\\n                }\\n                while(j+1<n&&nums[j+1]==nums[j]){\\n                    j++;\\n                }\\n            }\\n            while(i+1<n&&nums[i+1]==nums[i]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        if(n==0||n<3){\\n            return ans;\\n        }\\n        if(target==-294967296 || target==294967296){\\n            return ans;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int low=j+1;\\n                int high=n-1;\\n                int sum=target-nums[i]-nums[j];\\n                while(low<high){\\n                    if(nums[low]+nums[high]==sum){\\n                        List<Integer> temp=new ArrayList<>();\\n                        temp.add(nums[i]);\\n                        temp.add(nums[j]);\\n                        temp.add(nums[low]);\\n                        temp.add(nums[high]);\\n                        ans.add(temp);\\n                        while(low<high&&nums[low]==nums[low+1]){\\n                            low++;\\n                        }\\n                        while(low<high&&nums[high]==nums[high-1]){\\n                            high--;\\n                        }\\n                        low++;\\n                        high--;\\n                    }\\n                    else if(nums[low]+nums[high]<sum){\\n                        low++;\\n                    }\\n                    else{\\n                        high--;\\n                    }\\n                }\\n                while(j+1<n&&nums[j+1]==nums[j]){\\n                    j++;\\n                }\\n            }\\n            while(i+1<n&&nums[i+1]==nums[i]){\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344761,
                "title": "python-simple-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        nums.sort()\\n        for a in range(n):\\n            for b in range(a+1, n):\\n                c = b+1; d = n-1\\n                while c<d:\\n                    sums = nums[a]+nums[b]+nums[c]+nums[d]\\n                    if sums < target:\\n                        c += 1\\n                    elif sums > target:\\n                        d -= 1\\n                    else:\\n                        toappend = [nums[a],nums[b],nums[c],nums[d]]\\n                        if toappend not in res:\\n                            res.append(toappend)\\n                        c +=1\\n                        d-=1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        nums.sort()\\n        for a in range(n):\\n            for b in range(a+1, n):\\n                c = b+1; d = n-1\\n                while c<d:\\n                    sums = nums[a]+nums[b]+nums[c]+nums[d]\\n                    if sums < target:\\n                        c += 1\\n                    elif sums > target:\\n                        d -= 1\\n                    else:\\n                        toappend = [nums[a],nums[b],nums[c],nums[d]]\\n                        if toappend not in res:\\n                            res.append(toappend)\\n                        c +=1\\n                        d-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365829,
                "title": "java-simple-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result=new ArrayList<>();\\n        if(nums==null || nums.length<4){\\n            return result;\\n        }\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int low=j+1;\\n                int high=n-1;\\n                \\n                while(low<high){\\n                    int sum=nums[i]+nums[j]+nums[low]+nums[high];\\n                    if(sum==target){\\n                        List<Integer>list=new ArrayList<>();\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(nums[low]);\\n                        list.add(nums[high]);\\n                \\n                \\n                if(result.contains(list)==false){\\n                    result.add(list);\\n                }\\n                low++;\\n                high--;\\n                    }\\n             else if(sum<target){\\n                    low++;\\n                }\\n                else{\\n                    high--;\\n                }\\n                }\\n            }\\n        }\\n        return result;\\n                \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result=new ArrayList<>();\\n        if(nums==null || nums.length<4){\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 517139,
                "title": "c-generalized-to-ksum",
                "content": "# Generalization to k-sum problems\\n\\nFor `k >= 3`, the following solution achieves the best time complexity possible which is `O( n^{k-1} )`.\\n```c++\\n\\tvoid kSum(vector<int>& nums, int target, int k, int start, vector<vector<int>>& res, vector<int>& curr, int sm){\\n        if(k == 2){\\n            int i = start, j = nums.size() - 1;\\n            target -= sm;\\n            while(i < j){\\n                if(nums[i] + nums[j] < target) i++;\\n                else if(nums[i] + nums[j] > target) j--;\\n                else{\\n                    curr[curr.size() - 2] = nums[i];\\n                    curr[curr.size() - 1] = nums[j];\\n                    res.push_back(curr);\\n                    while(i + 1 < j && nums[i] == nums[i + 1]) i++;\\n                    i++;\\n                    while(i < j - 1 && nums[j] == nums[j - 1]) j--;\\n                    j--;\\n                }\\n            }\\n            return;\\n        }\\n        for(int i = start; i + k - 1 < nums.size(); i++){\\n            curr[curr.size() - k] = nums[i];\\n            kSum(nums, target, k - 1, i + 1, res, curr, sm + nums[i]);\\n            while(i + 1 < nums.size() && nums[i] == nums[i + 1]) i++;\\n        }\\n    }\\n    \\n    inline vector<vector<int>> kSumWrapper(vector<int>& nums, int target, int k){\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        vector<int> curr(k, 0);\\n        kSum(nums, target, k, 0, res, curr, 0);\\n        return res;\\n    }\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        return kSumWrapper(nums, target, 4);\\n    }\\n```\\n\\n************************************************************************************************\\n\\nFor `k == 2`, the above solution does not achieve the best time complexity possible. One should instead use hash-table approach to achieve `O(n)` time complexity.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\n\\tvoid kSum(vector<int>& nums, int target, int k, int start, vector<vector<int>>& res, vector<int>& curr, int sm){\\n        if(k == 2){\\n            int i = start, j = nums.size() - 1;\\n            target -= sm;\\n            while(i < j){\\n                if(nums[i] + nums[j] < target) i++;\\n                else if(nums[i] + nums[j] > target) j--;\\n                else{\\n                    curr[curr.size() - 2] = nums[i];\\n                    curr[curr.size() - 1] = nums[j];\\n                    res.push_back(curr);\\n                    while(i + 1 < j && nums[i] == nums[i + 1]) i++;\\n                    i++;\\n                    while(i < j - 1 && nums[j] == nums[j - 1]) j--;\\n                    j--;\\n                }\\n            }\\n            return;\\n        }\\n        for(int i = start; i + k - 1 < nums.size(); i++){\\n            curr[curr.size() - k] = nums[i];\\n            kSum(nums, target, k - 1, i + 1, res, curr, sm + nums[i]);\\n            while(i + 1 < nums.size() && nums[i] == nums[i + 1]) i++;\\n        }\\n    }\\n    \\n    inline vector<vector<int>> kSumWrapper(vector<int>& nums, int target, int k){\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        vector<int> curr(k, 0);\\n        kSum(nums, target, k, 0, res, curr, 0);\\n        return res;\\n    }\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        return kSumWrapper(nums, target, 4);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440321,
                "title": "c-4ms-99-88-9-1mb-94-74-2-pointers-within-2-for-loops",
                "content": "* Runtime: 4 ms, faster than 99.88% of C++ online submissions for 4Sum.\\n* Memory Usage: 9.1 MB, less than 94.74% of C++ online submissions for 4Sum.\\n\\n```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution {\\npublic:\\nvector< vector<int> > fourSum(vector<int>& nums, int target) {\\n\\tvector< vector<int> > result;\\n\\tsize_t n = nums.size();\\n\\tif (n < 4) \\treturn result;\\n\\n\\n\\tsort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n-3; ++i) {\\n\\t\\tif (target <= 0 && nums[i] > 0) break;\\n\\n\\t\\tif (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;\\n\\t\\tif (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\tif (i > 0 && nums[i] == nums[i-1]) continue;\\n\\n\\t\\tfor (int j = i+1; j < n - 2; ++j) {\\n\\t\\t\\tif (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;\\n\\t\\t\\tif (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t\\tif (j > i+1 && nums[j] == nums[j-1]) continue;\\n\\n\\t\\t\\tint left = j+1, right = n-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\t\\t\\t\\tif (sum == target) \\n                {\\n\\t\\t\\t\\t\\tresult.push_back({nums[i], nums[j], nums[left], nums[right]});\\n\\t\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t\\twhile (left < right && nums[left] == last_left) ++left;\\n\\t\\t\\t\\t\\twhile (left < right && nums[right] == last_right) --right;\\n\\t\\t\\t\\t} \\n                else if (sum < target) { ++left; } \\n                else { --right; }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\\n\\nclass Solution {\\npublic:\\nvector< vector<int> > fourSum(vector<int>& nums, int target) {\\n\\tvector< vector<int> > result;\\n\\tsize_t n = nums.size();\\n\\tif (n < 4) \\treturn result;\\n\\n\\n\\tsort(nums.begin(), nums.end());\\n\\tfor (int i = 0; i < n-3; ++i) {\\n\\t\\tif (target <= 0 && nums[i] > 0) break;\\n\\n\\t\\tif (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) break;\\n\\t\\tif (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\tif (i > 0 && nums[i] == nums[i-1]) continue;\\n\\n\\t\\tfor (int j = i+1; j < n - 2; ++j) {\\n\\t\\t\\tif (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) break;\\n\\t\\t\\tif (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) continue; \\n\\t\\t\\tif (j > i+1 && nums[j] == nums[j-1]) continue;\\n\\n\\t\\t\\tint left = j+1, right = n-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\t\\t\\t\\tif (sum == target) \\n                {\\n\\t\\t\\t\\t\\tresult.push_back({nums[i], nums[j], nums[left], nums[right]});\\n\\t\\t\\t\\t\\tint last_left = nums[left], last_right = nums[right];\\n\\t\\t\\t\\t\\twhile (left < right && nums[left] == last_left) ++left;\\n\\t\\t\\t\\t\\twhile (left < right && nums[right] == last_right) --right;\\n\\t\\t\\t\\t} \\n                else if (sum < target) { ++left; } \\n                else { --right; }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238725,
                "title": "ksum-java-solution-intuitive-and-clean",
                "content": "The idea is to decompose the K sum problem into classic 2 sum problem. \\nIn Two sum problem, we use head and tail pointer to find the solution.\\n```java\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> res = new LinkedList<>();\\n        if(nums == null || nums.length == 0){\\n            return res;\\n        }\\n        Arrays.sort(nums);\\n        return kSum(4, nums,0,target);\\n    }\\n\\n    public List<List<Integer>> kSum(int k, int[] nums, int startIndex, int target){\\n        List<List<Integer>> res = new LinkedList<>();\\n        if(k > nums.length - startIndex){\\n            return res;\\n        }\\n        if(k == 2){\\n            int i = startIndex, j = nums.length-1;\\n            while(i < j){\\n                if(nums[i] + nums[j] == target){\\n                    List<Integer> temp = new LinkedList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    res.add(temp);\\n                    while(i < j && nums[i] == nums[++i]);\\n                    while(i < j && nums[j] == nums[--j]);\\n                }\\n                else if(nums[i] + nums[j] < target){\\n                    i++;\\n                }\\n                else{\\n                    j--;\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            for(int i = startIndex; i < nums.length; i++){\\n                if(i > startIndex && nums[i] == nums[i-1]){\\n                    continue;\\n                }\\n                List<List<Integer>> tempLists = kSum(k - 1, nums, i + 1, target - nums[i]);\\n                for(List<Integer> temp : tempLists){\\n                    temp.add(0,nums[i]);\\n                    res.add(temp);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> res = new LinkedList<>();\\n        if(nums == null || nums.length == 0){\\n            return res;\\n        }\\n        Arrays.sort(nums);\\n        return kSum(4, nums,0,target);\\n    }\\n\\n    public List<List<Integer>> kSum(int k, int[] nums, int startIndex, int target){\\n        List<List<Integer>> res = new LinkedList<>();\\n        if(k > nums.length - startIndex){\\n            return res;\\n        }\\n        if(k == 2){\\n            int i = startIndex, j = nums.length-1;\\n            while(i < j){\\n                if(nums[i] + nums[j] == target){\\n                    List<Integer> temp = new LinkedList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    res.add(temp);\\n                    while(i < j && nums[i] == nums[++i]);\\n                    while(i < j && nums[j] == nums[--j]);\\n                }\\n                else if(nums[i] + nums[j] < target){\\n                    i++;\\n                }\\n                else{\\n                    j--;\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            for(int i = startIndex; i < nums.length; i++){\\n                if(i > startIndex && nums[i] == nums[i-1]){\\n                    continue;\\n                }\\n                List<List<Integer>> tempLists = kSum(k - 1, nums, i + 1, target - nums[i]);\\n                for(List<Integer> temp : tempLists){\\n                    temp.add(0,nums[i]);\\n                    res.add(temp);\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218940,
                "title": "o-n-2-method-with-cpp",
                "content": "It is very tricky that for cpp user, it would not be that much easier to implement the O(n^2) method since the deduplicate process is a bit disgusting. Here, I would share my code that solve such problem with built-in unique() function so as to implement the O(n^2) method. If you have any better method, please tell me. \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        if (nums.size() == 0)\\n            return result;\\n        \\n        unordered_map<int, vector<pair<int, int>>> map;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                map[target - nums[i] - nums[j]].push_back({i, j});\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int temp = nums[i] + nums[j];\\n                if (map.find(temp) != map.end()) {\\n                    for (auto p : map[temp]) {\\n                        if (p.first == i || p.first == j ||\\n                            p.second == i || p.second == j)\\n                            continue;                        \\n                        result.push_back({nums[p.first], nums[p.second], nums[i], nums[j]});\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < result.size(); ++i) {\\n            sort(result[i].begin(), result[i].end());\\n        }\\n        sort(result.begin(), result.end());\\n        result.erase(unique(result.begin(), result.end()), result.end());\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        if (nums.size() == 0)\\n            return result;\\n        \\n        unordered_map<int, vector<pair<int, int>>> map;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                map[target - nums[i] - nums[j]].push_back({i, j});\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int temp = nums[i] + nums[j];\\n                if (map.find(temp) != map.end()) {\\n                    for (auto p : map[temp]) {\\n                        if (p.first == i || p.first == j ||\\n                            p.second == i || p.second == j)\\n                            continue;                        \\n                        result.push_back({nums[p.first], nums[p.second], nums[i], nums[j]});\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < result.size(); ++i) {\\n            sort(result[i].begin(), result[i].end());\\n        }\\n        sort(result.begin(), result.end());\\n        result.erase(unique(result.begin(), result.end()), result.end());\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8604,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**4Sum** https://leetcode.com/problems/4sum/\\n\\n* Brute force solution will be O(N^4).\\n* Optimized solution will be O(N^3). We will first sort the input. Then we will use the two pointer technique.\\n* We will use the same optimizations which we used in 3SUM problem to avoid duplicates. \\n* Reference: https://discuss.leetcode.com/topic/75883/python-solution-with-detailed-explanation\\n```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        N, result = len(nums), []\\n        for i in range(N):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            for j in range(i+1, N):\\n                if j > i+1 and nums[j] == nums[j-1]:\\n                    continue\\n                x = target - nums[i] - nums[j]\\n                s,e = j+1, N-1\\n                while s < e:\\n                    if nums[s]+nums[e] == x:\\n                        result.append([nums[i], nums[j], nums[s], nums[e]])\\n                        s = s+1\\n                        while s < e and nums[s] == nums[s-1]:\\n                            s = s+1\\n                    elif nums[s]+nums[e] < x:\\n                        s = s+1\\n                    else:\\n                        e = e-1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        N, result = len(nums), []\\n        for i in range(N):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            for j in range(i+1, N):\\n                if j > i+1 and nums[j] == nums[j-1]:\\n                    continue\\n                x = target - nums[i] - nums[j]\\n                s,e = j+1, N-1\\n                while s < e:\\n                    if nums[s]+nums[e] == x:\\n                        result.append([nums[i], nums[j], nums[s], nums[e]])\\n                        s = s+1\\n                        while s < e and nums[s] == nums[s-1]:\\n                            s = s+1\\n                    elif nums[s]+nums[e] < x:\\n                        s = s+1\\n                    else:\\n                        e = e-1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8736,
                "title": "a-java-solution-with-two-pointers",
                "content": "     public List<List<Integer>> fourSum(int[] nums, int target) {\\n        \\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\tif (nums == null || nums.length < 4) {\\n        \\t\\treturn result;\\n        \\t}\\n        \\tArrays.sort(nums);\\n        \\tfor (int i = 0; i < nums.length - 3; i ++) {\\n        \\t\\tfor (int j = i + 1; j < nums.length - 2; j ++) {\\n        \\t\\t\\tint head = j + 1;\\n        \\t\\t\\tint tail = nums.length - 1;\\n        \\t\\t\\twhile (head < tail) {\\n        \\t\\t\\t\\tint tempSum = nums[i] + nums[j] + nums[head] + nums[tail];\\n        \\t\\t\\t\\tif (tempSum == target) {\\n        \\t\\t\\t\\t\\tList<Integer> item = new ArrayList<Integer>();\\n        \\t\\t\\t\\t\\titem.add(nums[i]);\\n        \\t\\t\\t\\t\\titem.add(nums[j]);\\n        \\t\\t\\t\\t\\titem.add(nums[head]);\\n        \\t\\t\\t\\t\\titem.add(nums[tail]);\\n        \\t\\t\\t\\t\\tif (result.contains(item) == false) {\\n        \\t\\t\\t\\t\\t\\tresult.add(item);\\n        \\t\\t\\t\\t\\t} \\n        \\t\\t\\t\\t\\thead ++;\\n        \\t\\t\\t\\t\\ttail --;\\n        \\t\\t\\t\\t} else if (tempSum < target) {\\n        \\t\\t\\t\\t\\thead ++;\\n        \\t\\t\\t\\t} else {\\n        \\t\\t\\t\\t\\ttail --;\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn result;\\n        }",
                "solutionTags": [],
                "code": "     public List<List<Integer>> fourSum(int[] nums, int target) {\\n        \\tList<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\tif (nums == null || nums.length < 4) {\\n        \\t\\treturn result;\\n        \\t}\\n        \\tArrays.sort(nums);\\n        \\tfor (int i = 0; i < nums.length - 3; i ++) {\\n        \\t\\tfor (int j = i + 1; j < nums.length - 2; j ++) {\\n        \\t\\t\\tint head = j + 1;\\n        \\t\\t\\tint tail = nums.length - 1;\\n        \\t\\t\\twhile (head < tail) {\\n        \\t\\t\\t\\tint tempSum = nums[i] + nums[j] + nums[head] + nums[tail];\\n        \\t\\t\\t\\tif (tempSum == target) {\\n        \\t\\t\\t\\t\\tList<Integer> item = new ArrayList<Integer>();\\n        \\t\\t\\t\\t\\titem.add(nums[i]);\\n        \\t\\t\\t\\t\\titem.add(nums[j]);\\n        \\t\\t\\t\\t\\titem.add(nums[head]);\\n        \\t\\t\\t\\t\\titem.add(nums[tail]);\\n        \\t\\t\\t\\t\\tif (result.contains(item) == false) {\\n        \\t\\t\\t\\t\\t\\tresult.add(item);\\n        \\t\\t\\t\\t\\t} \\n        \\t\\t\\t\\t\\thead ++;\\n        \\t\\t\\t\\t\\ttail --;\\n        \\t\\t\\t\\t} else if (tempSum < target) {\\n        \\t\\t\\t\\t\\thead ++;\\n        \\t\\t\\t\\t} else {\\n        \\t\\t\\t\\t\\ttail --;\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3917506,
                "title": "two-pointer-approach-easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&& nums[i]==nums[i-1])continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j!=(i+1) && nums[j]==nums[j-1])continue;\\n                int k=j+1;\\n                int l=n-1;\\n                while(k<l)\\n                {\\n                    long long  sum=nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n                    if(sum==target)\\n                    {\\n                    vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                    v.push_back(temp);\\n                    k=k+1;\\n                    l=l-1;\\n                    while(k<l && nums[k]==nums[k-1])k=k+1;\\n                    while(k<l && nums[l]==nums[l+1])l=l-1;\\n                    }\\n                    else if(sum<target)\\n                    {\\n                        k++;\\n                    }\\n                    else{l--;}\\n                }\\n            }\\n        } \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&& nums[i]==nums[i-1])continue;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j!=(i+1) && nums[j]==nums[j-1])continue;\\n                int k=j+1;\\n                int l=n-1;\\n                while(k<l)\\n                {\\n                    long long  sum=nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n                    if(sum==target)\\n                    {\\n                    vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                    v.push_back(temp);\\n                    k=k+1;\\n                    l=l-1;\\n                    while(k<l && nums[k]==nums[k-1])k=k+1;\\n                    while(k<l && nums[l]==nums[l+1])l=l-1;\\n                    }\\n                    else if(sum<target)\\n                    {\\n                        k++;\\n                    }\\n                    else{l--;}\\n                }\\n            }\\n        } \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609498,
                "title": "best-o-n-3-solution",
                "content": "# Approach\\nUsing Two Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^3)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> quadruplets;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0 && nums[i] == nums[i-1])\\n                continue;\\n            for (int j = i+1; j < n; j++) {\\n                if (j != i+1 && nums[j] == nums[j-1])\\n                    continue;\\n                int k = j+1, l = n-1; \\n                while (k < l) {\\n                    long long sum = nums[i] + nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        vector<int> temp = {nums[i], nums[j], nums[k], nums[l]};\\n                        quadruplets.push_back(temp);\\n                        k++;\\n                        l--;\\n                        while (k < l && nums[k] == nums[k-1]) k++;\\n                        while (k < l && nums[l] == nums[l+1]) l--;\\n                    } else if (sum > target) {\\n                        l--;\\n                    } else {\\n                        k++;\\n                    }\\n                }   \\n            }\\n        }\\n        return quadruplets;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> quadruplets;\\n        for (int i = 0; i < n; i++) {\\n            if (i != 0 && nums[i] == nums[i-1])\\n                continue;\\n            for (int j = i+1; j < n; j++) {\\n                if (j != i+1 && nums[j] == nums[j-1])\\n                    continue;\\n                int k = j+1, l = n-1; \\n                while (k < l) {\\n                    long long sum = nums[i] + nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if (sum == target) {\\n                        vector<int> temp = {nums[i], nums[j], nums[k], nums[l]};\\n                        quadruplets.push_back(temp);\\n                        k++;\\n                        l--;\\n                        while (k < l && nums[k] == nums[k-1]) k++;\\n                        while (k < l && nums[l] == nums[l+1]) l--;\\n                    } else if (sum > target) {\\n                        l--;\\n                    } else {\\n                        k++;\\n                    }\\n                }   \\n            }\\n        }\\n        return quadruplets;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440192,
                "title": "c-using-3-sum-easy-explanation-beginner-friendly",
                "content": "UPVOTE AGAR SAWAL ASAAN KIYA AAPKE LIYE \\uD83D\\uDE42.\\n# Advice\\nDONT GO DIRECTLY TO SOLUTION.UNDERSTAND THE FLOW/APPROACH.\\nYOU MUST BE KNOWING HOW TO SOLVE TWO SUM PROBLEM .\\n\\n# Intuition\\nI HAVE SOLVED 3SUM USING 2 SUM .THAT\\'S WHY I GOT INTUTION TO SOLVE FOUR SOME(\\uD83D\\uDE01) USING 3 SUM .\\n\\n# Approach\\n1. IN AN ARRAY AT INDEX I, I TAKE THE ARRAY ELEMENT IN FOUR SUM CONSIDERATION IF NOT PREVIOUSLY TAKEN AND STORE IT IN A VARIABLE A=NUMS[I] .THEN ASK THREE SUM TO FIND TARGET-NUMS[I] IN REMAINING ARRAY.\\n\\n2. AGAIN IN ARRAY AT INDEX I, TAKE THE ARRAY ELEMENT IN FOUR SUM CONSIDERATION IF NOT PREVIOUSLY TAKEN AND STORE IT IN A VARIABLE B=NUMS[I].THEN ASK FOR TWO SUM TO FIND TARGET-NUMS[I] IN REMAINING ARRAY.\\n\\n3. SIMPLE TWO SUM PROBLEM\\uD83D\\uDE0E.\\n\\n```\\nwhile(i<j){\\n            if(target==nums[i]+nums[j]){\\n                //STORE IN ANS \\n                ans.push_back({a,b,nums[i],nums[j]});\\n        // DISTINCT SUBARRAY SHOULD BE INSIDE VECTOR<VECTOR<INT>>ANS.\\n                i++,j--;\\n                while(j>i && nums[j]==nums[j+1])j--;\\n                while(i<j&&nums[i]==nums[i-1])i++;\\n            }\\n            else if(nums[i]+nums[j]>target)j--;\\n            else{\\n                ++i;\\n            }\\n        }\\n\\n```\\nEXAMPLE : LET ARRAY[-2,-2,-1,0,1,1,2,2].TARGET=0.\\n![WhatsApp Image 2023-04-21 at 12.06.57.jpg](https://assets.leetcode.com/users/images/13d0d6d0-ab45-404e-a022-9768e9af6854_1682059109.5560734.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void twosum(vector<int>&nums,int i,long long target,vector<vector<int>>&ans,int a ,int b){\\n        int n =nums.size();\\n        int j=n-1;\\n\\n        while(i<j){\\n            if(target==nums[i]+nums[j]){\\n                ans.push_back({a,b,nums[i],nums[j]});\\n                i++,j--;\\n                while(j>i && nums[j]==nums[j+1])j--;\\n                while(i<j&&nums[i]==nums[i-1])i++;\\n            }\\n            else if(nums[i]+nums[j]>target)j--;\\n            else{\\n                ++i;\\n            }\\n        }\\n        return;\\n    }\\n    void threesum(vector<vector<int>>&ans,vector<int>& nums,int j,long long target,int a ) {\\n        int n =nums.size();\\n        twosum(nums,j+1,target-nums[j],ans,a,nums[j]);\\n\\n        for(int i =j+1;i<n-2;i++){\\n            if(nums[i]==nums[i-1])continue;\\n            int b=nums[i];\\n            twosum(nums,i+1,target-nums[i],ans,a,b);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int t) {\\n        long long target=t;\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n =nums.size();\\n\\n        if(n>=4)threesum(ans,nums,1,target-nums[0],nums[0]);\\n        if(nums[0]>0 && nums[0]>target)return ans;\\n\\n        for(int i=1;i<n-3;i++){\\n            if(nums[i]==nums[i-1])continue;\\n            int a=nums[i];\\n            threesum(ans,nums,i+1,target-nums[i],a);\\n        }\\n        return ans ;\\n    }\\n};\\n```\\nTHANK YOU \\nCODE BY:) AMAN MAURYA",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i<j){\\n            if(target==nums[i]+nums[j]){\\n                //STORE IN ANS \\n                ans.push_back({a,b,nums[i],nums[j]});\\n        // DISTINCT SUBARRAY SHOULD BE INSIDE VECTOR<VECTOR<INT>>ANS.\\n                i++,j--;\\n                while(j>i && nums[j]==nums[j+1])j--;\\n                while(i<j&&nums[i]==nums[i-1])i++;\\n            }\\n            else if(nums[i]+nums[j]>target)j--;\\n            else{\\n                ++i;\\n            }\\n        }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    void twosum(vector<int>&nums,int i,long long target,vector<vector<int>>&ans,int a ,int b){\\n        int n =nums.size();\\n        int j=n-1;\\n\\n        while(i<j){\\n            if(target==nums[i]+nums[j]){\\n                ans.push_back({a,b,nums[i],nums[j]});\\n                i++,j--;\\n                while(j>i && nums[j]==nums[j+1])j--;\\n                while(i<j&&nums[i]==nums[i-1])i++;\\n            }\\n            else if(nums[i]+nums[j]>target)j--;\\n            else{\\n                ++i;\\n            }\\n        }\\n        return;\\n    }\\n    void threesum(vector<vector<int>>&ans,vector<int>& nums,int j,long long target,int a ) {\\n        int n =nums.size();\\n        twosum(nums,j+1,target-nums[j],ans,a,nums[j]);\\n\\n        for(int i =j+1;i<n-2;i++){\\n            if(nums[i]==nums[i-1])continue;\\n            int b=nums[i];\\n            twosum(nums,i+1,target-nums[i],ans,a,b);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int t) {\\n        long long target=t;\\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n =nums.size();\\n\\n        if(n>=4)threesum(ans,nums,1,target-nums[0],nums[0]);\\n        if(nums[0]>0 && nums[0]>target)return ans;\\n\\n        for(int i=1;i<n-3;i++){\\n            if(nums[i]==nums[i-1])continue;\\n            int a=nums[i];\\n            threesum(ans,nums,i+1,target-nums[i],a);\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817670,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        map<vector<int>, int> mp;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=i+1; j<nums.size(); j++) {\\n                int l = j + 1, r = nums.size() - 1; \\n                while(l < r) {\\n                    long long sum = (long long) nums[i] + nums[j] + nums[l] + nums[r];\\n                    if(sum == target) {\\n                        mp[{nums[i], nums[j], nums[l], nums[r]}]++;\\n                        if(mp[{nums[i], nums[j], nums[l], nums[r]}] == 1) ans.push_back({nums[i], nums[j], nums[l], nums[r]});\\n                        l++;\\n                        r--;\\n                    }\\n                    else if(sum < target) l++;\\n                    else if(sum > target) r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        map<vector<int>, int> mp;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=i+1; j<nums.size(); j++) {\\n                int l = j + 1, r = nums.size() - 1; \\n                while(l < r) {\\n                    long long sum = (long long) nums[i] + nums[j] + nums[l] + nums[r];\\n                    if(sum == target) {\\n                        mp[{nums[i], nums[j], nums[l], nums[r]}]++;\\n                        if(mp[{nums[i], nums[j], nums[l], nums[r]}] == 1) ans.push_back({nums[i], nums[j], nums[l], nums[r]});\\n                        l++;\\n                        r--;\\n                    }\\n                    else if(sum < target) l++;\\n                    else if(sum > target) r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682974,
                "title": "java-2-approaches-brute-and-optimal",
                "content": "### **Please Upvote** :D\\n##### 1. Brute force approach (TLE - 288/291 passed):\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int n = nums.length;\\n        if (n < 4) return new ArrayList<>(); // it\\'d still be handled even if we don\\'t write this condition\\n        Arrays.sort(nums);\\n\\n        Set<List<Integer>> ans = new HashSet<>();\\n\\n        for (int i = 0; i < n; i++) \\n            for (int j =  i + 1; j < n; j++) \\n                for (int k =  j + 1; k < n; k++) \\n                    for (int l = k + 1; l < n; l++) \\n                        if (nums[i] + nums[j] + nums[k] + nums[l] == target) \\n                            ans.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n\\n        return new ArrayList(ans);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 4) => O(n ^ 4)\\n// SC: O(1) - Ignoring output array\\n```\\n##### 2. Optimal solution (Two pointers):\\nWe iterate using the first for loop and find the remaining 3 elements by the same **[3Sum](https://leetcode.com/problems/3sum/discuss/2397624/JAVA-or-3-approaches)** approach.\\n\\nOr we can say, we find the first two elements using nested for loops and find the remaining 2 elements by the **[TwoSum](https://leetcode.com/problems/two-sum/discuss/2345909/Java-solution-(brute-force-and-optimized))** approach.\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n\\n                long target2 = (long) target - (long) nums[i] - (long) nums[j];\\n                int lo = j + 1, hi = n - 1;\\n\\n                while (lo < hi) {\\n                    int twoSum = nums[lo] + nums[hi];\\n\\n                    if (twoSum < target2) lo++;\\n                    else if (twoSum > target2) hi--;\\n                    else {\\n                        List<Integer> quad = Arrays.asList(nums[i], nums[j], nums[lo], nums[hi]);\\n                        ans.add(quad);\\n\\n                        while (lo < hi && nums[lo] == quad.get(2)) lo++;\\n                        while (lo < hi && nums[hi] == quad.get(3)) hi--;\\n                    }\\n                }\\n\\n                while (j + 1 < n && nums[j] == nums[j + 1]) j++;\\n            }\\n\\n            while (i + 1 < n && nums[i] == nums[i + 1]) i++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 3) => O(n ^ 3)\\n// SC: O(1) - ignoring the output array\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int n = nums.length;\\n        if (n < 4) return new ArrayList<>(); // it\\'d still be handled even if we don\\'t write this condition\\n        Arrays.sort(nums);\\n\\n        Set<List<Integer>> ans = new HashSet<>();\\n\\n        for (int i = 0; i < n; i++) \\n            for (int j =  i + 1; j < n; j++) \\n                for (int k =  j + 1; k < n; k++) \\n                    for (int l = k + 1; l < n; l++) \\n                        if (nums[i] + nums[j] + nums[k] + nums[l] == target) \\n                            ans.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l]));\\n\\n        return new ArrayList(ans);\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 4) => O(n ^ 4)\\n// SC: O(1) - Ignoring output array\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n\\n                long target2 = (long) target - (long) nums[i] - (long) nums[j];\\n                int lo = j + 1, hi = n - 1;\\n\\n                while (lo < hi) {\\n                    int twoSum = nums[lo] + nums[hi];\\n\\n                    if (twoSum < target2) lo++;\\n                    else if (twoSum > target2) hi--;\\n                    else {\\n                        List<Integer> quad = Arrays.asList(nums[i], nums[j], nums[lo], nums[hi]);\\n                        ans.add(quad);\\n\\n                        while (lo < hi && nums[lo] == quad.get(2)) lo++;\\n                        while (lo < hi && nums[hi] == quad.get(3)) hi--;\\n                    }\\n                }\\n\\n                while (j + 1 < n && nums[j] == nums[j + 1]) j++;\\n            }\\n\\n            while (i + 1 < n && nums[i] == nums[i + 1]) i++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n ^ 3) => O(n ^ 3)\\n// SC: O(1) - ignoring the output array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531547,
                "title": "bruteforce-to-better-to-optimal-c-multiple-solutions",
                "content": "```cpp\\ntypedef long long ll;\\n\\n\\n// Bruteforce | O(n^4) time | O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        set<vector<int>> st;\\n        sort(nums.begin(), nums.end());\\n        for (int i =0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    for (int t = k + 1; t < n; t++) {\\n                        if ((ll)nums[i] + nums[j] + nums[k] + nums[t] == (ll)target) {\\n                            vector<int> quad = {nums[i], nums[j], nums[k], nums[t]};\\n                            st.insert(quad);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> res(st.begin(), st.end());\\n        return res;\\n    }\\n};\\n\\n\\n// Bruteforce | O(n^4) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i =0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    for (int t = k + 1; t < n; t++) {\\n                        if ((ll)nums[i] + nums[j] + nums[k] + nums[t] == (ll)target) {\\n                            vector<int> quad = {nums[i], nums[j], nums[k], nums[t]};\\n                            res.push_back(quad);\\n                        }\\n                        while (t < n - 1 && nums[t] == nums[t + 1]) t++;\\n                    }\\n                    while (k < n - 1 && nums[k] == nums[k + 1]) k++;\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n// Optimal | O(n^3 * log(n)) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    ll sumOfThree = (ll)nums[i] + (ll)nums[j] + (ll)nums[k];\\n                    int fourthNum = target - sumOfThree;\\n                    if (binary_search(nums.begin() + k + 1, nums.end(), fourthNum)) {\\n                        vector<int> quad = {nums[i], nums[j], nums[k], fourthNum};\\n                        res.push_back(quad);\\n                    }\\n                    while (k < n - 1 && nums[k] == nums[k + 1]) k++;\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n// Most Optimal | O(n^3) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                int l = j + 1, r = n - 1;\\n                ll remSum = (ll)target - (ll)nums[i] - (ll)nums[j];\\n                while (l < r) {\\n                    ll sumOfLastTwo = nums[l] + nums[r];\\n                    if (sumOfLastTwo < remSum) l++;\\n                    else if (sumOfLastTwo > remSum) r--;\\n                    else {\\n                        vector<int> quad = {nums[i], nums[j], nums[l], nums[r]};\\n                        res.push_back(quad);\\n                        while (l < r && nums[l] == quad[2]) l++;\\n                        while (l < r && nums[r] == quad[3]) r--;\\n                    }\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\ntypedef long long ll;\\n\\n\\n// Bruteforce | O(n^4) time | O(n) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        set<vector<int>> st;\\n        sort(nums.begin(), nums.end());\\n        for (int i =0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    for (int t = k + 1; t < n; t++) {\\n                        if ((ll)nums[i] + nums[j] + nums[k] + nums[t] == (ll)target) {\\n                            vector<int> quad = {nums[i], nums[j], nums[k], nums[t]};\\n                            st.insert(quad);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> res(st.begin(), st.end());\\n        return res;\\n    }\\n};\\n\\n\\n// Bruteforce | O(n^4) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i =0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    for (int t = k + 1; t < n; t++) {\\n                        if ((ll)nums[i] + nums[j] + nums[k] + nums[t] == (ll)target) {\\n                            vector<int> quad = {nums[i], nums[j], nums[k], nums[t]};\\n                            res.push_back(quad);\\n                        }\\n                        while (t < n - 1 && nums[t] == nums[t + 1]) t++;\\n                    }\\n                    while (k < n - 1 && nums[k] == nums[k + 1]) k++;\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n// Optimal | O(n^3 * log(n)) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                for (int k = j + 1; k < n - 1; k++) {\\n                    ll sumOfThree = (ll)nums[i] + (ll)nums[j] + (ll)nums[k];\\n                    int fourthNum = target - sumOfThree;\\n                    if (binary_search(nums.begin() + k + 1, nums.end(), fourthNum)) {\\n                        vector<int> quad = {nums[i], nums[j], nums[k], fourthNum};\\n                        res.push_back(quad);\\n                    }\\n                    while (k < n - 1 && nums[k] == nums[k + 1]) k++;\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n// Most Optimal | O(n^3) time | O(1) space\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int> &nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n - 3; i++) {\\n            for (int j = i + 1; j < n - 2; j++) {\\n                int l = j + 1, r = n - 1;\\n                ll remSum = (ll)target - (ll)nums[i] - (ll)nums[j];\\n                while (l < r) {\\n                    ll sumOfLastTwo = nums[l] + nums[r];\\n                    if (sumOfLastTwo < remSum) l++;\\n                    else if (sumOfLastTwo > remSum) r--;\\n                    else {\\n                        vector<int> quad = {nums[i], nums[j], nums[l], nums[r]};\\n                        res.push_back(quad);\\n                        while (l < r && nums[l] == quad[2]) l++;\\n                        while (l < r && nums[r] == quad[3]) r--;\\n                    }\\n                }\\n                while (j < n - 1 && nums[j] == nums[j + 1]) j++;\\n            }\\n            while (i < n - 1 && nums[i] == nums[i + 1]) i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902903,
                "title": "extension-of-2-sum-solution-works-in-o-n-3",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                # two sum problem solution\\n                new_target = target - (nums[i] + nums[j])\\n                start = j+1\\n                end = n-1\\n                while end > start:\\n                    if(nums[start] + nums[end] == new_target):\\n                        ans.add((nums[i], nums[j], nums[start], nums[end]))\\n                        end -= 1\\n                        start += 1\\n                    elif nums[start] + nums[end] > new_target:\\n                        end -= 1\\n                    else:\\n                        start += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        ans = set()\\n        n = len(nums)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                # two sum problem solution\\n                new_target = target - (nums[i] + nums[j])\\n                start = j+1\\n                end = n-1\\n                while end > start:\\n                    if(nums[start] + nums[end] == new_target):\\n                        ans.add((nums[i], nums[j], nums[start], nums[end]))\\n                        end -= 1\\n                        start += 1\\n                    elif nums[start] + nums[end] > new_target:\\n                        end -= 1\\n                    else:\\n                        start += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341570,
                "title": "4sum-two-pointer-commented",
                "content": "```\\n vector<vector<int>> fourSum(vector<int> nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        //store in set as we need unique quadruplets  only\\n        set<vector<int>> res;\\n        \\n        //less than 4 no ans\\n        if(n < 4) return ans;\\n        \\n        sort(begin(nums),end(nums));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                //choose two pointer \\n                int l = j+1 , r = n-1;\\n                //calc rest req sum\\n                int req = target-nums[i]-nums[j];\\n                while(l < r){\\n                    //if it is our sum take it and inc or dec pointer if we nums[l]==nums[l+1], or otherwise.\\n                    if((nums[l]+nums[r]) == req){\\n                        //take it\\n                        res.insert({nums[i],nums[j],nums[l],nums[r]});\\n                        if(nums[l] == nums[l+1]) l++;\\n                        else r--;\\n                    }\\n                    //if the sum is greater than require dec last pointer to dec sum\\n                    else if((nums[l]+nums[r]) > req){\\n                        r--;\\n                    }\\n                    //otherwise inc\\n                    else{\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<vector<int>> fourSum(vector<int> nums, int target) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        //store in set as we need unique quadruplets  only\\n        set<vector<int>> res;\\n        \\n        //less than 4 no ans\\n        if(n < 4) return ans;\\n        \\n        sort(begin(nums),end(nums));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                //choose two pointer \\n                int l = j+1 , r = n-1;\\n                //calc rest req sum\\n                int req = target-nums[i]-nums[j];\\n                while(l < r){\\n                    //if it is our sum take it and inc or dec pointer if we nums[l]==nums[l+1], or otherwise.\\n                    if((nums[l]+nums[r]) == req){\\n                        //take it\\n                        res.insert({nums[i],nums[j],nums[l],nums[r]});\\n                        if(nums[l] == nums[l+1]) l++;\\n                        else r--;\\n                    }\\n                    //if the sum is greater than require dec last pointer to dec sum\\n                    else if((nums[l]+nums[r]) > req){\\n                        r--;\\n                    }\\n                    //otherwise inc\\n                    else{\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(auto it : res){\\n            ans.push_back(it);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624935,
                "title": "dp-twosum-style-python-solution",
                "content": "The idea is that fourSum is just two twoSums\\n1. We can treat the input like an N x N matrix of summed values \\nwhere eg. nums[0][1] is nums[0] + nums[1]\\nTo avoid duplicate calculations we only traverse half the matrix\\nstopping right before nums[i][i] because that would be a number plus itself\\n\\n2. Similar to twoSum, we keep track of sums we\\'ve seen so far\\nand find the other half we need to add up to the target\\nhave = nums[r] - nums[c] basically a new two sum\\nneed = target - have\\nHere we\\'re keeping track of the indexes in an array, with a key of their sum\\n\\n3. If we find it, make sure that all indexes are unique by counting a unique set\\nand making sure they add to up four. Then storying in a set\\n\\n112 ms\\nO(N^2)\\n\\t\\t\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        # Store a dp style table of [row][col] for each two sum\\n        dp = {}\\n        res = set()\\n        seen = defaultdict(list)\\n        # 1\\n        for r in range(len(nums)):\\n            for c in range(r):\\n                have = nums[r] + nums[c]\\n                need = target - have\\n                # 2\\n                if need in seen:\\n                    # 3\\n                    for r1,c1 in seen[need]:\\n                        if len({r1,c1,r,c}) == 4:\\n                            res.add( tuple(sorted([nums[r1],nums[c1],nums[r],nums[c]])) ) \\n                seen[have].append((r, c))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        # Store a dp style table of [row][col] for each two sum\\n        dp = {}\\n        res = set()\\n        seen = defaultdict(list)\\n        # 1\\n        for r in range(len(nums)):\\n            for c in range(r):\\n                have = nums[r] + nums[c]\\n                need = target - have\\n                # 2\\n                if need in seen:\\n                    # 3\\n                    for r1,c1 in seen[need]:\\n                        if len({r1,c1,r,c}) == 4:\\n                            res.add( tuple(sorted([nums[r1],nums[c1],nums[r],nums[c]])) ) \\n                seen[have].append((r, c))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292934,
                "title": "python-hashmap-64ms",
                "content": "Refer from [Python 140ms beats 100%, and works for N-sum (N>=2)](https://leetcode.com/problems/4sum/discuss/8545/Python-140ms-beats-100-and-works-for-N-sum-(Ngreater2)), some optimization is made for the sorted nums. Use defaultdict to improve the performance of hashmap.\\n\\n```\\nimport collections\\n\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        if len(nums) < 4 or 4*nums[0] > target or 4*nums[-1] < target: return []\\n        # use defaultdic for better performance\\n        total_map = collections.defaultdict(list)\\n        results = set()\\n        \\n        for num1 in range(len(nums)-1):\\n            for num2 in range(num1 + 1, len(nums)):\\n                diff = target - nums[num1] - nums[num2]\\n                total_map[diff].append((num1, num2))\\n\\n                    \\n        for num1 in range(len(nums) - 3):\\n            for num2 in range(num1 + 1, len(nums)):\\n                total = nums[num1] + nums[num2]\\n                if total in total_map:\\n                    for pair in total_map[total]:\\n                        # Exclude the case pair[0] or pair[1] is num1 or num2\\n                        if pair[0] > num2:\\n                            #Cannot add list directly. Python thinks list is unhashable\\n                            results.add((nums[num1], nums[num2], nums[pair[0]], nums[pair[1]]))\\n        \\n        return [list(result) for result in results]\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        if len(nums) < 4 or 4*nums[0] > target or 4*nums[-1] < target: return []\\n        # use defaultdic for better performance\\n        total_map = collections.defaultdict(list)\\n        results = set()\\n        \\n        for num1 in range(len(nums)-1):\\n            for num2 in range(num1 + 1, len(nums)):\\n                diff = target - nums[num1] - nums[num2]\\n                total_map[diff].append((num1, num2))\\n\\n                    \\n        for num1 in range(len(nums) - 3):\\n            for num2 in range(num1 + 1, len(nums)):\\n                total = nums[num1] + nums[num2]\\n                if total in total_map:\\n                    for pair in total_map[total]:\\n                        # Exclude the case pair[0] or pair[1] is num1 or num2\\n                        if pair[0] > num2:\\n                            #Cannot add list directly. Python thinks list is unhashable\\n                            results.add((nums[num1], nums[num2], nums[pair[0]], nums[pair[1]]))\\n        \\n        return [list(result) for result in results]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169493,
                "title": "java-o-n-2-using-heckloads-of-dicts-and-maps",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Set<Set<Integer>> set = new HashSet<>();\\n        Map<Integer, Set<Set<Integer>>> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int sum = nums[i] + nums[j];\\n                Set<Integer> indicesSet = new HashSet(Arrays.asList(i , j));\\n                int diff = target - sum;\\n                if (map.containsKey(diff)) {\\n                    for (Set<Integer> s : map.get(diff)) {\\n                        Set<Integer> ans = new HashSet<>(indicesSet);\\n                        for (Integer idx : s) {\\n                            ans.add(idx);\\n                        }\\n                        set.add(ans);\\n                    }\\n                }\\n                if (map.containsKey(sum)) {\\n                    map.get(sum).add(indicesSet);\\n                } else {\\n                    map.put(sum, new HashSet<>());\\n                    map.get(sum).add(indicesSet);\\n                }\\n            }\\n        }\\n        \\n        Set<List<Integer>> ans = new HashSet<>();\\n        for (Set<Integer> s : set) {\\n            if (s.size() == 4) {\\n                List<Integer> a = new ArrayList<>();\\n                for (Integer idx : s) {\\n                    a.add(nums[idx]);\\n                }\\n                Collections.sort(a);\\n                ans.add(a);\\n            }\\n        }\\n        return new ArrayList<List<Integer>>(ans);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Set<Set<Integer>> set = new HashSet<>();\\n        Map<Integer, Set<Set<Integer>>> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                int sum = nums[i] + nums[j];\\n                Set<Integer> indicesSet = new HashSet(Arrays.asList(i , j));\\n                int diff = target - sum;\\n                if (map.containsKey(diff)) {\\n                    for (Set<Integer> s : map.get(diff)) {\\n                        Set<Integer> ans = new HashSet<>(indicesSet);\\n                        for (Integer idx : s) {\\n                            ans.add(idx);\\n                        }\\n                        set.add(ans);\\n                    }\\n                }\\n                if (map.containsKey(sum)) {\\n                    map.get(sum).add(indicesSet);\\n                } else {\\n                    map.put(sum, new HashSet<>());\\n                    map.get(sum).add(indicesSet);\\n                }\\n            }\\n        }\\n        \\n        Set<List<Integer>> ans = new HashSet<>();\\n        for (Set<Integer> s : set) {\\n            if (s.size() == 4) {\\n                List<Integer> a = new ArrayList<>();\\n                for (Integer idx : s) {\\n                    a.add(nums[idx]);\\n                }\\n                Collections.sort(a);\\n                ans.add(a);\\n            }\\n        }\\n        return new ArrayList<List<Integer>>(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165059,
                "title": "my-javascript-solution-beats-88",
                "content": "To add another layer of index (I chose `start`) to 3Sum (`i, lo, hi`), we just need to wrap the 3Sum loops with another for loop, and change the starting index of `i` to `i = start + 1`.\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    // sort\\n    nums = nums.sort((a,b) => a - b)\\n    \\n    var answer = []\\n    if (nums.length < 4) return answer\\n    \\n    for (var start = 0; start <= nums.length - 4; start++) {\\n        if (start > 0 && nums[start] == nums[start - 1]) continue\\n        var _target = target - nums[start]\\n\\t\\t\\t\\t\\n        for (var i = start + 1; i <= nums.length - 3; i++) {\\n            if (i > start + 1 && nums[i] == nums[i - 1]) continue\\n            \\n            for (var lo = i + 1, hi = nums.length - 1; lo < hi; /* blank */) {\\n                var sum = nums[i] + nums[lo] + nums[hi]\\n                \\n                if (sum === _target) {\\n                    answer.push([nums[start], nums[i], nums[lo], nums[hi]])\\n                    while (lo < hi && nums[lo] == nums[lo + 1]) lo++\\n                    while (lo < hi && nums[hi] == nums[hi - 1]) hi--\\n                    lo++\\n                    hi--\\n                }\\n                else if (sum > _target) {\\n                    hi--\\n                }\\n                else {\\n                    lo++\\n                }\\n            }\\n        }\\n    }\\n    \\n    return answer\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    // sort\\n    nums = nums.sort((a,b) => a - b)\\n    \\n    var answer = []\\n    if (nums.length < 4) return answer\\n    \\n    for (var start = 0; start <= nums.length - 4; start++) {\\n        if (start > 0 && nums[start] == nums[start - 1]) continue\\n        var _target = target - nums[start]\\n\\t\\t\\t\\t\\n        for (var i = start + 1; i <= nums.length - 3; i++) {\\n            if (i > start + 1 && nums[i] == nums[i - 1]) continue\\n            \\n            for (var lo = i + 1, hi = nums.length - 1; lo < hi; /* blank */) {\\n                var sum = nums[i] + nums[lo] + nums[hi]\\n                \\n                if (sum === _target) {\\n                    answer.push([nums[start], nums[i], nums[lo], nums[hi]])\\n                    while (lo < hi && nums[lo] == nums[lo + 1]) lo++\\n                    while (lo < hi && nums[hi] == nums[hi - 1]) hi--\\n                    lo++\\n                    hi--\\n                }\\n                else if (sum > _target) {\\n                    hi--\\n                }\\n                else {\\n                    lo++\\n                }\\n            }\\n        }\\n    }\\n    \\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8599,
                "title": "golang-concise-26ms-solution",
                "content": "Just pick the first element and then for the remaining array, apply 3 sum.\\n`O(n^3)` .\\n\\n```\\nfunc fourSum(nums []int, target int) [][]int {\\n\\tsort.Ints(nums)\\n\\tvar res [][]int\\n\\tfor i := 0; i < len(nums)-3; i++ {\\n\\t\\tif i != 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tthreeSum(&res, nums[i], nums[i+1:], target-nums[i])\\n\\t}\\n\\treturn res\\n}\\n\\nfunc threeSum(res *[][]int, first int, nums []int, target int) {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen-2; i++ {\\n\\t\\tif i != 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tleft, right := i+1, nlen-1\\n\\t\\tfor left < right {\\n\\t\\t\\tsum := nums[i] + nums[left] + nums[right]\\n\\t\\t\\tif sum == target {\\n\\t\\t\\t\\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left+1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right-1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t} else if sum < target {\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left+1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right-1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tright--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fourSum(nums []int, target int) [][]int {\\n\\tsort.Ints(nums)\\n\\tvar res [][]int\\n\\tfor i := 0; i < len(nums)-3; i++ {\\n\\t\\tif i != 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tthreeSum(&res, nums[i], nums[i+1:], target-nums[i])\\n\\t}\\n\\treturn res\\n}\\n\\nfunc threeSum(res *[][]int, first int, nums []int, target int) {\\n\\tnlen := len(nums)\\n\\tfor i := 0; i < nlen-2; i++ {\\n\\t\\tif i != 0 && nums[i] == nums[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tleft, right := i+1, nlen-1\\n\\t\\tfor left < right {\\n\\t\\t\\tsum := nums[i] + nums[left] + nums[right]\\n\\t\\t\\tif sum == target {\\n\\t\\t\\t\\t*res = append(*res, []int{first, nums[i], nums[left], nums[right]})\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left+1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right-1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t\\tright--\\n\\t\\t\\t} else if sum < target {\\n\\t\\t\\t\\tfor left < right && nums[left] == nums[left+1] {\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleft++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor left < right && nums[right] == nums[right-1] {\\n\\t\\t\\t\\t\\tright--\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tright--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8678,
                "title": "a-typical-best-solution-accepted-as-8ms-in-c-well-commented",
                "content": "    void sort(int* nums, int begin, int end)\\n    {\\n        int l = begin;\\n        int r = end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                int t = nums[l];\\n                nums[l] = nums[r];\\n                nums[r] = t;\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n            sort(nums, begin, r);\\n        if(l < end)\\n            sort(nums, l, end);\\n    }\\n    \\n    //AC - 8ms;\\n    int** fourSum(int* nums, int size, int target, int* returnSize)\\n    {\\n        sort(nums, 0, size-1);\\n        int** arr = (int**)malloc(sizeof(int*));\\n        *returnSize = 0;\\n        for(int i = 0; i < size-3; i++)\\n        {\\n            if(i && nums[i]==nums[i-1]) continue;\\n            int t0 = target-nums[i]; //target for 3Sum;\\n            for(int j = i+1; j < size-2; j++)\\n            {\\n                if(j!=i+1 && nums[j]==nums[j-1]) continue; //the start position should be handled carefully, it's i+1 while removing redundancy;\\n                int t1 = t0-nums[j]; //target for 2Sum;\\n                if(nums[j+1]+nums[j+2] > t1) break; //the possible least sum is even bigger than the target - just try the next first candidate - i+1;\\n                if(nums[size-1]+nums[size-2] < t1) continue; //the possible maximal sum is smaller than the target - just try the next second candidate to make it bigger - j+1;\\n                int l = j+1;\\n                int r = size-1;\\n                while(l < r) //2Sum problem;\\n                {\\n                    int t2 = nums[l]+nums[r];\\n                    if(t1 > t2) l++;\\n                    else if(t1 < t2) r--;\\n                    else\\n                    {\\n                        if(!*returnSize || (*returnSize && (nums[i]!=arr[*returnSize-1][0]\\n                                        || nums[j]!=arr[*returnSize-1][1]\\n                                        || nums[l]!=arr[*returnSize-1][2]))) //avoid duplicates;\\n                        {\\n                            *returnSize += 1;\\n                            arr = (int**)realloc(arr, sizeof(int*)*(*returnSize));\\n                            arr[*returnSize-1] = (int*)malloc(sizeof(int)*4);\\n                            arr[*returnSize-1][0] = nums[i];\\n                            arr[*returnSize-1][1] = nums[j];\\n                            arr[*returnSize-1][2] = nums[l];\\n                            arr[*returnSize-1][3] = nums[r];\\n                        }\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "    void sort(int* nums, int begin, int end)\\n    {\\n        int l = begin;\\n        int r = end;\\n        int v = nums[l+(r-l)/2];\\n        while(l <= r)\\n        {\\n            while(nums[l] < v) l++;\\n            while(nums[r] > v) r--;\\n            if(l <= r)\\n            {\\n                int t = nums[l];\\n                nums[l] = nums[r];\\n                nums[r] = t;\\n                l++; r--;\\n            }\\n        }\\n        if(begin < r)\\n            sort(nums, begin, r);\\n        if(l < end)\\n            sort(nums, l, end);\\n    }\\n    \\n    //AC - 8ms;\\n    int** fourSum(int* nums, int size, int target, int* returnSize)\\n    {\\n        sort(nums, 0, size-1);\\n        int** arr = (int**)malloc(sizeof(int*));\\n        *returnSize = 0;\\n        for(int i = 0; i < size-3; i++)\\n        {\\n            if(i && nums[i]==nums[i-1]) continue;\\n            int t0 = target-nums[i]; //target for 3Sum;\\n            for(int j = i+1; j < size-2; j++)\\n            {\\n                if(j!=i+1 && nums[j]==nums[j-1]) continue; //the start position should be handled carefully, it's i+1 while removing redundancy;\\n                int t1 = t0-nums[j]; //target for 2Sum;\\n                if(nums[j+1]+nums[j+2] > t1) break; //the possible least sum is even bigger than the target - just try the next first candidate - i+1;\\n                if(nums[size-1]+nums[size-2] < t1) continue; //the possible maximal sum is smaller than the target - just try the next second candidate to make it bigger - j+1;\\n                int l = j+1;\\n                int r = size-1;\\n                while(l < r) //2Sum problem;\\n                {\\n                    int t2 = nums[l]+nums[r];\\n                    if(t1 > t2) l++;\\n                    else if(t1 < t2) r--;\\n                    else\\n                    {\\n                        if(!*returnSize || (*returnSize && (nums[i]!=arr[*returnSize-1][0]\\n                                        || nums[j]!=arr[*returnSize-1][1]\\n                                        || nums[l]!=arr[*returnSize-1][2]))) //avoid duplicates;\\n                        {\\n                            *returnSize += 1;\\n                            arr = (int**)realloc(arr, sizeof(int*)*(*returnSize));\\n                            arr[*returnSize-1] = (int*)malloc(sizeof(int)*4);\\n                            arr[*returnSize-1][0] = nums[i];\\n                            arr[*returnSize-1][1] = nums[j];\\n                            arr[*returnSize-1][2] = nums[l];\\n                            arr[*returnSize-1][3] = nums[r];\\n                        }\\n                        l++;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8686,
                "title": "c-implementation-with-carefully-pruning-accelerates-a-lot-from-100ms-to-16ms",
                "content": "First thanks to the post from  @cx1992 \\n\\nI will just say that with out the 2 using of the \\n\\n      if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target) break;\\n\\n      if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target) continue;\\n\\nThe runing time without these two lines cost 100ms.\\n\\nBut with these lines, cost 16ms !\\n\\nHere is the final implementation \\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> result;\\n            int n=nums.size();\\n            if(n<4)  return result;\\n            sort(nums.begin(), nums.end());\\n            for(int i=0; i<n-3; i++){\\n                if(i>0 && nums[i]==nums[i-1])  continue;\\n                /** cut edge to accelerate the speed **/\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1; j<n-2; j++){\\n                    if(j>i+1 && nums[j]==nums[j-1])  continue;\\n                    /** cut edge to accelerate the speed **/\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target)  break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target)  continue;\\n                    /** jia bi process **/\\n                    int start=j+1, end=n-1;\\n                    while(start < end){\\n                        int sum=nums[start]+nums[end]+nums[i]+nums[j];\\n                        if(sum<target)  start++;\\n                        else if(sum>target)  end--;\\n                        else{\\n                            result.push_back(vector<int>{nums[i], nums[j], nums[start], nums[end]});\\n                            start++; end--;\\n                            while(nums[start-1]==nums[start] && start<end)  start++;\\n                            while(nums[end+1]==nums[end] && start<end)  end--;\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>> result;\\n            int n=nums.size();\\n            if(n<4)  return result;\\n            sort(nums.begin(), nums.end());\\n            for(int i=0; i<n-3; i++){\\n                if(i>0 && nums[i]==nums[i-1])  continue;\\n                /** cut edge to accelerate the speed **/\\n                if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target) break;\\n                if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target) continue;\\n                for(int j=i+1; j<n-2; j++){\\n                    if(j>i+1 && nums[j]==nums[j-1])  continue;\\n                    /** cut edge to accelerate the speed **/\\n                    if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target)  break;\\n                    if(nums[i]+nums[j]+nums[n-2]+nums[n-1]<target)  continue;\\n                    /** jia bi process **/\\n                    int start=j+1, end=n-1;\\n                    while(start < end){\\n                        int sum=nums[start]+nums[end]+nums[i]+nums[j];\\n                        if(sum<target)  start++;\\n                        else if(sum>target)  end--;\\n                        else{\\n                            result.push_back(vector<int>{nums[i], nums[j], nums[start], nums[end]}",
                "codeTag": "Java"
            },
            {
                "id": 8709,
                "title": "c-easy-way-to-handle-duplication",
                "content": "        \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        for (unsigned int i=0; i<nums.size(); i++) {\\n            if (i>0 && nums[i]==nums[i-1])\\n                continue; // avoid duplication for i\\n            for (unsigned int j=i+1; j<nums.size(); j++) {\\n                if (j>i+1 && nums[j]==nums[j-1])\\n                    continue; // avoid duplication for j\\n                int l = j+1, r = nums.size()-1;\\n                while (l < r) {\\n                    int s = nums[i]+nums[j]+nums[l]+nums[r];\\n                    if (s > target)\\n                        r--;\\n                    else if (s < target)\\n                        l++;\\n                    else {\\n                        res.push_back({nums[i], nums[j], nums[l], nums[r]});\\n                        while (l < r && nums[l]==nums[l+1])\\n                            l++; // avoid duplication for l\\n                        while (l < r && nums[r]==nums[r-1])\\n                            r--; // avoid duplication for r\\n                        l++; r--;\\n                    }\\n                }\\n            }\\n         }\\n         return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "        \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        for (unsigned int i=0; i<nums.size(); i++) {\\n            if (i>0 && nums[i]==nums[i-1])\\n                continue; // avoid duplication for i\\n            for (unsigned int j=i+1; j<nums.size(); j++) {\\n                if (j>i+1 && nums[j]==nums[j-1])\\n                    continue; // avoid duplication for j\\n                int l = j+1, r = nums.size()-1;\\n                while (l < r) {\\n                    int s = nums[i]+nums[j]+nums[l]+nums[r];\\n                    if (s > target)\\n                        r--;\\n                    else if (s < target)\\n                        l++;\\n                    else {\\n                        res.push_back({nums[i], nums[j], nums[l], nums[r]});\\n                        while (l < r && nums[l]==nums[l+1])\\n                            l++; // avoid duplication for l\\n                        while (l < r && nums[r]==nums[r-1])\\n                            r--; // avoid duplication for r\\n                        l++; r--;\\n                    }\\n                }\\n            }\\n         }\\n         return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8722,
                "title": "simple-solution-in-javascript",
                "content": "    var fourSum = function(nums, target) {\\n        var ret = [];\\n        \\n        if(nums.length == 0)\\n            return ret;\\n            \\n        nums.sort(function(a,b){\\n            return a - b;    \\n        });\\n            \\n        for(var i = 0; i < nums.length; i++){\\n            var target2 = target - nums[i];\\n            \\n            for(var j = i + 1; j < nums.length; j++){\\n                var target3 = target2 - nums[j];\\n                \\n                var front = j + 1;\\n                var back = nums.length - 1;\\n                \\n                while(front < back){\\n                    var sum = nums[front] + nums[back];\\n                \\n                    if(sum < target3)\\n                        front++;\\n                        \\n                    else if(sum > target3)\\n                        back--;\\n                    \\n                    else{\\n                        var temp = new Array(4);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[front];\\n                        temp[3] = nums[back];\\n                        ret.push(temp);\\n                        \\n                        while(front < back && nums[front] === temp[2])\\n                            front++;\\n                            \\n                        while(front < back && nums[back] === temp[3])\\n                            back--;\\n                    }\\n                }\\n                \\n                while(j + 1 < nums.length && nums[j + 1] === nums[j]) ++j;\\n            }\\n            \\n            while(i + 1 < nums.length && nums[i + 1] === nums[i]) ++i;\\n        }\\n        \\n        return ret;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var fourSum = function(nums, target) {\\n        var ret = [];\\n        \\n        if(nums.length == 0)\\n            return ret;\\n            \\n        nums.sort(function(a,b){\\n            return a - b;    \\n        });\\n            \\n        for(var i = 0; i < nums.length; i++){\\n            var target2 = target - nums[i];\\n            \\n            for(var j = i + 1; j < nums.length; j++){\\n                var target3 = target2 - nums[j];\\n                \\n                var front = j + 1;\\n                var back = nums.length - 1;\\n                \\n                while(front < back){\\n                    var sum = nums[front] + nums[back];\\n                \\n                    if(sum < target3)\\n                        front++;\\n                        \\n                    else if(sum > target3)\\n                        back--;\\n                    \\n                    else{\\n                        var temp = new Array(4);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[front];\\n                        temp[3] = nums[back];\\n                        ret.push(temp);\\n                        \\n                        while(front < back && nums[front] === temp[2])\\n                            front++;\\n                            \\n                        while(front < back && nums[back] === temp[3])\\n                            back--;\\n                    }\\n                }\\n                \\n                while(j + 1 < nums.length && nums[j + 1] === nums[j]) ++j;\\n            }\\n            \\n            while(i + 1 < nums.length && nums[i + 1] === nums[i]) ++i;\\n        }\\n        \\n        return ret;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 8720,
                "title": "is-there-really-a-o-n-2-solution",
                "content": "The general k-sum problem is discussed here http://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem. The optimal solution is said to be O(N^(K/2) logN) in general for even K.\\n\\nI understand for some special cases there are faster solutions but I have seen not a single solution in the discuss which is O(N^2) (even some are claimed to be O(N^2)).\\n\\nPlease answer this question after you checked the following case:\\nNum has 2N elements of N -1s and N 1s. Target is 0. \\n\\nI modified @Chomolungma code which I think is O(N^2). After removing the number of repeating elements to at most 4, the size of duplicates can be bounded by a constant which leads to O(N^2).\\n\\n    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            results=set()\\n            num.sort()\\n            new_num=[]\\n            filter=dict()\\n            for x in num:\\n                if x not in filter:\\n                    filter[x]=1\\n                    new_num.append(x)\\n                elif filter[x]<4:\\n                    filter[x]+=1;\\n                    new_num.append(x)\\n            pairs=[[x,y] for x in xrange(len(new_num)) for y in xrange(x+1,len(new_num))]        \\n            twoSums=dict()\\n            for pair in pairs:\\n                if new_num[pair[0]]+new_num[pair[1]] in twoSums:\\n                    twoSums[new_num[pair[0]]+new_num[pair[1]]].append(pair)\\n                else:\\n                    twoSums[new_num[pair[0]]+new_num[pair[1]]]=[pair]\\n    \\n            for num1 in twoSums:\\n                num2=target-num1\\n                if num2 >= num1 and num2 in twoSums:\\n                    combinations=[pair1+pair2 for pair1 in twoSums[num1] for pair2 in twoSums[num2] if pair1[1]<pair2[0]]\\n                    for comb in combinations:\\n                        results.add(tuple([new_num[i] for i in comb]))\\n            return [list(sums) for sums in results]",
                "solutionTags": [],
                "code": "The general k-sum problem is discussed here http://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem. The optimal solution is said to be O(N^(K/2) logN) in general for even K.\\n\\nI understand for some special cases there are faster solutions but I have seen not a single solution in the discuss which is O(N^2) (even some are claimed to be O(N^2)).\\n\\nPlease answer this question after you checked the following case:\\nNum has 2N elements of N -1s and N 1s. Target is 0. \\n\\nI modified @Chomolungma code which I think is O(N^2). After removing the number of repeating elements to at most 4, the size of duplicates can be bounded by a constant which leads to O(N^2).\\n\\n    class Solution:\\n        # @return a list of lists of length 4, [[val1,val2,val3,val4]]\\n        def fourSum(self, num, target):\\n            results=set()\\n            num.sort()\\n            new_num=[]\\n            filter=dict()\\n            for x in num:\\n                if x not in filter:\\n                    filter[x]=1\\n                    new_num.append(x)\\n                elif filter[x]<4:\\n                    filter[x]+=1;\\n                    new_num.append(x)\\n            pairs=[[x,y] for x in xrange(len(new_num)) for y in xrange(x+1,len(new_num))]        \\n            twoSums=dict()\\n            for pair in pairs:\\n                if new_num[pair[0]]+new_num[pair[1]] in twoSums:\\n                    twoSums[new_num[pair[0]]+new_num[pair[1]]].append(pair)\\n                else:\\n                    twoSums[new_num[pair[0]]+new_num[pair[1]]]=[pair]\\n    \\n            for num1 in twoSums:\\n                num2=target-num1\\n                if num2 >= num1 and num2 in twoSums:\\n                    combinations=[pair1+pair2 for pair1 in twoSums[num1] for pair2 in twoSums[num2] if pair1[1]<pair2[0]]\\n                    for comb in combinations:\\n                        results.add(tuple([new_num[i] for i in comb]))\\n            return [list(sums) for sums in results]",
                "codeTag": "Java"
            },
            {
                "id": 8761,
                "title": "any-better-solution-than-o-n-3",
                "content": "I am using a very traditional way to solve this question. I wonder if there is better time complexity.\\n\\n    public class Solution {\\n    \\tpublic List<List<Integer>> fourSum(int[] num, int target) {\\n    \\t\\tList<List<Integer>> results = new LinkedList<List<Integer>>();\\n    \\t\\tif (num == null || num.length < 4)\\n    \\t\\t\\treturn results;\\n    \\t\\tArrays.sort(num);\\n    \\n    \\t\\tfor (int s = 0; s < num.length - 3; s++) {\\n    \\t\\t\\tif (s > 0 && num[s] == num[s - 1]) \\tcontinue;\\n    \\t\\t\\t\\n    \\n    \\t\\t\\tfor (int e = num.length - 1; e >= s + 3; e--) {\\n    \\t\\t\\t\\tif (e < num.length - 1 && num[e] == num[e + 1]) continue;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tint local = target - num[s] - num[e];\\n    \\t\\t\\t\\tint j = s + 1;\\n    \\t\\t\\t\\tint k = e - 1;\\n    \\t\\t\\t\\twhile (j < k) {\\n    \\n    \\t\\t\\t\\t\\tif (j > s + 1 && num[j] == num[j - 1]) {\\n    \\t\\t\\t\\t\\t\\tj++;\\n    \\t\\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tif (k < e - 1 && num[k] == num[k + 1]) {\\n    \\t\\t\\t\\t\\t\\tk--;\\n    \\t\\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\t}\\n    \\n    \\t\\t\\t\\t\\tif ((num[j] + num[k]) > local)\\n    \\t\\t\\t\\t\\t\\tk--;\\n    \\t\\t\\t\\t\\telse if ((num[j] + num[k]) < local)\\n    \\t\\t\\t\\t\\t\\tj++;\\n    \\t\\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\t\\tresults.add(new ArrayList<Integer>(Arrays.asList(\\n    \\t\\t\\t\\t\\t\\t\\t\\tnum[s], num[j++], num[k--], num[e])));\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn results;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\tpublic List<List<Integer>> fourSum(int[] num, int target) {\\n    \\t\\tList<List<Integer>> results = new LinkedList<List<Integer>>();\\n    \\t\\tif (num == null || num.length < 4)\\n    \\t\\t\\treturn results;\\n    \\t\\tArrays.sort(num);\\n    \\n    \\t\\tfor (int s = 0; s < num.length - 3; s++) {\\n    \\t\\t\\tif (s > 0 && num[s] == num[s - 1]) \\tcontinue;\\n    \\t\\t\\t\\n    \\n    \\t\\t\\tfor (int e = num.length - 1; e >= s + 3; e--) {\\n    \\t\\t\\t\\tif (e < num.length - 1 && num[e] == num[e + 1]) continue;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tint local = target - num[s] - num[e];\\n    \\t\\t\\t\\tint j = s + 1;\\n    \\t\\t\\t\\tint k = e - 1;\\n    \\t\\t\\t\\twhile (j < k) {\\n    \\n    \\t\\t\\t\\t\\tif (j > s + 1 && num[j] == num[j - 1]) {\\n    \\t\\t\\t\\t\\t\\tj++;\\n    \\t\\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3944331,
                "title": "brute-force-optimised-hashset-approach",
                "content": "# Brute Force--->O(N^4)--->[TLE]\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        n=len(nums)\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                for k in range(j+1,n-1):\\n                    for l in range(k+1,n):\\n                        temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                        sorted_num=sorted([nums[i],nums[j],nums[k],nums[l]])\\n                        if temp==target and sorted_num not in ans:\\n                            ans.append(sorted_num)\\n        return ans\\n```\\n# Optimised Approach-->Two Pointers Appraoch ----> O(N^3)---->[Accepted]\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                k=j+1\\n                l=n-1\\n                while k<l:\\n                    temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                    sorted_num=sorted([nums[i],nums[j],nums[k],nums[l]])\\n                    if temp==target and sorted_num not in ans:\\n                        ans.append(sorted_num)\\n                    elif temp>target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n        return ans\\n ```\\n # Using Hashset----->O(N^3)---->[Accepted]\\n ```\\n class Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=set()\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                k=j+1\\n                l=n-1\\n                while k<l:\\n                    temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                    if temp==target:\\n                        ans.add((nums[i],nums[j],nums[k],nums[l]))\\n                        k+=1\\n                    elif temp>target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n        return list(ans)\\n ```\\n # please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        n=len(nums)\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                for k in range(j+1,n-1):\\n                    for l in range(k+1,n):\\n                        temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                        sorted_num=sorted([nums[i],nums[j],nums[k],nums[l]])\\n                        if temp==target and sorted_num not in ans:\\n                            ans.append(sorted_num)\\n        return ans\\n```\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                k=j+1\\n                l=n-1\\n                while k<l:\\n                    temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                    sorted_num=sorted([nums[i],nums[j],nums[k],nums[l]])\\n                    if temp==target and sorted_num not in ans:\\n                        ans.append(sorted_num)\\n                    elif temp>target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n        return ans\\n ```\n```\\n class Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        ans=set()\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n-3):\\n            for j in range(i+1,n-2):\\n                k=j+1\\n                l=n-1\\n                while k<l:\\n                    temp=nums[i]+nums[j]+nums[k]+nums[l]\\n                    if temp==target:\\n                        ans.add((nums[i],nums[j],nums[k],nums[l]))\\n                        k+=1\\n                    elif temp>target:\\n                        l-=1\\n                    else:\\n                        k+=1\\n        return list(ans)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3822225,
                "title": "java-efficient-solution-for-4-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n         Arrays.sort(nums);\\n         List<List<Integer>> q=new ArrayList<>();\\n         int n=nums.length;\\n         for(int i=0;i<n-3;i++)\\n         {\\n             if(i>0&&nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             for(int j=i+1;j<n;j++)\\n             {\\n                 if(j>i+1&&nums[j]==nums[j-1])\\n                 {\\n                     continue;\\n                 }\\n                 int k=j+1;\\n                 int l=n-1;\\n                 while(k<l)\\n                 {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if(target==sum)\\n                    {\\n                        ArrayList<Integer> al=new ArrayList<>();\\n                        al.add(nums[i]);\\n                        al.add(nums[j]);\\n                        al.add(nums[k]);\\n                        al.add(nums[l]);\\n                        Collections.sort(al);\\n                        q.add(al);\\n                        k++;\\n                        l--;\\n\\n                    \\n                    while(k<l&&nums[l]==nums[l+1])\\n                    {\\n                        l--;\\n                    }\\n                    while(k<l&&nums[k]==nums[k-1])\\n                    {\\n                        k++;\\n                    }\\n                    }\\n                    else if(sum<target)\\n                    {\\n                        k++;\\n                    }\\n                    else\\n                    {\\n                        l--;\\n                    }\\n                 }\\n             }\\n         }\\n\\n         return q;\\n           \\n        }\\n      \\n       \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n         Arrays.sort(nums);\\n         List<List<Integer>> q=new ArrayList<>();\\n         int n=nums.length;\\n         for(int i=0;i<n-3;i++)\\n         {\\n             if(i>0&&nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             for(int j=i+1;j<n;j++)\\n             {\\n                 if(j>i+1&&nums[j]==nums[j-1])\\n                 {\\n                     continue;\\n                 }\\n                 int k=j+1;\\n                 int l=n-1;\\n                 while(k<l)\\n                 {\\n                    long sum = nums[i];\\n                    sum += nums[j];\\n                    sum += nums[k];\\n                    sum += nums[l];\\n                    if(target==sum)\\n                    {\\n                        ArrayList<Integer> al=new ArrayList<>();\\n                        al.add(nums[i]);\\n                        al.add(nums[j]);\\n                        al.add(nums[k]);\\n                        al.add(nums[l]);\\n                        Collections.sort(al);\\n                        q.add(al);\\n                        k++;\\n                        l--;\\n\\n                    \\n                    while(k<l&&nums[l]==nums[l+1])\\n                    {\\n                        l--;\\n                    }\\n                    while(k<l&&nums[k]==nums[k-1])\\n                    {\\n                        k++;\\n                    }\\n                    }\\n                    else if(sum<target)\\n                    {\\n                        k++;\\n                    }\\n                    else\\n                    {\\n                        l--;\\n                    }\\n                 }\\n             }\\n         }\\n\\n         return q;\\n           \\n        }\\n      \\n       \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227678,
                "title": "very-easy-detailed-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nList<List<Integer>>ans=new ArrayList<>();\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(i!=0 && nums[i]==nums[i-1]) continue;\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                if(j!=i+1 && nums[j]==nums[j-1]) continue;\\n\\n                int k=j+1;\\n                int l=n-1;\\n\\n                while(k < l){\\n                    long sum=nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n\\n                    if(sum < target){\\n                        k++;\\n                    }\\n                    else if(sum > target){\\n                        l--;\\n                    }\\n                    else{\\n                        List<Integer>temp=Arrays.asList(nums[i],nums[j],nums[k],nums[l]);\\n                        ans.add(temp);\\n                        k++;\\n                        l--;\\n\\n                        while(k < l && nums[k]==nums[k-1]) k++;\\n\\n                        while(k < l && nums[l]==nums[l+1]) l--;\\n\\n                    }\\n                }\\n            }    \\n\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nList<List<Integer>>ans=new ArrayList<>();\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(i!=0 && nums[i]==nums[i-1]) continue;\\n\\n            for(int j=i+1;j<n;j++){\\n\\n                if(j!=i+1 && nums[j]==nums[j-1]) continue;\\n\\n                int k=j+1;\\n                int l=n-1;\\n\\n                while(k < l){\\n                    long sum=nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n\\n                    if(sum < target){\\n                        k++;\\n                    }\\n                    else if(sum > target){\\n                        l--;\\n                    }\\n                    else{\\n                        List<Integer>temp=Arrays.asList(nums[i],nums[j],nums[k],nums[l]);\\n                        ans.add(temp);\\n                        k++;\\n                        l--;\\n\\n                        while(k < l && nums[k]==nums[k-1]) k++;\\n\\n                        while(k < l && nums[l]==nums[l+1]) l--;\\n\\n                    }\\n                }\\n            }    \\n\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055691,
                "title": "94-javascript-fast-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/U4cX-QMlmgA\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    let res = []\\n    nums.sort((a,b)=>a-b)\\n\\n    for(let i =0; i< nums.length-3;i++){\\n        for(let j =i+1; j<nums.length-2;j++){\\n            let f = nums[i];\\n            let s = nums[j];\\n            let left = j+1;\\n            let right = nums.length-1;\\n            while(left<right){\\n                let sum = f + s + nums[left] + nums[right];\\n                if(sum < target) left++\\n                else if(sum > target) right--\\n                else {\\n                    res.push([f,s,nums[left],nums[right]]);\\n                    while(nums[left] == nums[left+1])left++\\n                    while(nums[right] == nums[right-1]) right--\\n                    left++\\n                    right--\\n                }\\n            }\\n            while(nums[j] == nums[j+1]) j++\\n        }\\n        while(nums[i] == nums[i+1]) i++\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar fourSum = function(nums, target) {\\n    let res = []\\n    nums.sort((a,b)=>a-b)\\n\\n    for(let i =0; i< nums.length-3;i++){\\n        for(let j =i+1; j<nums.length-2;j++){\\n            let f = nums[i];\\n            let s = nums[j];\\n            let left = j+1;\\n            let right = nums.length-1;\\n            while(left<right){\\n                let sum = f + s + nums[left] + nums[right];\\n                if(sum < target) left++\\n                else if(sum > target) right--\\n                else {\\n                    res.push([f,s,nums[left],nums[right]]);\\n                    while(nums[left] == nums[left+1])left++\\n                    while(nums[right] == nums[right-1]) right--\\n                    left++\\n                    right--\\n                }\\n            }\\n            while(nums[j] == nums[j+1]) j++\\n        }\\n        while(nums[i] == nums[i+1]) i++\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3008845,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        if(nums.size()<4)\\n            return {};\\n        set<vector<int>> ans;\\n        long long int x,sum;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-3;i++)\\n        {\\n            for(int j=i+1;j<nums.size()-2;j++)\\n            {\\n                x=nums[i]+nums[j];\\n                int p=j+1,q=nums.size()-1;\\n                while(p<q)\\n                {\\n                    sum=nums[p]+nums[q];\\n                    if(sum+x==target)\\n                    {\\n                        ans.insert({nums[i],nums[j],nums[p],nums[q]});\\n                      p++;\\n                    }\\n                    else if(sum+x<target)\\n                        p++;\\n                    else if(sum+x>target)\\n                        q--;\\n                }\\n            }\\n        }\\n        vector<vector<int>> vc(ans.begin(), ans.end());\\n        return vc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        if(nums.size()<4)\\n            return {};\\n        set<vector<int>> ans;\\n        long long int x,sum;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-3;i++)\\n        {\\n            for(int j=i+1;j<nums.size()-2;j++)\\n            {\\n                x=nums[i]+nums[j];\\n                int p=j+1,q=nums.size()-1;\\n                while(p<q)\\n                {\\n                    sum=nums[p]+nums[q];\\n                    if(sum+x==target)\\n                    {\\n                        ans.insert({nums[i],nums[j],nums[p],nums[q]});\\n                      p++;\\n                    }\\n                    else if(sum+x<target)\\n                        p++;\\n                    else if(sum+x>target)\\n                        q--;\\n                }\\n            }\\n        }\\n        vector<vector<int>> vc(ans.begin(), ans.end());\\n        return vc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999541,
                "title": "super-easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^3)+O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787026,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/4-sum.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar fourSum = function (nums, target) {\\n    let solutionArrays = [];\\n\\n    // Sort the array\\n    sortedNums = nums.sort((a, b) => a - b);\\n\\n    // Loop through the array (excluding the last 3 entries)\\n    for (let i = 0; i < sortedNums.length - 3; i++) {\\n        // Check if this is the same number as the last one\\n        if (i > 0 && sortedNums[i] == sortedNums[i - 1]) {\\n            continue;\\n        }\\n\\n        // Loop through the remaining numbers\\n        for (let j = i + 1; j < sortedNums.length - 2; j++) {\\n            // Check if this is the same number as the last one\\n            if (j > i + 1 && sortedNums[j] == sortedNums[j - 1]) {\\n                continue;\\n            }\\n\\n            // Establish a window from the next number to the end of the array\\n            let left = j + 1;\\n            let right = sortedNums.length - 1;\\n\\n            // Run until the window is closed\\n            while (left < right) {\\n                // Add together the current numbers, and each side of the window\\n                const total =\\n                    sortedNums[i] +\\n                    sortedNums[j] +\\n                    sortedNums[left] +\\n                    sortedNums[right];\\n\\n                // If we\\'ve reached an answer, add it to the array of answers\\n                if (total == target) {\\n                    solutionArrays.push([\\n                        sortedNums[i],\\n                        sortedNums[j],\\n                        sortedNums[left],\\n                        sortedNums[right],\\n                    ]);\\n\\n                    // Move the left-hand edge of the window to the right until it reaches a different number\\n                    do {\\n                        left++;\\n                    } while (sortedNums[left] == sortedNums[left - 1]);\\n\\n                    // Move the right-hand edge of the window to the left until it reaches a different number\\n                    do {\\n                        right--;\\n                    } while (sortedNums[right] == sortedNums[right + 1]);\\n                }\\n                // If we\\'re too low\\n                else if (total < target) {\\n                    left++;\\n                }\\n                // If we\\'re too high\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n    }\\n\\n    return solutionArrays;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fourSum = function (nums, target) {\\n    let solutionArrays = [];\\n\\n    // Sort the array\\n    sortedNums = nums.sort((a, b) => a - b);\\n\\n    // Loop through the array (excluding the last 3 entries)\\n    for (let i = 0; i < sortedNums.length - 3; i++) {\\n        // Check if this is the same number as the last one\\n        if (i > 0 && sortedNums[i] == sortedNums[i - 1]) {\\n            continue;\\n        }\\n\\n        // Loop through the remaining numbers\\n        for (let j = i + 1; j < sortedNums.length - 2; j++) {\\n            // Check if this is the same number as the last one\\n            if (j > i + 1 && sortedNums[j] == sortedNums[j - 1]) {\\n                continue;\\n            }\\n\\n            // Establish a window from the next number to the end of the array\\n            let left = j + 1;\\n            let right = sortedNums.length - 1;\\n\\n            // Run until the window is closed\\n            while (left < right) {\\n                // Add together the current numbers, and each side of the window\\n                const total =\\n                    sortedNums[i] +\\n                    sortedNums[j] +\\n                    sortedNums[left] +\\n                    sortedNums[right];\\n\\n                // If we\\'ve reached an answer, add it to the array of answers\\n                if (total == target) {\\n                    solutionArrays.push([\\n                        sortedNums[i],\\n                        sortedNums[j],\\n                        sortedNums[left],\\n                        sortedNums[right],\\n                    ]);\\n\\n                    // Move the left-hand edge of the window to the right until it reaches a different number\\n                    do {\\n                        left++;\\n                    } while (sortedNums[left] == sortedNums[left - 1]);\\n\\n                    // Move the right-hand edge of the window to the left until it reaches a different number\\n                    do {\\n                        right--;\\n                    } while (sortedNums[right] == sortedNums[right + 1]);\\n                }\\n                // If we\\'re too low\\n                else if (total < target) {\\n                    left++;\\n                }\\n                // If we\\'re too high\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n    }\\n\\n    return solutionArrays;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204217,
                "title": "c-handling-runtime-error-handling-duplicates-fully-explained-easy-solution",
                "content": "**Please Upvote if you found this helpful.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \\n    {\\n        vector<vector<int>> res;\\n        int n = nums.size(); \\n        sort(nums.begin(),nums.end());\\n        for(int i= 0; i< n-3; i++) \\n        {\\n            long long target_3 = target - nums[i];\\n            for (int j= i+1; j< n-2; j++) \\n            {\\n                long long target_2 = target_3 - nums[j];\\n                int front = j + 1;\\n                int back = n - 1;\\n                while(front < back) \\n                {\\n                    long long two_sum = nums[front] + nums[back];\\n                    if (two_sum < target_2)\\n                    {\\n                        front++;\\n                    }\\n                    else if (two_sum > target_2)\\n                    {\\n                        back--;\\n                    }\\n                    else \\n                    {\\n\\n                        vector<int> quadruplet(4, 0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[3] = nums[back];\\n                        res.push_back(quadruplet);\\n\\n                        // Processing the duplicates of number 3\\n                        while (front < back && nums[front] == quadruplet[2])\\n                        {\\n                            front++;\\n                        }\\n\\n                        // Processing the duplicates of number 4\\n                        while (front < back && nums[back] == quadruplet[3])\\n                        {\\n                            back--;\\n                        }\\n                    }\\n                }\\n\\n                // Processing the duplicates of number 2\\n                while(j + 1 < n-2 && nums[j + 1] == nums[j])\\n                {\\n                    j++;\\n                }\\n            }\\n\\n            // Processing the duplicates of number 1\\n            while (i + 1 < n-3 && nums[i + 1] == nums[i])\\n            {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) \\n    {\\n        vector<vector<int>> res;\\n        int n = nums.size(); \\n        sort(nums.begin(),nums.end());\\n        for(int i= 0; i< n-3; i++) \\n        {\\n            long long target_3 = target - nums[i];\\n            for (int j= i+1; j< n-2; j++) \\n            {\\n                long long target_2 = target_3 - nums[j];\\n                int front = j + 1;\\n                int back = n - 1;\\n                while(front < back) \\n                {\\n                    long long two_sum = nums[front] + nums[back];\\n                    if (two_sum < target_2)\\n                    {\\n                        front++;\\n                    }\\n                    else if (two_sum > target_2)\\n                    {\\n                        back--;\\n                    }\\n                    else \\n                    {\\n\\n                        vector<int> quadruplet(4, 0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[3] = nums[back];\\n                        res.push_back(quadruplet);\\n\\n                        // Processing the duplicates of number 3\\n                        while (front < back && nums[front] == quadruplet[2])\\n                        {\\n                            front++;\\n                        }\\n\\n                        // Processing the duplicates of number 4\\n                        while (front < back && nums[back] == quadruplet[3])\\n                        {\\n                            back--;\\n                        }\\n                    }\\n                }\\n\\n                // Processing the duplicates of number 2\\n                while(j + 1 < n-2 && nums[j + 1] == nums[j])\\n                {\\n                    j++;\\n                }\\n            }\\n\\n            // Processing the duplicates of number 1\\n            while (i + 1 < n-3 && nums[i + 1] == nums[i])\\n            {\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924194,
                "title": "js-generic-k-sum-recursive-two-pointer",
                "content": "```\\n\\n//approach: Two Pointer\\n//it\\'s a array problem. \\n//\\n//since solving 2Sum, 3Sum, now tackling 4Sum, I\\'m convinced, # could only go up, \\n//so it\\'s more like a generic \\'KSum\\' problem.\\n//we can use loop like we did for 3Sum, where we will have 1 extra loop, before we hit while loop, \\n//same for 5Sum, where we will have 3 for loop, before we hit the while loop, \\n//same goes for increasing number, the for loop, will only increase before we hit the while loop, \\n//so to avoid having large number of for loop to tackle this K Sum problem, \\n//...I\\'m implementing a generalized solution, that could work with any number using backtracking\\n// backtracking technique I use is: \\n// loop(usually), choose(pushing a value in a storage/container), explore(recursive call), unchoose(removing the lates value previously pushed in, from the container)\\n//\\n//we want to sort the array, as we can avoid duplicates in a efficient manner, \\n//then we will recurse through the array elements, until we have 2 element \\n//once we got 2 element, we can basically, send that 2 element for while loop (similar to 2Sum problem)\\nvar fourSum = function(nums, target) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let store = new Array();\\n    let result = new Array();\\n    function helper(start, target, k){\\n        \\n        //base case: is just, when we have k === 2, \\n       //we do the opposite of it, base case technically would be two sum approach after if statement\\n        if(k !== 2){\\n            \\n            //looping until we have K values remaining since it\\'s 4Sum, we want 4 values remaining\\n            //we will have 4 pointers, if we have done the for loop way so, yea\\n            //like 2 for loop pointers, and one left pointer and one right pointer\\n            //since we already have one for loop, so we want to have 3 pointers remaining, so thats why (k+1)\\n            //we looping till (nums.length-k+1)\\n            for(let i = start; i < nums.length-k+1; i++){\\n                \\n                //skip if same element\\n                if(i > start && nums[i] === nums[i-1]) continue;\\n                \\n                //choose\\n                store.push(nums[i]);\\n                \\n                //explore\\n                helper(i+1, target-nums[i], k-1);\\n                \\n                //unchoose\\n                store.pop();\\n                \\n            }\\n            return;\\n        }\\n        \\n        let left = start;\\n        let right = nums.length-1;\\n        \\n        while(left < right){\\n            if(nums[left] + nums[right] > target)\\n                right--;\\n            else if (nums[left] + nums[right] < target)\\n                left++;\\n            else{\\n                let arr = new Array().concat(store);\\n                arr.push(nums[left]);\\n                arr.push(nums[right]);\\n                result.push(arr);\\n                \\n                //skip all the duplicates that left and right have stumbled on\\n                while(left < right && nums[left] === nums[left+1]) left++;\\n                while(left < right && nums[right] === nums[right-1]) right--;\\n                \\n                //one more increment, because we have already worked with this number\\n                //if while loop had worked, we would end with let\\'s say [0, 0, 3]\\n                //end of that 0, we would need to move that 3\\n                left++;\\n                right--;\\n                \\n            }\\n        }\\n    }\\n    \\n    //k= 4 (since it\\'s 4 sum)\\n    //target = target(given)\\n    //left = 0(since we want to start from the beginning of the array)\\n    helper(0, target, 4); \\n    \\n    return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\n//approach: Two Pointer\\n//it\\'s a array problem. \\n//\\n//since solving 2Sum, 3Sum, now tackling 4Sum, I\\'m convinced, # could only go up, \\n//so it\\'s more like a generic \\'KSum\\' problem.\\n//we can use loop like we did for 3Sum, where we will have 1 extra loop, before we hit while loop, \\n//same for 5Sum, where we will have 3 for loop, before we hit the while loop, \\n//same goes for increasing number, the for loop, will only increase before we hit the while loop, \\n//so to avoid having large number of for loop to tackle this K Sum problem, \\n//...I\\'m implementing a generalized solution, that could work with any number using backtracking\\n// backtracking technique I use is: \\n// loop(usually), choose(pushing a value in a storage/container), explore(recursive call), unchoose(removing the lates value previously pushed in, from the container)\\n//\\n//we want to sort the array, as we can avoid duplicates in a efficient manner, \\n//then we will recurse through the array elements, until we have 2 element \\n//once we got 2 element, we can basically, send that 2 element for while loop (similar to 2Sum problem)\\nvar fourSum = function(nums, target) {\\n    nums = nums.sort((a,b)=> a-b);\\n    let store = new Array();\\n    let result = new Array();\\n    function helper(start, target, k){\\n        \\n        //base case: is just, when we have k === 2, \\n       //we do the opposite of it, base case technically would be two sum approach after if statement\\n        if(k !== 2){\\n            \\n            //looping until we have K values remaining since it\\'s 4Sum, we want 4 values remaining\\n            //we will have 4 pointers, if we have done the for loop way so, yea\\n            //like 2 for loop pointers, and one left pointer and one right pointer\\n            //since we already have one for loop, so we want to have 3 pointers remaining, so thats why (k+1)\\n            //we looping till (nums.length-k+1)\\n            for(let i = start; i < nums.length-k+1; i++){\\n                \\n                //skip if same element\\n                if(i > start && nums[i] === nums[i-1]) continue;\\n                \\n                //choose\\n                store.push(nums[i]);\\n                \\n                //explore\\n                helper(i+1, target-nums[i], k-1);\\n                \\n                //unchoose\\n                store.pop();\\n                \\n            }\\n            return;\\n        }\\n        \\n        let left = start;\\n        let right = nums.length-1;\\n        \\n        while(left < right){\\n            if(nums[left] + nums[right] > target)\\n                right--;\\n            else if (nums[left] + nums[right] < target)\\n                left++;\\n            else{\\n                let arr = new Array().concat(store);\\n                arr.push(nums[left]);\\n                arr.push(nums[right]);\\n                result.push(arr);\\n                \\n                //skip all the duplicates that left and right have stumbled on\\n                while(left < right && nums[left] === nums[left+1]) left++;\\n                while(left < right && nums[right] === nums[right-1]) right--;\\n                \\n                //one more increment, because we have already worked with this number\\n                //if while loop had worked, we would end with let\\'s say [0, 0, 3]\\n                //end of that 0, we would need to move that 3\\n                left++;\\n                right--;\\n                \\n            }\\n        }\\n    }\\n    \\n    //k= 4 (since it\\'s 4 sum)\\n    //target = target(given)\\n    //left = 0(since we want to start from the beginning of the array)\\n    helper(0, target, 4); \\n    \\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701791,
                "title": "c-easy-approach-faster-than-91-o-n-3-two-pointer-approach",
                "content": "\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> ans;\\n        int n= nums.size();\\n        \\n        // If length of array is smaller than 4 then no quadruplet can be formed.\\n        if(n<4) return ans;\\n        \\n        sort(nums.begin(),nums.end()); // to apply two pointer approach\\n        \\n        for(int i=0 ; i<n ; i++){\\n            \\n            long long int a = nums[i];\\n            \\n            for(int j=i+1 ; j<n ; j++){\\n                \\n                long long int b= nums[j];\\n                \\n                // two element are now fixed one at i and other at j\\n                \\n                // applying two pointer approach over the remaining two\\n                \\n                int s = j+1;\\n                int e = n-1;\\n                \\n                \\n                while(s<e){\\n                    \\n                    long long int x = nums[s];\\n                    long long int y = nums[e];\\n                    \\n                    long long int sum = x+y+a+b;\\n                    \\n                    if(sum == target){\\n                        // Need to make all a,b,c,d back to int as ans is a vector of vector of int\\n                        ans.push_back({int(a),int(b),int(x),int(y)});\\n                        \\n                        // skipping same value of x and y\\n                        \\n                        while(s<e and nums[s] == x){\\n                            s++;\\n                        }\\n                        \\n                        while(s<e and nums[e] == y){\\n                            e--;\\n                        }\\n                        \\n                    }\\n                    \\n                    else if(sum > target){\\n                        e--;\\n                    }\\n                    \\n                    else{\\n                        s++;\\n                    }\\n                    \\n                }\\n                \\n                // skipping same value at jth point\\n            \\n                while(j+1<n and nums[j+1] == nums[j]){\\n                    j++;\\n                }  \\n                \\n            }\\n            // skipping same value at ith point\\n            while(i+1<n and nums[i+1] == nums[i]){\\n                i++;\\n            } \\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> ans;\\n        int n= nums.size();\\n        \\n        // If length of array is smaller than 4 then no quadruplet can be formed.\\n        if(n<4) return ans;\\n        \\n        sort(nums.begin(),nums.end()); // to apply two pointer approach\\n        \\n        for(int i=0 ; i<n ; i++){\\n            \\n            long long int a = nums[i];\\n            \\n            for(int j=i+1 ; j<n ; j++){\\n                \\n                long long int b= nums[j];\\n                \\n                // two element are now fixed one at i and other at j\\n                \\n                // applying two pointer approach over the remaining two\\n                \\n                int s = j+1;\\n                int e = n-1;\\n                \\n                \\n                while(s<e){\\n                    \\n                    long long int x = nums[s];\\n                    long long int y = nums[e];\\n                    \\n                    long long int sum = x+y+a+b;\\n                    \\n                    if(sum == target){\\n                        // Need to make all a,b,c,d back to int as ans is a vector of vector of int\\n                        ans.push_back({int(a),int(b),int(x),int(y)});\\n                        \\n                        // skipping same value of x and y\\n                        \\n                        while(s<e and nums[s] == x){\\n                            s++;\\n                        }\\n                        \\n                        while(s<e and nums[e] == y){\\n                            e--;\\n                        }\\n                        \\n                    }\\n                    \\n                    else if(sum > target){\\n                        e--;\\n                    }\\n                    \\n                    else{\\n                        s++;\\n                    }\\n                    \\n                }\\n                \\n                // skipping same value at jth point\\n            \\n                while(j+1<n and nums[j+1] == nums[j]){\\n                    j++;\\n                }  \\n                \\n            }\\n            // skipping same value at ith point\\n            while(i+1<n and nums[i+1] == nums[i]){\\n                i++;\\n            } \\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1080758,
                "title": "python-amazing-solution-o-n-2-easy-understanding",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = set()\\n        \\n        def makeLegalPairs(list1: List[int], list2: List[int]):\\n            for (i, j) in list1:\\n                for (k, l) in list2:\\n                    if i!=k and i!=l and j!=k and j!=l:\\n                        new = sorted([nums[i], nums[j], nums[k], nums[l]])\\n                        res.add(tuple(new))\\n        \\n        helper = defaultdict(list)\\n        for index1 in range(len(nums)):\\n            for index2 in range(index1 + 1, len(nums)):\\n                helper[nums[index1] + nums[index2]].append((index1, index2))\\n        \\n        if not target and len(nums) >= 4 and nums[-1] == 0: return [[0,0,0,0]]\\n\\t\\tsave = set(helper.keys())\\n        for num in helper:\\n            tmp = target - num\\n            if tmp in save:\\n                makeLegalPairs(helper[num], helper[tmp])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = set()\\n        \\n        def makeLegalPairs(list1: List[int], list2: List[int]):\\n            for (i, j) in list1:\\n                for (k, l) in list2:\\n                    if i!=k and i!=l and j!=k and j!=l:\\n                        new = sorted([nums[i], nums[j], nums[k], nums[l]])\\n                        res.add(tuple(new))\\n        \\n        helper = defaultdict(list)\\n        for index1 in range(len(nums)):\\n            for index2 in range(index1 + 1, len(nums)):\\n                helper[nums[index1] + nums[index2]].append((index1, index2))\\n        \\n        if not target and len(nums) >= 4 and nums[-1] == 0: return [[0,0,0,0]]\\n\\t\\tsave = set(helper.keys())\\n        for num in helper:\\n            tmp = target - num\\n            if tmp in save:\\n                makeLegalPairs(helper[num], helper[tmp])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1047540,
                "title": "rust-loop-solution",
                "content": "Runtime: 12 ms, faster than 74.29% of Rust online submissions for 4Sum.\\nMemory Usage: 2 MB, less than 97.14% of Rust online submissions for 4Sum.\\n```\\nimpl Solution {\\n    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\\n        let mut res: Vec<Vec<i32>> = vec![];\\n        if nums.len() < 4 {\\n            return res;\\n        }\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        for i in 0..nums.len() - 1 {\\n            if i > 0 && nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n\\n            for j in i + 1..nums.len() - 2 {\\n                if j > i + 1 && nums[j] == nums[j - 1] {\\n                    continue;\\n                }\\n\\n                let (mut left, mut right) = (j + 1, nums.len() - 1);\\n                while left < right {\\n                    let tmp = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if tmp == target {\\n                        res.push([nums[i], nums[j], nums[left], nums[right]].to_vec());\\n                        left += 1;\\n                        right -= 1;\\n\\n                        while left < right && nums[left] == nums[left - 1] {\\n                            left += 1;\\n                        }\\n                        while left < right && nums[right] == nums[right + 1] {\\n                            right -= 1;\\n                        }\\n                    } else if tmp < target {\\n                        left += 1;\\n                    } else if tmp > target {\\n                        right -= 1;\\n                    }\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn four_sum(nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\\n        let mut res: Vec<Vec<i32>> = vec![];\\n        if nums.len() < 4 {\\n            return res;\\n        }\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        for i in 0..nums.len() - 1 {\\n            if i > 0 && nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n\\n            for j in i + 1..nums.len() - 2 {\\n                if j > i + 1 && nums[j] == nums[j - 1] {\\n                    continue;\\n                }\\n\\n                let (mut left, mut right) = (j + 1, nums.len() - 1);\\n                while left < right {\\n                    let tmp = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if tmp == target {\\n                        res.push([nums[i], nums[j], nums[left], nums[right]].to_vec());\\n                        left += 1;\\n                        right -= 1;\\n\\n                        while left < right && nums[left] == nums[left - 1] {\\n                            left += 1;\\n                        }\\n                        while left < right && nums[right] == nums[right + 1] {\\n                            right -= 1;\\n                        }\\n                    } else if tmp < target {\\n                        left += 1;\\n                    } else if tmp > target {\\n                        right -= 1;\\n                    }\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935755,
                "title": "n-3-solution-with-4-pointers",
                "content": "We basically explore the array using 4 pointers: i, j, p and q. i and j are the outer pointers, and p and q are the inner pointers. i and j start at the edges and are incremented/decremented towards the middle of the array. p and q start between i and j, and we test for the solution (a + b + c + d == target). Whenever a combination is found, it is added to the result and we increment/decrement the pointers to guarantee no repetition.\\n\\nThis is only possible because we sorted the array at the beginning. We rely on this property to decide whether to move p, q or both, when looking for a smaller/bigger sum.\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (i > 0 && i < nums.length - 1 && nums[i-1] == nums[i]) i++; // avoid repetitions\\n            int a = nums[i];\\n\\n            for (int j = nums.length - 1; j >= 0; j--) {\\n                while (j < nums.length - 1 && j > 0 && nums[j] == nums[j+1]) j--; // avoid repetitions\\n                int d = nums[j];\\n                \\n                int p = i + 1;\\n                int q = j - 1;\\n                while (p < q) {\\n                    int b = nums[p];\\n                    int c = nums[q];\\n\\n                    int sum = a + b + c + d;\\n                    if (sum == target) {\\n                        result.add(List.of(a, b, c, d));\\n                        p++;\\n                        while(p < j && nums[p] == nums[p-1]) p++; // avoid repetitions\\n                        \\n                        q--;\\n                        while(i < q && nums[q] == nums[q+1]) q--; // avoid repetitions\\n                    }\\n                    else if (sum < target) { // sum is too small. Increment p so that we can look for bigger sums\\n                        p++;\\n                    } else { // sum is too big. Decrement q so that we can look for smaller sums\\n                        q--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (i > 0 && i < nums.length - 1 && nums[i-1] == nums[i]) i++; // avoid repetitions\\n            int a = nums[i];\\n\\n            for (int j = nums.length - 1; j >= 0; j--) {\\n                while (j < nums.length - 1 && j > 0 && nums[j] == nums[j+1]) j--; // avoid repetitions\\n                int d = nums[j];\\n                \\n                int p = i + 1;\\n                int q = j - 1;\\n                while (p < q) {\\n                    int b = nums[p];\\n                    int c = nums[q];\\n\\n                    int sum = a + b + c + d;\\n                    if (sum == target) {\\n                        result.add(List.of(a, b, c, d));\\n                        p++;\\n                        while(p < j && nums[p] == nums[p-1]) p++; // avoid repetitions\\n                        \\n                        q--;\\n                        while(i < q && nums[q] == nums[q+1]) q--; // avoid repetitions\\n                    }\\n                    else if (sum < target) { // sum is too small. Increment p so that we can look for bigger sums\\n                        p++;\\n                    } else { // sum is too big. Decrement q so that we can look for smaller sums\\n                        q--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502570,
                "title": "java-solution-faster-than-100-by-runtime",
                "content": "```\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n        //\\u5B9A\\u4E49\\u8FD4\\u56DE\\u503C\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (nums == null || nums.length < 4) return ans;\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        for (int i = 0; i < len - 3; i++) {\\n            /*\\u5F53k\\u7684\\u503C\\u4E0E\\u524D\\u9762\\u7684\\u503C\\u76F8\\u7B49\\u65F6\\u5FFD\\u7565*/\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5C0F\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5927\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5927\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F*/\\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)\\n                break;\\n            /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5927\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5927\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5C0F\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5C0F\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n            if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target)\\n                continue;\\n            for (int j = i + 1; j < len - 2; j++) {\\n                /*\\u5F53j\\u7684\\u503C\\u4E0E\\u524D\\u9762\\u7684\\u503C\\u76F8\\u7B49\\u65F6\\u5FFD\\u7565*/\\n                if (j > i + 1 && nums[j] == nums[j - 1])\\n                    continue;\\n                int l = j + 1, r = len - 1;\\n                /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5C0F\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5927\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5927\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target)\\n                    break;\\n                /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5927\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5927\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5C0F\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5C0F\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n                if (nums[i] + nums[j] + nums[r - 1] + nums[r] < target)\\n                    continue;\\n                while (l < r) {\\n                    int curr = nums[i] + nums[j] + nums[l] + nums[r];\\n                    if (target == curr) {\\n                        ans.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\\n                        /*\\u53BB\\u91CD*/\\n                        l++;\\n                        while (l < r && nums[l] == nums[l - 1]) l++;\\n                        r--;\\n                        while (r > l && nums[r] == nums[r + 1]) r--;\\n                    } else if (target > curr) {\\n                        l++;\\n                    } else\\n                        r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n        //\\u5B9A\\u4E49\\u8FD4\\u56DE\\u503C\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (nums == null || nums.length < 4) return ans;\\n        Arrays.sort(nums);\\n        int len = nums.length;\\n        for (int i = 0; i < len - 3; i++) {\\n            /*\\u5F53k\\u7684\\u503C\\u4E0E\\u524D\\u9762\\u7684\\u503C\\u76F8\\u7B49\\u65F6\\u5FFD\\u7565*/\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5C0F\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5927\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5927\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F*/\\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)\\n                break;\\n            /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5927\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5927\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5C0F\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5C0F\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n            if (nums[i] + nums[len - 1] + nums[len - 2] + nums[len - 3] < target)\\n                continue;\\n            for (int j = i + 1; j < len - 2; j++) {\\n                /*\\u5F53j\\u7684\\u503C\\u4E0E\\u524D\\u9762\\u7684\\u503C\\u76F8\\u7B49\\u65F6\\u5FFD\\u7565*/\\n                if (j > i + 1 && nums[j] == nums[j - 1])\\n                    continue;\\n                int l = j + 1, r = len - 1;\\n                /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5C0F\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5C0F\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5927\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5927\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target)\\n                    break;\\n                /*\\u83B7\\u53D6\\u5F53\\u524D\\u6700\\u5927\\u503C\\uFF0C\\u5982\\u679C\\u6700\\u5927\\u503C\\u6BD4\\u76EE\\u6807\\u503C\\u5C0F\\uFF0C\\u8BF4\\u660E\\u540E\\u9762\\u8D8A\\u6765\\u8D8A\\u5C0F\\u7684\\u503C\\u6839\\u672C\\u6CA1\\u620F\\uFF0C\\u5FFD\\u7565*/\\n                if (nums[i] + nums[j] + nums[r - 1] + nums[r] < target)\\n                    continue;\\n                while (l < r) {\\n                    int curr = nums[i] + nums[j] + nums[l] + nums[r];\\n                    if (target == curr) {\\n                        ans.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));\\n                        /*\\u53BB\\u91CD*/\\n                        l++;\\n                        while (l < r && nums[l] == nums[l - 1]) l++;\\n                        r--;\\n                        while (r > l && nums[r] == nums[r + 1]) r--;\\n                    } else if (target > curr) {\\n                        l++;\\n                    } else\\n                        r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 482856,
                "title": "javascript",
                "content": "Runtime: 108 ms, faster than 52.32% of JavaScript online submissions for 4Sum.\\nMemory Usage: 36.3 MB, less than 100.00% of JavaScript online submissions for 4Sum.\\n\\n```\\nvar fourSum = function(nums, target) {\\n  const sortedNums = nums.sort((a, b) => a - b);\\n  let resultArr = [];\\n  for (i = 0; i < sortedNums.length - 3; i++) {\\n    if (i > 0 && sortedNums[i] === sortedNums[i - 1]) {\\n      continue;\\n    }\\n    for (j = i + 1; j < sortedNums.length - 2; j++) {\\n      // \\u8981\\u8003\\u8651 j = i + 1\\u7684\\u60C5\\u51B5\\uFF0C\\u8FD9\\u662F\\u5408\\u7406\\u7684\\n      if (j > i + 1 && sortedNums[j] === sortedNums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = sortedNums.length - 1;\\n      while (left < right) {\\n        const sum =\\n          sortedNums[i] + sortedNums[j] + sortedNums[left] + sortedNums[right];\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          resultArr.push([\\n            sortedNums[i],\\n            sortedNums[j],\\n            sortedNums[left],\\n            sortedNums[right]\\n          ]);\\n          while (left < right && sortedNums[left] === sortedNums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && sortedNums[right] === sortedNums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return resultArr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar fourSum = function(nums, target) {\\n  const sortedNums = nums.sort((a, b) => a - b);\\n  let resultArr = [];\\n  for (i = 0; i < sortedNums.length - 3; i++) {\\n    if (i > 0 && sortedNums[i] === sortedNums[i - 1]) {\\n      continue;\\n    }\\n    for (j = i + 1; j < sortedNums.length - 2; j++) {\\n      // \\u8981\\u8003\\u8651 j = i + 1\\u7684\\u60C5\\u51B5\\uFF0C\\u8FD9\\u662F\\u5408\\u7406\\u7684\\n      if (j > i + 1 && sortedNums[j] === sortedNums[j - 1]) {\\n        continue;\\n      }\\n      let left = j + 1;\\n      let right = sortedNums.length - 1;\\n      while (left < right) {\\n        const sum =\\n          sortedNums[i] + sortedNums[j] + sortedNums[left] + sortedNums[right];\\n        if (sum < target) {\\n          left++;\\n        } else if (sum > target) {\\n          right--;\\n        } else {\\n          resultArr.push([\\n            sortedNums[i],\\n            sortedNums[j],\\n            sortedNums[left],\\n            sortedNums[right]\\n          ]);\\n          while (left < right && sortedNums[left] === sortedNums[left + 1]) {\\n            left++;\\n          }\\n          while (left < right && sortedNums[right] === sortedNums[right - 1]) {\\n            right--;\\n          }\\n          left++;\\n          right--;\\n        }\\n      }\\n    }\\n  }\\n  return resultArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405970,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        pairs = collections.defaultdict(list)\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                pairs[nums[i]+nums[j]].append((i, j))\\n        \\n        res = set()\\n        \\n        for s, ps in pairs.items():\\n            for a, b in ps:\\n                if target - s in pairs:\\n                    for k,v in pairs[target-s]:\\n                        if a != k and a != v and b != k and b != v:\\n                            res.add(tuple((sorted([nums[i] for i in [a,b,k,v]]))))\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        pairs = collections.defaultdict(list)\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                pairs[nums[i]+nums[j]].append((i, j))\\n        \\n        res = set()\\n        \\n        for s, ps in pairs.items():\\n            for a, b in ps:\\n                if target - s in pairs:\\n                    for k,v in pairs[target-s]:\\n                        if a != k and a != v and b != k and b != v:\\n                            res.add(tuple((sorted([nums[i] for i in [a,b,k,v]]))))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 385651,
                "title": "python-4sum-1-3sum",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i] > nums[i-1]:\\n                diff = target - nums[i]\\n                threeSums = self.threeSum(nums[i+1:], diff)\\n                for threeSum in threeSums:\\n                    res.append([nums[i]] + threeSum)\\n        return res\\n                \\n        \\n    def threeSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        if len(nums) < 3: return res\\n\\n        for i in range(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            l, r = i + 1, len(nums) - 1\\n            while l < r :\\n                s = nums[i] + nums[l] + nums[r]\\n                if s == target:\\n                    res.append([nums[i] ,nums[l] ,nums[r]])\\n                    l += 1; r -= 1\\n                    while l < r and nums[l] == nums[l - 1]: l += 1\\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\\n                elif s < target :\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if i == 0 or nums[i] > nums[i-1]:\\n                diff = target - nums[i]\\n                threeSums = self.threeSum(nums[i+1:], diff)\\n                for threeSum in threeSums:\\n                    res.append([nums[i]] + threeSum)\\n        return res\\n                \\n        \\n    def threeSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        if len(nums) < 3: return res\\n\\n        for i in range(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            l, r = i + 1, len(nums) - 1\\n            while l < r :\\n                s = nums[i] + nums[l] + nums[r]\\n                if s == target:\\n                    res.append([nums[i] ,nums[l] ,nums[r]])\\n                    l += 1; r -= 1\\n                    while l < r and nums[l] == nums[l - 1]: l += 1\\n                    while l < r and nums[r] == nums[r + 1]: r -= 1\\n                elif s < target :\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 236899,
                "title": "java-solution-4sum",
                "content": "**Solution 1: Reduce 4-Sum Problem to 3-Sum and 2-Sum sub-problems - Accepted in 20 ms**\\n\\nTime complexity: `O(n^3)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n\\tpublic List<List<Integer>> fourSum(int[] A, int target) \\n\\t{\\n\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\tArrays.sort(A);\\n\\n\\t\\tfor(int i = 0; i < A.length; i++) \\n\\t\\t{\\n\\t\\t\\tif(i == 0 || A[i] != A[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tthreeSum(list, A, i + 1, A.length - 1, target - A[i], A[i]);\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n\\n\\t// Three Sum Problem: list.add(Arrays.asList(w, the three numbers))\\n\\tprivate void threeSum(List<List<Integer>> list, int[] A, int start, int end, int target, int w) \\n\\t{\\n\\t\\tfor(int j = start; j < end; j++) \\n\\t\\t{\\n\\t\\t\\tif(j == start || A[j] != A[j - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\ttwoSum(list, A, j + 1, A.length - 1, target - A[j], w, A[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Two Sum Problem: list.add(Arrays.asList(w, x, the two numbers))\\n\\tprivate void twoSum(List<List<Integer>> list, int[] A, int start, int end, int target, int w, int x) \\n\\t{\\n\\t\\twhile(start < end) \\n\\t\\t{\\n\\t\\t\\tint y = A[start];\\n\\t\\t\\tint z = A[end];\\n\\n\\t\\t\\tif(y + z == target) \\n\\t\\t\\t{\\n\\t\\t\\t\\tlist.add(Arrays.asList(w, x, y, z));\\n\\t\\t\\t\\twhile(start < end && A[start] == A[start + 1]) start++;\\n\\t\\t\\t\\twhile(start < end && A[end] == A[end - 1]) \\t   end--;\\n                start++; end--;\\n\\t\\t\\t}\\n\\t\\t\\telse if(y + z < target)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n**Solution 2: General Solution for K Sum - Accepted in 31 ms**\\n\\nTime complexity: `O(n ^ (k - 1))`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic List<List<Integer>> fourSum(int[] A, int target)\\n\\t{\\n\\t\\tArrays.sort(A);\\n\\t\\treturn kSum(A, 0, A.length - 1, target, 4);\\n\\t}\\n\\n\\tprivate List<List<Integer>> kSum(int[] A, int start, int end, int target, int k)\\n\\t{\\n\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\t\\n\\t\\tif(k == 2)\\n\\t\\t{\\n\\t\\t\\twhile(start < end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(A[start] + A[end] == target)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlist.add(new LinkedList<Integer>(Arrays.asList(A[start], target - A[start])));\\n\\t\\t\\t\\t\\twhile(start < end && A[start] == A[start + 1]) start++;\\n\\t\\t\\t\\t\\twhile(start < end && A[end] == A[end - 1])     end--;\\n\\t\\t\\t\\t\\tstart++; end--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (A[start] + A[end] < target)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse // Reduce kSum to (k - 1)sum\\n\\t\\t{\\n\\t\\t\\tfor(int i = start; i < A.length - k + 1 && A[i] * k <= target; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i == start || A[i] != A[i - 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tList<List<Integer>> mainList = kSum(A, i + 1, A.length - 1, target - A[i], k - 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor(List<Integer> subList : mainList)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsubList.add(0, A[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlist.addAll(mainList);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n\\tpublic List<List<Integer>> fourSum(int[] A, int target) \\n\\t{\\n\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\tArrays.sort(A);\\n\\n\\t\\tfor(int i = 0; i < A.length; i++) \\n\\t\\t{\\n\\t\\t\\tif(i == 0 || A[i] != A[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tthreeSum(list, A, i + 1, A.length - 1, target - A[i], A[i]);\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n\\n\\t// Three Sum Problem: list.add(Arrays.asList(w, the three numbers))\\n\\tprivate void threeSum(List<List<Integer>> list, int[] A, int start, int end, int target, int w) \\n\\t{\\n\\t\\tfor(int j = start; j < end; j++) \\n\\t\\t{\\n\\t\\t\\tif(j == start || A[j] != A[j - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\ttwoSum(list, A, j + 1, A.length - 1, target - A[j], w, A[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Two Sum Problem: list.add(Arrays.asList(w, x, the two numbers))\\n\\tprivate void twoSum(List<List<Integer>> list, int[] A, int start, int end, int target, int w, int x) \\n\\t{\\n\\t\\twhile(start < end) \\n\\t\\t{\\n\\t\\t\\tint y = A[start];\\n\\t\\t\\tint z = A[end];\\n\\n\\t\\t\\tif(y + z == target) \\n\\t\\t\\t{\\n\\t\\t\\t\\tlist.add(Arrays.asList(w, x, y, z));\\n\\t\\t\\t\\twhile(start < end && A[start] == A[start + 1]) start++;\\n\\t\\t\\t\\twhile(start < end && A[end] == A[end - 1]) \\t   end--;\\n                start++; end--;\\n\\t\\t\\t}\\n\\t\\t\\telse if(y + z < target)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tend--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic List<List<Integer>> fourSum(int[] A, int target)\\n\\t{\\n\\t\\tArrays.sort(A);\\n\\t\\treturn kSum(A, 0, A.length - 1, target, 4);\\n\\t}\\n\\n\\tprivate List<List<Integer>> kSum(int[] A, int start, int end, int target, int k)\\n\\t{\\n\\t\\tList<List<Integer>> list = new ArrayList<>();\\n\\t\\t\\n\\t\\tif(k == 2)\\n\\t\\t{\\n\\t\\t\\twhile(start < end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(A[start] + A[end] == target)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlist.add(new LinkedList<Integer>(Arrays.asList(A[start], target - A[start])));\\n\\t\\t\\t\\t\\twhile(start < end && A[start] == A[start + 1]) start++;\\n\\t\\t\\t\\t\\twhile(start < end && A[end] == A[end - 1])     end--;\\n\\t\\t\\t\\t\\tstart++; end--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (A[start] + A[end] < target)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstart++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse // Reduce kSum to (k - 1)sum\\n\\t\\t{\\n\\t\\t\\tfor(int i = start; i < A.length - k + 1 && A[i] * k <= target; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i == start || A[i] != A[i - 1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tList<List<Integer>> mainList = kSum(A, i + 1, A.length - 1, target - A[i], k - 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfor(List<Integer> subList : mainList)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsubList.add(0, A[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlist.addAll(mainList);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn list;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175770,
                "title": "beats-79-java-with-explanations",
                "content": "**Thought**\\n```\\nfourSum(target) = {nums[i], threeSum(target - nums[i])}\\nthreeSum(target) = {nums[j], twoSum(target - nums[j])}\\ntwoSum(target) can be solved by Two-pointers.\\n```\\n\\n**Code**\\n```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        List<List<Integer>> threeSumResult, fourSumResult  = new ArrayList<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            if (nums[i] * 4 > target)\\n                return fourSumResult;\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            threeSumResult = threeSum(nums, target - nums[i], i + 1);\\n            if (threeSumResult.isEmpty())\\n                continue;\\n            for (List<Integer> list : threeSumResult) {\\n                if (!list.isEmpty()) {\\n                    list.add(nums[i]);\\n                    fourSumResult.add(new ArrayList<>(list));\\n                }\\n            }\\n        }\\n        return fourSumResult;\\n    }\\n    \\n    private List<List<Integer>> threeSum(int[] nums, int target, int startIndex) {\\n        int n = nums.length;\\n        List<List<Integer>> twoSumResult, threeSumResult = new ArrayList<>();\\n        for (int i = startIndex; i < n - 1; i++) {\\n            if (nums[i] * 3 > target)\\n                return threeSumResult;\\n            if (i > startIndex && nums[i] == nums[i - 1])\\n                continue;\\n            twoSumResult= twoSum(nums, target - nums[i], i + 1);\\n            if (twoSumResult.isEmpty())\\n                continue;\\n            for (List<Integer> list : twoSumResult) {\\n                if (!list.isEmpty()) {\\n                    list.add(nums[i]);\\n                    threeSumResult.add(new ArrayList<>(list));\\n                }\\n            }\\n        }\\n        return threeSumResult ;\\n    }\\n    \\n    private List<List<Integer>> twoSum(int[] nums, int target, int startIndex) {\\n        int n = nums.length;\\n        int lo = startIndex, hi = n - 1;\\n        if (nums[lo] * 2 > target)\\n            return new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> curResult = null;\\n        while (lo < hi) {\\n            if (nums[lo] + nums[hi] == target) {\\n                curResult = new ArrayList<>();\\n                curResult.add(nums[lo]);\\n                curResult.add(nums[hi]);\\n                result.add(new ArrayList<>(curResult));\\n                lo++;\\n                while (lo < nums.length && lo > 0 && nums[lo] == nums[lo - 1]) \\n                    lo++;\\n                hi--;\\n                while (hi < nums.length && hi > 0 && nums[hi] == nums[hi + 1])\\n                    hi--;\\n            } \\n            else if (nums[lo] + nums[hi] < target) {\\n                lo++;\\n                while (lo < nums.length && lo > 0  && nums[lo] == nums[lo - 1]) \\n                    lo++;\\n            }\\n            else {\\n                hi--;\\n                while (hi < nums.length && hi > 0 && nums[hi] == nums[hi + 1]) \\n                    hi--;\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\nfourSum(target) = {nums[i], threeSum(target - nums[i])}\\nthreeSum(target) = {nums[j], twoSum(target - nums[j])}\\ntwoSum(target) can be solved by Two-pointers.\\n```\n```\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        List<List<Integer>> threeSumResult, fourSumResult  = new ArrayList<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            if (nums[i] * 4 > target)\\n                return fourSumResult;\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            threeSumResult = threeSum(nums, target - nums[i], i + 1);\\n            if (threeSumResult.isEmpty())\\n                continue;\\n            for (List<Integer> list : threeSumResult) {\\n                if (!list.isEmpty()) {\\n                    list.add(nums[i]);\\n                    fourSumResult.add(new ArrayList<>(list));\\n                }\\n            }\\n        }\\n        return fourSumResult;\\n    }\\n    \\n    private List<List<Integer>> threeSum(int[] nums, int target, int startIndex) {\\n        int n = nums.length;\\n        List<List<Integer>> twoSumResult, threeSumResult = new ArrayList<>();\\n        for (int i = startIndex; i < n - 1; i++) {\\n            if (nums[i] * 3 > target)\\n                return threeSumResult;\\n            if (i > startIndex && nums[i] == nums[i - 1])\\n                continue;\\n            twoSumResult= twoSum(nums, target - nums[i], i + 1);\\n            if (twoSumResult.isEmpty())\\n                continue;\\n            for (List<Integer> list : twoSumResult) {\\n                if (!list.isEmpty()) {\\n                    list.add(nums[i]);\\n                    threeSumResult.add(new ArrayList<>(list));\\n                }\\n            }\\n        }\\n        return threeSumResult ;\\n    }\\n    \\n    private List<List<Integer>> twoSum(int[] nums, int target, int startIndex) {\\n        int n = nums.length;\\n        int lo = startIndex, hi = n - 1;\\n        if (nums[lo] * 2 > target)\\n            return new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> curResult = null;\\n        while (lo < hi) {\\n            if (nums[lo] + nums[hi] == target) {\\n                curResult = new ArrayList<>();\\n                curResult.add(nums[lo]);\\n                curResult.add(nums[hi]);\\n                result.add(new ArrayList<>(curResult));\\n                lo++;\\n                while (lo < nums.length && lo > 0 && nums[lo] == nums[lo - 1]) \\n                    lo++;\\n                hi--;\\n                while (hi < nums.length && hi > 0 && nums[hi] == nums[hi + 1])\\n                    hi--;\\n            } \\n            else if (nums[lo] + nums[hi] < target) {\\n                lo++;\\n                while (lo < nums.length && lo > 0  && nums[lo] == nums[lo - 1]) \\n                    lo++;\\n            }\\n            else {\\n                hi--;\\n                while (hi < nums.length && hi > 0 && nums[hi] == nums[hi + 1]) \\n                    hi--;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 171054,
                "title": "java-solution-with-explain-really-easy-to-understand",
                "content": "I checked a lot of discussion with their answer. Most of them are hard to read, they all focus on showing their  number of lines of code, or speed of their code, which is boring.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        //fix two numbers, two pointer to other two numbers.\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) { //our pointer(based on first number) is larger(pass) than target, stop searching.\\n                break;\\n            }\\n            if (nums[i] + nums[nums.length - 1] + nums[nums.length - 2] + nums[nums.length - 3] < target) {\\n                continue; //first candidate is too small.\\n            }\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue; // this value is already visited, skip to avoid duplicated value.\\n            }\\n            for (int j = i + 1; j < nums.length - 2; j++) {\\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\\n                    break; // our pointer based on second number is passed the target, stop searching.\\n                }\\n                if (nums[i] + nums[j] + nums[nums.length - 1] + nums[nums.length - 2] < target) { //j is too small\\n                    continue;\\n                }\\n                if (j > i + 1 && nums[j] == nums[j - 1]) { //here should be j > i + 1, because j can be equal to i at j = i + 1\\n                    continue;  // this value is already visited, skip to avoid duplicated value.\\n                }\\n                //Two pointer.\\n                int start = j + 1;\\n                int end = nums.length - 1;\\n                \\n                while (start < end) {\\n                    int sum = nums[i] + nums[j] + nums[start] + nums[end];\\n                    \\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));\\n                        \\n                        while (start < end && nums[start] == nums[start + 1]) {\\n                            start++; // skip duplicated value.\\n                        }\\n                        while (start < end && nums[end] == nums[end - 1]) {\\n                            end--;\\n                        }\\n                        start++;\\n                        end--;\\n                    } else if (sum < target) {\\n                        start++;\\n                    } else {\\n                        end--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        //fix two numbers, two pointer to other two numbers.\\n        List<List<Integer>> result = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        for (int i = 0; i < nums.length - 3; i++) {\\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) { //our pointer(based on first number) is larger(pass) than target, stop searching.\\n                break;\\n            }\\n            if (nums[i] + nums[nums.length - 1] + nums[nums.length - 2] + nums[nums.length - 3] < target) {\\n                continue; //first candidate is too small.\\n            }\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue; // this value is already visited, skip to avoid duplicated value.\\n            }\\n            for (int j = i + 1; j < nums.length - 2; j++) {\\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\\n                    break; // our pointer based on second number is passed the target, stop searching.\\n                }\\n                if (nums[i] + nums[j] + nums[nums.length - 1] + nums[nums.length - 2] < target) { //j is too small\\n                    continue;\\n                }\\n                if (j > i + 1 && nums[j] == nums[j - 1]) { //here should be j > i + 1, because j can be equal to i at j = i + 1\\n                    continue;  // this value is already visited, skip to avoid duplicated value.\\n                }\\n                //Two pointer.\\n                int start = j + 1;\\n                int end = nums.length - 1;\\n                \\n                while (start < end) {\\n                    int sum = nums[i] + nums[j] + nums[start] + nums[end];\\n                    \\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));\\n                        \\n                        while (start < end && nums[start] == nums[start + 1]) {\\n                            start++; // skip duplicated value.\\n                        }\\n                        while (start < end && nums[end] == nums[end - 1]) {\\n                            end--;\\n                        }\\n                        start++;\\n                        end--;\\n                    } else if (sum < target) {\\n                        start++;\\n                    } else {\\n                        end--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143219,
                "title": "my-java-recursive-solution-for-any-k-sum-problem",
                "content": "This is my lastested version of kSum, I simplified the previous code to make it easier to read.\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int k = 4;\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        if (nums == null || nums.length < k) return list;\\n        Arrays.sort(nums);\\n        List<Integer> track = new ArrayList<Integer>();\\n        kSum(nums, target, k, 0, track, list);\\n        return list;\\n    }\\n    private void kSum(int[] nums, int target, int k, int index, List<Integer> track, List<List<Integer>> list) {\\n        if (k == 2) {\\n            int i = index; int j = nums.length - 1;\\n            while (i < j) {\\n                int sum = nums[i] + nums[j];\\n                if (sum == target) {\\n                    List<Integer> temp = new ArrayList<Integer>(track);\\n                    temp.add(nums[i]); temp.add(nums[j]);\\n                    list.add(temp);\\n                    while (i < j && nums[i] == nums[i + 1]) i ++;\\n                    while (i < j && nums[j] == nums[j - 1]) j --;\\n                    i ++; j --;\\n                } else if (sum > target) {\\n                    while (i < j && nums[j] == nums[j - 1]) j --;\\n                    j --;\\n                } else {\\n                    while (i < j && nums[i] == nums[i + 1]) i ++;\\n                    i ++;\\n                }\\n            }\\n            return;\\n        }\\n        for (int i = index; i <= nums.length - k; i ++) {\\n            if (i > index && nums[i] == nums[i - 1]) continue;\\n            track.add(nums[i]);\\n            kSum(nums, target - nums[i], k - 1, i + 1, track, list);\\n            track.remove(track.size() - 1);\\n        }\\n    }\\n}\\n```\\nPrevious kSum code.\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        if (nums == null || nums.length < 4) return result;\\n        Arrays.sort(nums);\\n        // since this problem ask for the solution of 4 sum, so I just pass 4 to the method. But you can change 4 to any other K\\n        return findSum(nums, target, 0, 4, result);\\n    }\\n    private List<List<Integer>> findSum(int[] nums, int target, int start, int k, List<List<Integer>> result) {\\n        if (k == 2) {\\n            // Do two sum\\n            List<List<Integer>> curr = new LinkedList<List<Integer>>();\\n            int left = start;\\n            int right = nums.length - 1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] == target) {\\n                    List<Integer> list = new LinkedList<Integer>();\\n                    list.add(nums[left]); list.add(nums[right]);\\n                    curr.add(list);\\n                    while (left < right && nums[left] == nums[left + 1]) left ++;\\n                    while (left < right && nums[right] == nums[right - 1]) right --;\\n                    left ++; right --;\\n                } else if (nums[left] + nums[right] > target) right --;\\n                else left ++;\\n            }\\n            return curr;\\n        }\\n        \\n        List<List<Integer>> curr = new LinkedList<List<Integer>>();\\n        for (int i = start; i < nums.length - k + 1; i ++) {\\n            for (List<Integer> l : findSum(nums, target - nums[i], i + 1, k - 1, result)) {\\n                l.add(nums[i]);\\n                curr.add(l);\\n            }\\n            while (i < nums.length - k && nums[i] == nums[i + 1]) i ++;\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        int k = 4;\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        if (nums == null || nums.length < k) return list;\\n        Arrays.sort(nums);\\n        List<Integer> track = new ArrayList<Integer>();\\n        kSum(nums, target, k, 0, track, list);\\n        return list;\\n    }\\n    private void kSum(int[] nums, int target, int k, int index, List<Integer> track, List<List<Integer>> list) {\\n        if (k == 2) {\\n            int i = index; int j = nums.length - 1;\\n            while (i < j) {\\n                int sum = nums[i] + nums[j];\\n                if (sum == target) {\\n                    List<Integer> temp = new ArrayList<Integer>(track);\\n                    temp.add(nums[i]); temp.add(nums[j]);\\n                    list.add(temp);\\n                    while (i < j && nums[i] == nums[i + 1]) i ++;\\n                    while (i < j && nums[j] == nums[j - 1]) j --;\\n                    i ++; j --;\\n                } else if (sum > target) {\\n                    while (i < j && nums[j] == nums[j - 1]) j --;\\n                    j --;\\n                } else {\\n                    while (i < j && nums[i] == nums[i + 1]) i ++;\\n                    i ++;\\n                }\\n            }\\n            return;\\n        }\\n        for (int i = index; i <= nums.length - k; i ++) {\\n            if (i > index && nums[i] == nums[i - 1]) continue;\\n            track.add(nums[i]);\\n            kSum(nums, target - nums[i], k - 1, i + 1, track, list);\\n            track.remove(track.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\\n        if (nums == null || nums.length < 4) return result;\\n        Arrays.sort(nums);\\n        // since this problem ask for the solution of 4 sum, so I just pass 4 to the method. But you can change 4 to any other K\\n        return findSum(nums, target, 0, 4, result);\\n    }\\n    private List<List<Integer>> findSum(int[] nums, int target, int start, int k, List<List<Integer>> result) {\\n        if (k == 2) {\\n            // Do two sum\\n            List<List<Integer>> curr = new LinkedList<List<Integer>>();\\n            int left = start;\\n            int right = nums.length - 1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] == target) {\\n                    List<Integer> list = new LinkedList<Integer>();\\n                    list.add(nums[left]); list.add(nums[right]);\\n                    curr.add(list);\\n                    while (left < right && nums[left] == nums[left + 1]) left ++;\\n                    while (left < right && nums[right] == nums[right - 1]) right --;\\n                    left ++; right --;\\n                } else if (nums[left] + nums[right] > target) right --;\\n                else left ++;\\n            }\\n            return curr;\\n        }\\n        \\n        List<List<Integer>> curr = new LinkedList<List<Integer>>();\\n        for (int i = start; i < nums.length - k + 1; i ++) {\\n            for (List<Integer> l : findSum(nums, target - nums[i], i + 1, k - 1, result)) {\\n                l.add(nums[i]);\\n                curr.add(l);\\n            }\\n            while (i < nums.length - k && nums[i] == nums[i + 1]) i ++;\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8733,
                "title": "16ms-c-solution-with-pruning",
                "content": "Sometimes I got 12ms :)\\n\\nI just did some pruning when scan through the first two elements.   The other 2 elements are determined the same as in 2sum.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>>  result;\\n            if(nums.size() < 4) return result;\\n            \\n            vector<int> solution(4,0);\\n            std::sort(nums.begin(),nums.end());\\n            int sum,a,b,c,d,Max_d_when_a_increase = nums.size() - 1,Max_d_when_b_increase;\\n            \\n            //a,b,c,d are the four index\\n            //Max_d_when_a_increase is the max possible d when a increase. To have the same sum, when a increase, d can only decrease\\n            //Max_d_when_b_increase is the max possible d when b increase\\n            \\n            for( a = 0; a < Max_d_when_a_increase - 2;a++ )\\n            {\\n                //remove dupilcate & do pruning if a too small or too big\\n                if((a>0 && nums[a] == nums[a-1])\\n                || nums[a] + nums[Max_d_when_a_increase] + nums[Max_d_when_a_increase-1] + nums[Max_d_when_a_increase-2] < target) continue;\\n                if(nums[a]+nums[a+1]+nums[a+2]+nums[a+3] > target) break;            \\n    \\n                //update Max_d_when_a_increase\\n                sum = nums[a]+nums[a+1]+nums[a+2];\\n                while(sum+nums[Max_d_when_a_increase] > target)Max_d_when_a_increase--;\\n                Max_d_when_b_increase = Max_d_when_a_increase;\\n    \\n                solution[0] = nums[a];\\n                for( b=a+1; b < Max_d_when_b_increase - 1;b++)\\n                {\\n                    //remove dupilcate & do pruning if b too small or too big\\n                    if((b>a+1 && nums[b] == nums[b-1])\\n                    || nums[a] + nums[b] + nums[Max_d_when_b_increase-1] + nums[Max_d_when_b_increase] < target) continue;\\n                    sum = nums[a] + nums[b]+nums[b+1];\\n                    if(sum + nums[b+2] > target) break;\\n                    \\n                    //update Max_d_when_b_increase\\n                    while(sum+nums[Max_d_when_b_increase]>target) Max_d_when_b_increase--;\\n    \\n                    solution[1] = nums[b];\\n                    c = b+1;\\n                    d = Max_d_when_b_increase;\\n                    sum = nums[a] + nums[b];\\n                    while(c < d)//this are the same as two sum\\n                        if(sum + nums[c] + nums[d] == target)\\n                        {\\n                            solution[2]=nums[c];\\n                            solution[3]=nums[d];\\n                            result.push_back(solution);\\n                            \\n                            do{c++;}while(c < d && nums[c] == nums[c-1]);\\n                            do{d--;}while(c < d && nums[d] == nums[d+1]);\\n                        }\\n                        else if(sum + nums[c] + nums[d] < target) \\n                            do{c++;}while(c < d && nums[c] == nums[c-1]);\\n                        else do{d--;}while(c < d && nums[d] == nums[d+1]);\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n            vector<vector<int>>  result;\\n            if(nums.size() < 4) return result;\\n            \\n            vector<int> solution(4,0);\\n            std::sort(nums.begin(),nums.end());\\n            int sum,a,b,c,d,Max_d_when_a_increase = nums.size() - 1,Max_d_when_b_increase;\\n            \\n            //a,b,c,d are the four index\\n            //Max_d_when_a_increase is the max possible d when a increase. To have the same sum, when a increase, d can only decrease\\n            //Max_d_when_b_increase is the max possible d when b increase\\n            \\n            for( a = 0; a < Max_d_when_a_increase - 2;a++ )\\n            {\\n                //remove dupilcate & do pruning if a too small or too big\\n                if((a>0 && nums[a] == nums[a-1])\\n                || nums[a] + nums[Max_d_when_a_increase] + nums[Max_d_when_a_increase-1] + nums[Max_d_when_a_increase-2] < target) continue;\\n                if(nums[a]+nums[a+1]+nums[a+2]+nums[a+3] > target) break;            \\n    \\n                //update Max_d_when_a_increase\\n                sum = nums[a]+nums[a+1]+nums[a+2];\\n                while(sum+nums[Max_d_when_a_increase] > target)Max_d_when_a_increase--;\\n                Max_d_when_b_increase = Max_d_when_a_increase;\\n    \\n                solution[0] = nums[a];\\n                for( b=a+1; b < Max_d_when_b_increase - 1;b++)\\n                {\\n                    //remove dupilcate & do pruning if b too small or too big\\n                    if((b>a+1 && nums[b] == nums[b-1])\\n                    || nums[a] + nums[b] + nums[Max_d_when_b_increase-1] + nums[Max_d_when_b_increase] < target) continue;\\n                    sum = nums[a] + nums[b]+nums[b+1];\\n                    if(sum + nums[b+2] > target) break;\\n                    \\n                    //update Max_d_when_b_increase\\n                    while(sum+nums[Max_d_when_b_increase]>target) Max_d_when_b_increase--;\\n    \\n                    solution[1] = nums[b];\\n                    c = b+1;\\n                    d = Max_d_when_b_increase;\\n                    sum = nums[a] + nums[b];\\n                    while(c < d)//this are the same as two sum\\n                        if(sum + nums[c] + nums[d] == target)\\n                        {\\n                            solution[2]=nums[c];\\n                            solution[3]=nums[d];\\n                            result.push_back(solution);\\n                            \\n                            do{c++;}",
                "codeTag": "Java"
            },
            {
                "id": 3263647,
                "title": "3-solutions-explained-c",
                "content": "## APPROACH 1 (Take NotTake)\\n**NOTE** : this approach throws TLE\\n\\n**Intuition** :- \\n1. Firstly sort the given array(since we want all the unique combinations, also after sorting all the duplicates will be adjacent to each other).\\n2. Use the take & notTake approach to find all the possible combinations that gives a sum of target. \\n3. If target == 0 && size of currentAns == 4, then we have got a valid combination, so add it to the set(we are using a set since we want all the unique quads).\\n4. If we have exhausted the array or size of currentAns exceeds 4 then simply return.\\n5. Finally store the values of the set in the answer array and return answer.\\n\\n- Time Complexity = O(nlogn) + O(logn * 2^n)\\nO(nlogn) -> sorting \\nO(2^n) -> since at each index we are having two options i.e. to take or not take\\nO(logn) -> insertion in the set\\n\\n- Space Complexity = O(n), since we are using a set\\n\\n\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    void allCombinations(int currentIndex, int target, vector<int>&nums, vector<int>currentAns, \\n                    set<vector<int>>&st)\\n    {\\n        //valid combination\\n        if(target == 0 && currentAns.size() == 4)\\n        {\\n            st.insert(currentAns);\\n            return;\\n        }\\n        \\n        //invalid combination\\n        if(currentIndex == nums.size() || currentAns.size() >= 4)\\n            return ;\\n        \\n        \\n        //take\\n        currentAns.push_back(nums[currentIndex]);\\n        allCombinations(currentIndex+1,target-nums[currentIndex],nums,currentAns,st);\\n        currentAns.pop_back();\\n        \\n        //not take\\n        allCombinations(currentIndex+1,target,nums,currentAns,st);\\n    }\\n    \\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        vector<int>currentAns;\\n        set<vector<int>>st;\\n        vector<vector<int>>ans;\\n        \\n        sort(nums.begin(),nums.end());\\n        allCombinations(0,target,nums,currentAns,st);\\n        \\n        for(auto current : st)\\n            ans.push_back(current);\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n## APPROACH 2 (3 Pointers + Binary Search)\\n**Intuition** :- \\n1. Sort the given array, since we want unique combinations in answer array & after sortin all the duplicates will be adjacent to each other.\\n2. Take three pointers i,j and k. Such that i starts from 0, j starts from i+1 and k starts from j+1 and all of them goes till n.\\n3. Now, sum the values present at i,j and k-th index and find the remaining value to make target, i.e. remaining = target - nums[i] - nums[j] - nums[k].\\n4. Now search if this remaining value is present in the right half(i.e. from k+1 to n) or not.\\n5. If remaining is present in the right half, then it means that we have got a valid combination of size 4 that gives target.\\n6. So insert it into the set, we are using a set because we want only unique quadruplets.\\n7. Finally store the values of set in answer vector and return ans.\\n\\n- Time Complexity = O(nlogn) + O(logn * n^3)\\nO(nlogn) -> for sorting\\nO(logn * n^3) -> longn is for binary search and n^3 is for the 3 loops\\n\\n- Space Complexity = O(n), since we are using a set\\n\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    //binary search\\n    bool isPresent(int start, int end, long long target, vector<int>&nums)\\n    {\\n        if(start > end)\\n            return false;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        if(nums[mid] == target)\\n            return true;\\n        \\n        else if(nums[mid] < target)\\n            return isPresent(mid+1,end,target,nums);\\n        \\n        return isPresent(start,mid-1,target,nums);\\n    }\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                for(int k = j+1; k < n; k++)\\n                {\\n                    long long val = (long long)nums[i]+(long long)nums[j]+(long long)nums[k];\\n                    long long remaining = target - val;\\n                    \\n                    //implement binary search to check if remaining is present in the right part of array\\n                    if(isPresent(k+1,n-1,remaining,nums))\\n                    {\\n                        vector<int>temp(4,-1);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[k];\\n                        temp[3] = remaining;\\n                        \\n                        st.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //storing all the valid combinations from set to ans vector\\n        for(auto current : st)\\n            ans.push_back(current);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n## APPROACH 3 (OPTIMAL SOLUTION : 2 Pointers + two Sum)\\n**Intuition** :- \\n1. Sort the array, since we want only unique quadruplets and after sorting all duplicates will be adjacent to each other.\\n2. Take two iterators i ad j such that i starts from 0 and j starts from i+1 and goes till n.\\n3. Now calculate the remaining value, i.e. remaining  = target - nums[i] - nums[j].\\n4. Now we\\'ll take two pointers start & end, start = j+1 & end = n-1.\\n5. If nums[start] + nums[end] > target, then we\\'ll decrement end.\\n6. If nums[start] + nums[end] < target, then we\\'ll increment start.\\n7. If numd[start] + nums[end] == target, it means we have got a valid combination, so we\\'ll create a temp vector and will add it to answer.\\nNow since have used the values at start & end and we want unique combinations, so we\\'ll skip all the values that equal temp[2] by incrementing start and\\nthat are equal to temp[3] by by decrementing end.\\n8.Finally return ans.\\n\\n- Time Complexity = O(n^3)\\n\\n- Space Complexity = O(1)\\n\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        vector<vector<int>>ans;\\n        \\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                long long remaining = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                \\n                int start = j+1;\\n                int end = n-1;\\n                \\n                while(start < end)\\n                {\\n                    if(nums[start] + nums[end] > remaining)\\n                        end--;\\n                    \\n                    else if(nums[start] + nums[end] < remaining)\\n                        start++;\\n                    \\n                    //valid combination (nums[start] + nums[end] == remaining)\\n                    else\\n                    {\\n                        vector<int>temp(4,-1);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[start];\\n                        temp[3] = nums[end];\\n                    \\n                        ans.push_back(temp);\\n                        \\n                        //skip the duplicates\\n                        while(start < end && nums[start] == temp[2])\\n                            start++;\\n                        while(end > start && nums[end] == temp[3])\\n                            end--;\\n                    }\\n                }\\n                while(j < n-1 && nums[j] == nums[j+1])\\n                    j++;\\n            }\\n            while(i < n-1 && nums[i] == nums[i+1])\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2462f240-7461-4c7c-bd17-ea74d9091ad3_1678092631.7170804.png)\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    void allCombinations(int currentIndex, int target, vector<int>&nums, vector<int>currentAns, \\n                    set<vector<int>>&st)\\n    {\\n        //valid combination\\n        if(target == 0 && currentAns.size() == 4)\\n        {\\n            st.insert(currentAns);\\n            return;\\n        }\\n        \\n        //invalid combination\\n        if(currentIndex == nums.size() || currentAns.size() >= 4)\\n            return ;\\n        \\n        \\n        //take\\n        currentAns.push_back(nums[currentIndex]);\\n        allCombinations(currentIndex+1,target-nums[currentIndex],nums,currentAns,st);\\n        currentAns.pop_back();\\n        \\n        //not take\\n        allCombinations(currentIndex+1,target,nums,currentAns,st);\\n    }\\n    \\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        vector<int>currentAns;\\n        set<vector<int>>st;\\n        vector<vector<int>>ans;\\n        \\n        sort(nums.begin(),nums.end());\\n        allCombinations(0,target,nums,currentAns,st);\\n        \\n        for(auto current : st)\\n            ans.push_back(current);\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    //binary search\\n    bool isPresent(int start, int end, long long target, vector<int>&nums)\\n    {\\n        if(start > end)\\n            return false;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        if(nums[mid] == target)\\n            return true;\\n        \\n        else if(nums[mid] < target)\\n            return isPresent(mid+1,end,target,nums);\\n        \\n        return isPresent(start,mid-1,target,nums);\\n    }\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        set<vector<int>>st;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                for(int k = j+1; k < n; k++)\\n                {\\n                    long long val = (long long)nums[i]+(long long)nums[j]+(long long)nums[k];\\n                    long long remaining = target - val;\\n                    \\n                    //implement binary search to check if remaining is present in the right part of array\\n                    if(isPresent(k+1,n-1,remaining,nums))\\n                    {\\n                        vector<int>temp(4,-1);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[k];\\n                        temp[3] = remaining;\\n                        \\n                        st.insert(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //storing all the valid combinations from set to ans vector\\n        for(auto current : st)\\n            ans.push_back(current);\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n    {\\n        vector<vector<int>>ans;\\n        \\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i+1; j < n; j++)\\n            {\\n                long long remaining = (long long)target - (long long)nums[i] - (long long)nums[j];\\n                \\n                int start = j+1;\\n                int end = n-1;\\n                \\n                while(start < end)\\n                {\\n                    if(nums[start] + nums[end] > remaining)\\n                        end--;\\n                    \\n                    else if(nums[start] + nums[end] < remaining)\\n                        start++;\\n                    \\n                    //valid combination (nums[start] + nums[end] == remaining)\\n                    else\\n                    {\\n                        vector<int>temp(4,-1);\\n                        temp[0] = nums[i];\\n                        temp[1] = nums[j];\\n                        temp[2] = nums[start];\\n                        temp[3] = nums[end];\\n                    \\n                        ans.push_back(temp);\\n                        \\n                        //skip the duplicates\\n                        while(start < end && nums[start] == temp[2])\\n                            start++;\\n                        while(end > start && nums[end] == temp[3])\\n                            end--;\\n                    }\\n                }\\n                while(j < n-1 && nums[j] == nums[j+1])\\n                    j++;\\n            }\\n            while(i < n-1 && nums[i] == nums[i+1])\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138504,
                "title": "java-easy-to-understand-accepted",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i = 0; i < nums.length - 3; i++) {\\n            for(int j = i + 1; j < nums.length - 2; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while(k < l) {\\n                    long sum = (long)nums[i] + (long)nums[j] + (long)nums[k] + (long)nums[l];\\n                    if(sum == target){\\n                        set.add(List.of(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    else if(sum < target)\\n                        k++;\\n                    else\\n                        l--;\\n                }\\n            }\\n        }\\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int i = 0; i < nums.length - 3; i++) {\\n            for(int j = i + 1; j < nums.length - 2; j++) {\\n                int k = j + 1;\\n                int l = nums.length - 1;\\n                while(k < l) {\\n                    long sum = (long)nums[i] + (long)nums[j] + (long)nums[k] + (long)nums[l];\\n                    if(sum == target){\\n                        set.add(List.of(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    else if(sum < target)\\n                        k++;\\n                    else\\n                        l--;\\n                }\\n            }\\n        }\\n        return new ArrayList<>(set);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864893,
                "title": "two-pointer-easy-approach-java-easy",
                "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int tar) {\\n    long target =(long)tar;\\n    Arrays.sort(nums);\\n    List<List<Integer>> res=new ArrayList<>();\\n    List<Integer> temp=new ArrayList<>();\\n        helper(nums,target,res,temp);\\n        \\n        \\n        return res;\\n    }\\n    static void helper(int nums[],long target,List<List<Integer>> res,List<Integer> temp){\\n        \\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                            int k=j+1;\\n            int last=nums.length-1;\\n            \\n            while(k<last){\\n                long sum=(long)nums[i]+nums[j]+nums[k]+nums[last];\\n                if(sum==target){\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[k]);\\n                    temp.add(nums[last]);\\n                    \\n                    if(!res.contains(temp)){\\n                        res.add(new ArrayList<>(temp));\\n                    }\\n                    temp.clear();\\n                    k++;\\n                    last--;\\n                    \\n                }\\n                else if(sum>target){\\n                    last--;\\n                }\\n                else{\\n                        k++;\\n                }\\n                \\n            }\\n                \\n            }\\n            \\n            \\n            \\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int tar) {\\n    long target =(long)tar;\\n    Arrays.sort(nums);\\n    List<List<Integer>> res=new ArrayList<>();\\n    List<Integer> temp=new ArrayList<>();\\n        helper(nums,target,res,temp);\\n        \\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2798064,
                "title": "easy-and-optimized-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n     {\\n\\n      vector<vector<int>> v;\\n      sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i++){\\n        if(i != 0 && nums[i] == nums[i - 1]) continue;\\n        for(int j = i + 1; j < nums.size(); j++)\\n        {\\n          if(j != i + 1 && nums[j] == nums[j - 1]) continue;\\n          int k = j + 1;\\n          int l = nums.size() - 1;\\n          while(k < l){\\n            long long int sum = (long long) nums[i] + (long long) nums[j] + (long long) nums[k] + (long long) nums[l];\\n            if(target - sum == 0)\\n            {\\n              v.push_back({nums[i], nums[j], nums[k], nums[l]});\\n              k++;\\n              while(k < l && nums[k] == nums[k - 1]) k++;\\n            }\\n            else if(sum < target) k++;\\n            else l--;\\n          }\\n          \\n        }\\n      }\\n      \\n      return v;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target)\\n     {\\n\\n      vector<vector<int>> v;\\n      sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i++){\\n        if(i != 0 && nums[i] == nums[i - 1]) continue;\\n        for(int j = i + 1; j < nums.size(); j++)\\n        {\\n          if(j != i + 1 && nums[j] == nums[j - 1]) continue;\\n          int k = j + 1;\\n          int l = nums.size() - 1;\\n          while(k < l){\\n            long long int sum = (long long) nums[i] + (long long) nums[j] + (long long) nums[k] + (long long) nums[l];\\n            if(target - sum == 0)\\n            {\\n              v.push_back({nums[i], nums[j], nums[k], nums[l]});\\n              k++;\\n              while(k < l && nums[k] == nums[k - 1]) k++;\\n            }\\n            else if(sum < target) k++;\\n            else l--;\\n          }\\n          \\n        }\\n      }\\n      \\n      return v;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773994,
                "title": "java-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n     long[] nums=new long[num.length];\\n     for(int z=0;z<nums.length;z++){\\n         nums[z]=(long)num[z];\\n     } \\n     Arrays.sort(nums);\\n     long sum=0;\\n     HashSet<List<Integer>> set=new HashSet();\\n     List<List<Integer>> ar=new ArrayList();\\n    \\n       for(int i=0;i<nums.length;i++){\\n           if(i>0 && nums[i]==nums[i-1]) continue;\\n           for(int j=i+1;j<nums.length;j++){\\n               if(j>i+1 && nums[j]==nums[j-1]) continue;\\n               int k=j+1;\\n               int l=nums.length-1;\\n               while(k<l){\\n                   sum=nums[i]+nums[j]+nums[k]+nums[l];\\n                   if(sum>target){\\n                       \\n                       l--;\\n                   }\\n                else if(sum==target){\\n                     List<Integer>ar1=new ArrayList();\\n                    ar1.add((int)nums[i]);\\n                    ar1.add((int)nums[j]);\\n                    ar1.add((int)nums[k]);\\n                    ar1.add((int)nums[l]);   \\n                    set.add(ar1);\\n                    k++;\\n                          }\\n               \\n               else{\\n                   k++;\\n               }\\n           }                  \\n       }\\n        \\n    }for(List<Integer> res:set){\\n        ar.add(res);\\n    }  \\n    return ar;\\n   \\n}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] num, int target) {\\n     long[] nums=new long[num.length];\\n     for(int z=0;z<nums.length;z++){\\n         nums[z]=(long)num[z];\\n     } \\n     Arrays.sort(nums);\\n     long sum=0;\\n     HashSet<List<Integer>> set=new HashSet();\\n     List<List<Integer>> ar=new ArrayList();\\n    \\n       for(int i=0;i<nums.length;i++){\\n           if(i>0 && nums[i]==nums[i-1]) continue;\\n           for(int j=i+1;j<nums.length;j++){\\n               if(j>i+1 && nums[j]==nums[j-1]) continue;\\n               int k=j+1;\\n               int l=nums.length-1;\\n               while(k<l){\\n                   sum=nums[i]+nums[j]+nums[k]+nums[l];\\n                   if(sum>target){\\n                       \\n                       l--;\\n                   }\\n                else if(sum==target){\\n                     List<Integer>ar1=new ArrayList();\\n                    ar1.add((int)nums[i]);\\n                    ar1.add((int)nums[j]);\\n                    ar1.add((int)nums[k]);\\n                    ar1.add((int)nums[l]);   \\n                    set.add(ar1);\\n                    k++;\\n                          }\\n               \\n               else{\\n                   k++;\\n               }\\n           }                  \\n       }\\n        \\n    }for(List<Integer> res:set){\\n        ar.add(res);\\n    }  \\n    return ar;\\n   \\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745816,
                "title": "c-easy-sol-constant-space-approach",
                "content": "* Please upvote if you like my sol.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        long  n = nums.size();\\n        if(n<4) return {};\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        \\n        for(long i=0;i<n;i++){\\n            \\n            for(long j = i+1;j<n;j++){\\n                \\n                long long x = long(target) - long(nums[i])-long(nums[j]);\\n                long l = j+1,r=n-1;\\n                while(r>l){\\n                    \\n                    if(nums[l]+nums[r]>x) r--;\\n                    else if(nums[l]+nums[r]<x) l++;\\n                    else {\\n                        ans.push_back({nums[i],nums[j],nums[l++],nums[r--]});\\n                        while(l<r and nums[l]==nums[l-1]) l++;\\n                        while(l<r and nums[r]==nums[r+1]) r--;\\n                    }\\n                }\\n                while(j + 1 < n && nums[j + 1] == nums[j]) ++j;\\n            }\\n            while (i + 1 < n && nums[i + 1] == nums[i]) ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        long  n = nums.size();\\n        if(n<4) return {};\\n        \\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> ans;\\n        \\n        for(long i=0;i<n;i++){\\n            \\n            for(long j = i+1;j<n;j++){\\n                \\n                long long x = long(target) - long(nums[i])-long(nums[j]);\\n                long l = j+1,r=n-1;\\n                while(r>l){\\n                    \\n                    if(nums[l]+nums[r]>x) r--;\\n                    else if(nums[l]+nums[r]<x) l++;\\n                    else {\\n                        ans.push_back({nums[i],nums[j],nums[l++],nums[r--]});\\n                        while(l<r and nums[l]==nums[l-1]) l++;\\n                        while(l<r and nums[r]==nums[r+1]) r--;\\n                    }\\n                }\\n                while(j + 1 < n && nums[j + 1] == nums[j]) ++j;\\n            }\\n            while (i + 1 < n && nums[i + 1] == nums[i]) ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689946,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length - 3; i++) {\\n            for(int j = i + 1; j < nums.length - 2; j++) {\\n                long res = (nums[i] + nums[j]);\\n                long remSum = target - res;\\n                int front = j + 1, back = nums.length - 1;\\n                while(front < back) {\\n                    long twoSum = nums[front] + nums[back];\\n                    if(twoSum < remSum) front++;\\n                    else if(twoSum > remSum) back--;\\n                    else {\\n                        List<Integer> sum = new ArrayList<>();\\n                        sum.add(nums[i]);\\n                        sum.add(nums[j]);\\n                        sum.add(nums[front]);\\n                        sum.add(nums[back]);\\n                        ans.add(sum);\\n                        \\n                        while(front < back && nums[front] == sum.get(2)) front++;\\n                        while(front < back && nums[back] == sum.get(3)) back--;\\n                    }\\n                }\\n                while(i < nums.length - 1 && nums[i + 1] == nums[i]) i++;\\n                while(j < nums.length - 1 && nums[j + 1] == nums[j]) j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length - 3; i++) {\\n            for(int j = i + 1; j < nums.length - 2; j++) {\\n                long res = (nums[i] + nums[j]);\\n                long remSum = target - res;\\n                int front = j + 1, back = nums.length - 1;\\n                while(front < back) {\\n                    long twoSum = nums[front] + nums[back];\\n                    if(twoSum < remSum) front++;\\n                    else if(twoSum > remSum) back--;\\n                    else {\\n                        List<Integer> sum = new ArrayList<>();\\n                        sum.add(nums[i]);\\n                        sum.add(nums[j]);\\n                        sum.add(nums[front]);\\n                        sum.add(nums[back]);\\n                        ans.add(sum);\\n                        \\n                        while(front < back && nums[front] == sum.get(2)) front++;\\n                        while(front < back && nums[back] == sum.get(3)) back--;\\n                    }\\n                }\\n                while(i < nums.length - 1 && nums[i + 1] == nums[i]) i++;\\n                while(j < nums.length - 1 && nums[j + 1] == nums[j]) j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765703,
                "title": "python-2-pointers-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        if len(nums) < 4:\\n            return []\\n        quad = []\\n        nums.sort()\\n        for i in range(len(nums) - 3):\\n            for j in range(i + 1, len(nums) - 2):\\n                sumA = nums[i] + nums[j]\\n                left = j + 1\\n                right = len(nums) - 1\\n                while left < right:\\n                    sumB = sumA + nums[left] + nums[right]\\n                    if sumB == target:\\n                        quad.append((nums[i], nums[j], nums[left], nums[right]))\\n                        left += 1\\n                        right -= 1\\n                    elif sumB < target:\\n                         left += 1\\n                    else:\\n                         right -= 1\\n        return (set(quad))\\n\\n                        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        if len(nums) < 4:\\n            return []\\n        quad = []\\n        nums.sort()\\n        for i in range(len(nums) - 3):\\n            for j in range(i + 1, len(nums) - 2):\\n                sumA = nums[i] + nums[j]\\n                left = j + 1\\n                right = len(nums) - 1\\n                while left < right:\\n                    sumB = sumA + nums[left] + nums[right]\\n                    if sumB == target:\\n                        quad.append((nums[i], nums[j], nums[left], nums[right]))\\n                        left += 1\\n                        right -= 1\\n                    elif sumB < target:\\n                         left += 1\\n                    else:\\n                         right -= 1\\n        return (set(quad))\\n\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741754,
                "title": "java-4sum-solution-java-two-pointer",
                "content": "*Runtime is 22sec beating about 60% + submissions*\\nTime Complexity O(n^3)\\nTo understand this solution you must be aware of 2Sum solution using sorting.\\nBut don\\'t worry I\\'ll try to explain it real quick:\\n**2Sum Solution for 4Sum using two pointer**\\n1. We need to find two elements summing to given target.\\n2. Sort the array\\n3. Place 1st pointer(start) at 0 and 2nd pointer(end) at arr.length - 1\\n4. Loop and add location to compare the sum with target\\n5. Increment or decrement start or end accordingly\\nSomething like this:\\n```\\n// start = 0, end = nums.length - 1\\n// Note : nums is sorted\\n\\t\\twhile(start < end){ \\n                    if(target == nums[start]+nums[end]){\\n                        return new int[2] {start, end};\\n\\t\\t\\t\\t\\t\\t\\n                    }else if(temp < nums[start]+nums[end]){\\n                        end--;\\n                    }\\n                    else{\\n                        start++;\\n                    }\\n```\\nNow for **4Sum** \\nWhat we do is create 2 level loop and then do the above code and change them according to the question:\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\n\\t\\t// Sorting the array so we can use two pointer concept\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList();\\n        int n = nums.length;\\n\\t\\t\\n\\t\\t// 1st level loop, n-3 beacuse after i there should be another 3 elements \\n\\t\\t// to get into the result\\n        for(int i=0; i<n-3; i++){\\n\\t\\t\\t//  checking if duplicate is present or not\\n            if(i>0 && nums[i-1] == nums[i]) continue;\\n\\t\\t\\t\\n\\t\\t\\t// Same as outer loop\\n            for(int j=i+1; j< n-2; j++){\\n\\t\\t\\t\\t// Checking for duplicates\\n                if(j > i+1 && nums[j-1] == nums[j]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Defining variables for 2Sum type problem solution\\n                int start = j + 1;\\n                int end = n -1;\\n                int temp = target - nums[i] - nums[j];\\n\\t\\t\\t\\t// Here temp becomes the temporary target\\n                while(start < end){\\n                    // Check if equal\\n                    if(temp == nums[start]+nums[end]){\\n\\t\\t\\t\\t\\t\\t// Adding to the result\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//Checking if any duplicates present \\n                        while(start<end && nums[start] == nums[start+1]) start++;\\n                        while(start<end && nums[end] == nums[end-1]) end--;\\n                        start++;\\n                        end--;\\n                    }else if(temp < nums[start]+nums[end]){\\n                        end--;\\n                    }\\n                    else{\\n                        start++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nIf this helped please make sure to **upvote** and help others as well. Also share you thought and any easier solution.\\n**Thanks**\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n// start = 0, end = nums.length - 1\\n// Note : nums is sorted\\n\\t\\twhile(start < end){ \\n                    if(target == nums[start]+nums[end]){\\n                        return new int[2] {start, end};\\n\\t\\t\\t\\t\\t\\t\\n                    }else if(temp < nums[start]+nums[end]){\\n                        end--;\\n                    }\\n                    else{\\n                        start++;\\n                    }\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\t\\n\\t\\t// Sorting the array so we can use two pointer concept\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList();\\n        int n = nums.length;\\n\\t\\t\\n\\t\\t// 1st level loop, n-3 beacuse after i there should be another 3 elements \\n\\t\\t// to get into the result\\n        for(int i=0; i<n-3; i++){\\n\\t\\t\\t//  checking if duplicate is present or not\\n            if(i>0 && nums[i-1] == nums[i]) continue;\\n\\t\\t\\t\\n\\t\\t\\t// Same as outer loop\\n            for(int j=i+1; j< n-2; j++){\\n\\t\\t\\t\\t// Checking for duplicates\\n                if(j > i+1 && nums[j-1] == nums[j]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Defining variables for 2Sum type problem solution\\n                int start = j + 1;\\n                int end = n -1;\\n                int temp = target - nums[i] - nums[j];\\n\\t\\t\\t\\t// Here temp becomes the temporary target\\n                while(start < end){\\n                    // Check if equal\\n                    if(temp == nums[start]+nums[end]){\\n\\t\\t\\t\\t\\t\\t// Adding to the result\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t//Checking if any duplicates present \\n                        while(start<end && nums[start] == nums[start+1]) start++;\\n                        while(start<end && nums[end] == nums[end-1]) end--;\\n                        start++;\\n                        end--;\\n                    }else if(temp < nums[start]+nums[end]){\\n                        end--;\\n                    }\\n                    else{\\n                        start++;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538652,
                "title": "python-10-lines-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        ans, n = [], len(nums)\\n        nums.sort()\\n        for a in range(n):\\n            for b in range(a+1, n):\\n                c = b+1; d = n-1\\n                while c<d:\\n                    sums = nums[a]+nums[b]+nums[c]+nums[d]\\n                    if sums < target: c += 1\\n                    elif sums > target: d -= 1\\n                    else:\\n                        to_append = [nums[a],nums[b],nums[c],nums[d]]\\n                        if to_append not in ans:\\n                            ans.append(to_append)\\n                        c +=1; d-=1\\n        return ans\\n```\\nstart by sorting the `nums` array, and iterates through the length of `nums` array, \\n- A is the first district number, iterates through 0 to (n-1)\\n- B is the second distict number, iterates through `a+1` to (n-1)\\n- C is the third distict number, iterates through `b+1` until before idx for `d`\\n- D is the last distict number.\\n\\nIn each iteration, we calculate the sums of a+b+c+d,\\n- if sum is equal to target and not yet included into answer, then `[a,b,c,d]` stored to ans. \\n- if the sum < target, increment `c`\\n- if sum > target, decrement `d`\\n\\nrepeat the whole process until all conditions exhausted.\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def fourSum(self, nums, target):\\n        ans, n = [], len(nums)\\n        nums.sort()\\n        for a in range(n):\\n            for b in range(a+1, n):\\n                c = b+1; d = n-1\\n                while c<d:\\n                    sums = nums[a]+nums[b]+nums[c]+nums[d]\\n                    if sums < target: c += 1\\n                    elif sums > target: d -= 1\\n                    else:\\n                        to_append = [nums[a],nums[b],nums[c],nums[d]]\\n                        if to_append not in ans:\\n                            ans.append(to_append)\\n                        c +=1; d-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510015,
                "title": "python-o-n-2-with-o-n-extra-memory",
                "content": "```\\nfrom collections import defaultdict, Counter\\n\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        c = Counter(nums)\\n        nums = [i for i in c for j in range(min(4, c[i]))] # get rid of any extraneous duplicates\\n        \\n        pair_sums = {} # mapping of 2-tuple of indices to their sum\\n        sum_pairs = defaultdict(list) # mapping between sum and all pairs with that sum\\n        quadruplets = set() # all 4-sums, sorted by value\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                a, b = nums[i], nums[j]\\n                pair_sums[(i, j)] = a + b\\n                sum_pairs[a+b].append((i, j))\\n                \\n        for i,j in pair_sums:\\n            pair_target = target - pair_sums[(i,j)] # pair_sums[(i,j)] + pair_target = target\\n            for k,l in sum_pairs[pair_target]:\\n                if len(set((i,j,k,l))) == 4:\\n                    quadruplets.add(tuple(sorted((nums[i], nums[j], nums[k], nums[l]))))\\n        return list(quadruplets)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, Counter\\n\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        c = Counter(nums)\\n        nums = [i for i in c for j in range(min(4, c[i]))] # get rid of any extraneous duplicates\\n        \\n        pair_sums = {} # mapping of 2-tuple of indices to their sum\\n        sum_pairs = defaultdict(list) # mapping between sum and all pairs with that sum\\n        quadruplets = set() # all 4-sums, sorted by value\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                a, b = nums[i], nums[j]\\n                pair_sums[(i, j)] = a + b\\n                sum_pairs[a+b].append((i, j))\\n                \\n        for i,j in pair_sums:\\n            pair_target = target - pair_sums[(i,j)] # pair_sums[(i,j)] + pair_target = target\\n            for k,l in sum_pairs[pair_target]:\\n                if len(set((i,j,k,l))) == 4:\\n                    quadruplets.add(tuple(sorted((nums[i], nums[j], nums[k], nums[l]))))\\n        return list(quadruplets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493634,
                "title": "simple-cpp-sorting",
                "content": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<vector<int>>v;\\n        if(n<4) return {};\\n        else{\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++){\\n                if(i>0 && nums[i]==nums[i-1]) continue;\\n                for(int j=i+1;j<n-2;j++){\\n                    if(j>i+1 && nums[j]==nums[j-1]) continue;\\n                    \\n                    int val=target-nums[i]-nums[j];\\n                    int l=j+1;\\n                    int h=n-1;\\n                    while(l<h){\\n                        if(nums[l]+nums[h]==val){\\n                            vector<int>v1;\\n                            v1.push_back(nums[i]);\\n                            v1.push_back(nums[j]);\\n                            v1.push_back(nums[l]);\\n                            v1.push_back(nums[h]);\\n                            v.push_back(v1);\\n                            v1.clear();\\n                            while(l<h && nums[l]==nums[l+1]) l++;\\n                            while(l<h && nums[h]==nums[h-1]) h--;\\n                            l++;\\n                            h--;\\n                        }\\n                        else if(nums[l]+nums[h]<val) l++;\\n                        else if(nums[l]+nums[h]>val) h--;\\n                    }\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<vector<int>>v;\\n        if(n<4) return {};\\n        else{\\n            sort(nums.begin(),nums.end());\\n            for(int i=0;i<n-3;i++){\\n                if(i>0 && nums[i]==nums[i-1]) continue;\\n                for(int j=i+1;j<n-2;j++){\\n                    if(j>i+1 && nums[j]==nums[j-1]) continue;\\n                    \\n                    int val=target-nums[i]-nums[j];\\n                    int l=j+1;\\n                    int h=n-1;\\n                    while(l<h){\\n                        if(nums[l]+nums[h]==val){\\n                            vector<int>v1;\\n                            v1.push_back(nums[i]);\\n                            v1.push_back(nums[j]);\\n                            v1.push_back(nums[l]);\\n                            v1.push_back(nums[h]);\\n                            v.push_back(v1);\\n                            v1.clear();\\n                            while(l<h && nums[l]==nums[l+1]) l++;\\n                            while(l<h && nums[h]==nums[h-1]) h--;\\n                            l++;\\n                            h--;\\n                        }\\n                        else if(nums[l]+nums[h]<val) l++;\\n                        else if(nums[l]+nums[h]>val) h--;\\n                    }\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1412755,
                "title": "c-handles-duplicate-values-beginner-friendly-2-sum-modification",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n<4) return result;\\n        int i,j, first,last,current;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1]) continue;\\n            for(j=i+1;j<n;j++)\\n            {\\n                current = target - nums[i]- nums[j];\\n                first=j+1;\\n                last=n-1;\\n                while(first<last)\\n                {\\n                    if(nums[first]+nums[last]<current)\\n                    {\\n                        first++;\\n                    }\\n                    else if(nums[first]+nums[last]>current)\\n                    {\\n                        last--;\\n                    }\\n                    else\\n                    {\\n                        vector<int> res1(4,0);\\n                        res1[0]=(nums[i]); res1[1]=(nums[j]); res1[2]=(nums[first]); res1[3]=(nums[last]);\\n                        result.push_back(res1);\\n                        while(first<last and nums[first]==res1[2]) ++first;\\n                        while(first<last and nums[last]==res1[3]) --last;\\n                           \\n                    }\\n                }\\n                while(j+1<n and nums[j+1]==nums[j]) ++j;\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n<4) return result;\\n        int i,j, first,last,current;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1]) continue;\\n            for(j=i+1;j<n;j++)\\n            {\\n                current = target - nums[i]- nums[j];\\n                first=j+1;\\n                last=n-1;\\n                while(first<last)\\n                {\\n                    if(nums[first]+nums[last]<current)\\n                    {\\n                        first++;\\n                    }\\n                    else if(nums[first]+nums[last]>current)\\n                    {\\n                        last--;\\n                    }\\n                    else\\n                    {\\n                        vector<int> res1(4,0);\\n                        res1[0]=(nums[i]); res1[1]=(nums[j]); res1[2]=(nums[first]); res1[3]=(nums[last]);\\n                        result.push_back(res1);\\n                        while(first<last and nums[first]==res1[2]) ++first;\\n                        while(first<last and nums[last]==res1[3]) --last;\\n                           \\n                    }\\n                }\\n                while(j+1<n and nums[j+1]==nums[j]) ++j;\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341498,
                "title": "easy-to-understand-comments-added",
                "content": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> st; // to store unqiue vector\\n        vector<vector<int>> ans;// to store ans\\n        int n = nums.size();// calculating size\\n        if(n < 4)// because a, b,c, d should not same\\n            return ans; \\n        sort(nums.begin(), nums.end());\\n        int d = n-1;\\n\\n        for(int a=0; a<d-2; a++){\\n            for(int b=a+1; b<d-1; b++){\\n                for(int c=b+1,d=n-1; c<d; c++){\\n                    if(nums[a] + nums[b] + nums[c] + nums[d] > target)\\n                    {\\n                        d--;// a,b,c are on minimum and d is pointing on max so reducing d to next lower value\\n                        c--;// to keep c on same position b/c c will increment due to for loop\\n                    }\\n                    else if(nums[a] + nums[b] + nums[c] + nums[d] == target){\\n                        st.insert({nums[a], nums[b], nums[c], nums[d]});// storing one of the possible ans\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it:st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n\\t\\n```\\n**Do UpVote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> st; // to store unqiue vector\\n        vector<vector<int>> ans;// to store ans\\n        int n = nums.size();// calculating size\\n        if(n < 4)// because a, b,c, d should not same\\n            return ans; \\n        sort(nums.begin(), nums.end());\\n        int d = n-1;\\n\\n        for(int a=0; a<d-2; a++){\\n            for(int b=a+1; b<d-1; b++){\\n                for(int c=b+1,d=n-1; c<d; c++){\\n                    if(nums[a] + nums[b] + nums[c] + nums[d] > target)\\n                    {\\n                        d--;// a,b,c are on minimum and d is pointing on max so reducing d to next lower value\\n                        c--;// to keep c on same position b/c c will increment due to for loop\\n                    }\\n                    else if(nums[a] + nums[b] + nums[c] + nums[d] == target){\\n                        st.insert({nums[a], nums[b], nums[c], nums[d]});// storing one of the possible ans\\n                    }\\n                }\\n            }\\n        }\\n        for(auto it:st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341323,
                "title": "python-solution",
                "content": "Hope it helps\\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        quadruplets = []\\n        unique = set()\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n - 3):\\n            for j in range(i + 1, n - 2):\\n                start = j + 1\\n                end = n - 1\\n                while start < end:\\n                    if nums[start] + nums[end] == target - nums[i] - nums[j]:\\n                        if (nums[i], nums[j], nums[start], nums[end]) not in unique:\\n                            unique.add((nums[i], nums[j], nums[start], nums[end]))\\n                            quadruplets.append([nums[i], nums[j], nums[start], nums[end]])\\n                        start += 1\\n                        end -= 1\\n                    elif nums[start] + nums[end] < target - nums[i] - nums[j]:\\n                        start += 1\\n                    else:\\n                        end -= 1\\n                \\n        return quadruplets\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        quadruplets = []\\n        unique = set()\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n - 3):\\n            for j in range(i + 1, n - 2):\\n                start = j + 1\\n                end = n - 1\\n                while start < end:\\n                    if nums[start] + nums[end] == target - nums[i] - nums[j]:\\n                        if (nums[i], nums[j], nums[start], nums[end]) not in unique:\\n                            unique.add((nums[i], nums[j], nums[start], nums[end]))\\n                            quadruplets.append([nums[i], nums[j], nums[start], nums[end]])\\n                        start += 1\\n                        end -= 1\\n                    elif nums[start] + nums[end] < target - nums[i] - nums[j]:\\n                        start += 1\\n                    else:\\n                        end -= 1\\n                \\n        return quadruplets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295328,
                "title": "very-intutive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();        \\n        vector<vector<int>> ans;\\n        if(n<4)\\n            return ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int target_3=target-nums[i]; //target_3 is required target from now\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                \\n                int target_2=target_3-nums[j]; //target_2 is required target from now\\n                \\n                // now we can imagine as a two sum problem from here\\n                \\n                int low=j+1;\\n                int high=n-1;\\n                \\n                while(low<high)\\n                {\\n                    \\n                    int two_sum=nums[low]+nums[high];\\n                    \\n                    if(two_sum>target_2)\\n                    {\\n                        high--;\\n                    }\\n                    else if(two_sum<target_2)\\n                    {\\n                        low++;\\n                    }\\n                    else\\n                    {\\n                        \\n                        vector<int>quadruplet(4);// temporary vector to store quadruplets \\n                        \\n                        quadruplet[0]=nums[i];\\n                        quadruplet[1]=nums[j];\\n                        quadruplet[2]=nums[low];\\n                        quadruplet[3]=nums[high];\\n                        \\n                        ans.push_back(quadruplet);\\n                        \\n                        /// remove duplicates of number 3\\n                        \\n                        while(low<high&&nums[low]==quadruplet[2])\\n                            low++;\\n                        \\n                         /// remove duplicates of number 4\\n                        \\n                        while(low<high&&nums[high]==quadruplet[3])\\n                            high--;\\n                        \\n                        \\n                    }\\n                }\\n                \\n                 /// remove duplicates of number 2\\n                        \\n                 while(j+1<n&&nums[j+1]==nums[j])\\n                        j++;\\n                        \\n                \\n                \\n            }\\n            \\n             /// remove duplicates of number 1\\n                        \\n                while(i+1<n&&nums[i+1]==nums[i])\\n                            i++;\\n                        \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();        \\n        vector<vector<int>> ans;\\n        if(n<4)\\n            return ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int target_3=target-nums[i]; //target_3 is required target from now\\n            \\n            for(int j=i+1;j<n;j++)\\n            {\\n                \\n                int target_2=target_3-nums[j]; //target_2 is required target from now\\n                \\n                // now we can imagine as a two sum problem from here\\n                \\n                int low=j+1;\\n                int high=n-1;\\n                \\n                while(low<high)\\n                {\\n                    \\n                    int two_sum=nums[low]+nums[high];\\n                    \\n                    if(two_sum>target_2)\\n                    {\\n                        high--;\\n                    }\\n                    else if(two_sum<target_2)\\n                    {\\n                        low++;\\n                    }\\n                    else\\n                    {\\n                        \\n                        vector<int>quadruplet(4);// temporary vector to store quadruplets \\n                        \\n                        quadruplet[0]=nums[i];\\n                        quadruplet[1]=nums[j];\\n                        quadruplet[2]=nums[low];\\n                        quadruplet[3]=nums[high];\\n                        \\n                        ans.push_back(quadruplet);\\n                        \\n                        /// remove duplicates of number 3\\n                        \\n                        while(low<high&&nums[low]==quadruplet[2])\\n                            low++;\\n                        \\n                         /// remove duplicates of number 4\\n                        \\n                        while(low<high&&nums[high]==quadruplet[3])\\n                            high--;\\n                        \\n                        \\n                    }\\n                }\\n                \\n                 /// remove duplicates of number 2\\n                        \\n                 while(j+1<n&&nums[j+1]==nums[j])\\n                        j++;\\n                        \\n                \\n                \\n            }\\n            \\n             /// remove duplicates of number 1\\n                        \\n                while(i+1<n&&nums[i+1]==nums[i])\\n                            i++;\\n                        \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243001,
                "title": "c-solution-same-as-3sum-with-explanation",
                "content": "```\\n    /*\\n     * Approach followed is similar to 3 sum where first we sort the\\n     * input array in increasing order and traverse first loop start\\n     * with index i and second loop traverse from i + 1, now we need\\n     * to find 2 nos using Binary search that sums up to target.\\n    */\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // variable to store the result\\n        vector<vector<int>> res;\\n        \\n        // check if we have sufficient elements to find the quadruplets\\n        if (nums.size() < 4) {\\n            // no sufficient elemets for finding quadruplets\\n            return res;\\n        }\\n        \\n        // Sort the input array in increasing order\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        // variable to define remaining target\\n        int target_2;\\n        \\n        // Temp variables\\n        int a, b, c, d;\\n        \\n        // Traverse and find all quadruplets\\n        for (int i = 0; i < n; i++) {\\n            a = nums[i];\\n            \\n            for (int j = i + 1; j < n; j++) {\\n                b = nums[j];\\n                \\n                // a + b + c + d = target\\n                // => c + d = target - a - b\\n                target_2 = target - a - b;\\n                \\n                // Need to find the remaning two numbers that sum up to target_2\\n                // defining k & l indicies\\n                int k = j + 1;\\n                int l = n - 1;\\n                \\n                // Traverse remainig elements such that sum is equal to target_2\\n                // using binary search\\n                while (k < l) {\\n                    c = nums[k];\\n                    d = nums[l];\\n                    \\n                    // check if the sum is equal to target_2\\n                    if (c + d == target_2) {\\n                        // sum of the nums is zero, found a triplet\\n                        res.push_back({a, b, c, d});\\n                        \\n                        // check if the next element is a duplicate, if so\\n                        // exclude it as duplicate triplets are not allowed\\n                        while (k < l && nums[k] == c) {\\n                            // duplicate, exclude this\\n                            k++;\\n                        }\\n                        \\n                        while (k < l && nums[l] == d) {\\n                            // duplicate, exclude this\\n                            l--;\\n                        }\\n                    }\\n                    else {\\n                        // check if the sum is greater than target, if so reduce k\\n                        // if sum is less than target, then reduce j\\n                        c + d > target_2 ? --l : ++k;\\n                    }\\n                }\\n                \\n                // Check if the next element is duplicate, if so exclude it\\n                while (j + 1 < n && nums[j + 1] == b) {\\n                    j++;\\n                }\\n            }\\n\\n            // check if the next element is duplicate, if so exclude it\\n            while (i + 1 < n && nums[i + 1] == a) {\\n                i++;\\n            }\\n        }\\n        \\n        // return the quadruplets\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Approach followed is similar to 3 sum where first we sort the\\n     * input array in increasing order and traverse first loop start\\n     * with index i and second loop traverse from i + 1, now we need\\n     * to find 2 nos using Binary search that sums up to target.\\n    */\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // variable to store the result\\n        vector<vector<int>> res;\\n        \\n        // check if we have sufficient elements to find the quadruplets\\n        if (nums.size() < 4) {\\n            // no sufficient elemets for finding quadruplets\\n            return res;\\n        }\\n        \\n        // Sort the input array in increasing order\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        // variable to define remaining target\\n        int target_2;\\n        \\n        // Temp variables\\n        int a, b, c, d;\\n        \\n        // Traverse and find all quadruplets\\n        for (int i = 0; i < n; i++) {\\n            a = nums[i];\\n            \\n            for (int j = i + 1; j < n; j++) {\\n                b = nums[j];\\n                \\n                // a + b + c + d = target\\n                // => c + d = target - a - b\\n                target_2 = target - a - b;\\n                \\n                // Need to find the remaning two numbers that sum up to target_2\\n                // defining k & l indicies\\n                int k = j + 1;\\n                int l = n - 1;\\n                \\n                // Traverse remainig elements such that sum is equal to target_2\\n                // using binary search\\n                while (k < l) {\\n                    c = nums[k];\\n                    d = nums[l];\\n                    \\n                    // check if the sum is equal to target_2\\n                    if (c + d == target_2) {\\n                        // sum of the nums is zero, found a triplet\\n                        res.push_back({a, b, c, d});\\n                        \\n                        // check if the next element is a duplicate, if so\\n                        // exclude it as duplicate triplets are not allowed\\n                        while (k < l && nums[k] == c) {\\n                            // duplicate, exclude this\\n                            k++;\\n                        }\\n                        \\n                        while (k < l && nums[l] == d) {\\n                            // duplicate, exclude this\\n                            l--;\\n                        }\\n                    }\\n                    else {\\n                        // check if the sum is greater than target, if so reduce k\\n                        // if sum is less than target, then reduce j\\n                        c + d > target_2 ? --l : ++k;\\n                    }\\n                }\\n                \\n                // Check if the next element is duplicate, if so exclude it\\n                while (j + 1 < n && nums[j + 1] == b) {\\n                    j++;\\n                }\\n            }\\n\\n            // check if the next element is duplicate, if so exclude it\\n            while (i + 1 < n && nums[i + 1] == a) {\\n                i++;\\n            }\\n        }\\n        \\n        // return the quadruplets\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156100,
                "title": "100-faster-c-4-sum",
                "content": "\\n***Do upvote if you found it helpful to keep me motivated to post more*** \\n***For better understanding make a dry run***\\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& num, int target) {\\n    vector<vector<int>> res;\\n    if(num.empty())\\n    return res;\\n    int n=num.size();\\n    int i,j;\\n    sort(num.begin(),num.end()); // sort the array\\n    for(i=0;i<n;i++)\\n    {\\n        for(j=i+1;j<n;j++)\\n        {\\n            int target2;\\n            target2=target-num[i]-num[j];\\n            int front=j+1;\\n            int back=n-1;\\n            while(front<back)\\n            {\\n                int sum=num[front]+num[back];\\n                if(target2<sum) // decrement from end\\n                back--;\\n                else if(target2>sum) // increment from start\\n                front++;\\n                else\\n                 {\\n                 vector<int> v(4,0);\\n                 v[0]=num[i];\\n                 v[1]=num[j];\\n                 v[2]=num[front];\\n                 v[3]=num[back];\\n                 res.push_back(v);\\n\\t\\t\\t\\t \\n                 while(front<back && num[front]==v[2])\\n                     front++;\\n                 while(front<back && num[back]==v[3])\\n                     back--;\\n                }\\n                \\n             while(j+1<n && num[j+1]==num[j])\\n                j++;\\n            }\\n\\t\\t\\t\\n         while(i+1<n && num[i+1]==num[i])\\n            i++;  \\n        }\\n    }\\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& num, int target) {\\n    vector<vector<int>> res;\\n    if(num.empty())\\n    return res;\\n    int n=num.size();\\n    int i,j;\\n    sort(num.begin(),num.end()); // sort the array\\n    for(i=0;i<n;i++)\\n    {\\n        for(j=i+1;j<n;j++)\\n        {\\n            int target2;\\n            target2=target-num[i]-num[j];\\n            int front=j+1;\\n            int back=n-1;\\n            while(front<back)\\n            {\\n                int sum=num[front]+num[back];\\n                if(target2<sum) // decrement from end\\n                back--;\\n                else if(target2>sum) // increment from start\\n                front++;\\n                else\\n                 {\\n                 vector<int> v(4,0);\\n                 v[0]=num[i];\\n                 v[1]=num[j];\\n                 v[2]=num[front];\\n                 v[3]=num[back];\\n                 res.push_back(v);\\n\\t\\t\\t\\t \\n                 while(front<back && num[front]==v[2])\\n                     front++;\\n                 while(front<back && num[back]==v[3])\\n                     back--;\\n                }\\n                \\n             while(j+1<n && num[j+1]==num[j])\\n                j++;\\n            }\\n\\t\\t\\t\\n         while(i+1<n && num[i+1]==num[i])\\n            i++;  \\n        }\\n    }\\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101552,
                "title": "easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& s, int k) {\\n     int z=s.size();\\n    if(s.size()<4) return {};\\n    int arr[z];\\n    int p=0;\\n    for(int i=0;i<z;i++)\\n    {\\n        arr[p]=s[i];\\n        p++;\\n    }\\n    sort(arr,arr+z);\\n    vector<int>v1;\\n        \\n    set<vector<int>>st;\\n    vector<vector<int>>v;\\n       \\n    for(int i=0;i<z-3;i++)\\n    {\\n        for(int j=i+1;j<z-2;j++)\\n        {\\n            int l=j+1;\\n            int r=z-1;\\n            while(l<r)\\n            {\\n                if(arr[i]+arr[j]+arr[l]+arr[r]==k)\\n                {\\n                    v1.push_back(arr[i]);\\n                    v1.push_back(arr[j]);\\n                     v1.push_back(arr[l]);\\n                     v1.push_back(arr[r]);\\n                    if(!st.count(v1))\\n                    {\\n                        st.insert(v1);\\n                        v.push_back(v1);\\n                    }\\n                     v1.clear();\\n                     l++;\\n                     r--;\\n                     \\n                    \\n                }\\n                if(arr[i]+arr[j]+arr[l]+arr[r]<k)\\n                {\\n                l++;\\n                }\\n                \\n                else if(arr[i]+arr[j]+arr[l]+arr[r]>k)\\n                {\\n                   r--;\\n                    \\n                }\\n            }\\n            \\n        }\\n      \\n    }\\n    return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& s, int k) {\\n     int z=s.size();\\n    if(s.size()<4) return {};\\n    int arr[z];\\n    int p=0;\\n    for(int i=0;i<z;i++)\\n    {\\n        arr[p]=s[i];\\n        p++;\\n    }\\n    sort(arr,arr+z);\\n    vector<int>v1;\\n        \\n    set<vector<int>>st;\\n    vector<vector<int>>v;\\n       \\n    for(int i=0;i<z-3;i++)\\n    {\\n        for(int j=i+1;j<z-2;j++)\\n        {\\n            int l=j+1;\\n            int r=z-1;\\n            while(l<r)\\n            {\\n                if(arr[i]+arr[j]+arr[l]+arr[r]==k)\\n                {\\n                    v1.push_back(arr[i]);\\n                    v1.push_back(arr[j]);\\n                     v1.push_back(arr[l]);\\n                     v1.push_back(arr[r]);\\n                    if(!st.count(v1))\\n                    {\\n                        st.insert(v1);\\n                        v.push_back(v1);\\n                    }\\n                     v1.clear();\\n                     l++;\\n                     r--;\\n                     \\n                    \\n                }\\n                if(arr[i]+arr[j]+arr[l]+arr[r]<k)\\n                {\\n                l++;\\n                }\\n                \\n                else if(arr[i]+arr[j]+arr[l]+arr[r]>k)\\n                {\\n                   r--;\\n                    \\n                }\\n            }\\n            \\n        }\\n      \\n    }\\n    return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019809,
                "title": "c-detailed-explanation-3-sum-successor",
                "content": "First of all solve [two sum](https://leetcode.com/problems/two-sum/) & [3 sum](https://leetcode.com/problems/3sum/) , then you will get better idea to solve this problem and will be able to under my comments solution.\\n\\n### T = O(n^3) & S = O(1)\\n\\n```\\n vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       // T = O(n^3) & S = O(1)\\n        vector<vector<int>> res; // creating a result vector\\n        if(nums.empty()) { // If no element in given vector then empty vector iss returned\\n            return res;\\n        }\\n        int n = nums.size();  // size of given vector\\n        sort(nums.begin(), nums.end());  // sort the array in O(nlog(n)) for optimizing solution\\n        \\n        for(int i = 0; i < n; i++) {    // i pointer from 0 to n\\n            for(int j = i+1; j < n; j++) {  // j pointer from i+1 to n\\n                int rem = target - nums[i] - nums[j]; // remaining value to find\\n                int front = j+1;   // left pointer  just after j\\n                int back = n-1;    // right pointer at last index\\n                \\n                while(front < back) { // loop till front and back pointer donot cross over\\n                    int two_sum = nums[front] + nums[back]; // now come to two sum problem where we need to check for rem\\n                    if(two_sum < rem) front++;  // if(rem > two_sum) then logically we have to move front pointer ahead to increase value close to rem\\n                               \\n                    else if(two_sum > rem) back--; // if(rem < two_sum) then logically move back pointer to back to minimise value to come closer to rem value \\n                    \\n                    else {           // if (rem == two_sum) then we got the quadruplet (i, j, front, back indexed values)\\n                        vector<int> quadruplet(4, 0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[3] = nums[back];\\n                        res.push_back(quadruplet);\\n                        \\n                        // processing the duplicates of number 3\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n                        \\n                        // processing the duplicates of number 4\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n                // processing the duplicates of number 2\\n                while(j + 1 < n && nums[j + 1] == nums[j]) ++j;\\n            }\\n             // processing the duplicates of number 1\\n                while(i + 1 < n && nums[i + 1] == nums[i]) ++i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       // T = O(n^3) & S = O(1)\\n        vector<vector<int>> res; // creating a result vector\\n        if(nums.empty()) { // If no element in given vector then empty vector iss returned\\n            return res;\\n        }\\n        int n = nums.size();  // size of given vector\\n        sort(nums.begin(), nums.end());  // sort the array in O(nlog(n)) for optimizing solution\\n        \\n        for(int i = 0; i < n; i++) {    // i pointer from 0 to n\\n            for(int j = i+1; j < n; j++) {  // j pointer from i+1 to n\\n                int rem = target - nums[i] - nums[j]; // remaining value to find\\n                int front = j+1;   // left pointer  just after j\\n                int back = n-1;    // right pointer at last index\\n                \\n                while(front < back) { // loop till front and back pointer donot cross over\\n                    int two_sum = nums[front] + nums[back]; // now come to two sum problem where we need to check for rem\\n                    if(two_sum < rem) front++;  // if(rem > two_sum) then logically we have to move front pointer ahead to increase value close to rem\\n                               \\n                    else if(two_sum > rem) back--; // if(rem < two_sum) then logically move back pointer to back to minimise value to come closer to rem value \\n                    \\n                    else {           // if (rem == two_sum) then we got the quadruplet (i, j, front, back indexed values)\\n                        vector<int> quadruplet(4, 0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[3] = nums[back];\\n                        res.push_back(quadruplet);\\n                        \\n                        // processing the duplicates of number 3\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n                        \\n                        // processing the duplicates of number 4\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n                // processing the duplicates of number 2\\n                while(j + 1 < n && nums[j + 1] == nums[j]) ++j;\\n            }\\n             // processing the duplicates of number 1\\n                while(i + 1 < n && nums[i + 1] == nums[i]) ++i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850376,
                "title": "c-simple-easy-to-understand-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // T.C --> O(n^3) because n^2 for loop inside loop and n for 2 pointer technique  \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        if(n<4) return ans;\\n        // Sort the vector\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-3;++i) {\\n            for(int j=i+1;j<n-2;++j) {\\n                int target2 = target - (nums[i] + nums[j]);\\n                // 2_Sum for j+1 to n-1 or 2_pointer technique\\n                int left = j+1;\\n                int right = n-1;\\n                while(left < right) {\\n                    int sum = nums[left] + nums[right];\\n                    if(sum > target2) --right;\\n                    else if(sum < target2) ++left;\\n                    else {\\n                        vector<int> sub({ nums[i], nums[j], nums[left], nums[right] });\\n                        ans.push_back(sub);\\n                        // to avoid duplicates\\n                        while(left < right && nums[left] == sub[2]) ++left;\\n                        while(left < right && nums[right] == sub[3]) --right;\\n                    }\\n                }\\n                // to avoid duplicates\\n                while(j+1 < n && nums[j] == nums[j+1]) ++j;\\n            }\\n            // to avoid duplicates\\n            while(i+1 < n && nums[i] == nums[i+1]) ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // T.C --> O(n^3) because n^2 for loop inside loop and n for 2 pointer technique  \\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        if(n<4) return ans;\\n        // Sort the vector\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-3;++i) {\\n            for(int j=i+1;j<n-2;++j) {\\n                int target2 = target - (nums[i] + nums[j]);\\n                // 2_Sum for j+1 to n-1 or 2_pointer technique\\n                int left = j+1;\\n                int right = n-1;\\n                while(left < right) {\\n                    int sum = nums[left] + nums[right];\\n                    if(sum > target2) --right;\\n                    else if(sum < target2) ++left;\\n                    else {\\n                        vector<int> sub({ nums[i], nums[j], nums[left], nums[right] });\\n                        ans.push_back(sub);\\n                        // to avoid duplicates\\n                        while(left < right && nums[left] == sub[2]) ++left;\\n                        while(left < right && nums[right] == sub[3]) --right;\\n                    }\\n                }\\n                // to avoid duplicates\\n                while(j+1 < n && nums[j] == nums[j+1]) ++j;\\n            }\\n            // to avoid duplicates\\n            while(i+1 < n && nums[i] == nums[i+1]) ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577019,
                "title": "c-simple-o-n-2-solution-using-hashing-detailed-explanantion",
                "content": "```\\n/*\\n    https://leetcode.com/problems/4sum/\\n    \\n    Idea is to use a multi map to save the number pairs, if \\n    there exists a + b + c + d = target, then that means we will see 4 diff numbers.\\n    So we use two loops to pick a pair of numbers, initially when we had a and b, we look for target - (a+b)\\n    in the hash table, it might not be there, then push the current pair, so when we are at c and d and look\\n    for target - (c+d), that time we will get the (a,b) pair in the hash table. \\n    \\n    TC: O(N^2) + O(NlogN)\\n    SC: O(N)\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& arr, int target) {\\n        vector<vector<int>> result;\\n        multimap<int, pair<int, int>> mp;\\n        set<vector<int>> s;\\n\\n        for(int i = 0; i < arr.size(); i++) {\\n            for(int j = i + 1; j < arr.size(); j++) {\\n                // a + b = target - (c + d)\\n                // check if target - (c + d) exists in hash table\\n                int sum = arr[i] + arr[j];\\n                auto res = mp.equal_range(target - sum);\\n\\n                for(auto it = res.first; it != res.second; it++) {\\n                    int a = it->second.first;\\n                    int b = it->second.second;\\n                    \\n                    // check if the numbers are diff index wise also\\n                    if(a != i && a != j && b != i && b != j) {\\n                        vector<int> quadruplet = \\n                            {arr[a], arr[b], arr[i], arr[j]};\\n\\n                        sort(begin(quadruplet), end(quadruplet));\\n                        if(s.find(quadruplet) == s.end()) {\\n                            s.emplace(quadruplet);\\n                            result.emplace_back(move(quadruplet));\\n                        }\\n                    }\\n                }\\n                // insert the current pair\\n                mp.emplace(make_pair(sum, make_pair(i, j)));\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/4sum/\\n    \\n    Idea is to use a multi map to save the number pairs, if \\n    there exists a + b + c + d = target, then that means we will see 4 diff numbers.\\n    So we use two loops to pick a pair of numbers, initially when we had a and b, we look for target - (a+b)\\n    in the hash table, it might not be there, then push the current pair, so when we are at c and d and look\\n    for target - (c+d), that time we will get the (a,b) pair in the hash table. \\n    \\n    TC: O(N^2) + O(NlogN)\\n    SC: O(N)\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& arr, int target) {\\n        vector<vector<int>> result;\\n        multimap<int, pair<int, int>> mp;\\n        set<vector<int>> s;\\n\\n        for(int i = 0; i < arr.size(); i++) {\\n            for(int j = i + 1; j < arr.size(); j++) {\\n                // a + b = target - (c + d)\\n                // check if target - (c + d) exists in hash table\\n                int sum = arr[i] + arr[j];\\n                auto res = mp.equal_range(target - sum);\\n\\n                for(auto it = res.first; it != res.second; it++) {\\n                    int a = it->second.first;\\n                    int b = it->second.second;\\n                    \\n                    // check if the numbers are diff index wise also\\n                    if(a != i && a != j && b != i && b != j) {\\n                        vector<int> quadruplet = \\n                            {arr[a], arr[b], arr[i], arr[j]};\\n\\n                        sort(begin(quadruplet), end(quadruplet));\\n                        if(s.find(quadruplet) == s.end()) {\\n                            s.emplace(quadruplet);\\n                            result.emplace_back(move(quadruplet));\\n                        }\\n                    }\\n                }\\n                // insert the current pair\\n                mp.emplace(make_pair(sum, make_pair(i, j)));\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518661,
                "title": "ksum-java",
                "content": "My versions of kSum with list keep track of used elements\\n```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<> ();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<> ();\\n        kSum(nums, target, 4, result, list, 0);\\n        return result;\\n    }\\n    private void kSum(int[] nums, int target, int k, List<List<Integer>> result, List<Integer> list, int index) {\\n        if (k == 2) {\\n            int start = index;\\n            int end = nums.length - 1;\\n            while (start < end) {\\n                if (nums[start] + nums[end] == target) {\\n                    list.add(nums[start]);\\n                    list.add(nums[end]);\\n                    result.add(new ArrayList<> (list));\\n                    list.remove(list.size() - 1);\\n                    list.remove(list.size() - 1);\\n                    while (start < end && nums[start] == nums[start + 1]) {\\n                        start++;\\n                    }\\n                    start++;\\n                    while (start < end && nums[end] == nums[end - 1]) {\\n                        end--;\\n                    }\\n                    end--;\\n                } else if (nums[start] + nums[end] > target) {\\n                    end--;\\n                } else {\\n                    start++;\\n                }\\n            }\\n            return;\\n        }\\n        for (int i = index; i < nums.length; i++) {\\n            if (i == index || nums[i] != nums[i - 1]) {\\n                list.add(nums[i]);\\n                kSum(nums, target - nums[i], k - 1, result, list, i + 1);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<> ();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        Arrays.sort(nums);\\n        List<Integer> list = new ArrayList<> ();\\n        kSum(nums, target, 4, result, list, 0);\\n        return result;\\n    }\\n    private void kSum(int[] nums, int target, int k, List<List<Integer>> result, List<Integer> list, int index) {\\n        if (k == 2) {\\n            int start = index;\\n            int end = nums.length - 1;\\n            while (start < end) {\\n                if (nums[start] + nums[end] == target) {\\n                    list.add(nums[start]);\\n                    list.add(nums[end]);\\n                    result.add(new ArrayList<> (list));\\n                    list.remove(list.size() - 1);\\n                    list.remove(list.size() - 1);\\n                    while (start < end && nums[start] == nums[start + 1]) {\\n                        start++;\\n                    }\\n                    start++;\\n                    while (start < end && nums[end] == nums[end - 1]) {\\n                        end--;\\n                    }\\n                    end--;\\n                } else if (nums[start] + nums[end] > target) {\\n                    end--;\\n                } else {\\n                    start++;\\n                }\\n            }\\n            return;\\n        }\\n        for (int i = index; i < nums.length; i++) {\\n            if (i == index || nums[i] != nums[i - 1]) {\\n                list.add(nums[i]);\\n                kSum(nums, target - nums[i], k - 1, result, list, i + 1);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395655,
                "title": "java-dp-nsum-solution-65-in-time-and-100-in-memory",
                "content": "```\\n/*\\n\\t65% in time and 100% in memory.\\n\\t\\n    This is actually a solution for N Sum.\\n\\n    DP solution: Sort the array first. Recursion down to the twoSum level and \\n\\tget all solutions for every specific threeSum (scanning array from left to right).\\n\\t\\n\\tFor example, if you want all answers for threeSum, you need to know all twoSum answers for each condition.\\n\\tLet\\'s assume [n1, n2, n3] is one answer for the threeSum problem. \\n\\tOne condition (starting condition) could be n1 = nums[0], \\n\\tthen [n2, n3] will only be picked from index 1 to length-1. \\n\\tThen the next condition is n1 = nums[1], then all [n2, n3] solutions are from index 2 to length-1.\\n\\t\\n    Once you sovle all threeSum problem, then recursion back to do the same thing for fourSum, etc...\\n     */\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        // We want the answer of N Sum\\n        int N = 4;\\n\\n        // Filter out all impossible inputs\\n        if (nums.length < N) return new ArrayList<>();\\n\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        nSum(nums, target, 0, ans, N);\\n        return ans;\\n    }\\n    private void nSum(int[] nums, int target, int leftIndex, List<List<Integer>> ans, int n) {\\n        if (n > 2) {\\n            for (int i = leftIndex; i < nums.length-n+1; i++) {\\n\\t\\t\\t\\t// A bit performance improvement.\\n                // Just skip the iteration if the integer is same as the previous array item.\\n                if (i > leftIndex && nums[i] == nums[i-1]) continue;\\n\\t\\t\\t\\t\\n                nSum(nums, target-nums[i], i+1, ans, n-1);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// For example, if we are calculating fourSum and the line above this line produces answers for threeSum (the recursion call), which\\n\\t\\t\\t\\t// means some (only part of. the other part of the ans is found fourSum solutions) of the answers in the variable \"ans\" contains threeSums\\n\\t\\t\\t\\t// solutions.  This line is just adding the integer to those threeSum answers to assemble fourSum answers.\\n                for (List<Integer> lst : ans) if (lst.size() == n-1) lst.add(nums[i]);\\n            }\\n        } else _easyTwoSum(nums, target, leftIndex, ans);\\n    }\\n    private void _easyTwoSum(int[] nums, int target, int l, List<List<Integer>> ans) {\\n        int r = nums.length-1;\\n        int ol = l, or = r;\\n\\t\\t\\n\\t\\t// Moving two markers from two ends inwards until they meet.\\n        while (l < r) {\\n            if (nums[l] + nums[r] == target) {\\n                ans.add(new ArrayList<>(Arrays.asList(nums[l], nums[r])));\\n                l++;\\n                r--;\\n            } else {\\n                if (nums[l] + nums[r] > target) r--;\\n                else l++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// A bit performance gain.\\n\\t\\t\\t// Skip the iterations that have duplicated values in the array.\\n            while (l > ol && nums[l] == nums[l-1] && l < r) l++;\\n            while (r < or && nums[r] == nums[r+1] && l < r) r--;\\n        }\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\t65% in time and 100% in memory.\\n\\t\\n    This is actually a solution for N Sum.\\n\\n    DP solution: Sort the array first. Recursion down to the twoSum level and \\n\\tget all solutions for every specific threeSum (scanning array from left to right).\\n\\t\\n\\tFor example, if you want all answers for threeSum, you need to know all twoSum answers for each condition.\\n\\tLet\\'s assume [n1, n2, n3] is one answer for the threeSum problem. \\n\\tOne condition (starting condition) could be n1 = nums[0], \\n\\tthen [n2, n3] will only be picked from index 1 to length-1. \\n\\tThen the next condition is n1 = nums[1], then all [n2, n3] solutions are from index 2 to length-1.\\n\\t\\n    Once you sovle all threeSum problem, then recursion back to do the same thing for fourSum, etc...\\n     */\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        // We want the answer of N Sum\\n        int N = 4;\\n\\n        // Filter out all impossible inputs\\n        if (nums.length < N) return new ArrayList<>();\\n\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        nSum(nums, target, 0, ans, N);\\n        return ans;\\n    }\\n    private void nSum(int[] nums, int target, int leftIndex, List<List<Integer>> ans, int n) {\\n        if (n > 2) {\\n            for (int i = leftIndex; i < nums.length-n+1; i++) {\\n\\t\\t\\t\\t// A bit performance improvement.\\n                // Just skip the iteration if the integer is same as the previous array item.\\n                if (i > leftIndex && nums[i] == nums[i-1]) continue;\\n\\t\\t\\t\\t\\n                nSum(nums, target-nums[i], i+1, ans, n-1);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// For example, if we are calculating fourSum and the line above this line produces answers for threeSum (the recursion call), which\\n\\t\\t\\t\\t// means some (only part of. the other part of the ans is found fourSum solutions) of the answers in the variable \"ans\" contains threeSums\\n\\t\\t\\t\\t// solutions.  This line is just adding the integer to those threeSum answers to assemble fourSum answers.\\n                for (List<Integer> lst : ans) if (lst.size() == n-1) lst.add(nums[i]);\\n            }\\n        } else _easyTwoSum(nums, target, leftIndex, ans);\\n    }\\n    private void _easyTwoSum(int[] nums, int target, int l, List<List<Integer>> ans) {\\n        int r = nums.length-1;\\n        int ol = l, or = r;\\n\\t\\t\\n\\t\\t// Moving two markers from two ends inwards until they meet.\\n        while (l < r) {\\n            if (nums[l] + nums[r] == target) {\\n                ans.add(new ArrayList<>(Arrays.asList(nums[l], nums[r])));\\n                l++;\\n                r--;\\n            } else {\\n                if (nums[l] + nums[r] > target) r--;\\n                else l++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// A bit performance gain.\\n\\t\\t\\t// Skip the iterations that have duplicated values in the array.\\n            while (l > ol && nums[l] == nums[l-1] && l < r) l++;\\n            while (r < or && nums[r] == nums[r+1] && l < r) r--;\\n        }\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 370622,
                "title": "a-general-way-to-solve-x-sum-xsum",
                "content": "**\\u4E00\\u79CD\\u89E3\\u51B3XSum\\u7C7B\\u4F3C\\u7684\\u9898\\uFF08\\u5176\\u4E2DX\\u4E3A\\u4EFB\\u610F\\u5927\\u4E8E2\\u7684\\u6B63\\u6574\\u6570\\uFF09\\u7684\\u901A\\u7528\\u89E3\\u6CD5\\uFF1A**\\n```\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        // \\u6392\\u5E8F\\n        Arrays.sort(nums);\\n\\n        List<Integer> numsList = new ArrayList<>();\\n        for (int num : nums) {\\n            numsList.add(num);\\n        }\\n\\n        return findX(numsList, 4, target);\\n    }\\n\\n    /**\\n     * \\u4ECEsource\\u4E2D\\u627E\\u51FAsize\\u4E2A\\u6570\\uFF0C\\u4F7F\\u4E4B\\u548C\\u4E3Asum\\uFF0C\\u5E76\\u8FD4\\u56DE\\u6240\\u6709\\u7684\\u5E8F\\u5217\\uFF08\\u4E0D\\u91CD\\u590D\\uFF09\\n     *\\n     * @param source \\u5E8F\\u5217\\n     * @param size   \\u4E2A\\u6570\\n     * @param sum    \\u603B\\u548C\\n     */\\n    public List<List<Integer>> findX(List<Integer> source, int size, int sum) {\\n        List<List<Integer>> list = new ArrayList<>();\\n\\n        // \\u7528\\u4E8C\\u5206\\u6CD5\\u627E\\u5230\\u6240\\u9700\\u8981\\u7684\\u503C\\n        if (size == 1) {\\n            int leftIndex = 0;\\n            int rightIndex = source.size() - 1;\\n            while (rightIndex - leftIndex > 1) {\\n                int middleIndex = (leftIndex + rightIndex) / 2;\\n\\n                if (sum < source.get(middleIndex)) {\\n                    rightIndex = middleIndex;\\n                } else if (sum > source.get(middleIndex)) {\\n                    leftIndex = middleIndex;\\n                } else {\\n                    List<Integer> ans = new ArrayList<>();\\n                    ans.add(sum);\\n                    list.add(ans);\\n                    break;\\n                }\\n            }\\n\\n            // rightIndex - leftIndex == 1 \\u7684\\u60C5\\u51B5\\n            if (list.size() == 0) {\\n                if (sum == source.get(leftIndex) || sum == source.get(rightIndex)) {\\n                    List<Integer> ans = new ArrayList<>();\\n                    ans.add(sum);\\n                    list.add(ans);\\n                }\\n            }\\n\\n            return list;\\n        }\\n\\n        for (int i = 0; i < source.size() - size + 1; i++) {\\n            // \\u529B\\u6C42\\u4E0D\\u91CD\\u590D\\n            if (i > 0 && source.get(i).equals(source.get(i - 1))) {\\n                continue;\\n            }\\n\\n            int thisNum = source.get(i);\\n\\n            // \\u83B7\\u53D6\\u5269\\u4F59\\u90E8\\u5206\\u7684\\u5E8F\\u5217\\n            List<List<Integer>> tempList = findX(source.subList(i + 1, source.size()), size - 1, sum - thisNum);\\n\\n            // \\u62FC\\u4E0A\\u7B2C\\u4E00\\u4E2A\\u6570\\n            for (List<Integer> temp : tempList) {\\n                temp.add(0, thisNum);\\n                list.add(temp);\\n            }\\n        }\\n\\n        return list;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        // \\u6392\\u5E8F\\n        Arrays.sort(nums);\\n\\n        List<Integer> numsList = new ArrayList<>();\\n        for (int num : nums) {\\n            numsList.add(num);\\n        }\\n\\n        return findX(numsList, 4, target);\\n    }\\n\\n    /**\\n     * \\u4ECEsource\\u4E2D\\u627E\\u51FAsize\\u4E2A\\u6570\\uFF0C\\u4F7F\\u4E4B\\u548C\\u4E3Asum\\uFF0C\\u5E76\\u8FD4\\u56DE\\u6240\\u6709\\u7684\\u5E8F\\u5217\\uFF08\\u4E0D\\u91CD\\u590D\\uFF09\\n     *\\n     * @param source \\u5E8F\\u5217\\n     * @param size   \\u4E2A\\u6570\\n     * @param sum    \\u603B\\u548C\\n     */\\n    public List<List<Integer>> findX(List<Integer> source, int size, int sum) {\\n        List<List<Integer>> list = new ArrayList<>();\\n\\n        // \\u7528\\u4E8C\\u5206\\u6CD5\\u627E\\u5230\\u6240\\u9700\\u8981\\u7684\\u503C\\n        if (size == 1) {\\n            int leftIndex = 0;\\n            int rightIndex = source.size() - 1;\\n            while (rightIndex - leftIndex > 1) {\\n                int middleIndex = (leftIndex + rightIndex) / 2;\\n\\n                if (sum < source.get(middleIndex)) {\\n                    rightIndex = middleIndex;\\n                } else if (sum > source.get(middleIndex)) {\\n                    leftIndex = middleIndex;\\n                } else {\\n                    List<Integer> ans = new ArrayList<>();\\n                    ans.add(sum);\\n                    list.add(ans);\\n                    break;\\n                }\\n            }\\n\\n            // rightIndex - leftIndex == 1 \\u7684\\u60C5\\u51B5\\n            if (list.size() == 0) {\\n                if (sum == source.get(leftIndex) || sum == source.get(rightIndex)) {\\n                    List<Integer> ans = new ArrayList<>();\\n                    ans.add(sum);\\n                    list.add(ans);\\n                }\\n            }\\n\\n            return list;\\n        }\\n\\n        for (int i = 0; i < source.size() - size + 1; i++) {\\n            // \\u529B\\u6C42\\u4E0D\\u91CD\\u590D\\n            if (i > 0 && source.get(i).equals(source.get(i - 1))) {\\n                continue;\\n            }\\n\\n            int thisNum = source.get(i);\\n\\n            // \\u83B7\\u53D6\\u5269\\u4F59\\u90E8\\u5206\\u7684\\u5E8F\\u5217\\n            List<List<Integer>> tempList = findX(source.subList(i + 1, source.size()), size - 1, sum - thisNum);\\n\\n            // \\u62FC\\u4E0A\\u7B2C\\u4E00\\u4E2A\\u6570\\n            for (List<Integer> temp : tempList) {\\n                temp.add(0, thisNum);\\n                list.add(temp);\\n            }\\n        }\\n\\n        return list;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313867,
                "title": "java-solution-runtime-3-ms-faster-than-100-00-memory-usage-36-7-mb-less-than-99-95",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums == null || nums.length < 4) return res;\\n        Arrays.sort(nums);\\n        if (nums[0] + nums[1] + nums[2] + nums[3] > target ||\\n            nums[nums.length-1] + nums[nums.length-2] + nums[nums.length-3] + nums[nums.length-4] < target)\\n            return res;\\n        int len_3 = nums.length - 3;\\n        int len_2 = nums.length - 2;\\n        int len_1 = nums.length - 1;\\n        int last_i = nums[0] - 1;\\n        for (int i = 0; i < len_3; i++) {\\n            if (nums[i] == last_i) continue;\\n            last_i = nums[i];\\n            int last_j = last_i - 1;\\n            for (int j = i + 1; j < len_2; j++) {\\n                if (nums[j] == last_j) continue;\\n                last_j = nums[j];\\n                int innerTarget = target - last_i - last_j;\\n                if (nums[j+1] + nums[j+2] > innerTarget || nums[nums.length-1] + nums[nums.length-2] < innerTarget) continue;\\n                int left = j + 1, right = len_1;\\n                while (left < right) {\\n                    int innerSum = nums[left] + nums[right];\\n                    if (innerSum == innerTarget) {\\n                        res.add(Arrays.asList(last_i, last_j, nums[left], nums[right]));\\n                        left++;\\n                        right--;\\n                        while (nums[left] == nums[left-1] && left < right) left++;\\n                        while (nums[right] == nums[right+1] && left < right) right--;\\n                    } else if (innerSum < innerTarget) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\nIn addition to the conventional algorithm, the key points are in the 6th line and the 21st line.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (nums == null || nums.length < 4) return res;\\n        Arrays.sort(nums);\\n        if (nums[0] + nums[1] + nums[2] + nums[3] > target ||\\n            nums[nums.length-1] + nums[nums.length-2] + nums[nums.length-3] + nums[nums.length-4] < target)\\n            return res;\\n        int len_3 = nums.length - 3;\\n        int len_2 = nums.length - 2;\\n        int len_1 = nums.length - 1;\\n        int last_i = nums[0] - 1;\\n        for (int i = 0; i < len_3; i++) {\\n            if (nums[i] == last_i) continue;\\n            last_i = nums[i];\\n            int last_j = last_i - 1;\\n            for (int j = i + 1; j < len_2; j++) {\\n                if (nums[j] == last_j) continue;\\n                last_j = nums[j];\\n                int innerTarget = target - last_i - last_j;\\n                if (nums[j+1] + nums[j+2] > innerTarget || nums[nums.length-1] + nums[nums.length-2] < innerTarget) continue;\\n                int left = j + 1, right = len_1;\\n                while (left < right) {\\n                    int innerSum = nums[left] + nums[right];\\n                    if (innerSum == innerTarget) {\\n                        res.add(Arrays.asList(last_i, last_j, nums[left], nums[right]));\\n                        left++;\\n                        right--;\\n                        while (nums[left] == nums[left-1] && left < right) left++;\\n                        while (nums[right] == nums[right+1] && left < right) right--;\\n                    } else if (innerSum < innerTarget) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308118,
                "title": "java-3ms-pruning-solution-which-beats-100-with-explanation",
                "content": "The basic idea is turning 4Sum into 3Sum. In order to improve efficiency, there are some tricks to jump out of current traversal:\\n1. duplicate removal\\n2. current num is too small\\n3. current num is too large\\n\\nThe details are shown is the following code with comment:\\n\\n```\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n    Arrays.sort(nums);\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    for(int i = 0; i < nums.length - 3; i++) {\\n        if( i > 0 && nums[i] == nums[i - 1] ) // remove duplicate\\n            continue;\\n        if( nums[i] + 3 * nums[nums.length - 1] < target ) // current num is too small\\n            continue;\\n        if( nums[i] * 4 > target ) // current num is too large\\n            break;\\n        for(int j = i + 1; j < nums.length - 2; j++) {\\n            if( j > i + 1 && nums[j] == nums[j - 1] ) // duplicate removal\\n                continue;\\n            if( nums[i] + nums[j] + 2 * nums[nums.length - 1] < target ) // current num is too small\\n                continue;\\n            if( nums[i] + nums[j] * 3 > target ) // current num is too large\\n                break;\\n            int begin = j + 1, end = nums.length - 1;\\n            while( begin < end ) {\\n                int sum = nums[i] + nums[j] + nums[begin] + nums[end];\\n                if( sum > target ) \\n                    end--;\\n                else if( sum < target )\\n                    begin++;\\n                else if( sum == target ) {\\n                    if( begin == j + 1 || nums[begin] != nums[begin - 1] ) {\\n                        List<Integer> currentList = new ArrayList<Integer>();\\n                        currentList.add(nums[i]);\\n                        currentList.add(nums[j]);\\n                        currentList.add(nums[begin]);\\n                        currentList.add(nums[end]);\\n                        resultList.add(currentList);\\n                    }\\n                    begin++;\\n                    end--;\\n                }\\n            }\\n        }\\n    }\\n    return resultList;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<List<Integer>> fourSum(int[] nums, int target) {\\n    Arrays.sort(nums);\\n    List<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n    for(int i = 0; i < nums.length - 3; i++) {\\n        if( i > 0 && nums[i] == nums[i - 1] ) // remove duplicate\\n            continue;\\n        if( nums[i] + 3 * nums[nums.length - 1] < target ) // current num is too small\\n            continue;\\n        if( nums[i] * 4 > target ) // current num is too large\\n            break;\\n        for(int j = i + 1; j < nums.length - 2; j++) {\\n            if( j > i + 1 && nums[j] == nums[j - 1] ) // duplicate removal\\n                continue;\\n            if( nums[i] + nums[j] + 2 * nums[nums.length - 1] < target ) // current num is too small\\n                continue;\\n            if( nums[i] + nums[j] * 3 > target ) // current num is too large\\n                break;\\n            int begin = j + 1, end = nums.length - 1;\\n            while( begin < end ) {\\n                int sum = nums[i] + nums[j] + nums[begin] + nums[end];\\n                if( sum > target ) \\n                    end--;\\n                else if( sum < target )\\n                    begin++;\\n                else if( sum == target ) {\\n                    if( begin == j + 1 || nums[begin] != nums[begin - 1] ) {\\n                        List<Integer> currentList = new ArrayList<Integer>();\\n                        currentList.add(nums[i]);\\n                        currentList.add(nums[j]);\\n                        currentList.add(nums[begin]);\\n                        currentList.add(nums[end]);\\n                        resultList.add(currentList);\\n                    }\\n                    begin++;\\n                    end--;\\n                }\\n            }\\n        }\\n    }\\n    return resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8548,
                "title": "python-a-generalization-from-2sum-ad-3sum",
                "content": "```\\nclass Solution(object):\\n\\n    def fourSum(self,nums,target):\\n        solution2 = []\\n        solution3=[]\\n        solution = []\\n        nums.sort()\\n        for ai,a in enumerate(nums):\\n            if ai > 0 and a == nums[ai-1]:\\n                solution2 = self.two_some(nums[ai+1:],target-2*a,[a,a])\\n                if solution2:solution+=solution2\\n            else:\\n                solution3 = self.three_some(nums[ai+1:],target-a,[a])\\n                if solution3:solution+=solution3\\n        return solution\\n\\n    def three_some(self,nums,target,a):\\n        solution = []\\n        for idx,tgt in enumerate(nums):\\n            if idx>0 and nums[idx] == nums[idx-1]:continue\\n            path = {}\\n            vist = set()\\n            for i in xrange(idx+1,len(nums)):\\n                if nums[i] not in path:\\n                    path[target-tgt-nums[i]] = nums[i]\\n                elif nums[i] in path and nums[i] not in vist:\\n                    solution.append(a+[tgt,path[nums[i]],nums[i]])\\n                    vist.add(nums[i])\\n        return solution\\n\\n    def two_some(self,nums, target,b):\\n        path = {}\\n        solution = []\\n        for i in nums:\\n            if i in path:\\n                return solution.append(b+[path[i],i])\\n            else:\\n                path[target-i] = i\\n        return solution \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def fourSum(self,nums,target):\\n        solution2 = []\\n        solution3=[]\\n        solution = []\\n        nums.sort()\\n        for ai,a in enumerate(nums):\\n            if ai > 0 and a == nums[ai-1]:\\n                solution2 = self.two_some(nums[ai+1:],target-2*a,[a,a])\\n                if solution2:solution+=solution2\\n            else:\\n                solution3 = self.three_some(nums[ai+1:],target-a,[a])\\n                if solution3:solution+=solution3\\n        return solution\\n\\n    def three_some(self,nums,target,a):\\n        solution = []\\n        for idx,tgt in enumerate(nums):\\n            if idx>0 and nums[idx] == nums[idx-1]:continue\\n            path = {}\\n            vist = set()\\n            for i in xrange(idx+1,len(nums)):\\n                if nums[i] not in path:\\n                    path[target-tgt-nums[i]] = nums[i]\\n                elif nums[i] in path and nums[i] not in vist:\\n                    solution.append(a+[tgt,path[nums[i]],nums[i]])\\n                    vist.add(nums[i])\\n        return solution\\n\\n    def two_some(self,nums, target,b):\\n        path = {}\\n        solution = []\\n        for i in nums:\\n            if i in path:\\n                return solution.append(b+[path[i],i])\\n            else:\\n                path[target-i] = i\\n        return solution \\n```",
                "codeTag": "Java"
            },
            {
                "id": 8580,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& a, int target) {\\n        std::sort(a.begin(), a.end());\\n        set<vector<int>> set;\\n        for (int i = 0; i + 3 < a.size(); i++) {\\n            for (int j = i + 1; j + 2 < a.size(); j++) {\\n                for (int k = j + 1, l = a.size() - 1; k < l; ) {\\n                    int sum = a[i] + a[j] + a[k] + a[l];\\n                    if (sum == target) {\\n                        set.insert(vector<int>({ a[i], a[j], a[k], a[l] }));\\n                        k++;\\n                        l--;\\n                    }\\n                    else if (sum < target) {\\n                        k++;\\n                    }\\n                    else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> res;\\n        for (auto group : set) {\\n            res.push_back(group);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& a, int target) {\\n        std::sort(a.begin(), a.end());\\n        set<vector<int>> set;\\n        for (int i = 0; i + 3 < a.size(); i++) {\\n            for (int j = i + 1; j + 2 < a.size(); j++) {\\n                for (int k = j + 1, l = a.size() - 1; k < l; ) {\\n                    int sum = a[i] + a[j] + a[k] + a[l];\\n                    if (sum == target) {\\n                        set.insert(vector<int>({ a[i], a[j], a[k], a[l] }));\\n                        k++;\\n                        l--;\\n                    }\\n                    else if (sum < target) {\\n                        k++;\\n                    }\\n                    else {\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> res;\\n        for (auto group : set) {\\n            res.push_back(group);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8584,
                "title": "short-javascript-using-several-maps",
                "content": "```\\nvar fourSum = function(nums, target) {\\n    const counts = new Map();  // counts of elements in `nums`\\n    const aPlusB = new Map();  // sum tuples e.g. 5 => [[2, 3], [1, 4], ... ]\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        counts.set(nums[i], (counts.get(nums[i]) || 0) + 1);\\n        for (let j = i + 1; j < nums.length; j++) {\\n            let a = nums[i], b = nums[j];\\n            aPlusB.set(a + b, [...aPlusB.get(a + b) || [], [a, b]]);\\n        }\\n    }\\n    counts.set(nums[nums.length - 1], (counts.get(nums[nums.length - 1]) || 0) + 1);\\n    const res = new Set();  // Sets are unique, so no worries about duplicates\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            let c = nums[i], d = nums[j];\\n            if (!aPlusB.has(target - c - d)) continue;  // move on if wrong sum\\n            aPlusB.get(target - c - d)\\n                .forEach(ab => {\\n                    const abcd = [...ab, c, d];\\n                    if (!abcd.some(e => abcd.reduce((qty, a) => qty + (a === e), 0) > counts.get(e))) {\\n                        res.add(abcd.sort().join(','));\\n                    }\\n                });\\n        }\\n    }\\n    return [...res].map(abcd => abcd.split(',').map(e => parseInt(e)));\\n};\\n```\\nThis isn't particularly fast but gets the job done.\\n\\n1. Remember the `[a, b]` pairs keyed by their sum.\\n2. Find the `[c, d]` tuple which satisfies a + b + c + d = target.\\n3. If `nums` can supply the 4-tuple, add `[a, b, c, d]` to the unique set of results keyed by their sorted value.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fourSum = function(nums, target) {\\n    const counts = new Map();  // counts of elements in `nums`\\n    const aPlusB = new Map();  // sum tuples e.g. 5 => [[2, 3], [1, 4], ... ]\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        counts.set(nums[i], (counts.get(nums[i]) || 0) + 1);\\n        for (let j = i + 1; j < nums.length; j++) {\\n            let a = nums[i], b = nums[j];\\n            aPlusB.set(a + b, [...aPlusB.get(a + b) || [], [a, b]]);\\n        }\\n    }\\n    counts.set(nums[nums.length - 1], (counts.get(nums[nums.length - 1]) || 0) + 1);\\n    const res = new Set();  // Sets are unique, so no worries about duplicates\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            let c = nums[i], d = nums[j];\\n            if (!aPlusB.has(target - c - d)) continue;  // move on if wrong sum\\n            aPlusB.get(target - c - d)\\n                .forEach(ab => {\\n                    const abcd = [...ab, c, d];\\n                    if (!abcd.some(e => abcd.reduce((qty, a) => qty + (a === e), 0) > counts.get(e))) {\\n                        res.add(abcd.sort().join(','));\\n                    }\\n                });\\n        }\\n    }\\n    return [...res].map(abcd => abcd.split(',').map(e => parseInt(e)));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 8616,
                "title": "simple-java-solution-for-4-sum-3-sum-2-sum-any-sum",
                "content": "Any improvement is welcome.\\nUpdated: recursive stop at twoSum. Time Complexity of kSum is max( O(n^(k-1)), O(nlogn)).\\n```\\npublic class Solution {\\n    private List<List<Integer>> nSum(int[] nums, int start, int n, int target){\\n        List<List<Integer>> result = new LinkedList<>();\\n        // target is too small or too large so that there won't be solutions.\\n        if (target < nums[start]*n || target > nums[nums.length - 1]*n){\\n            return result;\\n        }\\n        \\n        for (int i = start, end = nums.length - n + 1; i < end; ++i){\\n            // avoid duplicated solutions\\n            if (i > start && nums[i - 1] == nums[i]){\\n                continue;\\n            }\\n\\n            if (n == 2){\\n                int required = target - nums[i];\\n                \\n                while(nums[end] > required){\\n                    end--;\\n                }\\n                if (nums[end] < required){\\n                    continue;\\n                }\\n                if (i >= end){\\n                    break;\\n                }\\n                \\n                // duplicated solution\\n                if (end + 1 < nums.length && nums[end+1] == nums[end]){\\n                    continue;\\n                }\\n                \\n                // get two sum\\n                result.add(new LinkedList<Integer>(Arrays.asList(nums[i], nums[end])));\\n                continue;\\n            }\\n            \\n            for (List<Integer> list : nSum(nums, i + 1, n - 1, target - nums[i])){\\n                list.add(nums[i]);\\n                result.add(list);\\n            }\\n            \\n        }\\n        return result;\\n    }\\n    \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if (nums.length == 0){\\n            return Arrays.asList();\\n        }\\n        Arrays.sort(nums);\\n        return nSum(nums, 0, 4, target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private List<List<Integer>> nSum(int[] nums, int start, int n, int target){\\n        List<List<Integer>> result = new LinkedList<>();\\n        // target is too small or too large so that there won't be solutions.\\n        if (target < nums[start]*n || target > nums[nums.length - 1]*n){\\n            return result;\\n        }\\n        \\n        for (int i = start, end = nums.length - n + 1; i < end; ++i){\\n            // avoid duplicated solutions\\n            if (i > start && nums[i - 1] == nums[i]){\\n                continue;\\n            }\\n\\n            if (n == 2){\\n                int required = target - nums[i];\\n                \\n                while(nums[end] > required){\\n                    end--;\\n                }\\n                if (nums[end] < required){\\n                    continue;\\n                }\\n                if (i >= end){\\n                    break;\\n                }\\n                \\n                // duplicated solution\\n                if (end + 1 < nums.length && nums[end+1] == nums[end]){\\n                    continue;\\n                }\\n                \\n                // get two sum\\n                result.add(new LinkedList<Integer>(Arrays.asList(nums[i], nums[end])));\\n                continue;\\n            }\\n            \\n            for (List<Integer> list : nSum(nums, i + 1, n - 1, target - nums[i])){\\n                list.add(nums[i]);\\n                result.add(list);\\n            }\\n            \\n        }\\n        return result;\\n    }\\n    \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if (nums.length == 0){\\n            return Arrays.asList();\\n        }\\n        Arrays.sort(nums);\\n        return nSum(nums, 0, 4, target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8692,
                "title": "python-beats-86-07-may-be-better",
                "content": "    class Solution(object):\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result=[]\\n        length=len(nums)\\n        nums.sort()\\n        for i in range(0,length-3):\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            if nums[i]*4>target:\\n                break\\n            for j in range(length-1,i+2,-1):\\n                if j!=length-1 and nums[j]==nums[j+1]:\\n                    continue\\n                if nums[j]*4<target:\\n                    break\\n                sub2=target-nums[i]-nums[j]\\n                low,high=i+1,j-1\\n                while low<high:\\n                    sum2=nums[low]+nums[high]\\n                    if sum2>sub2:\\n                        high-=1\\n                    elif sum2<sub2:\\n                        low+=1\\n                    else:\\n                        ans = [nums[i],nums[low],nums[high],nums[j]]\\n                        ans.sort()\\n                        result.append(ans)\\n                        while low<high and nums[low+1]==nums[low]:\\n                            low+=1\\n                        while low<high and nums[high-1]==nums[high]:\\n                            high-=1\\n                        high,low=high-1,low+1\\n        return result\\n                    \\nmake sure `nums[i]!=nums[i+1]` to avoid duplication and unnecessary computations<br>\\nand when`nums[i]*4 > target`,It'll be impossible to get another answer.<br>\\nand when `nums[j]*4 < target`,It should turn to next loop\\nmaybe in some situations:use`nums[i]+nums[i+1]+nums[i+2]+nums[i+3]`wil be better.I am just for convenience..",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def fourSum(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result=[]\\n        length=len(nums)\\n        nums.sort()\\n        for i in range(0,length-3):\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            if nums[i]*4>target:\\n                break\\n            for j in range(length-1,i+2,-1):\\n                if j!=length-1 and nums[j]==nums[j+1]:\\n                    continue\\n                if nums[j]*4<target:\\n                    break\\n                sub2=target-nums[i]-nums[j]\\n                low,high=i+1,j-1\\n                while low<high:\\n                    sum2=nums[low]+nums[high]\\n                    if sum2>sub2:\\n                        high-=1\\n                    elif sum2<sub2:\\n                        low+=1\\n                    else:\\n                        ans = [nums[i],nums[low],nums[high],nums[j]]\\n                        ans.sort()\\n                        result.append(ans)\\n                        while low<high and nums[low+1]==nums[low]:\\n                            low+=1\\n                        while low<high and nums[high-1]==nums[high]:\\n                            high-=1\\n                        high,low=high-1,low+1\\n        return result\\n                    \\nmake sure `nums[i]!=nums[i+1]` to avoid duplication and unnecessary computations<br>\\nand when`nums[i]*4 > target`,It'll be impossible to get another answer.<br>\\nand when `nums[j]*4 < target`,It should turn to next loop\\nmaybe in some situations:use`nums[i]+nums[i+1]+nums[i+2]+nums[i+3]`wil be better.I am just for convenience..",
                "codeTag": "Java"
            },
            {
                "id": 8700,
                "title": "easy-to-understand-java-solution-using-nsum",
                "content": "    public class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            return nSum(nums, 4, 0, target);\\n        }\\n        \\n        public List<List<Integer>> nSum(int[] nums, int n, int idx, int target) {\\n            if (n == 2) return twoSum(nums, idx, target);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            for (int i = idx; i <= nums.length - n; i++) {\\n                List<List<Integer>> temp = nSum(nums, n - 1, i + 1, target - nums[i]);\\n                for (List<Integer> l : temp) {\\n                    l.add(0, nums[i]);\\n                }\\n                result.addAll(temp);\\n                int t = nums[i];\\n                while (i <= nums.length - n && nums[i] == t) {\\n                    i++;\\n                }\\n                i--;\\n            }\\n            return result;\\n        }\\n        \\n        public List<List<Integer>> twoSum(int[] nums, int idx, int target) {\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            int ptr1 = idx, ptr2 = nums.length - 1;\\n            while (ptr1 < ptr2) {\\n                if (nums[ptr1] + nums[ptr2] == target) {\\n                    List<Integer> temp = new ArrayList<Integer>();\\n                    temp.add(nums[ptr1]);\\n                    temp.add(nums[ptr2]);\\n                    result.add(temp);\\n                    int t = nums[ptr1];\\n                    while (ptr1 < ptr2 && nums[ptr1] == t) {\\n                        ptr1++;\\n                    }\\n                } else if (nums[ptr1] + nums[ptr2] < target) {\\n                    ptr1++;\\n                } else {\\n                    ptr2--;\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> fourSum(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            return nSum(nums, 4, 0, target);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 8690,
                "title": "share-my-c-code-8ms-beats-100",
                "content": "add some condition to break or continue the loop by checking the maxinum and mininum.\\n\\n\\tint comp(const void* p, const void* q){ \\n\\t    return (*(int*) p - *(int*) q); \\n\\t}\\n\\n\\tint** fourSum(int* nums, int numsSize, int target, int* returnSize) {\\n\\t    if(nums ==NULL)\\treturn 0;\\n\\t    if(numsSize <4) return 0;\\n\\t    int **Ans = (int**)malloc(200*sizeof(int*));\\n\\t  \\tqsort(nums,numsSize,sizeof(int),comp);\\n\\t  \\tint a,b,c,d,count=0;;\\n\\t  \\tfor(a=0; a < numsSize-3;a++){\\n\\t  \\t\\t// check [a,x,x,x] mininum\\n\\t  \\t\\tif(nums[a]+nums[a+1]+nums[a+2]+nums[a+3]>target)\\t\\n\\t  \\t\\t\\tbreak;\\n\\t  \\t\\t// check [a,x,x,x] maxinum\\n\\t  \\t\\tif(nums[a]+nums[numsSize-3]+nums[numsSize-2]+nums[numsSize-1]<target)\\n\\t  \\t\\t\\tcontinue;\\n\\t  \\t\\tfor(b=a+1;b<numsSize-2;b++){\\n\\t  \\t\\t\\t// check [a,b,x,x] mininu\\n\\t  \\t\\t\\tif(nums[a]+nums[b]+nums[b+1]+nums[b+2]>target)\\n\\t  \\t\\t\\t\\tbreak;  \\t\\n\\t  \\t\\t\\t// check [a,b,x,x] maxinum\\t\\t\\t\\n\\t  \\t\\t\\tif(nums[a]+nums[b]+nums[numsSize-2]+nums[numsSize-1]<target)\\n\\t  \\t\\t\\t\\tcontinue;\\n\\t  \\t\\t\\tfor(c=b+1,d = (numsSize-1);c<d;){\\n\\t  \\t\\t\\t\\tif(nums[a]+nums[b]+nums[c]+nums[d]>target){\\n\\t  \\t\\t\\t\\t\\td--;\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t\\telse if(nums[a]+nums[b]+nums[c]+nums[d]<target){\\n\\t  \\t\\t\\t\\t\\tc++;\\n\\t  \\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tAns[count] = (int*)malloc(4*sizeof(int));\\n\\t\\t\\t\\t\\t\\tAns[count][0]=nums[a];\\n\\t\\t\\t\\t\\t\\tAns[count][1]=nums[b];\\n\\t\\t\\t\\t\\t\\tAns[count][2]=nums[c];\\n\\t\\t\\t\\t\\t\\tAns[count][3]=nums[d];\\n\\t\\t\\t\\t\\t\\twhile(c<d && Ans[count][2]==nums[c]) c++;\\t\\n\\t\\t\\t\\t\\t\\twhile(c<d && Ans[count][3]==nums[d]) d--;\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tif(count % 200 == 0)\\n\\t\\t\\t\\t\\t\\t    Ans = (int**)realloc(Ans,sizeof(int*)*(count+200));\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t}\\n\\t  \\t\\t\\twhile(b<numsSize-1 && nums[b+1] == nums[b]) b++;\\t\\n\\t  \\t\\t}\\n\\t  \\t\\twhile(a<numsSize-1 && nums[a+1] == nums[a]) a++;\\t\\t\\n\\t  \\t}\\n\\t  \\t*returnSize = count;\\n\\t  \\treturn (int**)realloc(Ans,sizeof(int*)*count);\\n\\t}",
                "solutionTags": [],
                "code": "add some condition to break or continue the loop by checking the maxinum and mininum.\\n\\n\\tint comp(const void* p, const void* q){ \\n\\t    return (*(int*) p - *(int*) q); \\n\\t}\\n\\n\\tint** fourSum(int* nums, int numsSize, int target, int* returnSize) {\\n\\t    if(nums ==NULL)\\treturn 0;\\n\\t    if(numsSize <4) return 0;\\n\\t    int **Ans = (int**)malloc(200*sizeof(int*));\\n\\t  \\tqsort(nums,numsSize,sizeof(int),comp);\\n\\t  \\tint a,b,c,d,count=0;;\\n\\t  \\tfor(a=0; a < numsSize-3;a++){\\n\\t  \\t\\t// check [a,x,x,x] mininum\\n\\t  \\t\\tif(nums[a]+nums[a+1]+nums[a+2]+nums[a+3]>target)\\t\\n\\t  \\t\\t\\tbreak;\\n\\t  \\t\\t// check [a,x,x,x] maxinum\\n\\t  \\t\\tif(nums[a]+nums[numsSize-3]+nums[numsSize-2]+nums[numsSize-1]<target)\\n\\t  \\t\\t\\tcontinue;\\n\\t  \\t\\tfor(b=a+1;b<numsSize-2;b++){\\n\\t  \\t\\t\\t// check [a,b,x,x] mininu\\n\\t  \\t\\t\\tif(nums[a]+nums[b]+nums[b+1]+nums[b+2]>target)\\n\\t  \\t\\t\\t\\tbreak;  \\t\\n\\t  \\t\\t\\t// check [a,b,x,x] maxinum\\t\\t\\t\\n\\t  \\t\\t\\tif(nums[a]+nums[b]+nums[numsSize-2]+nums[numsSize-1]<target)\\n\\t  \\t\\t\\t\\tcontinue;\\n\\t  \\t\\t\\tfor(c=b+1,d = (numsSize-1);c<d;){\\n\\t  \\t\\t\\t\\tif(nums[a]+nums[b]+nums[c]+nums[d]>target){\\n\\t  \\t\\t\\t\\t\\td--;\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t\\telse if(nums[a]+nums[b]+nums[c]+nums[d]<target){\\n\\t  \\t\\t\\t\\t\\tc++;\\n\\t  \\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tAns[count] = (int*)malloc(4*sizeof(int));\\n\\t\\t\\t\\t\\t\\tAns[count][0]=nums[a];\\n\\t\\t\\t\\t\\t\\tAns[count][1]=nums[b];\\n\\t\\t\\t\\t\\t\\tAns[count][2]=nums[c];\\n\\t\\t\\t\\t\\t\\tAns[count][3]=nums[d];\\n\\t\\t\\t\\t\\t\\twhile(c<d && Ans[count][2]==nums[c]) c++;\\t\\n\\t\\t\\t\\t\\t\\twhile(c<d && Ans[count][3]==nums[d]) d--;\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tif(count % 200 == 0)\\n\\t\\t\\t\\t\\t\\t    Ans = (int**)realloc(Ans,sizeof(int*)*(count+200));\\n\\t  \\t\\t\\t\\t}\\n\\t  \\t\\t\\t}\\n\\t  \\t\\t\\twhile(b<numsSize-1 && nums[b+1] == nums[b]) b++;\\t\\n\\t  \\t\\t}\\n\\t  \\t\\twhile(a<numsSize-1 && nums[a+1] == nums[a]) a++;\\t\\t\\n\\t  \\t}\\n\\t  \\t*returnSize = count;\\n\\t  \\treturn (int**)realloc(Ans,sizeof(int*)*count);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 8738,
                "title": "my-concise-c-solution-based-on-3sum",
                "content": "     vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size()<=3) return vector<vector<int>>();\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-3;i++){\\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            for(int j=i+1;j<nums.size()-2;j++){\\n                if(j>i+1 && nums[j]==nums[j-1]) continue;\\n                int k=j+1;\\n                int l=nums.size()-1;\\n                while(k<l){\\n                    if(k>j+1 && nums[k]==nums[k-1]){ k++; continue;}\\n                    if(l<nums.size()-1 && nums[l]==nums[l+1]){ l--; continue;}\\n                    int val=nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(val==target){\\n                        res.push_back(vector<int>{nums[i],nums[j],nums[k],nums[l]});\\n                        k++;\\n                        l--;\\n                    }\\n                    else if(val<target)\\n                        k++;\\n                    else\\n                        l--;\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size()<=3) return vector<vector<int>>();\\n        vector<vector<int>> res;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-3;i++){\\n            if(i>0 && nums[i]==nums[i-1]) continue;\\n            for(int j=i+1;j<nums.size()-2;j++){\\n                if(j>i+1 && nums[j]==nums[j-1]) continue;\\n                int k=j+1;\\n                int l=nums.size()-1;\\n                while(k<l){\\n                    if(k>j+1 && nums[k]==nums[k-1]){ k++; continue;}\\n                    if(l<nums.size()-1 && nums[l]==nums[l+1]){ l--; continue;}\\n                    int val=nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(val==target){\\n                        res.push_back(vector<int>{nums[i],nums[j],nums[k],nums[l]});\\n                        k++;\\n                        l--;\\n                    }\\n                    else if(val<target)\\n                        k++;\\n                    else\\n                        l--;\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 8601,
                "title": "share-my-ac-o-n2-python-solution",
                "content": "1: Create the sum for each pair, like this: [sum,list_of_pairs]\\n\\n2; sort the pairs by key.\\n\\n3: find the match condition pairs, and filter them out.\\n\\n\\n\\n    def fourSum(self, num, target):\\n        num=sorted(num);\\n        sum2={}\\n        for i in range(len(num)):\\n            for j in range(i+1,len(num)):\\n                sumij=num[i]+num[j];\\n                if(sumij not in sum2):\\n                    sum2[sumij]=[];\\n                sum2[sumij].append((i,j));\\n        sum2 = sorted(sum2.items(), key=lambda x:x[0])\\n        \\n        res=set();\\n        i,j=0,len(sum2)-1;\\n        while(i<=j):\\n            total=sum2[i][0]+sum2[j][0];\\n            if(total==target):\\n                for k1 in range(len(sum2[i][1])):\\n                    for k2 in range(len(sum2[j][1])):\\n                        a,b=sum2[i][1][k1];\\n                        c,d=sum2[j][1][k2];\\n                        items= set([a,b,c,d]);\\n                        if(len(items)==4):\\n                            newItem=[num[fi] for fi in items];\\n                            newItem=tuple(sorted(newItem));\\n                            res.add((newItem));\\n                i+=1;\\n                j-=1;\\n            elif(total<target):\\n                i+=1;\\n            else:\\n                j-=1;\\n\\n        resNums= [];\\n        for item in res:\\n            resNums.append([i for i in item]);\\n        return resNums;",
                "solutionTags": [
                    "Python"
                ],
                "code": "1: Create the sum for each pair, like this: [sum,list_of_pairs]\\n\\n2; sort the pairs by key.\\n\\n3: find the match condition pairs, and filter them out.\\n\\n\\n\\n    def fourSum(self, num, target):\\n        num=sorted(num);\\n        sum2={}\\n        for i in range(len(num)):\\n            for j in range(i+1,len(num)):\\n                sumij=num[i]+num[j];\\n                if(sumij not in sum2):\\n                    sum2[sumij]=[];\\n                sum2[sumij].append((i,j));\\n        sum2 = sorted(sum2.items(), key=lambda x:x[0])\\n        \\n        res=set();\\n        i,j=0,len(sum2)-1;\\n        while(i<=j):\\n            total=sum2[i][0]+sum2[j][0];\\n            if(total==target):\\n                for k1 in range(len(sum2[i][1])):\\n                    for k2 in range(len(sum2[j][1])):\\n                        a,b=sum2[i][1][k1];\\n                        c,d=sum2[j][1][k2];\\n                        items= set([a,b,c,d]);\\n                        if(len(items)==4):\\n                            newItem=[num[fi] for fi in items];\\n                            newItem=tuple(sorted(newItem));\\n                            res.add((newItem));\\n                i+=1;\\n                j-=1;\\n            elif(total<target):\\n                i+=1;\\n            else:\\n                j-=1;\\n\\n        resNums= [];\\n        for item in res:\\n            resNums.append([i for i in item]);\\n        return resNums;",
                "codeTag": "Python3"
            },
            {
                "id": 3716167,
                "title": "4sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                l = j+1\\n                r = len(nums)-1\\n                while l<r:\\n                    if nums[i] + nums[j] + nums[l] + nums[r]<target:\\n                        l+=1\\n                    elif nums[i] + nums[j] + nums[l] + nums[r]>target:\\n                        r-=1\\n                    elif nums[i] + nums[j] + nums[l] + nums[r]==target:\\n                        s.add((nums[i],nums[j],nums[l],nums[r]))\\n                        l+=1\\n                        r-=1\\n        return list(s)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        s = set()\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                l = j+1\\n                r = len(nums)-1\\n                while l<r:\\n                    if nums[i] + nums[j] + nums[l] + nums[r]<target:\\n                        l+=1\\n                    elif nums[i] + nums[j] + nums[l] + nums[r]>target:\\n                        r-=1\\n                    elif nums[i] + nums[j] + nums[l] + nums[r]==target:\\n                        s.add((nums[i],nums[j],nums[l],nums[r]))\\n                        l+=1\\n                        r-=1\\n        return list(s)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661494,
                "title": "c-2-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i>0 && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            for(int j=i+1;j<n;j++){\\n                if(j>i+1 && nums[j]==nums[j-1]){\\n                    continue;\\n                }\\n                int k = j+1;\\n                int l = n-1;\\n                while(k<l){\\n                    long long sum = nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n                    if(sum==target){\\n                        vector<int>res = {nums[i],nums[j],nums[k],nums[l]};\\n                        ans.push_back(res);\\n                        k++;\\n                        l--;\\n                        while(k<l && nums[k]==nums[k-1]){\\n                            k++;\\n                        }while(k<l && nums[l]==nums[l+1]){\\n                            l--;\\n                        }\\n                    }else if(sum<target){\\n                        k++;\\n                    }else{\\n                        l--;\\n                    }\\n                }\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i>0 && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            for(int j=i+1;j<n;j++){\\n                if(j>i+1 && nums[j]==nums[j-1]){\\n                    continue;\\n                }\\n                int k = j+1;\\n                int l = n-1;\\n                while(k<l){\\n                    long long sum = nums[i];\\n                    sum+=nums[j];\\n                    sum+=nums[k];\\n                    sum+=nums[l];\\n                    if(sum==target){\\n                        vector<int>res = {nums[i],nums[j],nums[k],nums[l]};\\n                        ans.push_back(res);\\n                        k++;\\n                        l--;\\n                        while(k<l && nums[k]==nums[k-1]){\\n                            k++;\\n                        }while(k<l && nums[l]==nums[l+1]){\\n                            l--;\\n                        }\\n                    }else if(sum<target){\\n                        k++;\\n                    }else{\\n                        l--;\\n                    }\\n                }\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633185,
                "title": "o-n-n-n-c-solution-without-map-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        for(int i=0; i<n; i++){\\n            if(i && nums[i] == nums[i-1]) continue;\\n            for(int j=i+1; j<n; j++){\\n                if(j>i+1 && nums[j] == nums[j-1]) continue;\\n                int k = j+1, l = n-1;\\n                while(k<l){\\n                    long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];\\n                    if(sum == target) ans.push_back({nums[i], nums[j], nums[k], nums[l]});\\n                    if(sum <= target){\\n                        int temp = nums[k];\\n                        while(k < n && nums[k] == temp) k++;\\n                    }\\n                    else{\\n                        int temp = nums[l];\\n                        while(l>=0 && nums[l] == temp) l--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        for(int i=0; i<n; i++){\\n            if(i && nums[i] == nums[i-1]) continue;\\n            for(int j=i+1; j<n; j++){\\n                if(j>i+1 && nums[j] == nums[j-1]) continue;\\n                int k = j+1, l = n-1;\\n                while(k<l){\\n                    long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];\\n                    if(sum == target) ans.push_back({nums[i], nums[j], nums[k], nums[l]});\\n                    if(sum <= target){\\n                        int temp = nums[k];\\n                        while(k < n && nums[k] == temp) k++;\\n                    }\\n                    else{\\n                        int temp = nums[l];\\n                        while(l>=0 && nums[l] == temp) l--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615198,
                "title": "o-n-3-c-solution-easy-to-understand-3-approaches",
                "content": "### BRUTE FORCE :\\n\\nRun 4 loops to traverse each element and if it equals sum store into ans. One thing to take care of is that it should not contain duplicates so for this purpose we make use of set but in a set we also need to keep the elements in a specific order to check for duplicates for ex 1 2 3 4 and 3 1 2 4 are both same quads but will be treated distinct by set thus we sort these quads and then store in a set to remove duplicates.\\n\\nAt last we create our ans vector and copy all the elements of the set.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       set<vector<int>> s;\\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=i+1;j<n;j++)\\n           {\\n               for(int k=j+1;k<n;k++)\\n               {\\n                   for(int l=k+1;l<n;l++)\\n                   {\\n                       long long sum=nums[i]+nums[j];\\n                       sum+=nums[k];\\n                       sum+=nums[l];\\n                       if(sum==target)\\n                       {\\n                           vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                           sort(temp.begin(),temp.end());\\n                           s.insert(temp);\\n                       }\\n                   }\\n               }\\n           }\\n       } \\n       vector<vector<int>> ans(s.begin(),s.end());\\n       return ans;\\n    }\\n};\\n```\\n\\n- Time Complexity : O(N^4)\\n- Space Complexity : O(2 * no. of the quadruplets) as we are using a set data structure and a list to store the quads.\\n\\n### Better Approach :\\n\\nWe will use 3loops now instead of 4 and use a hashset to find the fourth element. We need to find all unique combination so we need the elem at i,j,k but to find 4th element we check in the hashset whether the elem is present or not if it is not present then we add nums[k] into the ahshset and then move k in this fashion numbers between j and k will be stored in hashset uniquely and we can find a combination that gives the target without requiring 4th loop here j and k works as window start and end to find a variable.\\n\\nbefore k loop hashset must be defined because as j moves a new window will be formed.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       set<vector<int>> s;\\n       \\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=i+1;j<n;j++)\\n           {\\n               set<long long> hash;\\n               for(int k=j+1;k<n;k++)\\n               {\\n                   \\n                       long long sum=nums[i]+nums[j];\\n                       sum+=nums[k];\\n                       long long remains=target-sum;\\n                       if(hash.find(remains)!=hash.end())\\n                       {\\n                           vector<int> temp={nums[i],nums[j],nums[k],(int)remains};\\n                           sort(temp.begin(),temp.end());\\n                           s.insert(temp);\\n                       }\\n                       hash.insert(nums[k]);\\n                   \\n               }\\n           }\\n       } \\n       vector<vector<int>> ans(s.begin(),s.end());\\n       return ans;\\n    }\\n};\\n```\\n\\n- Time Complexity : O(N^3 log (M)) M is unique elements stored in hashset.\\n- Space Complexity : O(2 * no. of the quadruplets)+O(N)\\n\\n**Reason:**\\n\\nwe are using a set data structure and a list to store the quads. This results in the first term. And the second space is taken by the set data structure we are using to store the array elements. At most, the set can contain approximately all the array elements and so the space complexity is O(N).\\n\\n### Optimal Approach :\\n\\nWe now use two pointer approach initially we sort the array and keep i and j positions as fixed then we use two pointer to keep track of sum if sum is equal then we include it in ans and if it is less we move k pointer and if it is greater we shift l pointer to left. To deal with duplicate values we will make a comparison inside each loop whenever i>0 this means i is not at 0h position we need to check whether the previous elem that i was pointing to is the same element value that i is currently pointing to if yes then we continue the loop until i find a new value same goes for j but j>i+1 now for k and l when we have found sum==target then we need to shift both k and l k++ and l\\u2014 but what if they both again point to the same element value as previous for this we need to add a while loop for k and l as well to continue incrementing and decrementing value of k and l respectively until a new value is found also k<l should always be satisfied during these iterations.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       sort(nums.begin(),nums.end());\\n       vector<vector<int>> ans;\\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           if(i>0 && nums[i]==nums[i-1]) continue;\\n           for(int j=i+1;j<n;j++)\\n           {\\n               if(j>i+1 && nums[j]==nums[j-1]) continue;\\n               int k=j+1;\\n               int l=n-1;\\n               while(k<l)\\n               {\\n                   long long sum=nums[i]+nums[j];\\n                   sum+=nums[k];\\n                   sum+=nums[l];\\n                   if(sum==target)\\n                   {\\n                       vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                       ans.push_back(temp);\\n                       k++;l--;\\n                       while(k<l && nums[k]==nums[k-1]) k++;\\n                       while(k<l && nums[l]==nums[l+1]) l--;\\n                   }\\n                   else if(sum<target)\\n                        k++;\\n                   else\\n                        l--;\\n               }\\n               \\n           }\\n       } \\n       return ans;\\n    }\\n};\\n```\\n- Time Complexity : O(N^3) + O(NlogN)\\n\\nEach of the pointers i and j, is running for approximately N times. And both the pointers k and l combined can run for approximately N times including the operation of skipping duplicates. So the total time complexity will be O(N3). NlogN is for sorting the array.\\n\\n- Space Complexity : O(no. of quadruplets),\\xA0***This space is only used to store the answer. We are not using any extra space to solve this problem.***\\xA0So, from that perspective, space complexity can be written as O(1).\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       set<vector<int>> s;\\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=i+1;j<n;j++)\\n           {\\n               for(int k=j+1;k<n;k++)\\n               {\\n                   for(int l=k+1;l<n;l++)\\n                   {\\n                       long long sum=nums[i]+nums[j];\\n                       sum+=nums[k];\\n                       sum+=nums[l];\\n                       if(sum==target)\\n                       {\\n                           vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                           sort(temp.begin(),temp.end());\\n                           s.insert(temp);\\n                       }\\n                   }\\n               }\\n           }\\n       } \\n       vector<vector<int>> ans(s.begin(),s.end());\\n       return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       set<vector<int>> s;\\n       \\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=i+1;j<n;j++)\\n           {\\n               set<long long> hash;\\n               for(int k=j+1;k<n;k++)\\n               {\\n                   \\n                       long long sum=nums[i]+nums[j];\\n                       sum+=nums[k];\\n                       long long remains=target-sum;\\n                       if(hash.find(remains)!=hash.end())\\n                       {\\n                           vector<int> temp={nums[i],nums[j],nums[k],(int)remains};\\n                           sort(temp.begin(),temp.end());\\n                           s.insert(temp);\\n                       }\\n                       hash.insert(nums[k]);\\n                   \\n               }\\n           }\\n       } \\n       vector<vector<int>> ans(s.begin(),s.end());\\n       return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n       sort(nums.begin(),nums.end());\\n       vector<vector<int>> ans;\\n       int n=nums.size();\\n       for(int i=0;i<n;i++)\\n       {\\n           if(i>0 && nums[i]==nums[i-1]) continue;\\n           for(int j=i+1;j<n;j++)\\n           {\\n               if(j>i+1 && nums[j]==nums[j-1]) continue;\\n               int k=j+1;\\n               int l=n-1;\\n               while(k<l)\\n               {\\n                   long long sum=nums[i]+nums[j];\\n                   sum+=nums[k];\\n                   sum+=nums[l];\\n                   if(sum==target)\\n                   {\\n                       vector<int> temp={nums[i],nums[j],nums[k],nums[l]};\\n                       ans.push_back(temp);\\n                       k++;l--;\\n                       while(k<l && nums[k]==nums[k-1]) k++;\\n                       while(k<l && nums[l]==nums[l+1]) l--;\\n                   }\\n                   else if(sum<target)\\n                        k++;\\n                   else\\n                        l--;\\n               }\\n               \\n           }\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444947,
                "title": "solving-the-4sum-problem-on-leetcode-a-step-by-step-guide",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to fix two indices i and j in the input array and use two pointers left and right to find all possible pairs of elements nums[k] and nums[l] such that nums[i] + nums[j] + nums[k] + nums[l] = target.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter handling the base case we move to main solution part.\\n\\nTo do this, we\\'ll first sort the input array in ascending order. This allows us to easily eliminate duplicates and move the pointers left and right based on the sum of the four elements.\\n\\nWe\\'ll loop over all possible pairs of i and j, then use the two pointers left and right to find all possible pairs of k and l that add up to the target. We\\'ll increment left if the sum of the four elements is less than the target, and decrement right if the sum is greater than the target.\\n\\nIf the sum of the four elements is equal to the target, we add the quadruplet [nums[i], nums[j], nums[k], nums[l]] to a set to eliminate duplicates.\\n\\nOnce we\\'ve looped over all possible quadruplets, we\\'ll convert the set to a list and return it. That\\'s it! We done with this problem\\n**\\n***if u are confused y i used loops till n-3 and n-2 so, here is explaination for that too:*****\\n\\nwe use n-3 and n-2 as the upper bounds because we need at least 4 elements to form a valid quadruplet.\\n\\nBy starting the first loop at 0 and going up to n-3, we ensure that we have at least 3 elements after the current index to form a quadruplet.\\n\\nSimilarly, by starting the second loop at i+1 and going up to n-2, we ensure that we have at least 2 elements after the current index to form a quadruplet with the current element.\\n\\nIf we used <n as the upper bound in these loops, we would be considering all possible combinations of 4 or more elements in the input array, including those that don\\'t form a valid quadruplet. This would lead to unnecessary computation and longer running time.\\n\\nTherefore, using n-3 and n-2 as the upper bounds is a more efficient way to iterate over all possible quadruplets in the input array.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n^3), since we use nested loops to iterate over all possible quadruplets. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), since we use a set to store unique quadruplets.\\n\\n\\n****Hope this helps! Let me know if you have any questions.**\\n**\\n\\n********DO UPVOTE!** **\\n**Peace Out:)******\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n           set<vector<int>> s;\\n        vector<vector<int>> ans;\\n        \\n        if (nums.size()<4) {\\n            return ans;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        for (int i=0; i<n-3; i++) {\\n            for (int j=i+1; j<n-2; j++) {\\n                int low = j+1;\\n                int high = n-1;\\n                \\n                while (low<high) {\\n                  long long sum = (long long)nums[i] + nums[j] + nums[low] + nums[high];                    \\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[low], nums[high]});\\n                        low++;\\n                        high--;\\n                    }\\n                    else if (sum<target) {\\n                        low++;\\n                    }\\n                    else {\\n                        high--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (auto x : s) {\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n           set<vector<int>> s;\\n        vector<vector<int>> ans;\\n        \\n        if (nums.size()<4) {\\n            return ans;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        for (int i=0; i<n-3; i++) {\\n            for (int j=i+1; j<n-2; j++) {\\n                int low = j+1;\\n                int high = n-1;\\n                \\n                while (low<high) {\\n                  long long sum = (long long)nums[i] + nums[j] + nums[low] + nums[high];                    \\n                    if (sum == target) {\\n                        s.insert({nums[i], nums[j], nums[low], nums[high]});\\n                        low++;\\n                        high--;\\n                    }\\n                    else if (sum<target) {\\n                        low++;\\n                    }\\n                    else {\\n                        high--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (auto x : s) {\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569729,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1564576,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1643461,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1576905,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569477,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1565074,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569530,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1570712,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1565936,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1576376,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569729,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1564576,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1643461,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1576905,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569477,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1565074,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1569530,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1570712,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1565936,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1576376,
                "content": [
                    {
                        "username": "Swapnil510",
                        "content": "This problem should be in Hard category"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Some people say their solutions are O(n<sup>2</sup> log n) or even O(n<sup>2</sup>), but...\\n\\nConsider cases where nums is the n numbers from 1 to n.  \\n=> There are \\u0398(n<sup>4</sup>) different quadruplets (nC4, to be exact, so about n<sup>4</sup> / 24).  \\n=> There are \\u0398(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums).  \\n=> At least one sum must have \\u03a9(n<sup>3</sup>) different quadruplets.  \\n=> For that sum, we must generate those \\u03a9(n<sup>3</sup>) quadruplets.  \\n=> **For these cases we have to do \\u03a9(n<sup>3</sup>) work.**\\n=> **O(n<sup>2</sup> log n) or even O(n<sup>2</sup>) are impossible.**\\n\\n(I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.)"
                    },
                    {
                        "username": "olivierkessler",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) yes but how do you populate your hashtable ? wouldn\\'t you have O(n**2) just to populate the table ?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@ZimoSyndrome](/ZimoSyndrome) Just tried this stuff in C++ with STL unordered_map. Shows awful 73ms and 32 Mb of memory usage vs 12ms / 13-15Mb used by top O(n^3) solutions. Usage of multimap dropped it to 48ms / 28.4 Mb, which is far from perfect anyway.\\nI guess the point is that for a given target sum you have to walk through all combinations comprising that sum, exactly as the top level comment states, and in addition to O(n^3) calculations it becomes O(n^2) memory with all the computational overhead to initialize/copy/free etc."
                    },
                    {
                        "username": "ZimoSyndrome",
                        "content": "O(n^2) time is possible.\\n\\nBy breaking down this problem into 2Sum through finding corresponding elements through iterating over all triplets. This will take O(n^3) time. However, by using a Hash table or a set we can iterate over all pairs of elements and check if there exists two other elements that sum up to the target value. Minimum time complexity is hence O(n^2)"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "but...\\n\\n \\u03A9(n\\xB2) time is easily possible, since the overwhelming majority of possible input sets will not have the property of having a great many different pairs generating a single pair-sum. Only those data sets that consist of a regular list of equally spaced integers with a target that is the sum of the lowest two and the highest two will reach O(n\\xB3). Any more realistic data set would not be that regular, and is far more likely to have 0 to 10 solutions than the upper bound of 208617 solutions - and these majority of cases will closely approach n\\xB2 time if the algorithm can do it."
                    },
                    {
                        "username": "thejavamentor",
                        "content": "For test nums= [2,2,2,2,2] with target = 8.\\nI think this would have nC4 = 5 different answers, as indexes are different for each answer. \\n\\nOutput in my case is:\\n[\\n[2,2,2,2], indexes are like [0,1,2,3]\\n[2,2,2,2], indexes are like [0,1,2,4]\\n[2,2,2,2], indexes are like [0,1,3,4]\\n[2,2,2,2], indexes are like [0,2,3,4]\\n[2,2,2,2], indexes are like [1,2,3,4]\\n]\\n\\nDo we need to consider unique values along with unique indexes?\\n\\n"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "only one 2,2,2,2 is valid since the answers must be unique (1,2,3,4 is same as 2,3,1,4 etc). the extra 2 doesn\\'t give permission to repeat the 2,2,2,2 answer. numbers within the solution can repeat if there are that many of that number in the set since the numbers within a solution must be distinct, but not unique."
                    },
                    {
                        "username": "sandip93291",
                        "content": "I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution link\\nhttps://leetcode.com/submissions/detail/723679975/"
                    },
                    {
                        "username": "rayaan_khan",
                        "content": "long long tempsum = static_cast<long long>(target)-static_cast<long long>(a)-static_cast<long long>(b);\\n\\nlong long t = static_cast<long long>(nums[idx1])+static_cast<long long>(nums[idx2]);\\n\\nthis helped me"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "The sum of four large integers can exceed the maximum value that an \"int\" can hold, causing overflow and resulting in incorrect comparisons.\\nif you change sum to \"long\" instead of \"int\" the code will work fine."
                    },
                    {
                        "username": "Hengul",
                        "content": "my solution is pretty much similar... but it\\'s showing signed integer overflow..."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "[@pranjal300](/pranjal300) thanks \\ngot the correct answer :)"
                    },
                    {
                        "username": "pranjal300",
                        "content": " if((long)nums[a]+(long)nums[i]+(long)nums[j]+(long)nums[k]>Integer.MAX_VALUE)\n                   return result;\n               \nto handle integer overflow"
                    },
                    {
                        "username": "allpass",
                        "content": "[@rag_ji_3006](/rag_ji_3006) integer overflow. just change the target to long can solve."
                    },
                    {
                        "username": "vanshjagyas",
                        "content": "Hey, I solved this error by putting a condition that if(abs(large_number)>INT_MAX) then skip ahead. Solution Link:- https://leetcode.com/problems/4sum/submissions/860636707/"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "I was getting the same Please try long sum = (long)nums[i] + (long)(nums[j]) + (long)(nums[k]) + (long)(nums[m]);"
                    },
                    {
                        "username": "kairatovalmat2003",
                        "content": "[@rag_ji_3006](/rag_ji_3006) i think it is because limit of int type so in goes to the beginning of this int type"
                    },
                    {
                        "username": "magicianabesh123",
                        "content": "use :                       long long sum = (long long )nums[i] + nums[j] + nums[left] + nums[right];\\n"
                    },
                    {
                        "username": "rag_ji_3006",
                        "content": "same situation. I don\\'t understand this test case! How is the addition of 4 positive number a negative number?"
                    },
                    {
                        "username": "uiopuiop",
                        "content": "I have solved many questions now and this question\\'s hardness is similar to other question marked as Hard.\\n \\n Can some moderator please review this and check if it should be marked as Hard?"
                    },
                    {
                        "username": "kevincr",
                        "content": "I got \"Output Limit Exceeded\" error, what does it mean? Thanks."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "2014"
                    },
                    {
                        "username": "user0727se",
                        "content": "[@bj-jiwrajka](/bj-jiwrajka) He replied on 23rd june and you are replying on june 28th"
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "[@iamadit](/iamadit) He replied in Oct,2022 and now you\\'re replying him  in Jun 2023"
                    },
                    {
                        "username": "iamadit",
                        "content": "[@thejavamentor](/thejavamentor)  \\nHe ask question in 2014, and you gave answer in 2022 now he very well , why this is come "
                    },
                    {
                        "username": "thejavamentor",
                        "content": "This meant if you print statement, that you should remove it."
                    },
                    {
                        "username": "alok5",
                        "content": "This should be a hard question to generalize to k sum"
                    },
                    {
                        "username": "tlorance",
                        "content": "The specifications of this problem require that \"a, b, c, and d are distinct\", which most people would interpret to mean \"unique\", \"not equal in value\"; however, their test case accepts results with duplicate values for one or more of the four values."
                    },
                    {
                        "username": "warblegarble",
                        "content": "a,b,c,d are indices, not values"
                    },
                    {
                        "username": "lemac",
                        "content": "After read past discusses about the 4Sum problem, I think there isn't a O(n^2logn) or better solution.\\n\\nFirst of all, here is some discuss about k-sum problem\\nhttp://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem\\nWe can find that \\nFor even k:  exits algorithm runs in O(n^(k/2)logn) time.\\nFor odd k: exits algorithm runs in O(n^((k+1)/2)) time.\\nBut if you read these two papers: \"Lower bounds for linear degeneracy testing\" and \"Lower bounds for linear satisfiability problems\" you can see that the problem discussed in these papers is just to determine whether exist k numbers sum to target or not. But here we aim to find all combinations of the suitable k numbers. It is different.\\n\\nSecond, for these solutions claimed to be O(n^2logn) or better, the computation of time complexity I think is not complete. Mainly two solutions:\\n\\nSolution 1: \\n\\n1) Use hash like map<int, vector<pair<int, int>>> to store all sums of two number and the indexes of the two number.\\n2) Scan the hash map for each key_i, if target-key_i is in the map, \\n3) then scan the index pair list of key_i and target-key_i and if four indexes are different, get 1 combination. \\n\\nThe size of the map is O(n^2). But for each key, the size of pair list is O(n). So we cannot simply think the time complexity is O(n^2).\\n\\nSolution 2:\\n\\n1)Use array like vector<pair<int, pair<int, int>>> to store all sums of two number and the indexes of the two number. The size of the array is O(n^2).\\n2)Sort the array, cost time O(n^2logn)\\n3)Use two points walk the array and find if sum[i]+sum[j]==target and the indexes of sum[i],sum[j] are all different, just look like 2Sum problem. Cost time O(n^2)\\n\\nBut we cannot simply walk the array one time like 2Sum. For example array={(10, (1,9)), (10, (2,8)), (10, (3,7)), (10, (4,6)), (10, (5,5))}, target=20. if just walk once, some combinations will miss."
                    },
                    {
                        "username": "raccoonious",
                        "content": "[EDIT] **unique** quadruplets is the reason why it should not be outputted. Thanks for mentioning pointing this out\\n\\n[ORIGINAL]\\nIf we have input of [-2,-1,0,0,3] I don\\'t understand why we should not be outputting [-2, -1, 0, 3] twice. The question states...\\n\\n*Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:*\\n* 0 <= a, b, c, d < n\\n* a, b, c, and d are distinct.\\n* nums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nc that satisfies nums[c] = 0 is c=2, c=3. In this example, it is different from a, b, d (a=0, b=1, d=4) and is distinct. Could someone please explain this?\\n\\nSummary: solution of {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement above. Yet the \"correct solution\" as indicated by running the input in the console does not reflect this."
                    },
                    {
                        "username": "Vithesh",
                        "content": "They also want it in sorted way. So this means they should be unique in order to avoid duplicate sequence."
                    },
                    {
                        "username": "nihalbaranwal",
                        "content": "The question says \\'unique quadruplets\\' i.e., all the quadruplets should be unique, though {a=0, b=1, c=2, d=4} and {a=0, b=1, c=3, d=4} satisfies the requirement of having distinct a,b,c and d but it doesn\\'t satisfy the rule that all the quadruplets should be different.\\nI hope it made sense"
                    }
                ]
            },
            {
                "id": 1568214,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1871117,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1576606,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 2014354,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1568836,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1996655,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1978288,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1576834,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1576650,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1575179,
                "content": [
                    {
                        "username": "gzrjzcx",
                        "content": "Is anyone using C solve this problem? \\nI really not understand the meaning of argument `int **returnColumnSizes`.\\nWho can explain this for me?  \\n\\nIn fact, I think it is unnessessary, I can only return `int **result` because it is 4sum, lenght of each array is 4 right? However, it is a runtime error if I only return  `int **result`(it has been malloced)."
                    },
                    {
                        "username": "holzhey",
                        "content": "I can\\'t submit. Result is:\\n`292 / 292 testcases passed`\\nBut i get:\\n`Time Limit Exceeded`\\nHow can that be possible? Also, the \"Last Executed Input\" is:\\n`nums = `\\nWhich does not make sense and/or explain which test is causing the time out."
                    },
                    {
                        "username": "Achraf_Jarrar",
                        "content": "Same, I think it\\'s because we need to solve it having a \" not catastrophic complexity\" , Mine is , O(n^(4))"
                    },
                    {
                        "username": "WhiteShadow1337",
                        "content": "I\\'m confused about the first example which appears to violate the first constraint.\\n\\nFirst constraint:\\n0 <= a, b, c, d < n\\n\\nFirst example:\\nInput: nums = [1,0,-1,0,-2,2], target = 0\\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\\n\\nThere are numbers in the output violate both bounds of the constraint (it is unsatisfiable). (0 <= a, b, c, d < 0)\\nWhat am I missing?"
                    },
                    {
                        "username": "vishalj026",
                        "content": "a,b,c, and d are indices, not the numbers themselves."
                    },
                    {
                        "username": "bruce_wayne16",
                        "content": "questions like these make me question my existence in dsa world T_T"
                    },
                    {
                        "username": "eaglesky",
                        "content": "I've seen so many solutions which claim to have O(n^2logn) time complexity. However all of them have three-layer loop, which obviously not O(n^2logn). None of the authors have actually proved the time complexity of their solutions. I was hoping someone could give me a solution of time complexity O(n^2logn) and prove it. \\n\\nThanks!"
                    },
                    {
                        "username": "qiren96",
                        "content": "who give this test case?\\n\\n[1000000000,1000000000,1000000000,1000000000]\\n\\n-294967296\\n\\ngive you 1000000000 dislikes and -294967296 likes :("
                    },
                    {
                        "username": "niclim65",
                        "content": "I passed 293/293 but had TLE. what"
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-"
                    },
                    {
                        "username": "shubhamsinghrajput",
                        "content": "**https://leetcode.com/discuss/study-guide/1154632/C%2B%2B-STL-powerful-guide-or-Compiled-list-of-popular-STL-operations/*"
                    }
                ]
            },
            {
                "id": 1571047,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 1568837,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 1576306,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 1571883,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2070353,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2069020,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2061755,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2060509,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2045743,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2045583,
                "content": [
                    {
                        "username": "singku",
                        "content": "4 sum, with input [-3,-2,-1, 0,0,1,2,3] \\n\\nShall (-3,0,1,2), (-3,0,1,2)  be duplicated entries?  The two zeros are different"
                    },
                    {
                        "username": "nirvanaforu",
                        "content": "for all the 3pointer/4pointer approach, I feel it's not easy to generalize that approach to address the general question like 'kSum'. Any suggestions?"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/4sum-problem-leetcode-python-solutions/"
                    },
                    {
                        "username": "rachitpant",
                        "content": "Found an intersting solution here:\\nhttps://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/"
                    },
                    {
                        "username": "vedanshagrawal",
                        "content": "Damn\\n"
                    },
                    {
                        "username": "nithinchepuri",
                        "content": "class Solution {\\npublic: \\n    void logic(vector<int>&nums,int index,long long target,vector<int>&p, set<vector<int>>&s,int n){\\n        // if(p.size()>4)return ;\\n        if(index==n||p.size()==4 ){\\n            if(p.size()==4 && target==0){\\n                s.insert(p);    \\n            }\\n            \\n            return;\\n        }\\n        p.push_back(nums[index]);\\n        logic(nums,index+1,target-nums[index],p,s,n);\\n        p.pop_back();\\n        logic(nums,index+1,target,p,s,n);\\n    }\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result;\\n        int n= nums.size();\\n        if(n<4)return result;\\n\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]==nums[n-1]){\\n            if(target!=0 && nums[0]!=0 && target%nums[0]==0){\\n                int q = target/nums[0];\\n                vector<int>v(q,nums[0]);\\n                result.push_back(v);\\n    \\n            }\\n            else if(nums[0]==0 && target==0){\\n                result.push_back({0,0,0,0});\\n            }\\n            return result;\\n        }\\n        set <vector<int>> s;\\n        vector<int>p;\\n        logic(nums,0,target,p,s,n);\\n        for(auto m:s){\\n            result.push_back(m);\\n        }\\n        return result;\\n    }\\n};\\n\\n\\nCode passed for all test cases but it shows Time Limited Exceeded.\\nAny one please tell me the reason and possible modification?"
                    },
                    {
                        "username": "Androw77",
                        "content": "This can be solved the same as 3 Sum just add one more for loop. But the test cases might be higher than Integer.MAX_VALUE so use long instead of int on ur sum"
                    },
                    {
                        "username": "lumiatorstuff",
                        "content": "For similar testCase : [0,0,0,-1000000000,-1000000000,-1000000000,-1000000000]\nUSE :\nlong sum  = (long) A + B + C + D;"
                    },
                    {
                        "username": "Limon020",
                        "content": "3sum with an extra step"
                    },
                    {
                        "username": "pankajj_",
                        "content": "\\'\\'\\'nums = [-3,-1,0,2,4,5]\\ntarget = 1\\nOutput\\n[[-3,-1,0,5],[-3,0,0,4],[-1,0,0,2]]\\nExpected\\n[[-3,-1,0,5]]\\'\\'\\'.\\n\\nI think my code is giving the right answer, there are more than one quadruplets and its returning all of them , what\\'s the problem in this ?"
                    }
                ]
            },
            {
                "id": 2043272,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 2041575,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 2032562,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 2017943,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1991619,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1983044,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1973054,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1971678,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1971642,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1968387,
                "content": [
                    {
                        "username": "entitled_american",
                        "content": "I eagerly await 5Sum. "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I submitted an answer about 3-4 months ago that ran with 56 mb of memory. Now, the exact same code runs with 123 mb. What\\'s up with that?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I\\'m tired with the edge testcases :(("
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Hint PS!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "The simple approach used here is Two pointer & Jumping the duplicates. \\nUse two loops that start from i = 0 and j = i+1, then declare two pointers low & high where low = j+1 and high = n-1 \\nTraverse and match the condition, if condition holds true, push the elements into vector, then jump the duplicates elements. \\n\\nThis is a brief hint, to see this approach you can view my solution in Solution tab "
                    },
                    {
                        "username": "IDurgeshShukla",
                        "content": "In this question it is mentioned that nums[i] <= 10^9 but still in some of the test cases they have given nums beyond this range [0,0,0,1000000000,1000000000,1000000000,1000000000] this is one of the test case"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "I don't think this testcase goes beyond the constraints. It's still in range"
                    },
                    {
                        "username": "dpw82",
                        "content": "I have a map set to a list of the index and what the value is at that index to try to make sure it is unique. I am confused as to how to proceed at this point.\n `\nif(target - nums[i] + nums[j] + nums[k] == map.contains(??????)){\n                        subset.add(map.get(i))\n                        ans.add(new ArrayList<>(subset};\n}\n\n`"
                    },
                    {
                        "username": "countdankula",
                        "content": "Python. Here you Go\\n\\n        nums.sort()\\n\\n        res = []\\n        n = len(nums)\\n\\n        for i in range(n):\\n\\n            if i > 0 and nums[i - 1] == nums[i]:\\n                continue\\n\\n            for j in range(i + 1, n):\\n\\n                if j > i + 1 and nums[j - 1] == nums[j]:\\n                    continue\\n\\n                l = j + 1\\n                r = n - 1\\n\\n                while l < r:\\n                    Sum = nums[i] + nums[j] + nums[l] + nums[r]\\n\\n                    if Sum < target:\\n                        l += 1\\n                    elif Sum > target:\\n                        r -= 1\\n                    else:\\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\\n                        \\n                        l += 1\\n                        while l < r and nums[l - 1] == nums[l]:\\n                            l += 1\\n\\n        return res"
                    },
                    {
                        "username": "vladboj",
                        "content": "Any idea why my code doesn\\'t work and I get integer overflow? From what I\\'ve found, long long should be sufficient for my numbers. I get overflow for [1000000000,1000000000,1000000000,1000000000].\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        if(nums.size() < 4) return {};\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        int a, b, c, d;\\n        for(a = 0; a < nums.size() - 3; a++) {\\n            while(a > 0 && nums[a] == nums[a - 1]) a++; \\n            for(b = a + 1; b < nums.size() - 2; b++) {\\n                while(b > a + 1 && nums[b] == nums[b - 1]) b++; \\n                c = b + 1;\\n                d = nums.size() - 1;\\n                while(c < d) {\\n                    long long sum = nums[a] + nums[b] + nums[c] + nums[d];\\n                    if(sum == target) {\\n                        ans.push_back({nums[a], nums[b], nums[c], nums[d]});\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                    else if(sum < target) {\\n                        c++;\\n                        while(c < nums.size() - 1 && nums[c] == nums[c - 1]) c++;\\n                    }\\n                    else {\\n                        d--;\\n                        while(d > 2 && nums[d] == nums[d + 1]) d--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\t\\t}\\n```"
                    },
                    {
                        "username": "nadohs",
                        "content": "it says \"a, b, c, and d are distinct.\"\\nbut if then a, b, c, d can be the same numbers what does this even mean????\\n"
                    },
                    {
                        "username": "amansinghrajpoot",
                        "content": "distinct means at different places \\nnums[a] + nums[b] + nums[c] + nums[d] == target\\na, b, c, d are different index but nums[b] can be = 1 and nums[d] = 1. "
                    }
                ]
            },
            {
                "id": 1966221,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1963190,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1959734,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1957460,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1951675,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1947853,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1938894,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1938526,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1932441,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1930318,
                "content": [
                    {
                        "username": "vivan_19",
                        "content": "K-Sum should be marked as hard, wasn\\'t able to get it with the K-Sum without the editorial."
                    },
                    {
                        "username": "zep3152",
                        "content": "I know the classical answer with two pointers entails nested loop, but I am just thinking IF it is possible to do a triple pointer so that the time complexity can be reduce?"
                    },
                    {
                        "username": "han-keong",
                        "content": "The idea behind using two pointers is to sort the input array and select elements from each side moving inwards. Excluding the sorting step which is O(nlogn), the two pointer search itself is O(n), which is as good as it gets. I don\\u2019t know how a third pointer can improve that."
                    },
                    {
                        "username": "mahsankhan024",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length < 4) {\\n            return result;\\n    }\\n    Arrays.sort(nums);\\n\\n        int n = nums.length;\\n        for (int i = 0; i < n - 3; i++) {\\n            // Skip duplicate values\\n            if (i > 0 && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n\\n            for (int j = i + 1; j < n - 2; j++) {\\n                // Skip duplicate values\\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\\n                    continue;\\n                }\\n\\n                int left = j + 1;\\n                int right = n - 1;\\n\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n\\n                        // Skip duplicate values\\n                        while (left < right && nums[left] == nums[left + 1]) {\\n                            left++;\\n                        }\\n                        while (left < right && nums[right] == nums[right - 1]) {\\n                            right--;\\n                        }\\n\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = {1, 0, -1, 0, -2, 2};\\n        int target = 0;\\n\\n        Solution solution = new Solution();\\n        List<List<Integer>> result = solution.fourSum(nums, target);\\n\\n        System.out.println(result);\\n    }\\n}"
                    },
                    {
                        "username": "sayakbasak842",
                        "content": "why the name is sus?"
                    },
                    {
                        "username": "navneetdubey2002",
                        "content": "what should be return if we have nums length less than 3 what should we return in answer"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "Then the empty ans_arr should be returned. "
                    },
                    {
                        "username": "bj-jiwrajka",
                        "content": "I can\\'t submit. Result is:\\n293 / 293 testcases passed\\nBut I m getting Time Limit Exceeded\\nAlso, the \"Last Executed Input\" is: nums =\\n"
                    },
                    {
                        "username": "rajesh_chandela",
                        "content": "if test case stop due to integer overflow then concider this \\u2B50\\uFE0F\\n\\n\\nlong sum = static_cast<long>(nums[i]) + static_cast<long>(nums[j]) + static_cast<long>(nums[k]) + static_cast<long>(nums[l]); \\n\\nwe can see that individual nums are   almonst going out of intiger limit \\nso using static_cast them to long can solve the proble "
                    },
                    {
                        "username": "whybhanu",
                        "content": "Someone explain why this test case is not passing, 290/292 test cases passed. [1000000000,1000000000,1000000000,1000000000]\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList();\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        if(nums.length < 4 || nums == null) return result;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++){\\n            if(i == 0 || nums[i] != nums[i - 1]){\\n                for(int j = i + 1; j < nums.length; j++){\\n                    int a = nums[i];\\n                    int b = nums[j];\\n                    if(j == i + 1 || nums[j - 1] != nums[j]){\\n                        twoSum(nums, j + 1, target - a - b, a, b);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    void twoSum(int[] nums, int index, int target, int first, int second){\\n        int start = index;\\n        int end = nums.length - 1;\\n        while(start < end){\\n            long a = nums[start] + nums[end] + first + second;\\n            if(a > Integer.MAX_VALUE || a < Integer.MIN_VALUE) continue;\\n            ArrayList<Integer> list = new ArrayList<>();\\n            if(nums[start] + nums[end] < target){\\n                start++;\\n            } else if(nums[start] + nums[end] > target){\\n                end--;\\n            } else{\\n                list.add(first);\\n                list.add(second);\\n                list.add(nums[start]);\\n                list.add(nums[end]);\\n                result.add(list);\\n                while(start < end && nums[start] == nums[start + 1]) start++;\\n                while(start < end && nums[end] == nums[end - 1]) end--;\\n                start++;\\n                end--;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type\\nit is even possible that the sum may exceed the bit limit of int data type\\nso,use long data type."
                    },
                    {
                        "username": "han-keong",
                        "content": "How I did it was to use two nested loops for the first two numbers, and a two-pointer search in the inner loop for the last two numbers. I managed to optimize my solution using a few techniques such as skipping duplicates, applying early termination conditions, and utilizing remainders. Check out my [post](https://leetcode.com/problems/4sum/solutions/3646410/optimized-4sum-solution-by-skipping-duplicates-early-termination-and-utilizing-remainders/) for more details."
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "analyse the code with your own example step by step you will get algorithm."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "I'm a bit surprised with the following test case\n```[1000000000,1000000000,1000000000,1000000000] -294967296```\n\nI have the following code:\n```\nint localTarget = target - nums[a] - nums[b];\nint sum = nums[lo] + nums[hi];\n...\nif (sum == localTarget) {\n...\n}\n```\nI know about integer overlap, but I'm surprised because on my local machine `2000000000` <> `-1705032704`. Why it's `true` on leetcode?  "
                    },
                    {
                        "username": "Kusi_Hemanth",
                        "content": "you used the int data type \\nit is even possible that the sum may exceed the bit limit of int data type \\nso,use long data type."
                    }
                ]
            },
            {
                "id": 1913615,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1908688,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1901515,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1897797,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1875014,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1874752,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1874583,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1853364,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1853054,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1850059,
                "content": [
                    {
                        "username": "yale3450",
                        "content": "Not the kinda 4sum I want to do"
                    },
                    {
                        "username": "Shoaib88",
                        "content": "5sum coming soon......\\n"
                    },
                    {
                        "username": "valaz",
                        "content": "Hint: \\nYou can preprocess initial array.\\nBeacuse you don\\'t need more than 4 equals numbers in it.\\nIt could be done by O(n).\\n\\n"
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\\na, b, c, and d are distinct.\\nnums[a] + nums[b] + nums[c] + nums[d] == target\\n\\nin the instructions a,b,c,d are indices, not values.\\n\\n\\nExample 2:\\n\\nInput: nums = [2,2,2,2,2], target = 8\\nOutput: [[2,2,2,2]]\\n\\nIn this example this would be 5 choose 4, which would be more than 1 result.\\n\\nso a,b,c,d are values.....not indices."
                    },
                    {
                        "username": "xecuti431",
                        "content": "How can the numbers be distinct if one of the examples is literally an array of four 2's?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "I used recursion and it is giving TLE on test case 216;\\ncan any one help me with DP tabulation approach."
                    },
                    {
                        "username": "user2748pU",
                        "content": "Is anyone else\\'s last testcase on submission just empty and always times out?\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000] \\ntarget =\\n-294967296\\nthis test case not work using set"
                    },
                    {
                        "username": "Narasimha-png",
                        "content": "nums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\nOutput\\n[[1000000000,1000000000,1000000000,1000000000]]\\nExpected\\n[]\\n\\ni am  getting wrong\\n\\n\\nmy code\\n\\n\\nclass Solution {\\n  \\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n       Arrays.sort(nums);\\n       List<List<Integer>> res=new ArrayList<>();\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n               long t=target-(nums[i]+nums[j]);\\n               int start=j+1;\\n               int end=nums.length-1;\\n               while(start<end){\\n                   long te=nums[start]+nums[end];\\n                   if(te<t)\\n                   start+=1;\\n                   else if(te>t)\\n                   end-=1;\\n                   else{\\n                       List temp=new ArrayList<Integer>();\\n                       temp.add(nums[i]);\\n                       temp.add(nums[j]);\\n                       temp.add(nums[start]);\\n                       temp.add(nums[end]);\\n                       res.add(temp);\\n                       while(start<end&&nums[start]==(int)temp.get(2))start++;\\n                       while(start<end&&nums[end]==(int)temp.get(3))end--;\\n                   }\\n\\n               }\\n               while(j+1<nums.length&&nums[j+1]==nums[j])\\n               j++;\\n           }\\n           while(i+1<nums.length&&nums[i+1]==nums[i])\\n               i++;\\n       }\\n       return res;\\n        \\n    }\\n}\\n\\n\\n [@Stefan Pochmann](/StefanPochmann)\\n [@Sandip Yadav](/sandip93291)"
                    },
                    {
                        "username": "ericocarina1987",
                        "content": "var fourSum = function(nums, target) {\\n    let result = [];\\n    for(let i = 0;i < nums.length-3; i++){\\n        for(let j = i+1;j < nums.length-2; j++){\\n         for(let k = j+1;k < nums.length-1; k++){\\n         for(let l = k+1;l < nums.length; l++){\\n        if(nums[i] + nums[j] + nums[k] + nums[l]===target){\\n          let ele = [nums[i],nums[j],nums[k],nums[l]]\\n          if(result.every(e => e !== ele)) result.push(ele)\\n    }\\n    }\\n    }\\n    }\\n    }\\n    return result;\\n};\\n\\ncant figure out witch part is wrong"
                    }
                ]
            },
            {
                "id": 1849938,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1842157,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1836635,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1835733,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1830666,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1820115,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1813309,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1809982,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1807714,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1805487,
                "content": [
                    {
                        "username": "DVNama",
                        "content": "\\ncan someone please tell where i am getting wrong in this code\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> v;\\n     int n=nums.size();\\n     sort(nums.begin(),nums.end());\\n     for(int i=0;i<n-3;i++){\\n         int j=i+1;\\n         for(int k=n-1;k>j;k--)  {\\n         int l=k-1;\\n         while(j<l){\\n             int sum=nums[i]+nums[j]+nums[k]+nums[l];\\n             if(sum==target){\\n                 s.insert({nums[i],nums[j],nums[k],nums[l]});\\n                 l--;\\n                 j++;\\n             }\\n             else if(sum>target){\\n                 l--;                \\n             }\\n             else{\\n                 j++;\\n             }\\n         }\\n     }\\n   }\\n   for(auto m:s)\\n    v.push_back(m);   \\n     return v;\\n    }\\n};"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "Can Anyone Tell me How can i optimize this \\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        matrix = []\\n        temp_list = []\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    for m in range(k+1,len(nums)):\\n                        if nums[i]+nums[j]+nums[k]+nums[m] == target:\\n                            matrix.append([nums[i],nums[j],nums[k],nums[m]])\\n        \\n        unique_matrix = list({tuple(sorted(row)): row for row in matrix}.values())\\n        return unique_matrix\\n        "
                    },
                    {
                        "username": "Ayush10web",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\nThis is my solution in Java :) Someone plss help \\n `My inline code.....`\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length - 3; i++) {\\n            // Skip duplicates\\n            if (i > 0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            for (int j = i+1; j < nums.length - 2; j++) {\\n                // Skip duplicates\\n                if (j > i+1 && nums[j] == nums[j-1]) {\\n                    continue;\\n                }\\n                int left = j+1, right = nums.length-1;\\n                while (left < right) {\\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\\n                    if (sum == target) {\\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\\n                        // Skip duplicates\\n                        while (left < right && nums[left] == nums[left+1]) left++;\\n                        while (left < right && nums[right] == nums[right-1]) right--;\\n                        left++;\\n                        right--;\\n                    } else if (sum < target) {\\n                        left++;\\n                    } else {\\n                        right--;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "klaca",
                        "content": "adding 3 times 10^9 results in signed integer overflow\nFor example int sum = nums[i] + nums[j] + nums[left] + nums[right]; results in 4x10^9 and that is higher than the maximum positive value of type int\nFind a way around it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "I used subsequence algorithm and it is not efficient at all.\\nI used recursion here and Time complexity is over 2^n and that is the worst time complexity and im really stupid."
                    },
                    {
                        "username": "AdityaBharat",
                        "content": "It is not Medium \\uD83E\\uDD37\\u200D\\u2640\\uFE0F , else i am dumb"
                    },
                    {
                        "username": "sanz_29",
                        "content": "long long int target_2 = target_3 - num[j];\\n\\nIt was saying that the target overflowed in the data-type INT but then I tried using LONG LONG INT for the sake of getting a long integer as a target but it seems like that is not working either. Anybody can help me ?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s the step-by-step approach for solving this problem:\\n\\nStep 1: Sort the input array in non-decreasing order.\\n\\nSorting the array helps us in finding the solution because it allows us to use two nested loops to fix two elements and use binary search to find the other two elements that would complete the quadruplet.\\n\\nStep 2: Iterate through the array with two outer loops for the first two elements and two inner loops for the remaining two elements.\\n\\nWe can use two outer loops to fix the first two elements of the quadruplet and then use two inner loops to iterate over the remaining elements of the array. This allows us to consider all possible combinations of four elements in the array.\\n\\nStep 3: Skip the duplicates by checking the adjacent elements.\\n\\nWhile iterating over the array, we need to skip the duplicates to avoid considering the same quadruplet multiple times. We can do this by checking the adjacent elements and skipping them if they are the same.\\n\\nStep 4: Use binary search to find the fourth element that would complete the quadruplet and add it to the result list.\\n\\nFor each pair of fixed elements, we can use binary search to find the other two elements that would complete the quadruplet and add it to the result list if the sum of the quadruplet is equal to the target value.\\n\\nStep 5: Skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly.\\n\\nWhile adding quadruplets to the result list, we need to skip the duplicates and avoid repetition of quadruplets by checking the adjacent elements and moving the pointers accordingly."
                    },
                    {
                        "username": "kryuki",
                        "content": "When will the 5 sum problem come out?"
                    },
                    {
                        "username": "jk_sharath",
                        "content": "Can anyone help me out why my code is giving duplicate elements too\nclass Solution:\n    def fourSum(self, arr: List[int], target: int) -> List[List[int]]:\n        n=len(arr)\n        res=[]\n        arr.sort()\n        for i in range(n-3):\n            for j in range(i+1,n-2):\n                ans=target-arr[i]-arr[j]\n                low=j+1\n                high=n-1\n                while(low<high):\n                    k=arr[low]+arr[high]\n                    if k<ans:\n                        low+=1\n                    elif k>ans:\n                        high-=1\n                    else:\n                        res.append([arr[i],arr[j],arr[low],arr[high])\n                        t1=arr[low]\n                        t2=arr[high]\n                        while(low<high and arr[low]==t1):\n                            low+=1\n                        while(low< high and arr[high]==t2):\n                            high-=1\n                while(j+1<n and arr[j+1]==arr[j]):\n                    j+=1\n            while(i+1<n and arr[i+1]==arr[i]):\n                i+=1\n        \n        return res\nthankyou in advance"
                    },
                    {
                        "username": "EserCengiz",
                        "content": "I also got Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nthis is my solution in C# ;\\n\\n        public static (bool isOverflow, int Sum) SumAndCheckOverflow(params int[] numbers)\\n        {\\n            try\\n            {\\n                checked\\n                {\\n                    int result = 0;\\n                    foreach (var item in numbers)\\n                    {\\n                        result += item;\\n                    }\\n                    return (false, result);\\n                }\\n            }\\n            catch (OverflowException)\\n            {\\n                return (true, 0);\\n            }\\n        }"
                    }
                ]
            },
            {
                "id": 1792521,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1791814,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1787331,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1787220,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1784650,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1778937,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1772280,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1764835,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1762313,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1758542,
                "content": [
                    {
                        "username": "justinbass",
                        "content": "Test case is incorrect: [0,1,5,-2,2], 6, expected output: [-2, 2, 1, 5]\\nHowever, the problem statement says: 0 <= a, b, c, d < n\\nn = 5 for this case, so d < 5, but the expected answer has d == 5."
                    },
                    {
                        "username": "nmetts",
                        "content": "a, b, c, and d are all indices for the array nums, not the values stored in the array, while n is the length of the array.\\n\\n\"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\\n\\n0 <= a, b, c, d < n\""
                    },
                    {
                        "username": "mjeevan320",
                        "content": "i am feeling difficult to solve medium and hard problems i have just enter into dsa after basics\\n"
                    },
                    {
                        "username": "avigaikwad007",
                        "content": " Does anyone please explain why this error and how can remove it..\\nruntime error: signed integer overflow:"
                    },
                    {
                        "username": "duffer_coder",
                        "content": "This solution in java didn\\'t work, how should I optimise it ?\\n\\n`class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList <>();\\n        Arrays.sort(nums);\\n\\n    // -3 as other than i , 3 elements were left i.e. j, Left , right\\n        for (int i=0; i<nums.length-3; i++){\\n\\n            // duplicates\\n            if (i!=0 && nums[i]==nums[i-1]) {continue;}\\n\\n            for (int j=i+1; j<nums.length-2; j++){\\n\\n                if (j!=i+1 && nums[j]==nums[j-1]){ continue;}\\n\\n\\n                long long left = j+1, right = nums.length-1;\\n\\n                while(left<right){\\n                    long long sum = nums[i] +nums[j] +nums[left]+nums[right];\\n\\n                    if (sum<target) left++;\\n                    else if (sum>target) right--;\\n                    else{\\n                        //succesful combination\\n                        List<Integer> combination = new ArrayList <>();\\n                        combination.add(nums[i]);\\n                        combination.add(nums[j]);\\n                        combination.add(nums[left]);\\n                        combination.add(nums[right]);\\n\\n                        ans.add(combination);\\n                        left++;\\n                        right--;\\n\\n                        //removing duplication which we won\\'t take under consideration\\n                        while(left < right && nums[left]==nums[left-1]) left++;\\n                        while(left<right && nums[right]==nums[right+1]) right--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}`"
                    },
                    {
                        "username": "ketharithika18",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        ArrayList<List<Integer>> res = new ArrayList<List<Integer>>();\\n        if(nums==null || nums.length<3)\\n                return res;\\n                if(target==-294967296 || target==294967296) return res;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i=0;i<n-3;i++){\\n            for(int j=i+1;j<n-2;j++){\\n                int target2 = target-nums[j]-nums[i];\\n                int front = j+1;\\n                int back = n-1;\\n                while(front<back){\\n                     int two_sum =nums[front] +nums[back];\\n                    if(two_sum<target2) front++;\\n                    else if(two_sum>target2) back--;\\n                    else{\\n                        List<Integer> quad = new ArrayList();\\n                        quad.add(nums[i]);\\n                        quad.add(nums[j]);\\n                        quad.add(nums[front]);\\n                        quad.add(nums[back]);\\n                        res.add(quad);\\n                    \\n                    while(front<back && nums[front] == quad.get(2)) ++front;\\n                    while(front<back && nums[back] == quad.get(3)) --back; \\n                    \\n                }\\n                }\\n                while(j+1<n-2 && nums[j+1] == nums[j]) ++j;\\n            }while(i+1<n-3 && nums[i+1] == nums[i]) ++i;\\n        } \\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "lokesh_pandey",
                        "content": "I didn't understand this test case\n\n[1000000000,1000000000,1000000000,1000000000]\n\nWhy the expected result for this is empty list ?\n\nMy answer is [[1000000000,1000000000,1000000000,1000000000]]"
                    },
                    {
                        "username": "klaca",
                        "content": "What is the target in the test case? Adding these 4 together is 4000000000."
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "use long type instead of int for all sums to prevent overflow"
                    },
                    {
                        "username": "aryan728",
                        "content": "Why following code is failing on this particular test case : nums = [1000000000,1000000000,1000000000,1000000000] and target = -294967296\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        set<vector<int>> sv;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    int x = (long long)target - (long long)nums[i] - (long long)nums[j] - (long long)nums[k];\\n                    if(binary_search(nums.begin()+k+1,nums.end(),x)){\\n                        vector<int> v;\\n                        v.push_back(nums[i]);\\n                        v.push_back(nums[j]);\\n                        v.push_back(nums[k]);\\n                        v.push_back(x);\\n                        sort(v.begin(),v.end());\\n                        sv.insert(v);\\n                    }\\n                }\\n            }\\n        }\\n        vector<vector<int>> ans(sv.begin(),sv.end());\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "kanungosahil123",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        HashSet<List<Integer>> hset = new HashSet<>();\\n        if(nums.length==0){\\n            return new ArrayList<>();\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-3;i++){\\n            for(int j=i+1;j<nums.length-2;j++){\\n                int k = j+1;\\n                int l = nums.length-1;\\n\\n                while(k<l){\\n                    int sum = nums[i]+nums[j]+nums[k]+nums[l];\\n                    if(sum==target){\\n                        hset.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\\n                        k++;\\n                        l--;\\n                    }\\n                    if(sum<target){\\n                        k++;\\n                    }\\n                    if(sum>target){\\n                        l--;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(hset); \\n\\n    }\\n}\\n\\nCan anyone please review . Which testcase is not handled by the code !!"
                    },
                    {
                        "username": "theVirus031",
                        "content": "I\\'m getting TLE for last testcase with code :-\\n\\npls help\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>> sol;\\n        vector<int> ans;\\n        set<vector<int>>s;\\n        long long n = nums.size();\\n        map<long long, long long> count;\\n        for(long long i=0;i<n;i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        for(long long i=0; i<n-3 ; i++)\\n        {\\n                    count[nums[i]]--;\\n            for(long long j=i+1; j<n-2;j++)\\n            {\\n                    count[nums[j]]--;\\n                for(long long k=j+1; k<n-1; k++)\\n                {\\n                    long long tmp = (long long)target - nums[i] - nums[j] - nums[k];\\n                    count[nums[k]]--;\\n                    if(count[tmp]>=1)\\n                    {\\n                        ans.push_back(nums[i]);\\n                        ans.push_back(nums[j]);\\n                        ans.push_back(nums[k]);\\n                        ans.push_back(tmp);\\n                        sort(ans.begin(),ans.begin()+4);\\n                        // sol.push_back(ans);\\n                        s.insert(ans);\\n                        ans.clear();\\n                    }\\n                    count[nums[k]]++;\\n                        }\\n                    count[nums[j]]++;\\n                    }\\n                    count[nums[i]]++;\\n        }\\n        long long tmp2 = sol.size();\\n        cout<<\"ihoihiohioh\"<<endl;\\n        if(s.size()==0)\\n        {\\n            return sol;\\n        }\\n        // sort(sol.begin(),sol.end());\\n        for(auto x:s)\\n        {\\n            sol.push_back(x);\\n        }  \\n        cout<<\"ihoihiohioh\"<<endl;\\n        \\n        return sol;\\n    }\\n};"
                    },
                    {
                        "username": "jainambhavsar2108",
                        "content": "Before submitting, consider overflow. \\n\\nTestcase:\\nnums = \\n[1000000000,1000000000,1000000000,1000000000]\\n\\ntarget = \\n -294967296"
                    },
                    {
                        "username": "SiameseTheDog",
                        "content": "this test case is so sick :("
                    }
                ]
            },
            {
                "id": 1752589,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1746855,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1741836,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1740291,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1731417,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1725638,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1725607,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1725249,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1722548,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1722469,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Rohan_k14",
                        "content": "runtime error: signed integer overflow: 2000000000 + 1000000000 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nPlease anyone can help me to modify my code\\nnums[lo]+nums[hi]+nums[j]+nums[i]==target"
                    },
                    {
                        "username": "null_coder",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        vector<vector<int>>v;\\n        int l1=0;\\n        int l2=l1+1;\\n        int r1=nums.size()-1;\\n        int r2=r1-1;\\n        sort(nums.begin(),nums.end());\\n       // cout<<nums[l2];\\n       \\n        while(l1<l2<r2<r1)\\n        {\\n            while(l2<r2)\\n            {\\n                if(nums[l1]+nums[l2]+nums[r2]+nums[r1]==target)\\n                {\\n                    v.push_back({nums[l1],nums[l2],nums[r2],nums[r1]});\\n                    l2++;\\n                    r2--;\\n                }\\n                else if(nums[l1]+nums[l2]+nums[r2]+nums[r1]>target)\\n                {\\n                   // cout<<nums[l1]+nums[l2]+nums[r2]+nums[r1]<<\" \" <<l1<<\" \";\\n                    r2--;\\n                }\\n                else l2++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n            if(nums[l1]+nums[l2]+nums[r1]+nums[r2]>target)\\n            {\\n                r1--;\\n            }\\n            else if(nums[l1]+nums[l2]+nums[r1]+nums[r2]<target)\\n            {\\n                l1++;\\n            }\\n            else \\n            {\\n                r1--;\\n                l1++;\\n            }\\n            l2=l1+1;\\n            r2=r1-1;\\n      \\n        }\\n        return v;\\n        }\\n\\n};\\n\\ncan someone please explain me what is the problem with 4 pointer approach?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "four-sum, five-sum, six-sum, seven-sum... eight-sum nuts!!!"
                    },
                    {
                        "username": "mohitpanjikar21",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target){\\n         vector<vector<int>> result ;\\n\\n         if(nums.empty())\\n            return result;\\n\\n        int n =  nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<n; i++){\\n\\n            for(int j=i+1; j<n; j++){\\n\\n                long long target_2 = target - (long long int)nums[i]-(long long int)nums[j];\\n\\n                long long front = j+1;\\n                long long back = n-1;\\n\\n                while(front < back){\\n                    long long two_sum = (long long int)nums[front] + (long long int)nums[back];\\n                    if(two_sum < target_2) front++;\\n\\n                    else if(two_sum > target_2) back--;\\n\\n                    else{\\n                        vector<int>quadruplet(4,0);\\n                        quadruplet[0] = nums[i];\\n                        quadruplet[1] = nums[j];\\n                        quadruplet[2] = nums[front];\\n                        quadruplet[0] = nums[back];\\n                        result.push_back(quadruplet);\\n\\n                        //processing the duplicates of number 3 (for front wala pointer)\\n                        while(front < back && nums[front] == quadruplet[2]) ++front;\\n\\n                        //processing the duplicates of number 4 (for back wala pointer)\\n                        while(front < back && nums[back] == quadruplet[3]) --back;\\n                    }\\n                }\\n               //processing the duplicates of number 2\\n               while(j+1 < n && nums[j+1] == nums[j]) ++j; \\n            }\\n            //processing the duplicates of number 1\\n            while(i+1 < n && nums[i+1] == nums[i]) ++i; \\n        }\\n    return result;\\n    }\\n};\\n\\n\\n\\n\\nNot working any guess whyyy ???"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "This is Now working code pass all the test cases  \\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int Target) {\\n        long target = Target;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = (long)arr[i] + (long)arr[j] + (long)arr[left] + (long)arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        // System.out.println(\"sum is \"+ sum);\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "djkhanna835",
                        "content": "Any one please help why this is not working for only 1 test casee\\narry is  [1000000000,1000000000,1000000000,1000000000]\\ntarget = -294967296;\\n `\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] arr, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        int N = arr.length;\\n        Arrays.sort(arr);\\n        for(int i=0; i < N; i++){\\n            for(int j=i+1; j< N; j++){\\n                int left = j+1, right = N -1;\\n                long sum = 0;\\n                while(left < right){\\n                    sum = arr[i] + arr[j] + arr[left] + arr[right];\\n                    if(sum == target){\\n                        List<Integer> temp = new ArrayList<>();\\n                        temp.add(arr[i]);\\n                        temp.add(arr[j]);\\n                        temp.add(arr[left]);\\n                        temp.add(arr[right]);\\n                        set.add(temp);\\n                        left++;\\n                    }else if(sum > target) right--;\\n                    else left++;\\n\\n                }\\n            }\\n        }\\n\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "shrawank22",
                        "content": "All testcases passed but It\\'s showing TLE. Why it\\'s so?"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. Solve 3Sum.\\n2. For each element e,\\n    e + 3Sum(rest_of_elements) == target"
                    },
                    {
                        "username": "santanusen",
                        "content": "My technically O(n^2) solution is hitting \"Time Limit Exceeded\" with a testcase with n=180 only. Any idea why?\\n\\n```\\nclass Solution {\\n    struct MyHash {\\n        size_t operator()(const std::vector<int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            for (int i : v)\\n                seed ^= hasher(i) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n\\n        size_t operator()(const std::pair<int, int>& v) const {\\n            std::hash<int> hasher;\\n            size_t seed = 0;\\n            seed ^= hasher(v.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            seed ^= hasher(v.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\\n            return seed;\\n        }\\n};\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        // Map of sum to sets of pairs of indexes that produce the sum.\\n        unordered_map<int, unordered_set<pair<int, int>, MyHash>> smap;\\n        \\n        // Store only unique quadruplets in result.\\n        unordered_set<vector<int>, MyHash> res;\\n\\n        // Examine all pairs.\\n        for (int i = 0; i + 1 < nums.size(); ++i)\\n            for (int j = i + 1; j < nums.size(); ++j) {\\n                int sum = nums[i] + nums[j];\\n                // Check if a pair with sum equaling target - sum exists: that pair and this\\n                // pair together constitute the quadruplet that produce the target sum.\\n                int tsum = target - sum;\\n                auto itr = smap.find(tsum);\\n                if (itr != smap.end()) {\\n                    for (auto& [k, l] : itr->second) {\\n                        if (i != k && j != k && i != l && j != l) {\\n                            vector<int> quad {nums[i], nums[j], nums[k], nums[l]};\\n                            sort(quad.begin(), quad.end());\\n                            res.insert(quad);\\n                        }\\n                    }\\n                }\\n                smap[sum].insert({i, j});\\n            }\\n\\n        return vector<vector<int>>(res.begin(), res.end());\\n    }\\n};\\n```"
                    },
                    {
                        "username": "alhazeem",
                        "content": "[@alhazeem](/alhazeem) how is it ON^2 though lol its O(N^4)\\nin the worst case you will have set in the inner loop of size N^2. "
                    },
                    {
                        "username": "alhazeem",
                        "content": "remove 4 duplocates from input (say 4,4,4,4,4,,4) you only two consider 4 of them max\\n"
                    }
                ]
            },
            {
                "id": 1717743,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1713969,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1713123,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1711533,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1700158,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1671266,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1665683,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1656318,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1648664,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            },
            {
                "id": 1641554,
                "content": [
                    {
                        "username": "djkhanna835",
                        "content": "=========================\\n\\nAny one Please Help this code is not working for a big test case\\n\\n=========================\\nclass Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n        List<List<Integer>> ans  = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n        Arrays.sort(nums);\\n        int N= nums.length;\\n        for(int i=0; i< N; i++){\\n            for(int j=i+1; j< N; j++){\\n                HashSet<Integer> hs = new HashSet<>();\\n                for(int k=j+1; k< N; k++){\\n                    List<Integer> list = new ArrayList<>();\\n                    if(hs.contains(target-nums[i] - nums[j]- nums[k])){\\n                        list.add(nums[i]);\\n                        list.add(nums[j]);\\n                        list.add(target-nums[i]- nums[j]-nums[k]);\\n                        list.add(nums[k]);\\n                        hs.remove(target-nums[i]-nums[j]-nums[k]);\\n                        set.add(list);\\n                        System.out.println(\"list is \"+ list);\\n                    }else {\\n                        hs.add(nums[k]);\\n                    }\\n                }\\n            }\\n        }\\n        System.out.println(\"set is \"+ set);\\n        for(List<Integer> temp : set) ans.add(temp);\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "abhishek9915",
                        "content": "class Solution {\\n    public List<List<Integer>> fourSum(int[] nums, int target) {\\n\\n        ArrayList<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums);\\n\\n        if(nums.length == 0) return ans;\\n\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i+1; j < nums.length; j++) {\\n                int new_target = target - nums[j] - nums[i];\\n                int start = j+1;\\n                int end = nums.length - 1;\\n\\n                while(start < end) {\\n                    if(nums[start] + nums[end] > new_target) {\\n                        end--;\\n                    }\\n                    else if(nums[start] + nums[end] < new_target) {\\n                        start++;\\n                    }\\n                else {\\n                    ArrayList<Integer> temp = new ArrayList<>();\\n                    temp.add(nums[i]);\\n                    temp.add(nums[j]);\\n                    temp.add(nums[start]);\\n                    temp.add(nums[end]);\\n                    ans.add(temp);\\n\\n                    //Move ahead the pointer to avoid duplicates in 3rd Number\\n                    while(start < end && nums[start] == temp.get(2)) start++;\\n\\n                    //Move ahead the pointer to avoid duplicates in 4th Number\\n                    while(start < end && nums[end] == temp.get(3)) end--;\\n                }\\n             }\\n                // Move ahead to avoid duplicate 2nd Number\\n                while(j + 1 < nums.length && nums[j+1] == nums[j]) j++;\\n            }\\n                // Move ahead to avoid duplicate 1st Number\\n                 while(i + 1 < nums.length && nums[i+1] == nums[i]) i++;\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n//I get Wrong Answer for [1000000000,1000000000,1000000000,1000000000] -294967296\\n\\nCan someone help me understand why? "
                    },
                    {
                        "username": "Bobzero",
                        "content": "LeetCode compiler is too picky..\\uD83D\\uDE03"
                    },
                    {
                        "username": "deepak130797",
                        "content": "why it says \\nruntime error: signed integer overflow: -294967296 - 2000000000 cannot be represented in type \\'int\\'\\n-------FAILED FOR THIS INPUT---------------\\nnums =\\n[1000000000,1000000000,1000000000,1000000000]\\ntarget =\\n-294967296\\n---------------------\\n\\n\\nclass Solution {\\npublic:\\nvoid twosum(vector<vector<int>> &ans,vector<int> nums,int n,int i,int j,int target){\\n    int k=j+1;\\n    int l=n-1;\\n\\n    while(k<l)\\n    {\\n        if(nums[k]+nums[l]>target)\\n        {\\n            l--;\\n        }\\n        else if(nums[k]+nums[l]<target)\\n        {\\n            k++;\\n        }\\n        else{\\n            ans.push_back({nums[i],nums[j],nums[k],nums[l]});\\n            while(k<n-1 && nums[k]==nums[k+1])k++;\\n            while(l>0 && nums[l]==nums[l-1])l--;\\n            k++;\\n            l--;\\n        }\\n    }\\n}\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>>ans;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n\\n\\n        if(n<4)\\n        {\\n            return ans; \\n        }\\n\\n        for(int i=0;i<n-3;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            for(int j=i+1;j<n-2;j++)\\n            {\\n                if(j>i+1 && nums[j]==nums[j-1])\\n                {\\n                    continue;\\n                }\\n                long long targetsum=target-(nums[i]+nums[j]);\\n                twosum(ans,nums,n,i,j,targetsum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mudhapakamanohar",
                        "content": "if(arr.length==4){\\n            if((long)arr[0] + (long) arr[1] + (long) arr[2] + (long) arr[3] != target){\\n                  return ans;\\n            }else{\\n                List<Integer> list =new ArrayList<>(); \\n                list.add(arr[0]); \\n                list.add(arr[1]); \\n                list.add(arr[2]); \\n                list.add(arr[3]); \\n                ans.add(list);\\n                return ans;\\n            }\\n        }\\n\\nI did like this. It got accepted"
                    },
                    {
                        "username": "lingpri",
                        "content": " `input_array = [[1,0,-1,0,-2,2],[2,2,2,2,2]]\n   target_array = [0,8]\n\n\nimport itertools\n\ndef find_quad(input,target):\n quadruplets = itertools.combinations(input, 4)\n return [(a[0],a[1],a[2],a[3])  for a in quadruplets if sum(a) == target]\n\noutput = set()\n#iterate over both inputs and it in the output as a single set.\nfor i,elem in enumerate(input_array):\n    result = find_quad(input_array[i],target_array[i]);\n    #print(type(result))\n    output.update(result)\n\nprint(output) [@pythonProgrammerHere](/pythonProgrammerHere)\n`\n\nAbove is just a sample of my thought process and not a solution. "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, C++, Java and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-4sum-problem-solution.html)"
                    },
                    {
                        "username": "user0837ed",
                        "content": "There are two contradictory test cases\n[1000000000,1000000000,1000000000,1000000000] , target= -294967296\n[2,2,2,2],  target= 8\nwhere if we follow the challenge description and remove duplicates to satisfy the unique quadruplets condition the second case is not accepted and first is, while on the other hand, if we keep duplicates the second case is accepted but that will make the first case always not accepted.\n\n"
                    },
                    {
                        "username": "meetHadvani",
                        "content": " `a = list(itertools.combinations(nums, 4))\n                 b = [list(i) for i in set(a) if sum(i)==target]\n                 return(b)`\nGetting the wrong answer in only one test case\nany help for improvement?"
                    },
                    {
                        "username": "user0763CV",
                        "content": "return set(x for x in itertools.combinations(sorted(nums), 4) if sum(x)==target)  your going to produce copies when multiple copies of a number exist in the nums list. This can be fixed by sorting the nums first but wont run fast enough to pass all test"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\nhttps://zeroplusfour.com/4sum-leetcode-solution/"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This question is hard."
                    }
                ]
            }
        ]
    },
    {
        "title": "Pascal's Triangle",
        "question_content": "<p>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> numRows = 5\n<strong>Output:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> numRows = 1\n<strong>Output:</strong> [[1]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numRows &lt;= 30</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 38171,
                "title": "maybe-shortest-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > generate(int numRows) {\\n            vector<vector<int>> r(numRows);\\n    \\n            for (int i = 0; i < numRows; i++) {\\n                r[i].resize(i + 1);\\n                r[i][0] = r[i][i] = 1;\\n      \\n                for (int j = 1; j < i; j++)\\n                    r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n            }\\n            \\n            return r;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > generate(int numRows) {\\n            vector<vector<int>> r(numRows);\\n    \\n            for (int i = 0; i < numRows; i++) {\\n                r[i].resize(i + 1);\\n                r[i][0] = r[i][i] = 1;\\n      \\n                for (int j = 1; j < i; j++)\\n                    r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38128,
                "title": "python-4-lines-short-solution-using-map",
                "content": "    def generate(self, numRows):\\n            res = [[1]]\\n            for i in range(1, numRows):\\n                res += [map(lambda x, y: x+y, res[-1] + [0], [0] + res[-1])]\\n            return res[:numRows]\\n\\n\\nexplanation: Any row can be constructed using the offset sum of the previous row. Example:\\n\\n        \\n        1 3 3 1 0 \\n     +  0 1 3 3 1\\n     =  1 4 6 4 1",
                "solutionTags": [],
                "code": "    def generate(self, numRows):\\n            res = [[1]]\\n            for i in range(1, numRows):\\n                res += [map(lambda x, y: x+y, res[-1] + [0], [0] + res[-1])]\\n            return res[:numRows]\\n\\n\\nexplanation: Any row can be constructed using the offset sum of the previous row. Example:\\n\\n        \\n        1 3 3 1 0 \\n     +  0 1 3 3 1\\n     =  1 4 6 4 1",
                "codeTag": "Python3"
            },
            {
                "id": 38141,
                "title": "my-concise-solution-in-java",
                "content": "    public class Solution {\\n    public List<List<Integer>> generate(int numRows)\\n\\t{\\n\\t\\tList<List<Integer>> allrows = new ArrayList<List<Integer>>();\\n\\t\\tArrayList<Integer> row = new ArrayList<Integer>();\\n\\t\\tfor(int i=0;i<numRows;i++)\\n\\t\\t{\\n\\t\\t\\trow.add(0, 1);\\n\\t\\t\\tfor(int j=1;j<row.size()-1;j++)\\n\\t\\t\\t\\trow.set(j, row.get(j)+row.get(j+1));\\n\\t\\t\\tallrows.add(new ArrayList<Integer>(row));\\n\\t\\t}\\n\\t\\treturn allrows;\\n\\t\\t\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> generate(int numRows)\\n\\t{\\n\\t\\tList<List<Integer>> allrows = new ArrayList<List<Integer>>();\\n\\t\\tArrayList<Integer> row = new ArrayList<Integer>();\\n\\t\\tfor(int i=0;i<numRows;i++)\\n\\t\\t{\\n\\t\\t\\trow.add(0, 1);\\n\\t\\t\\tfor(int j=1;j<row.size()-1;j++)\\n\\t\\t\\t\\trow.set(j, row.get(j)+row.get(j+1));\\n\\t\\t\\tallrows.add(new ArrayList<Integer>(row));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3169582,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  vector<vector<int>> generate(int numRows) {\\n    vector<vector<int>> ans;\\n\\n    for (int i = 0; i < numRows; ++i)\\n      ans.push_back(vector<int>(i + 1, 1));\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < ans[i].size() - 1; ++j)\\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];\\n\\n    return ans;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        finalNums=[]\\n        finalNums.append([1])\\n        for i in range(numRows-1):\\n            newRow=[1]\\n            for j in range(i):\\n                newRow.append(finalNums[i][j]+finalNums[i][j+1])\\n            newRow.append(1)\\n            finalNums.append(newRow)\\n        return finalNums\\n```\\n\\n```Java []\\nclass Solution {\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      ans.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < ans.get(i).size() - 1; ++j)\\n        ans.get(i).set(j, ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j));\\n\\n    return ans;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  vector<vector<int>> generate(int numRows) {\\n    vector<vector<int>> ans;\\n\\n    for (int i = 0; i < numRows; ++i)\\n      ans.push_back(vector<int>(i + 1, 1));\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < ans[i].size() - 1; ++j)\\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];\\n\\n    return ans;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        finalNums=[]\\n        finalNums.append([1])\\n        for i in range(numRows-1):\\n            newRow=[1]\\n            for j in range(i):\\n                newRow.append(finalNums[i][j]+finalNums[i][j+1])\\n            newRow.append(1)\\n            finalNums.append(newRow)\\n        return finalNums\\n```\n```Java []\\nclass Solution {\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      ans.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < ans.get(i).size() - 1; ++j)\\n        ans.get(i).set(j, ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j));\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727318,
                "title": "c-simple-solution-0-ms-beats-100-00",
                "content": "```\\n// Please, UpVote, if you like it :-) Thank you\\nvector<vector<int>> generate(int numRows) {\\n\\tvector<vector<int>> ret;\\n\\tfor (int i = 0; i < numRows; i++) {\\n\\t\\tvector<int> row(i + 1, 1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\trow[j] = ret[i - 1][j] + ret[i - 1][j - 1];\\n\\t\\t}\\n\\t\\tret.push_back(row);\\n\\t}\\n\\treturn ret;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Please, UpVote, if you like it :-) Thank you\\nvector<vector<int>> generate(int numRows) {\\n\\tvector<vector<int>> ret;\\n\\tfor (int i = 0; i < numRows; i++) {\\n\\t\\tvector<int> row(i + 1, 1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\trow[j] = ret[i - 1][j] + ret[i - 1][j - 1];\\n\\t\\t}\\n\\t\\tret.push_back(row);\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38277,
                "title": "simple-python-4-lines",
                "content": "    def generate(numRows):\\n        pascal = [[1]*(i+1) for i in range(numRows)]\\n        for i in range(numRows):\\n            for j in range(1,i):\\n                pascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j]\\n        return pascal",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def generate(numRows):\\n        pascal = [[1]*(i+1) for i in range(numRows)]\\n        for i in range(numRows):\\n            for j in range(1,i):\\n                pascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j]\\n        return pascal",
                "codeTag": "Python3"
            },
            {
                "id": 38125,
                "title": "solution-in-java",
                "content": "two loops, one go through the row, one go through the column\\n\\ndatabase: pretty straight forward, ArrayList\\n\\ncalculate element value: K(i)(j)=K(i-1)(j-1)+K(i-1)(j) except for the first and last element\\n\\n    public class Solution {\\n        public List<List<Integer>> generate(int numRows) {\\n            List<List<Integer>> triangle = new ArrayList<List<Integer>>();\\n            if (numRows <=0){\\n                return triangle;\\n            }\\n            for (int i=0; i<numRows; i++){\\n                List<Integer> row =  new ArrayList<Integer>();\\n                for (int j=0; j<i+1; j++){\\n                    if (j==0 || j==i){\\n                        row.add(1);\\n                    } else {\\n                        row.add(triangle.get(i-1).get(j-1)+triangle.get(i-1).get(j));\\n                    }\\n                }\\n                triangle.add(row);\\n            }\\n            return triangle;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> generate(int numRows) {\\n            List<List<Integer>> triangle = new ArrayList<List<Integer>>();\\n            if (numRows <=0){\\n                return triangle;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2490404,
                "title": "easy-0-ms-100-fully-explained-java-c-python-javascript-python3-dp",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Pascal\\'s Triangle.\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        // Create an array list to store the output result...\\n        List<List<Integer>> output = new ArrayList<List<Integer>>();\\n        // Base cases...\\n\\t    if (numRows <= 0)  return output;\\n        // Create an array list to store the prev triangle value for further addition...\\n\\t    ArrayList<Integer> prev = new ArrayList<Integer>();\\n        // Inserting for the first row & store the prev array to the output array...\\n\\t    prev.add(1);\\n\\t    output.add(prev);\\n        // For rest of the rows, Traverse all elements through a for loop...\\n\\t    for (int i = 2; i <= numRows; i++) {\\n            // Create another array to store the current triangle value...\\n\\t\\t    ArrayList<Integer> curr = new ArrayList<Integer>();\\n\\t\\t    curr.add(1);    //first\\n            // Calculate for each of the next values...\\n\\t\\t    for (int j = 0; j < prev.size() - 1; j++) {\\n                // Inserting the addition of the prev arry two values...\\n\\t\\t\\t    curr.add(prev.get(j) + prev.get(j + 1));    //middle\\n\\t\\t    }\\n            // Store the number 1...\\n\\t\\t    curr.add(1);    //last\\n            // Store the value in the Output array...\\n\\t\\t    output.add(curr);\\n            // Set prev is equal to curr...\\n\\t\\t    prev = curr;\\n\\t    }\\n\\t    return output;      // Return the output list of pascal values...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> output;\\n        // Base cases...\\n        if(numRows == 0)  return output;\\n        // Traverse all the elements through a loop\\n        for(int i=0; i<numRows; i++)\\n            output.push_back(vector<int>(i + 1, 1));    // Initialize the first row of the pascal triangle as {1}.\\n        // For generating each row of the triangle...\\n        for (int i = 2; i < numRows; ++i)\\n            // Run an inner loop from j = 1 to j = {previous row size} for calculating element of each row of the triangle.\\n            for (int j = 1; j < output[i].size() - 1; ++j)\\n                // Calculate the elements of a row, add each pair of adjacent elements of the previous row in each step of the inner loop.\\n                output[i][j] = output[i - 1][j - 1] + output[i - 1][j];\\n        return output;      // After the inner loop gets over, simply output the row generated.\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        # Create an array list to store the output result...\\n        output = []\\n        for i in range(numRows):\\n            if(i == 0):\\n                # Create a list to store the prev triangle value for further addition...\\n                # Inserting for the first row & store the prev array to the output array...\\n                prev = [1]\\n                output.append(prev)\\n            else:\\n                curr = [1]\\n                j = 1\\n                # Calculate for each of the next values...\\n                while(j < i):\\n                    # Inserting the addition of the prev arry two values...\\n                    curr.append(prev[j-1] + prev[j])\\n                    j+=1\\n                # Store the number 1...\\n                curr.append(1)\\n                # Store the value in the Output array...\\n                output.append(curr)\\n                # Set prev is equal to curr...\\n                prev = curr\\n        return output       # Return the output list of pascal values...\\n```\\n                        \\n# **JavaScript Solution:**\\n```\\nvar generate = function(numRows) {\\n    var i = 0;\\n    var j = 0;\\n    // Create an array list to store the output result...\\n    var res = [];\\n    // For generating each row of the triangle...\\n    for (i = 0; i < numRows; i++) {\\n        res.push(Array(i + 1));       // Initialize the first row of the pascal triangle as {1}...\\n        for (j = 0; j <= i; j++) {\\n            // Primary...\\n            if (j === 0 || j === i) {\\n                res[i][j] = 1;\\n            }\\n            else {\\n                // Calculate the elements of a row, add each pair of adjacent elements of the previous row in each step of the inner loop.\\n                res[i][j] = res[i - 1][j - 1] + res[i - 1][j];\\n            }\\n        }\\n    }\\n    return res;      // Return the output list of pascal values...\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        // Create an array list to store the output result...\\n        List<List<Integer>> output = new ArrayList<List<Integer>>();\\n        // Base cases...\\n\\t    if (numRows <= 0)  return output;\\n        // Create an array list to store the prev triangle value for further addition...\\n\\t    ArrayList<Integer> prev = new ArrayList<Integer>();\\n        // Inserting for the first row & store the prev array to the output array...\\n\\t    prev.add(1);\\n\\t    output.add(prev);\\n        // For rest of the rows, Traverse all elements through a for loop...\\n\\t    for (int i = 2; i <= numRows; i++) {\\n            // Create another array to store the current triangle value...\\n\\t\\t    ArrayList<Integer> curr = new ArrayList<Integer>();\\n\\t\\t    curr.add(1);    //first\\n            // Calculate for each of the next values...\\n\\t\\t    for (int j = 0; j < prev.size() - 1; j++) {\\n                // Inserting the addition of the prev arry two values...\\n\\t\\t\\t    curr.add(prev.get(j) + prev.get(j + 1));    //middle\\n\\t\\t    }\\n            // Store the number 1...\\n\\t\\t    curr.add(1);    //last\\n            // Store the value in the Output array...\\n\\t\\t    output.add(curr);\\n            // Set prev is equal to curr...\\n\\t\\t    prev = curr;\\n\\t    }\\n\\t    return output;      // Return the output list of pascal values...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> output;\\n        // Base cases...\\n        if(numRows == 0)  return output;\\n        // Traverse all the elements through a loop\\n        for(int i=0; i<numRows; i++)\\n            output.push_back(vector<int>(i + 1, 1));    // Initialize the first row of the pascal triangle as {1}.\\n        // For generating each row of the triangle...\\n        for (int i = 2; i < numRows; ++i)\\n            // Run an inner loop from j = 1 to j = {previous row size} for calculating element of each row of the triangle.\\n            for (int j = 1; j < output[i].size() - 1; ++j)\\n                // Calculate the elements of a row, add each pair of adjacent elements of the previous row in each step of the inner loop.\\n                output[i][j] = output[i - 1][j - 1] + output[i - 1][j];\\n        return output;      // After the inner loop gets over, simply output the row generated.\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        # Create an array list to store the output result...\\n        output = []\\n        for i in range(numRows):\\n            if(i == 0):\\n                # Create a list to store the prev triangle value for further addition...\\n                # Inserting for the first row & store the prev array to the output array...\\n                prev = [1]\\n                output.append(prev)\\n            else:\\n                curr = [1]\\n                j = 1\\n                # Calculate for each of the next values...\\n                while(j < i):\\n                    # Inserting the addition of the prev arry two values...\\n                    curr.append(prev[j-1] + prev[j])\\n                    j+=1\\n                # Store the number 1...\\n                curr.append(1)\\n                # Store the value in the Output array...\\n                output.append(curr)\\n                # Set prev is equal to curr...\\n                prev = curr\\n        return output       # Return the output list of pascal values...\\n```\n```\\nvar generate = function(numRows) {\\n    var i = 0;\\n    var j = 0;\\n    // Create an array list to store the output result...\\n    var res = [];\\n    // For generating each row of the triangle...\\n    for (i = 0; i < numRows; i++) {\\n        res.push(Array(i + 1));       // Initialize the first row of the pascal triangle as {1}...\\n        for (j = 0; j <= i; j++) {\\n            // Primary...\\n            if (j === 0 || j === i) {\\n                res[i][j] = 1;\\n            }\\n            else {\\n                // Calculate the elements of a row, add each pair of adjacent elements of the previous row in each step of the inner loop.\\n                res[i][j] = res[i - 1][j - 1] + res[i - 1][j];\\n            }\\n        }\\n    }\\n    return res;      // Return the output list of pascal values...\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301657,
                "title": "simple-o-1-solution-in-python",
                "content": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1], [1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1], [1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1], [1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1], [1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1], [1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1]][:numRows]\\n```\\n\\nWhy so serious? \\xAF\\\\\\\\\\\\_(\\u30C4)_/\\xAF\\n\\nNOTE: This one is faster than 87.94% of python3 submissions\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1], [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1], [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1], [1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1], [1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1], [1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1], [1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1], [1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1], [1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1], [1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1], [1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1], [1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1], [1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1], [1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1], [1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1], [1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1], [1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1], [1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1], [1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1], [1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1]][:numRows]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176431,
                "title": "best-c-solution-ever-dp-tabulation-bottom-up-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolved using Dynamic Programming Approach(Tabulation: Bottom Up).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N^2). Where N is the numRows. Here total number of iterations are : N*(N+1)/2 which creates the time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1). Constant space. Because we are creating 2D vector output as per the demand of program.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the numRows. Here total number of iterations are : N*(N+1)/2 which creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating 2D vector output as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up).\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> output(numRows);\\n        for(int i=0; i<numRows; i++){\\n            output[i].resize(i+1, 1);\\n            for(int j=1; j<i; j++){\\n                output[i][j] = output[i-1][j-1] + output[i-1][j];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2). Where N is the numRows. Here total number of iterations are : N*(N+1)/2 which creates the time complexity.\\n\\n    Space Complexity : O(1). Constant space. Because we are creating 2D vector output as per the demand of\\n    program.\\n\\n    Solved using Dynamic Programming Approach(Tabulation: Bottom Up).\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> output(numRows);\\n        for(int i=0; i<numRows; i++){\\n            output[i].resize(i+1, 1);\\n            for(int j=1; j<i; j++){\\n                output[i][j] = output[i-1][j-1] + output[i-1][j];\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287175,
                "title": "short-simple-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Dynamic Programming - Iterative)***\\n\\nThe pascal triangle problem has a very simple and intuitive dynamic programming approach. As the definition states, every element of a row is formed by the sum of the two numbers directly above. So, we can just apply DP and use the previously stored rows of trianlge to calculate the new rows.\\n\\nWe can just initialize the start and end elements of each row as 1 and update only the elements between them. This will make the code simpler and avoid the need of having extra checks for edge elements of each row.\\n\\n<iframe src=\"https://leetcode.com/playground/e8owLiQV/shared\" width=\"100%\" height=270 frameBorder=\"0\"></iframe>\\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Top-Down Recursive)***\\n\\nHere, the same logic as above is applied, just using a recursive implementation. We will start from the bottom of triangle and recursively call the *`generate(n-1)`*, till the top-most row of trianlge is generated  and then construct the bottom rows one-by-one using the values from the above rows.\\n\\n\\n<iframe src=\"https://leetcode.com/playground/K8tqSfYu/shared\" frameBorder=\"0\" width=\"100%\" height=\"270\"></iframe>\\n\\n \\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "\\u2714\\uFE0F ***Solution - I (Dynamic Programming - Iterative)***\\n\\nThe pascal triangle problem has a very simple and intuitive dynamic programming approach. As the definition states, every element of a row is formed by the sum of the two numbers directly above. So, we can just apply DP and use the previously stored rows of trianlge to calculate the new rows.\\n\\nWe can just initialize the start and end elements of each row as 1 and update only the elements between them. This will make the code simpler and avoid the need of having extra checks for edge elements of each row.\\n\\n<iframe src=\"https://leetcode.com/playground/e8owLiQV/shared\" width=\"100%\" height=270 frameBorder=\"0\"></iframe>\\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Top-Down Recursive)***\\n\\nHere, the same logic as above is applied, just using a recursive implementation. We will start from the bottom of triangle and recursively call the *`generate(n-1)`*, till the top-most row of trianlge is generated  and then construct the bottom rows one-by-one using the values from the above rows.\\n\\n\\n<iframe src=\"https://leetcode.com/playground/K8tqSfYu/shared\" frameBorder=\"0\" width=\"100%\" height=\"270\"></iframe>\\n\\n \\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "codeTag": "Unknown"
            },
            {
                "id": 4016203,
                "title": "three-approaches-beginner-friendly-full-explanation-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**The problem** of generating Pascal\\'s triangle can be approached in **various ways.**\\n**Here are some approaches and their intuition to solve the problem:**\\n\\n# Approach 1: Using Recursion\\n<!-- Describe your approach to solving the problem. -->\\n**Intuition:** In Pascal\\'s triangle, **each element is the sum of the two elements directly above it**. We can use a **recursive approach** to generate the triangle. **The base case is when numRows is 1**, in which case we return [[1]]. **Otherwise, we recursively generate the triangle for numRows - 1** and then calculate the current row by summing the adjacent elements from the previous row.\\n\\n# Approach 2: Using Combinatorial Formula\\n\\n**Intuition:** Pascal\\'s triangle **can also be generated using combinatorial formula C(n, k) = C(n-1, k-1) + C(n-1, k)**, where C(n, k) **represents the binomial coefficient**. **We can calculate each element of the triangle using this formula.** This approach avoids the need for storing the entire triangle in memory, **making it memory-efficient.**\\n\\n# Approach 3: Using Dynamic Programming with 1D Array\\n\\n**Intuition:** **We can use a dynamic programming approach with a 1D array to generate Pascal\\'s triangle row by row**. Instead of maintaining a 2D array, we can use a single array to store the current row and update it as we iterate through the rows. This approach reduces space complexity.\\n\\n# Here\\'s a brief outline of each approach:\\n1. **Recursion Approach:**\\n\\n    - Base case: If numRows is 1, return [[1]].\\n    - Recursively generate the triangle for numRows - 1.\\n    - Calculate the current row by summing adjacent elements from the previous row.\\n\\n2. **Combinatorial Formula Approach:**\\n\\n    - Use the binomial coefficient formula C(n, k) to calculate each element.\\n    - Build the triangle row by row using the formula.\\n\\n3. **Dynamic Programming with 1D Array:**\\n    - Initialize a 1D array to store the current row.\\n    - Iterate through numRows and update the array for each row.\\n\\n\\n# Complexity\\n**In terms of time complexity**, all three methods have the same overall time complexity of **O(numRows^2)** because we need to generate all the elements of Pascal\\'s triangle. **However, in terms of space complexity,** Method 3 is the most efficient as it uses only O(numRows) space, while the other two methods use O(numRows^2) space due to storing the entire triangle or previous rows in recursion.\\n\\n---\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n\\n\\n# Method 1: Using Recursion\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        if (numRows == 0) return {};\\n        if (numRows == 1) return {{1}};\\n        \\n        vector<vector<int>> prevRows = generate(numRows - 1);\\n        vector<int> newRow(numRows, 1);\\n        \\n        for (int i = 1; i < numRows - 1; i++) {\\n            newRow[i] = prevRows.back()[i - 1] + prevRows.back()[i];\\n        }\\n        \\n        prevRows.push_back(newRow);\\n        return prevRows;\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        if (numRows == 0) return new ArrayList<>();\\n        if (numRows == 1) {\\n            List<List<Integer>> result = new ArrayList<>();\\n            result.add(Arrays.asList(1));\\n            return result;\\n        }\\n        \\n        List<List<Integer>> prevRows = generate(numRows - 1);\\n        List<Integer> newRow = new ArrayList<>();\\n        \\n        for (int i = 0; i < numRows; i++) {\\n            newRow.add(1);\\n        }\\n        \\n        for (int i = 1; i < numRows - 1; i++) {\\n            newRow.set(i, prevRows.get(numRows - 2).get(i - 1) + prevRows.get(numRows - 2).get(i));\\n        }\\n        \\n        prevRows.add(newRow);\\n        return prevRows;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 0:\\n            return []\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        prevRows = self.generate(numRows - 1)\\n        newRow = [1] * numRows\\n        \\n        for i in range(1, numRows - 1):\\n            newRow[i] = prevRows[-1][i - 1] + prevRows[-1][i]\\n        \\n        prevRows.append(newRow)\\n        return prevRows\\n\\n```\\n```JavaScript []\\nvar generate = function(numRows) {\\n    if (numRows === 0) {\\n        return [];\\n    }\\n    if (numRows === 1) {\\n        return [[1]];\\n    }\\n    \\n    let prevRows = generate(numRows - 1);\\n    let newRow = new Array(numRows).fill(1);\\n    \\n    for (let i = 1; i < numRows - 1; i++) {\\n        newRow[i] = prevRows[numRows - 2][i - 1] + prevRows[numRows - 2][i];\\n    }\\n    \\n    prevRows.push(newRow);\\n    return prevRows;\\n};\\n\\n```\\n\\n# Method 2: Using Combinatorial Formula\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> result;\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n            for (int j = 1; j < i; j++) {\\n                row[j] = result[i - 1][j - 1] + result[i - 1][j];\\n            }\\n            result.push_back(row);\\n        }\\n        return result;\\n    }\\n};\\n\\n```\\n```java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (numRows == 0) {\\n            return result;\\n        }\\n\\n        List<Integer> firstRow = new ArrayList<>();\\n        firstRow.add(1);\\n        result.add(firstRow);\\n\\n        for (int i = 1; i < numRows; i++) {\\n            List<Integer> prevRow = result.get(i - 1);\\n            List<Integer> currentRow = new ArrayList<>();\\n            currentRow.add(1);\\n\\n            for (int j = 1; j < i; j++) {\\n                currentRow.add(prevRow.get(j - 1) + prevRow.get(j));\\n            }\\n\\n            currentRow.add(1);\\n            result.add(currentRow);\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        result = []\\n        if numRows == 0:\\n            return result\\n\\n        first_row = [1]\\n        result.append(first_row)\\n\\n        for i in range(1, numRows):\\n            prev_row = result[i - 1]\\n            current_row = [1]\\n\\n            for j in range(1, i):\\n                current_row.append(prev_row[j - 1] + prev_row[j])\\n\\n            current_row.append(1)\\n            result.append(current_row)\\n\\n        return result\\n\\n```\\n```Javascript []\\nvar generate = function(numRows) {\\n    let result = [];\\n    if (numRows === 0) {\\n        return result;\\n    }\\n\\n    let firstRow = [1];\\n    result.push(firstRow);\\n\\n    for (let i = 1; i < numRows; i++) {\\n        let prevRow = result[i - 1];\\n        let currentRow = [1];\\n\\n        for (let j = 1; j < i; j++) {\\n            currentRow.push(prevRow[j - 1] + prevRow[j]);\\n        }\\n\\n        currentRow.push(1);\\n        result.push(currentRow);\\n    }\\n\\n    return result;\\n};\\n\\n```\\n\\n---\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n\\n# Method 3: Using Dynamic Programming with 1D Array\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> result;\\n        vector<int> prevRow;\\n        \\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> currentRow(i + 1, 1);\\n            \\n            for (int j = 1; j < i; j++) {\\n                currentRow[j] = prevRow[j - 1] + prevRow[j];\\n            }\\n            \\n            result.push_back(currentRow);\\n            prevRow = currentRow;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\\n```Java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (numRows == 0) {\\n            return result;\\n        }\\n\\n        if (numRows == 1) {\\n            List<Integer> firstRow = new ArrayList<>();\\n            firstRow.add(1);\\n            result.add(firstRow);\\n            return result;\\n        }\\n\\n        result = generate(numRows - 1);\\n        List<Integer> prevRow = result.get(numRows - 2);\\n        List<Integer> currentRow = new ArrayList<>();\\n        currentRow.add(1);\\n\\n        for (int i = 1; i < numRows - 1; i++) {\\n            currentRow.add(prevRow.get(i - 1) + prevRow.get(i));\\n        }\\n\\n        currentRow.add(1);\\n        result.add(currentRow);\\n\\n        return result;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 0:\\n            return []\\n        if numRows == 1:\\n            return [[1]]\\n\\n        prev_rows = self.generate(numRows - 1)\\n        prev_row = prev_rows[-1]\\n        current_row = [1]\\n\\n        for i in range(1, numRows - 1):\\n            current_row.append(prev_row[i - 1] + prev_row[i])\\n\\n        current_row.append(1)\\n        prev_rows.append(current_row)\\n\\n        return prev_rows\\n\\n```\\n```Javascript []\\nvar generate = function(numRows) {\\n    if (numRows === 0) {\\n        return [];\\n    }\\n    if (numRows === 1) {\\n        return [[1]];\\n    }\\n\\n    let prevRows = generate(numRows - 1);\\n    let prevRow = prevRows[prevRows.length - 1];\\n    let currentRow = [1];\\n\\n    for (let i = 1; i < numRows - 1; i++) {\\n        currentRow.push(prevRow[i - 1] + prevRow[i]);\\n    }\\n\\n    currentRow.push(1);\\n    prevRows.push(currentRow);\\n\\n    return prevRows;\\n};\\n\\n```\\n\\n\\n---\\n\\n#SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n![UPVOTE.png](https://assets.leetcode.com/users/images/30c9c311-3f11-4ceb-9d94-bc0e937a7b99_1694134277.317914.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        if (numRows == 0) return {};\\n        if (numRows == 1) return {{1}};\\n        \\n        vector<vector<int>> prevRows = generate(numRows - 1);\\n        vector<int> newRow(numRows, 1);\\n        \\n        for (int i = 1; i < numRows - 1; i++) {\\n            newRow[i] = prevRows.back()[i - 1] + prevRows.back()[i];\\n        }\\n        \\n        prevRows.push_back(newRow);\\n        return prevRows;\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        if (numRows == 0) return new ArrayList<>();\\n        if (numRows == 1) {\\n            List<List<Integer>> result = new ArrayList<>();\\n            result.add(Arrays.asList(1));\\n            return result;\\n        }\\n        \\n        List<List<Integer>> prevRows = generate(numRows - 1);\\n        List<Integer> newRow = new ArrayList<>();\\n        \\n        for (int i = 0; i < numRows; i++) {\\n            newRow.add(1);\\n        }\\n        \\n        for (int i = 1; i < numRows - 1; i++) {\\n            newRow.set(i, prevRows.get(numRows - 2).get(i - 1) + prevRows.get(numRows - 2).get(i));\\n        }\\n        \\n        prevRows.add(newRow);\\n        return prevRows;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 0:\\n            return []\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        prevRows = self.generate(numRows - 1)\\n        newRow = [1] * numRows\\n        \\n        for i in range(1, numRows - 1):\\n            newRow[i] = prevRows[-1][i - 1] + prevRows[-1][i]\\n        \\n        prevRows.append(newRow)\\n        return prevRows\\n\\n```\n```JavaScript []\\nvar generate = function(numRows) {\\n    if (numRows === 0) {\\n        return [];\\n    }\\n    if (numRows === 1) {\\n        return [[1]];\\n    }\\n    \\n    let prevRows = generate(numRows - 1);\\n    let newRow = new Array(numRows).fill(1);\\n    \\n    for (let i = 1; i < numRows - 1; i++) {\\n        newRow[i] = prevRows[numRows - 2][i - 1] + prevRows[numRows - 2][i];\\n    }\\n    \\n    prevRows.push(newRow);\\n    return prevRows;\\n};\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> result;\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n            for (int j = 1; j < i; j++) {\\n                row[j] = result[i - 1][j - 1] + result[i - 1][j];\\n            }\\n            result.push_back(row);\\n        }\\n        return result;\\n    }\\n};\\n\\n```\n```java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (numRows == 0) {\\n            return result;\\n        }\\n\\n        List<Integer> firstRow = new ArrayList<>();\\n        firstRow.add(1);\\n        result.add(firstRow);\\n\\n        for (int i = 1; i < numRows; i++) {\\n            List<Integer> prevRow = result.get(i - 1);\\n            List<Integer> currentRow = new ArrayList<>();\\n            currentRow.add(1);\\n\\n            for (int j = 1; j < i; j++) {\\n                currentRow.add(prevRow.get(j - 1) + prevRow.get(j));\\n            }\\n\\n            currentRow.add(1);\\n            result.add(currentRow);\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        result = []\\n        if numRows == 0:\\n            return result\\n\\n        first_row = [1]\\n        result.append(first_row)\\n\\n        for i in range(1, numRows):\\n            prev_row = result[i - 1]\\n            current_row = [1]\\n\\n            for j in range(1, i):\\n                current_row.append(prev_row[j - 1] + prev_row[j])\\n\\n            current_row.append(1)\\n            result.append(current_row)\\n\\n        return result\\n\\n```\n```Javascript []\\nvar generate = function(numRows) {\\n    let result = [];\\n    if (numRows === 0) {\\n        return result;\\n    }\\n\\n    let firstRow = [1];\\n    result.push(firstRow);\\n\\n    for (let i = 1; i < numRows; i++) {\\n        let prevRow = result[i - 1];\\n        let currentRow = [1];\\n\\n        for (let j = 1; j < i; j++) {\\n            currentRow.push(prevRow[j - 1] + prevRow[j]);\\n        }\\n\\n        currentRow.push(1);\\n        result.push(currentRow);\\n    }\\n\\n    return result;\\n};\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> result;\\n        vector<int> prevRow;\\n        \\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> currentRow(i + 1, 1);\\n            \\n            for (int j = 1; j < i; j++) {\\n                currentRow[j] = prevRow[j - 1] + prevRow[j];\\n            }\\n            \\n            result.push_back(currentRow);\\n            prevRow = currentRow;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\n```Java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (numRows == 0) {\\n            return result;\\n        }\\n\\n        if (numRows == 1) {\\n            List<Integer> firstRow = new ArrayList<>();\\n            firstRow.add(1);\\n            result.add(firstRow);\\n            return result;\\n        }\\n\\n        result = generate(numRows - 1);\\n        List<Integer> prevRow = result.get(numRows - 2);\\n        List<Integer> currentRow = new ArrayList<>();\\n        currentRow.add(1);\\n\\n        for (int i = 1; i < numRows - 1; i++) {\\n            currentRow.add(prevRow.get(i - 1) + prevRow.get(i));\\n        }\\n\\n        currentRow.add(1);\\n        result.add(currentRow);\\n\\n        return result;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 0:\\n            return []\\n        if numRows == 1:\\n            return [[1]]\\n\\n        prev_rows = self.generate(numRows - 1)\\n        prev_row = prev_rows[-1]\\n        current_row = [1]\\n\\n        for i in range(1, numRows - 1):\\n            current_row.append(prev_row[i - 1] + prev_row[i])\\n\\n        current_row.append(1)\\n        prev_rows.append(current_row)\\n\\n        return prev_rows\\n\\n```\n```Javascript []\\nvar generate = function(numRows) {\\n    if (numRows === 0) {\\n        return [];\\n    }\\n    if (numRows === 1) {\\n        return [[1]];\\n    }\\n\\n    let prevRows = generate(numRows - 1);\\n    let prevRow = prevRows[prevRows.length - 1];\\n    let currentRow = [1];\\n\\n    for (let i = 1; i < numRows - 1; i++) {\\n        currentRow.push(prevRow[i - 1] + prevRow[i]);\\n    }\\n\\n    currentRow.push(1);\\n    prevRows.push(currentRow);\\n\\n    return prevRows;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375650,
                "title": "javascript-intuitive-simple-solution-99-49-faster-40ms-100-space-easy-to-understand",
                "content": "```\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    var pascal = [];\\n    for (var i = 0; i < numRows; i++) {\\n        pascal[i] = [];\\n        pascal[i][0] = 1;\\n        for (var j = 1; j < i; j++) {\\n            pascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j]\\n        }\\n        pascal[i][i] = 1;\\n    }\\n    return pascal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    var pascal = [];\\n    for (var i = 0; i < numRows; i++) {\\n        pascal[i] = [];\\n        pascal[i][0] = 1;\\n        for (var j = 1; j < i; j++) {\\n            pascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j]\\n        }\\n        pascal[i][i] = 1;\\n    }\\n    return pascal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016165,
                "title": "99-53-recursion-math-dynamic-programming",
                "content": "# Comprehensive Guide to Generating Pascal\\'s Triangle: A Three-Pronged Approach for Programmers\\n\\n## Introduction & Problem Statement\\n\\nWelcome to this in-depth guide on generating Pascal\\'s Triangle up to a given number of rows. Pascal\\'s Triangle is a mathematical concept that finds applications in various domains, including combinatorics, probability theory, and computer science. In this guide, we will explore three distinct methods to solve this problem: Dynamic Programming, Recursion, and Math (Combinatorics).\\n\\n## Key Concepts and Constraints\\n\\n1. **Row Anatomy**:  \\n   In Pascal\\'s Triangle, each row starts and ends with 1. Each inner element is the sum of the two elements directly above it in the previous row.\\n\\n2. **Row Generation**:  \\n   Our primary task is to generate the first `numRows` of Pascal\\'s Triangle.\\n\\n3. **Constraints**:  \\n   1 <= `numRows` <= 30. The constraint allows us to generate up to 30 rows of Pascal\\'s Triangle.\\n\\n---\\n\\n# Strategies to Tackle the Problem: A Three-Pronged Approach\\n\\n### Live Coding Dynamic Programming\\nhttps://youtu.be/g1QAZX8MLWo?si=eeIe-f-Hi4PJfipl\\n\\n## Method 1. Dynamic Programming\\n\\n### Intuition and Logic Behind the Solution\\n\\nIn Dynamic Programming, we use the concept of \"building upon previous solutions\" to solve the problem. We start with the first row and iteratively generate each subsequent row based on the row above it.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**:  \\n   - Start with a list containing the first row `[1]`.\\n\\n2. **Iterative Row Generation**:  \\n   - For each subsequent row, generate it based on the last row in the list. Start and end each row with 1 and fill the middle elements according to Pascal\\'s rule.\\n\\n3. **Return the Triangle**:  \\n   - After generating the required number of rows, return the triangle.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$O(n^2)$$ \\u2014 Each row takes $$O(n)$$ time to generate.\\n- **Space Complexity**: $$O(n^2)$$ \\u2014 Storing the triangle takes $$O(n^2)$$ space.\\n\\n## Code Dynamic Programming \\n``` Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 0:\\n            return []\\n        \\n        triangle = [[1]]\\n        \\n        for i in range(1, numRows):\\n            prev_row = triangle[-1]\\n            new_row = [1]\\n            \\n            for j in range(1, len(prev_row)):\\n                new_row.append(prev_row[j-1] + prev_row[j])\\n            \\n            new_row.append(1)\\n            triangle.append(new_row)\\n        \\n        return triangle\\n```\\n``` Go []\\nfunc generate(numRows int) [][]int {\\n\\tvar triangle [][]int\\n\\tif numRows == 0 {\\n\\t\\treturn triangle\\n\\t}\\n\\n\\ttriangle = append(triangle, []int{1})\\n\\n\\tfor i := 1; i < numRows; i++ {\\n\\t\\tprevRow := triangle[i-1]\\n\\t\\tvar newRow []int\\n\\t\\tnewRow = append(newRow, 1)\\n\\n\\t\\tfor j := 1; j < len(prevRow); j++ {\\n\\t\\t\\tnewRow = append(newRow, prevRow[j-1]+prevRow[j])\\n\\t\\t}\\n\\n\\t\\tnewRow = append(newRow, 1)\\n\\t\\ttriangle = append(triangle, newRow)\\n\\t}\\n\\n\\treturn triangle\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut triangle = Vec::new();\\n        if num_rows == 0 {\\n            return triangle;\\n        }\\n\\n        triangle.push(vec![1]);\\n\\n        for _ in 1..num_rows {\\n            let prev_row = triangle.last().unwrap();\\n            let mut new_row = vec![1];\\n\\n            for j in 1..prev_row.len() {\\n                new_row.push(prev_row[j-1] + prev_row[j]);\\n            }\\n\\n            new_row.push(1);\\n            triangle.push(new_row);\\n        }\\n\\n        triangle\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n        if (numRows == 0) return triangle;\\n\\n        triangle.push_back({1});\\n\\n        for (int i = 1; i < numRows; ++i) {\\n            vector<int> prev_row = triangle.back();\\n            vector<int> new_row = {1};\\n\\n            for (int j = 1; j < prev_row.size(); ++j) {\\n                new_row.push_back(prev_row[j-1] + prev_row[j]);\\n            }\\n\\n            new_row.push_back(1);\\n            triangle.push_back(new_row);\\n        }\\n\\n        return triangle;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> triangle = new ArrayList<>();\\n        if (numRows == 0) return triangle;\\n\\n        triangle.add(new ArrayList<>());\\n        triangle.get(0).add(1);\\n\\n        for (int i = 1; i < numRows; i++) {\\n            List<Integer> prev_row = triangle.get(i - 1);\\n            List<Integer> new_row = new ArrayList<>();\\n            new_row.add(1);\\n\\n            for (int j = 1; j < prev_row.size(); j++) {\\n                new_row.add(prev_row.get(j - 1) + prev_row.get(j));\\n            }\\n\\n            new_row.add(1);\\n            triangle.add(new_row);\\n        }\\n\\n        return triangle;\\n    }\\n}\\n```\\n``` C# []\\nclass Solution {\\n    public IList<IList<int>> Generate(int numRows) {\\n        List<IList<int>> triangle = new List<IList<int>>();\\n        if (numRows == 0) return triangle;\\n\\n        triangle.Add(new List<int>() { 1 });\\n\\n        for (int i = 1; i < numRows; i++) {\\n            List<int> prevRow = (List<int>)triangle[i - 1];\\n            List<int> newRow = new List<int> { 1 };\\n\\n            for (int j = 1; j < prevRow.Count; j++) {\\n                newRow.Add(prevRow[j - 1] + prevRow[j]);\\n            }\\n\\n            newRow.Add(1);\\n            triangle.Add(newRow);\\n        }\\n\\n        return triangle;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let triangle = [];\\n    if (numRows === 0) return triangle;\\n\\n    triangle.push([1]);\\n\\n    for (let i = 1; i < numRows; i++) {\\n        let prevRow = triangle[i - 1];\\n        let newRow = [1];\\n\\n        for (let j = 1; j < prevRow.length; j++) {\\n            newRow.push(prevRow[j - 1] + prevRow[j]);\\n        }\\n\\n        newRow.push(1);\\n        triangle.push(newRow);\\n    }\\n\\n    return triangle;\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function generate($numRows) {\\n    $triangle = [];\\n    if ($numRows == 0) return $triangle;\\n\\n    $triangle[] = [1];\\n\\n    for ($i = 1; $i < $numRows; $i++) {\\n        $prevRow = end($triangle);\\n        $newRow = [1];\\n\\n        for ($j = 1; $j < count($prevRow); $j++) {\\n            $newRow[] = $prevRow[$j - 1] + $prevRow[$j];\\n        }\\n\\n        $newRow[] = 1;\\n        $triangle[] = $newRow;\\n    }\\n\\n    return $triangle;\\n}\\n}\\n```\\n\\n---\\n\\n## Method 2. Recursion\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe Recursive approach generates Pascal\\'s Triangle by making recursive calls to generate the previous rows and then building upon that to generate the current row.\\n\\n### Step-by-step Explanation\\n\\n1. **Base Case**:  \\n   - If `numRows` is 1, return `[[1]]`.\\n\\n2. **Recursive Row Generation**:  \\n   - Make a recursive call to generate the first `numRows - 1` rows.\\n   - Generate the `numRows`-th row based on the last row in the list.\\n\\n3. **Return the Triangle**:  \\n   - Return the triangle after adding the new row.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$O(n^2)$$\\n- **Space Complexity**: $$O(n^2)$$\\n\\n## Code Recursion\\n``` Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        triangle = self.generate(numRows - 1)\\n        \\n        prev_row = triangle[-1]\\n        new_row = [1]\\n        \\n        for i in range(1, len(prev_row)):\\n            new_row.append(prev_row[i-1] + prev_row[i])\\n        \\n        new_row.append(1)\\n        triangle.append(new_row)\\n        \\n        return triangle\\n```\\n``` Go []\\nfunc generate(numRows int) [][]int {\\n    if numRows == 1 {\\n        return [][]int{{1}}\\n    }\\n\\n    triangle := generate(numRows - 1)\\n    prevRow := triangle[len(triangle) - 1]\\n    var newRow []int\\n    newRow = append(newRow, 1)\\n\\n    for i := 1; i < len(prevRow); i++ {\\n        newRow = append(newRow, prevRow[i-1] + prevRow[i])\\n    }\\n\\n    newRow = append(newRow, 1)\\n    triangle = append(triangle, newRow)\\n\\n    return triangle\\n}\\n\\n```\\n\\n---\\n\\n## Method 3. Math (Combinatorics)\\n\\n### Intuition and Logic Behind the Solution\\n\\nThis method uses the mathematical formula for combinations to directly compute the elements of Pascal\\'s Triangle without relying on previous rows. This formula is $$ \\\\binom{n}{k} $$.\\n\\n### Step-by-step Explanation\\n\\n1. **Define the Combination Function**:  \\n   - Use `math.comb()` or a custom function to calculate $$ \\\\binom{n}{k} $$.\\n\\n2. **Direct Row Generation**:  \\n   - For each row $$ n $$ and each index $$ k $$ in that row, directly compute the element using $$ \\\\binom{n}{k} $$.\\n\\n3. **Return the Triangle**:  \\n   - Return the generated triangle.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$O(n^2)$$\\n- **Space Complexity**: $$O(n^2)$$\\n\\n## Code Math\\n``` Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        import math\\n\\n        triangle = []\\n        \\n        for n in range(numRows):\\n            row = []\\n            for k in range(n+1):\\n                row.append(math.comb(n, k))\\n            triangle.append(row)\\n        \\n        return triangle\\n```\\n\\n## Performance\\n\\n| Language     | Method      | Execution Time (ms) | Memory (MB) |\\n|--------------|-------------|---------------------|-------------|\\n| Go           | Recursion          | 0                   | 2.5         |\\n| Rust         | DP          | 1                   | 2.0         |\\n| Java         | DP          | 1                   | 41.2        |\\n| Go           | DP          | 2                   | 2.4         |\\n| PHP          | DP          | 3                   | 19          |\\n| C++          | DP          | 4                   | 6.8         |\\n| Python3      | Recursion   | 27                  | 16.3        |\\n| Python3      | Math        | 35                  | 16.2        |\\n| Python3      | DP          | 40                  | 16.3        |\\n| JavaScript   | DP          | 48                  | 42.1        |\\n| C#           | DP          | 76                  | 36.9        |\\n\\n![p118a.png](https://assets.leetcode.com/users/images/a22d8743-5d37-487b-b720-2a04bbb240d2_1694135797.2657475.png)\\n\\n\\n## Live Coding Recursion\\nhttps://youtu.be/DW5CiB4WBu0?si=Hg1oI3_R6BlA6_X5\\n\\n\\n## Code Highlights and Best Practices\\n\\n- In the Dynamic Programming and Recursion approaches, we build upon previous solutions, making them more intuitive but dependent on previous rows.\\n- The Math approach directly computes each element, making it independent of previous rows but less intuitive.\\n- The Dynamic Programming approach is often the most straightforward and easy to implement.\\n\\nBy understanding these three approaches, you\\'ll be well-equipped to tackle problems that involve generating Pascal\\'s Triangle or similar combinatorial constructs.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 0:\\n            return []\\n        \\n        triangle = [[1]]\\n        \\n        for i in range(1, numRows):\\n            prev_row = triangle[-1]\\n            new_row = [1]\\n            \\n            for j in range(1, len(prev_row)):\\n                new_row.append(prev_row[j-1] + prev_row[j])\\n            \\n            new_row.append(1)\\n            triangle.append(new_row)\\n        \\n        return triangle\\n```\n``` Go []\\nfunc generate(numRows int) [][]int {\\n\\tvar triangle [][]int\\n\\tif numRows == 0 {\\n\\t\\treturn triangle\\n\\t}\\n\\n\\ttriangle = append(triangle, []int{1})\\n\\n\\tfor i := 1; i < numRows; i++ {\\n\\t\\tprevRow := triangle[i-1]\\n\\t\\tvar newRow []int\\n\\t\\tnewRow = append(newRow, 1)\\n\\n\\t\\tfor j := 1; j < len(prevRow); j++ {\\n\\t\\t\\tnewRow = append(newRow, prevRow[j-1]+prevRow[j])\\n\\t\\t}\\n\\n\\t\\tnewRow = append(newRow, 1)\\n\\t\\ttriangle = append(triangle, newRow)\\n\\t}\\n\\n\\treturn triangle\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut triangle = Vec::new();\\n        if num_rows == 0 {\\n            return triangle;\\n        }\\n\\n        triangle.push(vec![1]);\\n\\n        for _ in 1..num_rows {\\n            let prev_row = triangle.last().unwrap();\\n            let mut new_row = vec![1];\\n\\n            for j in 1..prev_row.len() {\\n                new_row.push(prev_row[j-1] + prev_row[j]);\\n            }\\n\\n            new_row.push(1);\\n            triangle.push(new_row);\\n        }\\n\\n        triangle\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n        if (numRows == 0) return triangle;\\n\\n        triangle.push_back({1});\\n\\n        for (int i = 1; i < numRows; ++i) {\\n            vector<int> prev_row = triangle.back();\\n            vector<int> new_row = {1};\\n\\n            for (int j = 1; j < prev_row.size(); ++j) {\\n                new_row.push_back(prev_row[j-1] + prev_row[j]);\\n            }\\n\\n            new_row.push_back(1);\\n            triangle.push_back(new_row);\\n        }\\n\\n        return triangle;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> triangle = new ArrayList<>();\\n        if (numRows == 0) return triangle;\\n\\n        triangle.add(new ArrayList<>());\\n        triangle.get(0).add(1);\\n\\n        for (int i = 1; i < numRows; i++) {\\n            List<Integer> prev_row = triangle.get(i - 1);\\n            List<Integer> new_row = new ArrayList<>();\\n            new_row.add(1);\\n\\n            for (int j = 1; j < prev_row.size(); j++) {\\n                new_row.add(prev_row.get(j - 1) + prev_row.get(j));\\n            }\\n\\n            new_row.add(1);\\n            triangle.add(new_row);\\n        }\\n\\n        return triangle;\\n    }\\n}\\n```\n``` C# []\\nclass Solution {\\n    public IList<IList<int>> Generate(int numRows) {\\n        List<IList<int>> triangle = new List<IList<int>>();\\n        if (numRows == 0) return triangle;\\n\\n        triangle.Add(new List<int>() { 1 });\\n\\n        for (int i = 1; i < numRows; i++) {\\n            List<int> prevRow = (List<int>)triangle[i - 1];\\n            List<int> newRow = new List<int> { 1 };\\n\\n            for (int j = 1; j < prevRow.Count; j++) {\\n                newRow.Add(prevRow[j - 1] + prevRow[j]);\\n            }\\n\\n            newRow.Add(1);\\n            triangle.Add(newRow);\\n        }\\n\\n        return triangle;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let triangle = [];\\n    if (numRows === 0) return triangle;\\n\\n    triangle.push([1]);\\n\\n    for (let i = 1; i < numRows; i++) {\\n        let prevRow = triangle[i - 1];\\n        let newRow = [1];\\n\\n        for (let j = 1; j < prevRow.length; j++) {\\n            newRow.push(prevRow[j - 1] + prevRow[j]);\\n        }\\n\\n        newRow.push(1);\\n        triangle.push(newRow);\\n    }\\n\\n    return triangle;\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function generate($numRows) {\\n    $triangle = [];\\n    if ($numRows == 0) return $triangle;\\n\\n    $triangle[] = [1];\\n\\n    for ($i = 1; $i < $numRows; $i++) {\\n        $prevRow = end($triangle);\\n        $newRow = [1];\\n\\n        for ($j = 1; $j < count($prevRow); $j++) {\\n            $newRow[] = $prevRow[$j - 1] + $prevRow[$j];\\n        }\\n\\n        $newRow[] = 1;\\n        $triangle[] = $newRow;\\n    }\\n\\n    return $triangle;\\n}\\n}\\n```\n``` Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        triangle = self.generate(numRows - 1)\\n        \\n        prev_row = triangle[-1]\\n        new_row = [1]\\n        \\n        for i in range(1, len(prev_row)):\\n            new_row.append(prev_row[i-1] + prev_row[i])\\n        \\n        new_row.append(1)\\n        triangle.append(new_row)\\n        \\n        return triangle\\n```\n``` Go []\\nfunc generate(numRows int) [][]int {\\n    if numRows == 1 {\\n        return [][]int{{1}}\\n    }\\n\\n    triangle := generate(numRows - 1)\\n    prevRow := triangle[len(triangle) - 1]\\n    var newRow []int\\n    newRow = append(newRow, 1)\\n\\n    for i := 1; i < len(prevRow); i++ {\\n        newRow = append(newRow, prevRow[i-1] + prevRow[i])\\n    }\\n\\n    newRow = append(newRow, 1)\\n    triangle = append(triangle, newRow)\\n\\n    return triangle\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        import math\\n\\n        triangle = []\\n        \\n        for n in range(numRows):\\n            row = []\\n            for k in range(n+1):\\n                row.append(math.comb(n, k))\\n            triangle.append(row)\\n        \\n        return triangle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301854,
                "title": "java-c-beautiful-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/cafe33b5-40ce-49ad-9863-bf1a0c6c8dcc_1658199351.4939024.gif)\\n\\n```\\nIntution\\n```\\nWhen you see the image above, you get a pretty good idea of what you are supposed to do here. Think about the image as a matrix now where each line is basically a row in the matrix. So, first things first, if you are at the edge of the matrix, the value is 1, that\\u2019s for sure. Now, what about the inner elements? Well, any inner element is obtained by doing the sum of the 2 values present in the row just above it, i.e., if the element is at **index (i, j)**, then `matrix[i][j]` can be obtained by doing `matrix[i \\u2013 1][j \\u2013 1] + matrix[i \\u2013 1][j]`.\\n\\n```\\nApproach\\n```\\nTo solve the problem, we need to first create an array of size N or numRows (input value). This array is used to store each of the rows expected in the output, so, for example, **array[1] = [1,1]**. In this array, the number of columns (say, numCols) is equal to the number of the **i-th row + 1** (Since, 0-indexed), i.e., for 0-th row, **numCols = 1**. So, the number of columns is different for each row.\\n\\nNext, we need to run a loop from **i = 0 to numRows \\u2013 1** (inclusive) in order to store each row in our array. For each of iteration of this loop, we follow the below steps:\\n\\n* Create an array of size **(i + 1)** *(For some languages such as C++, you need to create a 2D array at the start of the program and resize array[i] to (i + 1)).*\\n\\n\\n* Set the first and last value of **array[i] to 1.**\\n* Run another loop from **j = 1 to i \\u2013 1** (inclusive) and for each iteration put `array[i][j] = array[i \\u2013 1][j \\u2013 1] + array[i \\u2013 1][j].`\\n\\nAfter iterating numRows times, you return the array.\\n\\n```\\nDry Run\\n```\\n\\nLet\\u2019s do a dry run to understand it in a much better way.\\n\\n**Input**: numRows = 5\\n**Output**: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\\n\\n* Step \\u2013 I: Initialized an array of size numRows, `array = [[],[],[],[],[]]`\\n* Step \\u2013 II: Run a loop from **i = 0 to numRows \\u2013 1**\\n\\n```\\nAt i = 0:\\n\\n> We resize the first row of the array to (i + 1) = (0 + 1) = 1, so array = [[0],[],[],[],[]].\\n> Set the first and last value of array[i] = 1, so, array[0][0] = 1 and array[0][i] = 1. Therefore, array = [[1],[],[],[],[]]\\n> Since, i = 0, the nested for loop does not satisfy the running criteria and hence does not get executed.\\n```\\n\\n```\\nAt i = 1:\\n\\n> We resize the second row of the array to (i + 1) = (1 + 1) = 2, so array = [[1],[0,0],[],[],[]].\\n> Set the first and last value of array[i] = 1, so, array[1][0] = 1 and array[1][i] = 1. Therefore, array = [[1],[1,1],[],[],[]]\\n> Since, i = 1, the nested for loop does not satisfy the running criteria and hence does not get executed.\\n```\\n\\n```\\nAt i = 2:\\n\\n> We resize the third row of the array to (i + 1) = (2 + 1) = 3, so array = [[1],[1,1],[0,0,0],[],[]].\\n> Set the first and last value of array[i] = 1, so, array[2][0] = 1 and array[2][i] = 1. Therefore, array = [[1],[1,1],[1,0,1],[],[]]\\n> Run a loop from j = 1 to i \\u2013 1:\\n\\n> At j = 1:\\narray[i][j] = array[i \\u2013 1][j \\u2013 1] + array[i \\u2013 1][j]  = array[1][0] + array[1][1] = 1 + 1 = 2\\n```\\n\\nSo, `array = [[1],[1,1],[1,2,1],[],[]]`\\n\\n* At **i = 3 and i = 4**, we follow the same approach to fill the two rows of the array and get `array = [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]].`\\n* Step \\u2013 III: **Return array.**\\n\\n**Java**\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\tList<Integer> row, pre = null;\\n\\t\\tfor (int i = 0; i < numRows; ++i) {\\n\\t\\t\\trow = new ArrayList<Integer>();\\n\\t\\t\\tfor (int j = 0; j <= i; ++j)\\n\\t\\t\\t\\tif (j == 0 || j == i)\\n\\t\\t\\t\\t\\trow.add(1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\trow.add(pre.get(j - 1) + pre.get(j));\\n\\t\\t\\tpre = row;\\n\\t\\t\\tres.add(row);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n```\\n\\nANALYSIS:-\\n* **Time Complexity:-** We are creating a 2D array of size **(numRows * numCols) (where 1 <= numCols <= numRows)**, and we are traversing through each of the cells to update it with its correct value, so Time Complexity = O(N^2).\\n\\n* **Space Complexity:-** Since we are creating a 2D array, space complexity = O(N^2).",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nIntution\\n```\n```\\nApproach\\n```\n```\\nDry Run\\n```\n```\\nAt i = 0:\\n\\n> We resize the first row of the array to (i + 1) = (0 + 1) = 1, so array = [[0],[],[],[],[]].\\n> Set the first and last value of array[i] = 1, so, array[0][0] = 1 and array[0][i] = 1. Therefore, array = [[1],[],[],[],[]]\\n> Since, i = 0, the nested for loop does not satisfy the running criteria and hence does not get executed.\\n```\n```\\nAt i = 1:\\n\\n> We resize the second row of the array to (i + 1) = (1 + 1) = 2, so array = [[1],[0,0],[],[],[]].\\n> Set the first and last value of array[i] = 1, so, array[1][0] = 1 and array[1][i] = 1. Therefore, array = [[1],[1,1],[],[],[]]\\n> Since, i = 1, the nested for loop does not satisfy the running criteria and hence does not get executed.\\n```\n```\\nAt i = 2:\\n\\n> We resize the third row of the array to (i + 1) = (2 + 1) = 3, so array = [[1],[1,1],[0,0,0],[],[]].\\n> Set the first and last value of array[i] = 1, so, array[2][0] = 1 and array[2][i] = 1. Therefore, array = [[1],[1,1],[1,0,1],[],[]]\\n> Run a loop from j = 1 to i \\u2013 1:\\n\\n> At j = 1:\\narray[i][j] = array[i \\u2013 1][j \\u2013 1] + array[i \\u2013 1][j]  = array[1][0] + array[1][1] = 1 + 1 = 2\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\tList<Integer> row, pre = null;\\n\\t\\tfor (int i = 0; i < numRows; ++i) {\\n\\t\\t\\trow = new ArrayList<Integer>();\\n\\t\\t\\tfor (int j = 0; j <= i; ++j)\\n\\t\\t\\t\\tif (j == 0 || j == i)\\n\\t\\t\\t\\t\\trow.add(1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\trow.add(pre.get(j - 1) + pre.get(j));\\n\\t\\t\\tpre = row;\\n\\t\\t\\tres.add(row);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38150,
                "title": "my-c-code-0ms",
                "content": "just do it in a straightforward, each time generate a new line, first push all 1 vector into res and then update the elements from 1 to i-1.\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> generate(int numRows) {\\n            vector<vector<int>> res;\\n            for(auto i=0;i<numRows;++i)\\n            {\\n                res.push_back(vector<int>(i+1,1));\\n                for(auto j=1; j<i; ++j) res[i][j] = res[i-1][j-1] + res[i-1][j];\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> generate(int numRows) {\\n            vector<vector<int>> res;\\n            for(auto i=0;i<numRows;++i)\\n            {\\n                res.push_back(vector<int>(i+1,1));\\n                for(auto j=1; j<i; ++j) res[i][j] = res[i-1][j-1] + res[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1490520,
                "title": "python3-easy-code-faster-than-96-67",
                "content": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        l=[0]*numRows\\n        for i in range(numRows):\\n            l[i]=[0]*(i+1)\\n            l[i][0]=1\\n            l[i][i]=1\\n            for j in range(1,i):\\n                l[i][j]=l[i-1][j-1]+l[i-1][j]\\n        return l\\n```\\nFor any doubts or suggestions, please **comment**\\n**Upvote**, if you liked the code",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        l=[0]*numRows\\n        for i in range(numRows):\\n            l[i]=[0]*(i+1)\\n            l[i][0]=1\\n            l[i][i]=1\\n            for j in range(1,i):\\n                l[i][j]=l[i-1][j-1]+l[i-1][j]\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443512,
                "title": "python-build-rows-by-rows-super-clean-concise",
                "content": "![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\\n\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        rows = [[1]]\\n        for r in range(1, numRows):\\n            rows.append([1] * (r+1))\\n            for c in range(1, r):\\n                rows[r][c] = rows[r-1][c] + rows[r-1][c-1]\\n        return rows                \\n```\\nComplexity:\\n- Time: `O(N^2)`, where `N <= 30` is number of rows. \\n- Space: `O(N^2)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        rows = [[1]]\\n        for r in range(1, numRows):\\n            rows.append([1] * (r+1))\\n            for c in range(1, r):\\n                rows[r][c] = rows[r-1][c] + rows[r-1][c-1]\\n        return rows                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 38260,
                "title": "java-clean-code-1ms-dp",
                "content": "    public class Solution {\\n    \\tpublic List<List<Integer>> generate(int numRows) {\\n    \\t\\tList<List<Integer>> res = new ArrayList<List<Integer>>();\\n    \\t\\tList<Integer> row, pre = null;\\n    \\t\\tfor (int i = 0; i < numRows; ++i) {\\n    \\t\\t\\trow = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int j = 0; j <= i; ++j)\\n    \\t\\t\\t\\tif (j == 0 || j == i)\\n    \\t\\t\\t\\t\\trow.add(1);\\n    \\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\trow.add(pre.get(j - 1) + pre.get(j));\\n    \\t\\t\\tpre = row;\\n    \\t\\t\\tres.add(row);\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tpublic List<List<Integer>> generate(int numRows) {\\n    \\t\\tList<List<Integer>> res = new ArrayList<List<Integer>>();\\n    \\t\\tList<Integer> row, pre = null;\\n    \\t\\tfor (int i = 0; i < numRows; ++i) {\\n    \\t\\t\\trow = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int j = 0; j <= i; ++j)\\n    \\t\\t\\t\\tif (j == 0 || j == i)\\n    \\t\\t\\t\\t\\trow.add(1);\\n    \\t\\t\\t\\telse\\n    \\t\\t\\t\\t\\trow.add(pre.get(j - 1) + pre.get(j));\\n    \\t\\t\\tpre = row;\\n    \\t\\t\\tres.add(row);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 153969,
                "title": "concise-javascript-solution",
                "content": "This takes advantage of the fact that each row can be calculated by the offset sum of the previous row.\\n\\n```\\n  1 2 1 0\\n+ 0 1 2 1\\n  -------\\n  1 3 3 1\\n```\\n\\nI realize it\\'s probably not the most well-optimized, but hopefully this will help somebody as a springboard to a better JavaScript implementation using this concept.\\n\\n```\\nfunction calculatePascal(numRows) {\\n  if (!numRows || numRows <= 0) return [];\\n\\n  const pascal = [[1]];\\n\\n  for (let i = 1; i < numRows; i++) {\\n    const prevRow = pascal[pascal.length - 1];\\n    const shiftLeft = [...prevRow, 0];\\n    const shiftRight = [0, ...prevRow];\\n    \\n    const currentRow = shiftLeft.map((r, i) => r + shiftRight[i]);\\n    pascal.push(currentRow);\\n  }\\n\\n  return pascal;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n  1 2 1 0\\n+ 0 1 2 1\\n  -------\\n  1 3 3 1\\n```\n```\\nfunction calculatePascal(numRows) {\\n  if (!numRows || numRows <= 0) return [];\\n\\n  const pascal = [[1]];\\n\\n  for (let i = 1; i < numRows; i++) {\\n    const prevRow = pascal[pascal.length - 1];\\n    const shiftLeft = [...prevRow, 0];\\n    const shiftRight = [0, ...prevRow];\\n    \\n    const currentRow = shiftLeft.map((r, i) => r + shiftRight[i]);\\n    pascal.push(currentRow);\\n  }\\n\\n  return pascal;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626079,
                "title": "0-ms-shortest-c-solution",
                "content": "```\\n\\tvector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> res;\\n        for(int i = 0; i < numRows; i++) {\\n            res.push_back(vector<int>(i+1,1));\\n            for(int j = 1; j < i; j++)\\n                res[i][j] = res[i-1][j-1] + res[i-1][j];\\n        }\\n        return res;\\n    }\\n```\\n\\n***Another similar question : Pascal\\'s Triangle II*** [https://leetcode.com/problems/pascals-triangle-ii/discuss/2626185/0-ms-beats-100-9919-possibly-best-solution-with-explanation](http://)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tvector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> res;\\n        for(int i = 0; i < numRows; i++) {\\n            res.push_back(vector<int>(i+1,1));\\n            for(int j = 1; j < i; j++)\\n                res[i][j] = res[i-1][j-1] + res[i-1][j];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2301636,
                "title": "c-100-easy-to-understand-beginner-friendly",
                "content": "# 118. Pascal\\'s Triangle\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**Image it self visualises what need to be done, so see how we are going to acheive it**\\n![image](https://assets.leetcode.com/users/images/2ed8e682-eccb-490c-a560-017ea3a6e621_1658202693.740435.gif)\\n\\n\\n\\n\\n**ALGORITHM**\\n\\n* **BruteForce , A Simple Solution that I guarranty you will understand..**\\n* Now Read these Steps.\\n* \\t**Consider These Edge Cases First.**\\n* \\t**Declare** a **ans 2-d vector**.\\n* let **take the edge case for n == 1**, than you just push {1} in ans vector.\\n* let take **n == 2** you just **push again a {1,1} in your answer vector.**\\n* now onward **n is greater than or equal toh 3** so you **need to make the solution using upper rows.**\\n* See **how we acheive this**.\\n* **Follow the edges** cases in this too, \\n* Now take a **variable level** and **initialise it with 2** as you have done for two levels.\\n* **Itearate  a fow loop from 1** as **2 rows are already formed**, and **iterate till n-1** as we need n-1 rows ( array index start from 0).\\n* now **declare a vector and iterated another for loop from 0 to  less than equal to level.**\\n* now we **need to take care of edge cases** because when we are **at the starting and last index.**\\n*  **we have to keep the same element as it in previous row.**\\n*  we will acces those element from our ans vector, i.e **ans[i][0] this will be the first element of our new row.**\\n*  and, **ans[i][level - 1] this will be the last element or our new row.**\\n*  And, the **reaminng elements are the sum of previouse row prior 2 element**, which we will **calculate from, ans[i][j-1] + ans[i]][j];**\\n*  At the end **return ans vector.**\\n\\n![image](https://assets.leetcode.com/users/images/74ddc51e-4978-4bfe-bb3f-35a3ca14728d_1658195043.6267989.png)\\n\\n\\n**CODE**\\n```\\n//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        \\n        int n =  numRows;\\n        \\n        vector<vector<int>> ans;\\n        if( n == 1)\\n        {\\n\\t\\t\\t// edge case just push {1} to ans vec tor\\n            ans.push_back({1});\\n        }\\n        if(n == 2)\\n        {\\n\\t\\t\\t// edge case just push {1}  and {1,1}  ans vec tor\\n            ans.push_back({1});\\n            ans.push_back({1,1});\\n        }\\n        \\n        if(n >=3)\\n        {\\n\\t\\t\\t// repeat these prior steps\\n            ans.push_back({1});\\n            ans.push_back({1,1});\\n            \\n\\t\\t\\t// an variable which will tell us how many element to put on current row\\n            int level = 2;\\n            \\n            for(int i = 1; i<n-1; ++i)\\n            {\\n                vector<int> v;\\n                for(int j = 0; j<= level; ++j)\\n                {\\n\\t\\t\\t\\t\\t// edges case first element of current row has to be first element of prev row.\\n                    if(j == 0)\\n                        v.push_back(ans[i][0]);\\n                    else if(j == level)\\n                    {\\n\\t\\t\\t\\t\\t\\t\\t// edges case last element of current row has to be last element of prev row.\\n                        v.push_back(ans[i][level-1]);\\n                    }\\n                    else\\n                    {\\n                        v.push_back(ans[i][j-1] + ans[i][j]);\\n                    }    \\n                }\\n                ++level;\\n                ans.push_back(v);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**And Same This can be acheived by this too the algorithm is  same how we using prior row to create new row.**\\n* **So if you gone through above algorithm you will understand how the same is acheived by this piece of code.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> generate(int numRows) {\\n        for(int i = 0; i<numRows; ++i)\\n        {\\n            vector<int> row(i+1, 1);\\n            for(int j = 1; j<i; ++j)\\n                row[j] = ans[i-1][j] + ans[i-1][j-1];\\n            ans.push_back(row);\\n        }\\n        return ans;\\n    }\\n    \\n};\\n\\n```\\n\\n**APPROACH 3 Inspired by** @limgit\\n**[]Linear Time Complexity O(n)[]\\nresize() operatesLinearly**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans = {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}, {1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1}, {1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1}, {1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1}};\\n        \\n        ans.resize(numRows);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Please Upvote if it helps\\u2B06\\uFE0F\\n5. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n```\\n//\\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        \\n        int n =  numRows;\\n        \\n        vector<vector<int>> ans;\\n        if( n == 1)\\n        {\\n\\t\\t\\t// edge case just push {1} to ans vec tor\\n            ans.push_back({1});\\n        }\\n        if(n == 2)\\n        {\\n\\t\\t\\t// edge case just push {1}  and {1,1}  ans vec tor\\n            ans.push_back({1});\\n            ans.push_back({1,1});\\n        }\\n        \\n        if(n >=3)\\n        {\\n\\t\\t\\t// repeat these prior steps\\n            ans.push_back({1});\\n            ans.push_back({1,1});\\n            \\n\\t\\t\\t// an variable which will tell us how many element to put on current row\\n            int level = 2;\\n            \\n            for(int i = 1; i<n-1; ++i)\\n            {\\n                vector<int> v;\\n                for(int j = 0; j<= level; ++j)\\n                {\\n\\t\\t\\t\\t\\t// edges case first element of current row has to be first element of prev row.\\n                    if(j == 0)\\n                        v.push_back(ans[i][0]);\\n                    else if(j == level)\\n                    {\\n\\t\\t\\t\\t\\t\\t\\t// edges case last element of current row has to be last element of prev row.\\n                        v.push_back(ans[i][level-1]);\\n                    }\\n                    else\\n                    {\\n                        v.push_back(ans[i][j-1] + ans[i][j]);\\n                    }    \\n                }\\n                ++level;\\n                ans.push_back(v);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<vector<int>> generate(int numRows) {\\n        for(int i = 0; i<numRows; ++i)\\n        {\\n            vector<int> row(i+1, 1);\\n            for(int j = 1; j<i; ++j)\\n                row[j] = ans[i-1][j] + ans[i-1][j-1];\\n            ans.push_back(row);\\n        }\\n        return ans;\\n    }\\n    \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans = {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}, {1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1}, {1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1}, {1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1}};\\n        \\n        ans.resize(numRows);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439724,
                "title": "easy-to-understand-python3-code-using-append",
                "content": "I made the code as simple as possible with the purpose of being readable (not short). It first calculates each element, appends that element to the row, and then append the row to the triangle. Each element of a row is calculated based on the previous row. The exception is first and last elements of each row (which are 1). \\n\\n```\\n        if numRows   == 0: return []\\n        elif numRows == 1: return [[1]]\\n        Tri = [[1]]\\n        for i in range(1,numRows):\\n            row = [1]\\n            for j in range(1,i):\\n                row.append(Tri[i-1][j-1] + Tri[i-1][j]) \\n            row.append(1)\\n            Tri.append(row)\\n        return Tri\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        if numRows   == 0: return []\\n        elif numRows == 1: return [[1]]\\n        Tri = [[1]]\\n        for i in range(1,numRows):\\n            row = [1]\\n            for j in range(1,i):\\n                row.append(Tri[i-1][j-1] + Tri[i-1][j]) \\n            row.append(1)\\n            Tri.append(row)\\n        return Tri\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216062,
                "title": "python-with-explanations",
                "content": "```\\nIf we mark each number in triangle as (row, col) as below\\n         [(0,1)],\\n      [(1,0),(1,1)],\\n   [(2,0),(2,1),(2,2)]\\n \\nWe observe that\\n1) (i, j) = (i - 1, j - 1) + (i - 1, j) for i is row number, j is column number (both starting at 0)\\n2) row i (starting at 0) has i + 1 elements\\n```\\n****\\n```\\n    def generate(self, numRows):\\n        if numRows == 0:\\n            return []\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        res = [[1]]\\n        \\n        for x in range(1, numRows): \\n            # Build a new row.\\n            row = []\\n            row.append(1)\\n            if x > 1:\\n                for y in range(1, x): \\n                    row.append(lastRow[y] + lastRow[y - 1])\\n            row.append(1)\\n            \\n            lastRow = row\\n            \\n            res.append(list(row))\\n        \\n        return res\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nIf we mark each number in triangle as (row, col) as below\\n         [(0,1)],\\n      [(1,0),(1,1)],\\n   [(2,0),(2,1),(2,2)]\\n \\nWe observe that\\n1) (i, j) = (i - 1, j - 1) + (i - 1, j) for i is row number, j is column number (both starting at 0)\\n2) row i (starting at 0) has i + 1 elements\\n```\n```\\n    def generate(self, numRows):\\n        if numRows == 0:\\n            return []\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        res = [[1]]\\n        \\n        for x in range(1, numRows): \\n            # Build a new row.\\n            row = []\\n            row.append(1)\\n            if x > 1:\\n                for y in range(1, x): \\n                    row.append(lastRow[y] + lastRow[y - 1])\\n            row.append(1)\\n            \\n            lastRow = row\\n            \\n            res.append(list(row))\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 38220,
                "title": "recursive-solution-java-1-ms",
                "content": "```\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        generate(list, numRows);\\n        return list;\\n        \\n    }\\n    \\n    public void generate(List<List<Integer>> list, int numRows) {\\n        if (numRows == 1) list.add(Arrays.asList(1));\\n        else if (numRows > 1) {\\n            generate(list, numRows -1);\\n            List<Integer> previousList = list.get(numRows -2);\\n            List<Integer> thisList = new ArrayList<>();\\n            for (int i = 0; i < previousList.size(); i++) {\\n                if (i == 0) thisList.add(1);\\n                if (i > 0) thisList.add(previousList.get(i) + previousList.get(i-1));\\n                if (i == previousList.size() -1) thisList.add(1);\\n            }\\n            list.add(thisList);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        generate(list, numRows);\\n        return list;\\n        \\n    }\\n    \\n    public void generate(List<List<Integer>> list, int numRows) {\\n        if (numRows == 1) list.add(Arrays.asList(1));\\n        else if (numRows > 1) {\\n            generate(list, numRows -1);\\n            List<Integer> previousList = list.get(numRows -2);\\n            List<Integer> thisList = new ArrayList<>();\\n            for (int i = 0; i < previousList.size(); i++) {\\n                if (i == 0) thisList.add(1);\\n                if (i > 0) thisList.add(previousList.get(i) + previousList.get(i-1));\\n                if (i == previousList.size() -1) thisList.add(1);\\n            }\\n            list.add(thisList);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1666411,
                "title": "c-solution-with-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n## Explanation:\\n\\n### Solution 01\\n\\n- Type: Return n lines of Pascal Triangle.\\n- We took vector of vector ***ans*** of size n.\\n- As we know ***i-th*** row will have ***i+1*** elements, so we resized the vector.\\n- Initialize the first and the last element of every vector with 1.\\n- In pascal triangle element of ***array[row][column]*** will be the sum of 2 elements of the previous row: ***array[row-1][column-1]*** & ***array[row-1][column].***\\n- **Time complexity:** O(n^2).\\n\\n### Similar type questions:\\n\\n### Type 01\\n\\n- Return an element of Pascal Triangle which row & column is given.\\n- Can be solved with a simple formula: (r-1)C(c-1).\\n- **Time complexity:** O(n).\\n\\n### Type 02\\n\\n- Return a specific row of the Pascal Triangle.\\n- Run loop & use the same formula of type 1.\\n- Edge cases: first and last element will be 1.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1);\\n            ans[i][0] = ans[i][i] = 1;\\n            \\n            for(int j=1; j<i; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1);\\n            ans[i][0] = ans[i][i] = 1;\\n            \\n            for(int j=1; j<i; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306460,
                "title": "intuitive-solution-as-if-you-solved-it-by-hand-java",
                "content": "This solution mimics how you would fill out Pascals triangle by hand, which is why it is intuitive.\\n1) Start by creating the first row of just 1\\n2) On each iteration, always add the first 1 and ending 1 separately from the middle numbers\\n3) The middle numbers are just index `j-1` and `j` from the previous row\\n```\\nclass Solution {\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    if (numRows == 0) return result;\\n\\n    result.add(new ArrayList<>(Arrays.asList(1))); // seed first row\\n\\n    for (int i = 1; i < numRows; i++) { // starting from second row because we seeded the first\\n      List<Integer> row = new ArrayList<>();\\n      row.add(1); // add first 1 in each row\\n\\t  \\n      for (int j = 1; j < i; j++) {\\n        int left = result.get(i-1).get(j-1);\\n        int right = result.get(i-1).get(j);\\n        row.add(left + right); \\n      }\\n\\t  \\n      row.add(1); // add last 1 to each row\\n      result.add(row);\\n    }\\n\\n    return result;\\n  }\\n}\\n```\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    if (numRows == 0) return result;\\n\\n    result.add(new ArrayList<>(Arrays.asList(1))); // seed first row\\n\\n    for (int i = 1; i < numRows; i++) { // starting from second row because we seeded the first\\n      List<Integer> row = new ArrayList<>();\\n      row.add(1); // add first 1 in each row\\n\\t  \\n      for (int j = 1; j < i; j++) {\\n        int left = result.get(i-1).get(j-1);\\n        int right = result.get(i-1).get(j);\\n        row.add(left + right); \\n      }\\n\\t  \\n      row.add(1); // add last 1 to each row\\n      result.add(row);\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040184,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>(i+1);\\n            while (row.size() <= i) row.add(1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans.get(i-1).get(j-1) + ans.get(i-1).get(j);\\n                row.set(j, val);\\n                row.set(row.size()-j-1, val);\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nvector<vector<int>> generate(int numRows) {\\n\\tvector<vector<int>> ret;\\n\\tfor (int i = 0; i < numRows; i++) {\\n\\t\\tvector<int> row(i + 1, 1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\trow[j] = ret[i - 1][j] + ret[i - 1][j - 1];\\n\\t\\t}\\n\\t\\tret.push_back(row);\\n\\t}\\n\\treturn ret;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans = [None] * numRows\\n        for i in range(numRows):\\n            row, mid = [1] * (i + 1), (i >> 1) + 1\\n            for j in range(1, mid):\\n                val = ans[i-1][j-1] + ans[i-1][j]\\n                row[j], row[len(row)-j-1] = val, val\\n            ans[i] = row\\n        return ans\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar generate = function(numRows) {\\n    let ans = new Array(numRows)\\n    for (let i = 0; i < numRows; i++) {\\n        let row = new Uint32Array(i+1).fill(1),\\n            mid = i >> 1\\n        for (let j = 1; j <= mid; j++) {\\n            let val = ans[i-1][j-1] + ans[i-1][j]\\n            row[j] = val, row[row.length-j-1] = val\\n        }\\n        ans[i] = row\\n    }\\n    return ans\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\n  fun generate(numRows: Int): List<List<Int>> {\\n    val rows = mutableListOf<List<Int>>()\\n    \\n    val pascaleLineMap = mutableMapOf<Int, List<Int>>()\\n    for (lineNumber in 1..numRows) {\\n      rows.add(pascaleLine(lineNumber, pascaleLineMap))\\n    }\\n    \\n    return rows\\n  }\\n  \\n  private fun pascaleLine(\\n    lineNumber: Int,\\n    pascaleLineMap: MutableMap<Int, List<Int>>\\n  ): List<Int> {\\n    if (lineNumber == 1) return listOf(1)\\n    if (lineNumber == 2) return listOf(1, 1)\\n    \\n    if (pascaleLineMap.containsKey(lineNumber)) return pascaleLineMap[lineNumber]!!\\n    \\n    val row = mutableListOf<Int>()\\n    row.add(1)\\n    \\n    val previous = pascaleLine(lineNumber - 1, pascaleLineMap)\\n    for (i in 1 until lineNumber - 1) {\\n      row.add(previous[i - 1] + previous[i])\\n    }\\n    \\n    row.add(1)\\n    \\n    return row\\n      .also { pascaleLineMap[lineNumber] = it }\\n  }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func generate(_ numRows: Int) -> [[Int]] {        \\n       var matrix = Array(repeating: Array(repeating: 0, count: numRows), count: numRows)\\n       for i in 0..<numRows {\\n           matrix[i][0] = 1\\n           for j in 1..<numRows where i > 0 {\\n               matrix[i][j] = matrix[i-1][j] + matrix[i-1][j-1]\\n          }          \\n       }        \\n       return matrix.compactMap{ $0.filter { $0 > 0 }}\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>(i+1);\\n            while (row.size() <= i) row.add(1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans.get(i-1).get(j-1) + ans.get(i-1).get(j);\\n                row.set(j, val);\\n                row.set(row.size()-j-1, val);\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nvector<vector<int>> generate(int numRows) {\\n\\tvector<vector<int>> ret;\\n\\tfor (int i = 0; i < numRows; i++) {\\n\\t\\tvector<int> row(i + 1, 1);\\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\trow[j] = ret[i - 1][j] + ret[i - 1][j - 1];\\n\\t\\t}\\n\\t\\tret.push_back(row);\\n\\t}\\n\\treturn ret;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans = [None] * numRows\\n        for i in range(numRows):\\n            row, mid = [1] * (i + 1), (i >> 1) + 1\\n            for j in range(1, mid):\\n                val = ans[i-1][j-1] + ans[i-1][j]\\n                row[j], row[len(row)-j-1] = val, val\\n            ans[i] = row\\n        return ans\\n```\n```\\n```\n```\\n```\n```\\nvar generate = function(numRows) {\\n    let ans = new Array(numRows)\\n    for (let i = 0; i < numRows; i++) {\\n        let row = new Uint32Array(i+1).fill(1),\\n            mid = i >> 1\\n        for (let j = 1; j <= mid; j++) {\\n            let val = ans[i-1][j-1] + ans[i-1][j]\\n            row[j] = val, row[row.length-j-1] = val\\n        }\\n        ans[i] = row\\n    }\\n    return ans\\n};\\n```\n```\\n```\n```\\n```\n```\\n  fun generate(numRows: Int): List<List<Int>> {\\n    val rows = mutableListOf<List<Int>>()\\n    \\n    val pascaleLineMap = mutableMapOf<Int, List<Int>>()\\n    for (lineNumber in 1..numRows) {\\n      rows.add(pascaleLine(lineNumber, pascaleLineMap))\\n    }\\n    \\n    return rows\\n  }\\n  \\n  private fun pascaleLine(\\n    lineNumber: Int,\\n    pascaleLineMap: MutableMap<Int, List<Int>>\\n  ): List<Int> {\\n    if (lineNumber == 1) return listOf(1)\\n    if (lineNumber == 2) return listOf(1, 1)\\n    \\n    if (pascaleLineMap.containsKey(lineNumber)) return pascaleLineMap[lineNumber]!!\\n    \\n    val row = mutableListOf<Int>()\\n    row.add(1)\\n    \\n    val previous = pascaleLine(lineNumber - 1, pascaleLineMap)\\n    for (i in 1 until lineNumber - 1) {\\n      row.add(previous[i - 1] + previous[i])\\n    }\\n    \\n    row.add(1)\\n    \\n    return row\\n      .also { pascaleLineMap[lineNumber] = it }\\n  }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func generate(_ numRows: Int) -> [[Int]] {        \\n       var matrix = Array(repeating: Array(repeating: 0, count: numRows), count: numRows)\\n       for i in 0..<numRows {\\n           matrix[i][0] = 1\\n           for j in 1..<numRows where i > 0 {\\n               matrix[i][j] = matrix[i-1][j] + matrix[i-1][j-1]\\n          }          \\n       }        \\n       return matrix.compactMap{ $0.filter { $0 > 0 }}\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979266,
                "title": "simple-java-solution-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows == 0) return new ArrayList();\\n        List<List<Integer>> res = new ArrayList();\\n\\n        for(int i = 1; i <= numRows; i++){\\n            List<Integer> row = new ArrayList();\\n            for(int j = 0 ; j < i ; j++){\\n                if(j == 0  || j== i-1){\\n                    row.add(1);\\n                }else{\\n                    row.add(res.get(i-2).get(j) + res.get(i-2).get(j-1));\\n                }       \\n            }\\n            res.add(row);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows == 0) return new ArrayList();\\n        List<List<Integer>> res = new ArrayList();\\n\\n        for(int i = 1; i <= numRows; i++){\\n            List<Integer> row = new ArrayList();\\n            for(int j = 0 ; j < i ; j++){\\n                if(j == 0  || j== i-1){\\n                    row.add(1);\\n                }else{\\n                    row.add(res.get(i-2).get(j) + res.get(i-2).get(j-1));\\n                }       \\n            }\\n            res.add(row);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016175,
                "title": "video-beats-97-21-python-javascript-java-c",
                "content": "# Main point of the Solution\\n\\nThe main point of this solution is to generate Pascal\\'s triangle, up to a specified number of rows, by iteratively constructing each row based on the previous one. It initializes with the first row containing a single \"1,\" then iterates through the desired number of rows, creating each row by adding zeros at both ends of the previous row, and calculating the inner values as sums of adjacent elements.\\n\\nThis Python solution beats 97.61%\\n\\n![Screen Shot 2023-09-08 at 9.15.28.png](https://assets.leetcode.com/users/images/a18c8c4b-82ec-4e31-b0e3-dfa0c6e27ee9_1694132390.838179.png)\\n\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 257 videos as of September 8th, 2023.\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/oiO0ov9SSF8\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2253\\nThank you for your support!\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize the result list `res` with a single row containing the value 1.\\n   - Explanation: The `res` list will store the generated Pascal\\'s triangle.\\n\\n2. Use a for loop to iterate `numRows - 1` times.\\n   - Explanation: We need to generate a total of `numRows` rows in Pascal\\'s triangle, so we start with one row already added in `res`.\\n\\n3. Create a `dummy_row` by adding a 0 at the beginning and end of the last row in `res`.\\n   - Explanation: In Pascal\\'s triangle, each row begins and ends with a 1, so we add a 0 on both sides of the previous row to calculate the values for the current row.\\n\\n4. Initialize an empty list `row` to store the values of the current row.\\n\\n5. Use a for loop to iterate over the indices of `dummy_row`.\\n   - Explanation: We iterate through `dummy_row` to calculate the values of the current row by adding pairs of adjacent values from `dummy_row`.\\n\\n6. Inside the loop, calculate the sum of `dummy_row[i]` and `dummy_row[i+1]` and append it to the `row` list.\\n   - Explanation: Each value in the current row is the sum of the two values directly above it in the `dummy_row`.\\n\\n7. After the loop completes, append the `row` list to the `res` list.\\n   - Explanation: The calculated values for the current row are added to the `res` list.\\n\\n8. Repeat steps 3-7 for a total of `numRows - 1` times to generate the required number of rows.\\n\\n9. Once the loop finishes, return the `res` list containing Pascal\\'s triangle.\\n\\nIn summary, this code generates Pascal\\'s triangle up to the specified number of rows by iteratively calculating each row based on the previous row using the principle that each value in a row is the sum of the two values directly above it.\\n\\n# Complexity\\n- **Time complexity: O(n^2)** where n is numRows\\n\\n    - The outer for loop iterates numRows - 1 times.\\n    - Inside the loop, we perform operations that depend on the length of the current row (which increases with each iteration).\\n    - The inner loop iterates over the elements of the `dummy_row`, which has a length equal to the length of the last row in `res` plus 2 (due to the added zeros at both ends).\\n    - In the worst case, the length of the last row in `res` would be numRows - 1 (e.g., for the 5th row, it would be [1, 4, 6, 4, 1]).\\n    - So, the inner loop runs a number of times proportional to numRows.\\n\\nConsidering the outer and inner loops, the overall time complexity is O(numRows^2).\\n\\n- **Space complexity: O(n^2)**, where n is numRows\\n\\n    - The `res` list stores the entire Pascal\\'s triangle, which has numRows rows and a total of (numRows^2)/2 elements (since each row has an increasing number of elements).\\n    - The `dummy_row` list is created in each iteration of the loop and has a length equal to the length of the last row in `res` plus 2.\\n    - The `row` list is created in each iteration and has a length equal to the length of the current `dummy_row`.\\n\\n    Considering the space used by `res`, `dummy_row`, and `row`, the space complexity is O(numRows^2).\\n\\n\\nIn summary, both the time and space complexity of this code are O(n^2), meaning they grow quadratically with the input parameter `numRows`.\\n\\n\\n```python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        res = [[1]]\\n\\n        for _ in range(numRows - 1):\\n            dummy_row = [0] + res[-1] + [0]\\n            row = []\\n\\n            for i in range(len(res[-1]) + 1):\\n                row.append(dummy_row[i] + dummy_row[i+1])\\n            res.append(row)\\n        \\n        return res\\n```\\n```javascript []\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    const res = [[1]];\\n\\n    for (let i = 0; i < numRows - 1; i++) {\\n        const dummyRow = [0, ...res[res.length - 1], 0];\\n        const row = [];\\n\\n        for (let j = 0; j < dummyRow.length - 1; j++) {\\n            row.push(dummyRow[j] + dummyRow[j + 1]);\\n        }\\n\\n        res.push(row);\\n    }\\n\\n    return res;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(List.of(1));\\n\\n        for (int i = 0; i < numRows - 1; i++) {\\n            List<Integer> dummyRow = new ArrayList<>();\\n            dummyRow.add(0);\\n            dummyRow.addAll(res.get(res.size() - 1));\\n            dummyRow.add(0);\\n            List<Integer> row = new ArrayList<>();\\n\\n            for (int j = 0; j < dummyRow.size() - 1; j++) {\\n                row.add(dummyRow.get(j) + dummyRow.get(j + 1));\\n            }\\n\\n            res.add(row);\\n        }\\n\\n        return res;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        std::vector<std::vector<int>> res;\\n        res.push_back({1});\\n\\n        for (int i = 0; i < numRows - 1; i++) {\\n            std::vector<int> dummyRow = {0};\\n            dummyRow.insert(dummyRow.end(), res.back().begin(), res.back().end());\\n            dummyRow.push_back(0);\\n            std::vector<int> row;\\n\\n            for (int j = 0; j < dummyRow.size() - 1; j++) {\\n                row.push_back(dummyRow[j] + dummyRow[j + 1]);\\n            }\\n\\n            res.push_back(row);\\n        }\\n\\n        return res;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        res = [[1]]\\n\\n        for _ in range(numRows - 1):\\n            dummy_row = [0] + res[-1] + [0]\\n            row = []\\n\\n            for i in range(len(res[-1]) + 1):\\n                row.append(dummy_row[i] + dummy_row[i+1])\\n            res.append(row)\\n        \\n        return res\\n```\n```javascript []\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    const res = [[1]];\\n\\n    for (let i = 0; i < numRows - 1; i++) {\\n        const dummyRow = [0, ...res[res.length - 1], 0];\\n        const row = [];\\n\\n        for (let j = 0; j < dummyRow.length - 1; j++) {\\n            row.push(dummyRow[j] + dummyRow[j + 1]);\\n        }\\n\\n        res.push(row);\\n    }\\n\\n    return res;    \\n};\\n```\n```java []\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(List.of(1));\\n\\n        for (int i = 0; i < numRows - 1; i++) {\\n            List<Integer> dummyRow = new ArrayList<>();\\n            dummyRow.add(0);\\n            dummyRow.addAll(res.get(res.size() - 1));\\n            dummyRow.add(0);\\n            List<Integer> row = new ArrayList<>();\\n\\n            for (int j = 0; j < dummyRow.size() - 1; j++) {\\n                row.add(dummyRow.get(j) + dummyRow.get(j + 1));\\n            }\\n\\n            res.add(row);\\n        }\\n\\n        return res;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        std::vector<std::vector<int>> res;\\n        res.push_back({1});\\n\\n        for (int i = 0; i < numRows - 1; i++) {\\n            std::vector<int> dummyRow = {0};\\n            dummyRow.insert(dummyRow.end(), res.back().begin(), res.back().end());\\n            dummyRow.push_back(0);\\n            std::vector<int> row;\\n\\n            for (int j = 0; j < dummyRow.size() - 1; j++) {\\n                row.push_back(dummyRow[j] + dummyRow[j + 1]);\\n            }\\n\\n            res.push_back(row);\\n        }\\n\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38136,
                "title": "a-simple-python-solution",
                "content": "    class Solution:\\n    # @return a list of lists of integers\\n    def generate(self, numRows):\\n        lists = []\\n        for i in range(numRows):\\n            lists.append([1]*(i+1))\\n            if i>1 :\\n                for j in range(1,i):\\n                    lists[i][j]=lists[i-1][j-1]+lists[i-1][j]\\n        return lists",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @return a list of lists of integers\\n    def generate(self, numRows):\\n        lists = []\\n        for i in range(numRows):\\n            lists.append([1]*(i+1))\\n            if i>1 :\\n                for j in range(1,i):\\n                    lists[i][j]=lists[i-1][j-1]+lists[i-1][j]\\n        return lists",
                "codeTag": "Java"
            },
            {
                "id": 2302960,
                "title": "concise-solution-intuition-explained-with-image",
                "content": "Good morning :)\\n\\nIf you found this post helpful, please upvote <3\\n\\n<hr />\\n\\nWe need to return the pascal triangle in a matrix form, up to some row `numRows`\\n\\nLet\\'s run a simple simulation to calculate the rows.\\n\\nIn the first row, we have 1 element in the pascal triangle.\\n\\nIn the second row we have 2 elements. In row `n` we have `n` elements\\n\\nNow how the elements are calculated?\\n\\nIn the third row, we have 1 in `index 0` and in index `3-1=2`. And the element in `index 1` is calculated as looking up one element directly in the row above, and one element to the left in the row above.\\n\\nSo the transition is: `pascal_triangle[row][col] = pascal_triangle[row - 1][col] + pascal_triangle[row - 1][col - 1]`\\n\\nHere is an image to illustrate the example\\n\\n![image](https://assets.leetcode.com/users/images/4452feee-3072-45ba-90de-a8df7fcfd656_1658215458.5572944.png)\\n\\n# Let\\'s code it up\\n\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        pascal_triangle = [[1 for _ in range(row + 1)] for row in range(numRows)]\\n        \\n        for row in range(numRows):\\n            for col in range(1, row):\\n                pascal_triangle[row][col] = pascal_triangle[row - 1][col] + pascal_triangle[row - 1][col - 1]\\n        \\n        return pascal_triangle\\n```\\n\\n\\nHave a fantastic and productive day!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        pascal_triangle = [[1 for _ in range(row + 1)] for row in range(numRows)]\\n        \\n        for row in range(numRows):\\n            for col in range(1, row):\\n                pascal_triangle[row][col] = pascal_triangle[row - 1][col] + pascal_triangle[row - 1][col - 1]\\n        \\n        return pascal_triangle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113300,
                "title": "simple-golang-code",
                "content": "```\\nfunc generate(numRows int) [][]int {\\n    a := make([][]int, numRows)\\n    for i := 0; i <numRows; i++ {\\n        a[i] = make([]int, i+1)\\n        a[i][0] = 1;\\n        a[i][i] = 1;\\n        for j := 1; j<i; j++ {\\n            a[i][j] = a[i-1][j-1] + a[i-1][j]\\n        }\\n    }\\n    return a;\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generate(numRows int) [][]int {\\n    a := make([][]int, numRows)\\n    for i := 0; i <numRows; i++ {\\n        a[i] = make([]int, i+1)\\n        a[i][0] = 1;\\n        a[i][i] = 1;\\n        for j := 1; j<i; j++ {\\n            a[i][j] = a[i-1][j-1] + a[i-1][j]\\n        }\\n    }\\n    return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879863,
                "title": "c-dp-based-solution-faster-than-100-00-of-c",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Pascal\\'s Triangle.\\nMemory Usage: 6.5 MB, less than 55.79% of C++ online submissions for Pascal\\'s Triangle.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) \\n    {\\n        vector<vector<int>> triangle(numRows);\\n        triangle[0].push_back(1);\\n\\n        for(int i=1; i< numRows; i++){\\n            triangle[i].push_back(1);\\n            for( int j = 1; j < i; j++){\\n                triangle[i].push_back(triangle[i-1][j-1]+triangle[i-1][j]);\\n            }\\n            triangle[i].push_back(1);                                      \\n        }\\n        return triangle;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) \\n    {\\n        vector<vector<int>> triangle(numRows);\\n        triangle[0].push_back(1);\\n\\n        for(int i=1; i< numRows; i++){\\n            triangle[i].push_back(1);\\n            for( int j = 1; j < i; j++){\\n                triangle[i].push_back(triangle[i-1][j-1]+triangle[i-1][j]);\\n            }\\n            triangle[i].push_back(1);                                      \\n        }\\n        return triangle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287111,
                "title": "python-simple-and-clean-4-line-solution",
                "content": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        triangle = [[1]]\\n        \\n        for j in range(1, numRows):\\n            prev = triangle[-1]\\n            triangle.append([1] + [prev[i]+prev[i+1] for i in range(len(prev)-1)] + [1])\\n            \\n        return triangle\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        triangle = [[1]]\\n        \\n        for j in range(1, numRows):\\n            prev = triangle[-1]\\n            triangle.append([1] + [prev[i]+prev[i+1] for i in range(len(prev)-1)] + [1])\\n            \\n        return triangle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172623,
                "title": "c-solution-iterative-approach-0ms-faster-than-100-tc-o-n-2",
                "content": "**Explanation:**\\n\\n* Return n lines of Pascal Triangle.\\n* We took vector of vector ans of size n.\\n* From observing, we know that i-th row will have i+1 elements, so we resize the vector.\\n* We also observed and thus initialized the first and the last element of every vector with 1.\\n* In pascal triangle element of array[row][column] will be the sum of 2 elements of the previous row: array[row-1][column-1] & array[row-1][column].\\n* Time complexity: `O(n^2)`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> ans(n);          // initialize n rows        \\n        for(int i = 0; i < n; i++) {\\n            ans[i].resize(i+1);              // ith row(0-indexed) has i+1 elements\\n            ans[i][0] = ans[i][i] = 1;       // first and last element of the row will be 1\\n            \\n            for(int j = 1; j < i; j++)       // calc the sum of two elements from above row \\n                ans[i][j] = ans[i - 1][j-1] + ans[i - 1][j];            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> ans(n);          // initialize n rows        \\n        for(int i = 0; i < n; i++) {\\n            ans[i].resize(i+1);              // ith row(0-indexed) has i+1 elements\\n            ans[i][0] = ans[i][i] = 1;       // first and last element of the row will be 1\\n            \\n            for(int j = 1; j < i; j++)       // calc the sum of two elements from above row \\n                ans[i][j] = ans[i - 1][j-1] + ans[i - 1][j];            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067664,
                "title": "most-simplest-and-shortest-solution-with-proper-explaination-beats-100",
                "content": "# Observation of pascal\\'s triangle before solving it\\n1. every row starts and ends with 1.\\n2. every number is sum of 2 number directly above it.\\n3. total no. of element in every row is equal to row number. for example 2nd row has 2 elements .....nth row has n no. of elements.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) \\n    {\\n        vector<vector<int>>v(numRows);\\n        for(int i=0;i<numRows;i++)\\n        {\\n            v[i].resize(i+1);//resize every row for example 0th row with size 1,2nd row with size 3..\\n            v[i][0]=v[i][i]=1;//fix value of first nand last element of every row as 1.\\n              for(int j=1;j<i;j++)\\n              {\\n                  v[i][j]=v[i-1][j-1]+v[i-1][j];//finding value by adding above 2 elements.\\n              }\\n        }      \\n        return v;\\n    }\\n};\\n```\\n\\nplease upvote if solution is helpful and feel free to comment for doubts.",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) \\n    {\\n        vector<vector<int>>v(numRows);\\n        for(int i=0;i<numRows;i++)\\n        {\\n            v[i].resize(i+1);//resize every row for example 0th row with size 1,2nd row with size 3..\\n            v[i][0]=v[i][i]=1;//fix value of first nand last element of every row as 1.\\n              for(int j=1;j<i;j++)\\n              {\\n                  v[i][j]=v[i-1][j-1]+v[i-1][j];//finding value by adding above 2 elements.\\n              }\\n        }      \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747372,
                "title": "c-easiest-solution-with-explanation",
                "content": "```\\n vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> m(numRows);// creating 2-D vector with rows=numRows\\n        \\n            for(int i=0;i<numRows;i++)\\n            {\\n                m[i].resize(i + 1);    //to increase column size as level increases\\n                m[i][0] = m[i][i] = 1; //first and last element of every row is 1 always so\\n\\n                //loop to calculate sum of remaining elements from previous row  \\n                for (int j = 1; j < i; j++)\\n                   m[i][j] = m[i - 1][j - 1] + m[i - 1][j];\\n        \\n            }\\n        return m;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> m(numRows);// creating 2-D vector with rows=numRows\\n        \\n            for(int i=0;i<numRows;i++)\\n            {\\n                m[i].resize(i + 1);    //to increase column size as level increases\\n                m[i][0] = m[i][i] = 1; //first and last element of every row is 1 always so\\n\\n                //loop to calculate sum of remaining elements from previous row  \\n                for (int j = 1; j < i; j++)\\n                   m[i][j] = m[i - 1][j - 1] + m[i - 1][j];\\n        \\n            }\\n        return m;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016403,
                "title": "python-easy-to-understand-fast",
                "content": "# Python | Easy to Understand | Fast\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        finalNums=[]\\n        finalNums.append([1])\\n        for i in range(numRows-1):\\n            newRow=[1]\\n            for j in range(i):\\n                newRow.append(finalNums[i][j]+finalNums[i][j+1])\\n            newRow.append(1)\\n            finalNums.append(newRow)\\n        return finalNums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        finalNums=[]\\n        finalNums.append([1])\\n        for i in range(numRows-1):\\n            newRow=[1]\\n            for j in range(i):\\n                newRow.append(finalNums[i][j]+finalNums[i][j+1])\\n            newRow.append(1)\\n            finalNums.append(newRow)\\n        return finalNums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190724,
                "title": "python-clean-simple-fibonacci-like-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans = []\\n        for i in range(1, numRows + 1):\\n            row = [1] * i\\n            for j in range(1,i-1):\\n                row[j] = ans[i - 2][j] + ans[i - 2][j - 1]\\n            ans.append(row)\\n        return ans\\n```\\n## Using Map:\\n```\\ndef generate(self, numRows):\\n    res = [[1]]\\n    for i in range(1, numRows):\\n        res += [map(lambda x, y: x+y, res[-1] + [0], [0] + res[-1])]\\n    return res[:numRows]\\n```\\n\\nExplanation:\\nAny row can be constructed using the offset sum of the previous row. \\nExample:\\n\\n```\\n    1 3 3 1 0 \\n +  0 1 3 3 1\\n =  1 4 6 4 1\\n```\\nThis Above Solution using map is given by [sherlok321](https://leetcode.com/problems/pascals-triangle/solutions/38128/python-4-lines-short-solution-using-map/) check it out.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans = []\\n        for i in range(1, numRows + 1):\\n            row = [1] * i\\n            for j in range(1,i-1):\\n                row[j] = ans[i - 2][j] + ans[i - 2][j - 1]\\n            ans.append(row)\\n        return ans\\n```\n```\\ndef generate(self, numRows):\\n    res = [[1]]\\n    for i in range(1, numRows):\\n        res += [map(lambda x, y: x+y, res[-1] + [0], [0] + res[-1])]\\n    return res[:numRows]\\n```\n```\\n    1 3 3 1 0 \\n +  0 1 3 3 1\\n =  1 4 6 4 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791227,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386147,
                "title": "0ms-c-100-faster-easy-explanation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        \\n        // 2D vector of size equal to numRows as there will be this many rows.\\n        vector<vector<int>> ans(numRows);\\n        \\n        \\n        // Outer loop for iterating rows of 2D vector. Iterate from 0 to numRows-1.\\n        for(int i=0;i<numRows;i++)\\n        {\\n            // Inner loop for filling columns of each row of 2D vector.\\n            for(int j=0;j<i+1;j++)\\n            {\\n                // If it\\'s first col of any row or last col of any row then it must be 1.\\n                if(j==0 || j==i)\\n                    ans[i].push_back(1);\\n                // Else go to prev row and add last two columns i.e jth colm and j-1 th colm of that row.\\n                else\\n                    ans[i].push_back(ans[i-1][j] + ans[i-1][j-1]);\\n            }\\n        }\\n        \\n        // We have filled our 2D vector. Happy Return !! :)\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        \\n        // 2D vector of size equal to numRows as there will be this many rows.\\n        vector<vector<int>> ans(numRows);\\n        \\n        \\n        // Outer loop for iterating rows of 2D vector. Iterate from 0 to numRows-1.\\n        for(int i=0;i<numRows;i++)\\n        {\\n            // Inner loop for filling columns of each row of 2D vector.\\n            for(int j=0;j<i+1;j++)\\n            {\\n                // If it\\'s first col of any row or last col of any row then it must be 1.\\n                if(j==0 || j==i)\\n                    ans[i].push_back(1);\\n                // Else go to prev row and add last two columns i.e jth colm and j-1 th colm of that row.\\n                else\\n                    ans[i].push_back(ans[i-1][j] + ans[i-1][j-1]);\\n            }\\n        }\\n        \\n        // We have filled our 2D vector. Happy Return !! :)\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932101,
                "title": "100-fastest-swift-solution-time-o-n-n-space-o-n-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * n), where n is the numRows.\\n    //   - space: O(n * n), where n is the numRows.\\n    \\n    func generate(_ numRows: Int) -> [[Int]] {\\n        var ans = [[Int]](repeating: [Int](), count: numRows)\\n\\n        for i in 0..<numRows {\\n            ans[i] = [Int](repeating: 0, count: i+1)\\n\\n            for j in 0..<i+1 {\\n                if j == 0 || j == i {\\n                    ans[i][j] = 1\\n                } else {\\n                    ans[i][j] = ans[i-1][j-1] + ans[i-1][j]\\n                }\\n            }\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * n), where n is the numRows.\\n    //   - space: O(n * n), where n is the numRows.\\n    \\n    func generate(_ numRows: Int) -> [[Int]] {\\n        var ans = [[Int]](repeating: [Int](), count: numRows)\\n\\n        for i in 0..<numRows {\\n            ans[i] = [Int](repeating: 0, count: i+1)\\n\\n            for j in 0..<i+1 {\\n                if j == 0 || j == i {\\n                    ans[i][j] = 1\\n                } else {\\n                    ans[i][j] = ans[i-1][j-1] + ans[i-1][j]\\n                }\\n            }\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200315,
                "title": "c-solution-faster-than-100-00",
                "content": "* Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n\\n\\n```\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    *returnSize = numRows;\\n    int **output = calloc(1, sizeof(int *[numRows]));\\n    *returnColumnSizes = calloc(1, sizeof(int [numRows]));\\n    \\n    //Allocate memory for the whole triangle\\n    for (int i=0; i<numRows; i++) {\\n        (*returnColumnSizes)[i] = i + 1;\\n        output[i] = calloc(1, sizeof(int [i + 1]));\\n    }\\n    \\n    //the first row will always be 1\\n    output[0][0] = 1;\\n    \\n    for (int i=1; i<numRows; i++) {\\n        output[i][0] = 1;\\n        for (int j=1; j<i; j++) {\\n            output[i][j] = output[i-1][j-1] + output[i-1][j];\\n        }\\n        output[i][i] = 1;\\n    }\\n    return output;\\n}\\n```\\n\\nThe following uses malloc which is easier to see the size of memory allocation.\\n\\n```\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    *returnSize = numRows;\\n    int **output = (int**)malloc(numRows*sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(numRows*sizeof(int));\\n    \\n    //Allocate memory for the whole triangle\\n    for (int i=0; i<numRows; i++) {\\n        (*returnColumnSizes)[i] = i + 1;\\n        output[i] = (int*)malloc((i+1)*sizeof(int));\\n    }\\n    \\n    //the first row will always be 1\\n    output[0][0] = 1;\\n    \\n    for (int i=1; i<numRows; i++) {\\n        output[i][0] = 1;\\n        for (int j=1; j<i; j++) {\\n            output[i][j] = output[i-1][j-1] + output[i-1][j];\\n        }\\n        output[i][i] = 1;\\n    }\\n    return output;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    *returnSize = numRows;\\n    int **output = calloc(1, sizeof(int *[numRows]));\\n    *returnColumnSizes = calloc(1, sizeof(int [numRows]));\\n    \\n    //Allocate memory for the whole triangle\\n    for (int i=0; i<numRows; i++) {\\n        (*returnColumnSizes)[i] = i + 1;\\n        output[i] = calloc(1, sizeof(int [i + 1]));\\n    }\\n    \\n    //the first row will always be 1\\n    output[0][0] = 1;\\n    \\n    for (int i=1; i<numRows; i++) {\\n        output[i][0] = 1;\\n        for (int j=1; j<i; j++) {\\n            output[i][j] = output[i-1][j-1] + output[i-1][j];\\n        }\\n        output[i][i] = 1;\\n    }\\n    return output;\\n}\\n```\n```\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    *returnSize = numRows;\\n    int **output = (int**)malloc(numRows*sizeof(int*));\\n    *returnColumnSizes = (int*)malloc(numRows*sizeof(int));\\n    \\n    //Allocate memory for the whole triangle\\n    for (int i=0; i<numRows; i++) {\\n        (*returnColumnSizes)[i] = i + 1;\\n        output[i] = (int*)malloc((i+1)*sizeof(int));\\n    }\\n    \\n    //the first row will always be 1\\n    output[0][0] = 1;\\n    \\n    for (int i=1; i<numRows; i++) {\\n        output[i][0] = 1;\\n        for (int j=1; j<i; j++) {\\n            output[i][j] = output[i-1][j-1] + output[i-1][j];\\n        }\\n        output[i][i] = 1;\\n    }\\n    return output;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524023,
                "title": "c-java-python-javascript-10-lines-of-code-easy-to-understand",
                "content": "# Intuition:\\nThe given code is generating Pascal\\'s triangle up to a given number of rows. Pascal\\'s triangle is a triangular array of numbers where each number is the sum of the two numbers directly above it. The first and last elements of each row are always 1.\\n\\n# Approach:\\n1. Create a 2D vector `r` to store the Pascal\\'s triangle.\\n2. Resize each row of `r` according to the row number.\\n3. Initialize the first and last elements of each row as 1.\\n4. For the elements in between (excluding the first and last), calculate their values by adding the corresponding elements from the previous row.\\n5. Return the resulting Pascal\\'s triangle.\\n\\n# Complexity:\\n- The time complexity of this code is O(numRows^2) because we need to fill each element of the triangle.\\n- The space complexity is O(numRows^2) because we are storing all the elements of the triangle in the `r` vector.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n        for(int i=0;i<numRows;i++){\\n            r[i].resize(i + 1);\\n            r[i][0]=1;\\n            r[i][i]=1;\\n            for(int j=1;j<i;j++){\\n                r[i][j]=r[i-1][j-1]+r[i-1][j];\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>();\\n            row.add(1);\\n            for (int j = 1; j < i; j++) {\\n                row.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));\\n            }\\n            if (i > 0) {\\n                row.add(1);\\n            }\\n            result.add(row);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        result = []\\n        for i in range(numRows):\\n            row = [None] * (i + 1)\\n            row[0] = 1\\n            row[i] = 1\\n            for j in range(1, i):\\n                row[j] = result[i - 1][j - 1] + result[i - 1][j]\\n            result.append(row)\\n        return result\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar generate = function(numRows) {\\n    let result = [];\\n    for (let i = 0; i < numRows; i++) {\\n        result[i] = new Array(i + 1);\\n        result[i][0] = 1;\\n        result[i][i] = 1;\\n        for (let j = 1; j < i; j++) {\\n            result[i][j] = result[i - 1][j - 1] + result[i - 1][j];\\n        }\\n    }\\n    return result;  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n        for(int i=0;i<numRows;i++){\\n            r[i].resize(i + 1);\\n            r[i][0]=1;\\n            r[i][i]=1;\\n            for(int j=1;j<i;j++){\\n                r[i][j]=r[i-1][j-1]+r[i-1][j];\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>();\\n            row.add(1);\\n            for (int j = 1; j < i; j++) {\\n                row.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));\\n            }\\n            if (i > 0) {\\n                row.add(1);\\n            }\\n            result.add(row);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        result = []\\n        for i in range(numRows):\\n            row = [None] * (i + 1)\\n            row[0] = 1\\n            row[i] = 1\\n            for j in range(1, i):\\n                row[j] = result[i - 1][j - 1] + result[i - 1][j]\\n            result.append(row)\\n        return result\\n\\n```\n```\\nvar generate = function(numRows) {\\n    let result = [];\\n    for (let i = 0; i < numRows; i++) {\\n        result[i] = new Array(i + 1);\\n        result[i][0] = 1;\\n        result[i][i] = 1;\\n        for (let j = 1; j < i; j++) {\\n            result[i][j] = result[i - 1][j - 1] + result[i - 1][j];\\n        }\\n    }\\n    return result;  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151541,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        int[][] pascal = new int[numRows][];\\n        for (int i = 0; i < numRows; i++){\\n            int[] row = new int[i + 1];\\n            row[0] = 1;\\n            row[i] = 1;\\n            for (int j = 1; j < i; j++){\\n                row[j] = pascal[i - 1][j - 1] + pascal[i - 1][j];\\n            }\\n            pascal[i] = row;\\n        }\\n        return (List)Arrays.asList(pascal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        int[][] pascal = new int[numRows][];\\n        for (int i = 0; i < numRows; i++){\\n            int[] row = new int[i + 1];\\n            row[0] = 1;\\n            row[i] = 1;\\n            for (int j = 1; j < i; j++){\\n                row[j] = pascal[i - 1][j - 1] + pascal[i - 1][j];\\n            }\\n            pascal[i] = row;\\n        }\\n        return (List)Arrays.asList(pascal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787410,
                "title": "java-o-n-2-100-faster-easy-solution-with-comments",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1. Using Binomial Coefficients**\\n- Each row elements correspond to a sequence of binomial coefficients ->\\n  - For eg - *Row 3* [2c0 = 1, 2c1 = 2, 2c2 = 1]\\n  - For eg - *Row 4* [3c0 = 1, 3c1 = 3, 3c2 = 3, 3c3 = 1] $$and$$ $$so$$ $$on$$...\\n  \\n**2. Using the unique pattern (Optimal approach)**\\n- Each row\\'s element can be derived from previous row\\'s 2 elements. This pattern can be observed from the animation given in question itself.\\n# Complexity\\n- Time complexity: **O(n^2)** - *Beats 100% solutions*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n^2)** - *Beats 93.13% solutions*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution... :)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n        //This list is the final answer to be obtained\\n        List<List<Integer>> list = new ArrayList<>();\\n\\n        //For handling Row 1, which will include 0c0 = 1\\n        List<Integer> list1 = new ArrayList<>();\\n        list1.add(1);\\n        list.add(list1);\\n        if(numRows == 1) {\\n            return list;\\n        }\\n\\n        for(int i = 1; i < numRows; i++) {\\n            List<Integer> temp = new ArrayList<>();\\n            \\n            //For adding first element in each row -> (ic0) = 1 where i ranges from 1 to numRows-1\\n            temp.add(1);\\n\\n            for(int j = 1; j < i; j++) {\\n                temp.add(list.get(i-1).get(j-1) + list.get(i-1).get(j));\\n            }\\n\\n            //For adding last element in each row -> (ici) = 1 where i ranges from 1 to numRows-1\\n            temp.add(1);\\n            list.add(temp);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n        //This list is the final answer to be obtained\\n        List<List<Integer>> list = new ArrayList<>();\\n\\n        //For handling Row 1, which will include 0c0 = 1\\n        List<Integer> list1 = new ArrayList<>();\\n        list1.add(1);\\n        list.add(list1);\\n        if(numRows == 1) {\\n            return list;\\n        }\\n\\n        for(int i = 1; i < numRows; i++) {\\n            List<Integer> temp = new ArrayList<>();\\n            \\n            //For adding first element in each row -> (ic0) = 1 where i ranges from 1 to numRows-1\\n            temp.add(1);\\n\\n            for(int j = 1; j < i; j++) {\\n                temp.add(list.get(i-1).get(j-1) + list.get(i-1).get(j));\\n            }\\n\\n            //For adding last element in each row -> (ici) = 1 where i ranges from 1 to numRows-1\\n            temp.add(1);\\n            list.add(temp);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016395,
                "title": "c-fastest-0ms-easy-to-understand",
                "content": "# C++ | Fastest | 0ms | Easy to Understand\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809536,
                "title": "simple-o-n-2-c-solution-with-comments-0ms-beats-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        //this vector of vectors will store all the levels of the Pascal\\'s triangle\\n        vector<vector<int>>ans;\\n        for(int i=1;i<=numRows;i++){\\n            //we iterate from 1 till the number of rows there are in the triangle.\\n            //we can consider each iteration as the i\\'th level\\n            \\n            //at i-th level, the number of elements will be i\\n            //therefore we create a vector of length i\\n            vector<int> temp (i);\\n            \\n            //in order to fill the numbers of the i-th level\\n            //we will run a loop from j=0 till i-1, denoting \\n            //the number at each index\\n            for(int j=0;j<i;j++){\\n                //clearly, the first and the last element will\\n                //always be 1, so use conditional statements to achieve that\\n                if(j==0 || j==i-1) temp[j] = 1;\\n                else{\\n                    //other than the first and the last elements,\\n                    //the rest of the entries of the triangle are the sum of the j-th and (j-1)th\\n                    //numbers from the previous level\\n                    temp[j] = ans[i-2][j] + ans[i-2][j-1];\\n                }\\n            }\\n            //push back the level into the answer vector\\n            ans.push_back(temp);\\n        }\\n        //return the answer vector\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        //this vector of vectors will store all the levels of the Pascal\\'s triangle\\n        vector<vector<int>>ans;\\n        for(int i=1;i<=numRows;i++){\\n            //we iterate from 1 till the number of rows there are in the triangle.\\n            //we can consider each iteration as the i\\'th level\\n            \\n            //at i-th level, the number of elements will be i\\n            //therefore we create a vector of length i\\n            vector<int> temp (i);\\n            \\n            //in order to fill the numbers of the i-th level\\n            //we will run a loop from j=0 till i-1, denoting \\n            //the number at each index\\n            for(int j=0;j<i;j++){\\n                //clearly, the first and the last element will\\n                //always be 1, so use conditional statements to achieve that\\n                if(j==0 || j==i-1) temp[j] = 1;\\n                else{\\n                    //other than the first and the last elements,\\n                    //the rest of the entries of the triangle are the sum of the j-th and (j-1)th\\n                    //numbers from the previous level\\n                    temp[j] = ans[i-2][j] + ans[i-2][j-1];\\n                }\\n            }\\n            //push back the level into the answer vector\\n            ans.push_back(temp);\\n        }\\n        //return the answer vector\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38182,
                "title": "short-c-solution-using-only-o-k-extra-space",
                "content": "Starting with empty array. Because row i + 1 is longer than row i by 1, and the last number in each row is always 1.\\n\\nSo suppose we are just done with row i, when when proceed with row i + 1:\\n\\n1) We need to push a \"1\" to the current array first we have (with row i's result), \\n\\n2) Then update index 1 through i. Observing that first number of array always will be 1 too, which doesn't need to be updated since we already did that when we deal with row 0 (last and first index are both 0 for row 0).\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> generate(int numRows) {\\n            vector<vector<int>> result;\\n            \\n            vector<int> row;\\n            for(int i = 0; i < numRows; i++){\\n                row.push_back(1);\\n                for(int j = i - 1; j > 0; j--){\\n                    row[j] = row[j - 1] + row[j];\\n                }\\n                result.push_back(row);\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> generate(int numRows) {\\n            vector<vector<int>> result;\\n            \\n            vector<int> row;\\n            for(int i = 0; i < numRows; i++){\\n                row.push_back(1);\\n                for(int j = i - 1; j > 0; j--){\\n                    row[j] = row[j - 1] + row[j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1287181,
                "title": "pascal-s-triangle-js-python-java-c-simple-iterative-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we can do pretty much just as the instructions tell us. We\\'ll iterate through the building of **Pascal\\'s triangle** (**ans**), row by row. When we create each new **row**, we should initially fill it with **1**s so that we don\\'t have to worry about the logic of filling the edge cells that only have one number above.\\n\\nThen we can start on **j = 1** for each **row** and repeat the process of summing up the value of the current cell until we reach the midpoint (**mid**). Since the triangle is symmetrical, we can actually fill both halves of the row at once, while we work inward.\\n\\nOnce we reach the end of the last row, we can **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the **numRows**th **triangular number**_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar generate = function(numRows) {\\n    let ans = new Array(numRows)\\n    for (let i = 0; i < numRows; i++) {\\n        let row = new Uint32Array(i+1).fill(1),\\n            mid = i >> 1\\n        for (let j = 1; j <= mid; j++) {\\n            let val = ans[i-1][j-1] + ans[i-1][j]\\n            row[j] = val, row[row.length-j-1] = val\\n        }\\n        ans[i] = row\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans = [None] * numRows\\n        for i in range(numRows):\\n            row, mid = [1] * (i + 1), (i >> 1) + 1\\n            for j in range(1, mid):\\n                val = ans[i-1][j-1] + ans[i-1][j]\\n                row[j], row[len(row)-j-1] = val, val\\n            ans[i] = row\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>(i+1);\\n            while (row.size() <= i) row.add(1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans.get(i-1).get(j-1) + ans.get(i-1).get(j);\\n                row.set(j, val);\\n                row.set(row.size()-j-1, val);\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i+1, 1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans[i-1][j-1] + ans[i-1][j];\\n                row[j] = val;\\n                row[row.size()-j-1] = val;\\n            }\\n            ans[i] = row;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar generate = function(numRows) {\\n    let ans = new Array(numRows)\\n    for (let i = 0; i < numRows; i++) {\\n        let row = new Uint32Array(i+1).fill(1),\\n            mid = i >> 1\\n        for (let j = 1; j <= mid; j++) {\\n            let val = ans[i-1][j-1] + ans[i-1][j]\\n            row[j] = val, row[row.length-j-1] = val\\n        }\\n        ans[i] = row\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans = [None] * numRows\\n        for i in range(numRows):\\n            row, mid = [1] * (i + 1), (i >> 1) + 1\\n            for j in range(1, mid):\\n                val = ans[i-1][j-1] + ans[i-1][j]\\n                row[j], row[len(row)-j-1] = val, val\\n            ans[i] = row\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>(i+1);\\n            while (row.size() <= i) row.add(1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans.get(i-1).get(j-1) + ans.get(i-1).get(j);\\n                row.set(j, val);\\n                row.set(row.size()-j-1, val);\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i+1, 1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans[i-1][j-1] + ans[i-1][j];\\n                row[j] = val;\\n                row[row.size()-j-1] = val;\\n            }\\n            ans[i] = row;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287157,
                "title": "well-commented-python-solution",
                "content": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n\\t\\ttriangle = []          #initiating the triangle which we will output\\n\\t\\t\\n\\t\\tfor row_num in range(numRows):            # for loop for adding rows to the final triangle\\n            row = [None for _ in range(row_num + 1)]  #intiating each row with None, notice the no. of elements in the row\\n\\t\\t\\trow[0], row[-1] = 1, 1        #first and last element of each row is 1\\n\\t\\t\\t\\n            for j in range(1, row_num):     # nested for loop to fill up each row\\n                row[j] = triangle[row_num - 1][j-1] + triangle[row_num - 1][j]   #as seen in question animation, each element is the sum of the elements directly above it\\n\\t\\t\\t\\t\\n            triangle.append(row)  #After filling up the row - append it to the main traingle\\n\\t\\t\\t\\n        return triangle   #return the triangle\\n \\n```\\n\\nPlease upvote - if it helped you",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n\\t\\ttriangle = []          #initiating the triangle which we will output\\n\\t\\t\\n\\t\\tfor row_num in range(numRows):            # for loop for adding rows to the final triangle\\n            row = [None for _ in range(row_num + 1)]  #intiating each row with None, notice the no. of elements in the row\\n\\t\\t\\trow[0], row[-1] = 1, 1        #first and last element of each row is 1\\n\\t\\t\\t\\n            for j in range(1, row_num):     # nested for loop to fill up each row\\n                row[j] = triangle[row_num - 1][j-1] + triangle[row_num - 1][j]   #as seen in question animation, each element is the sum of the elements directly above it\\n\\t\\t\\t\\t\\n            triangle.append(row)  #After filling up the row - append it to the main traingle\\n\\t\\t\\t\\n        return triangle   #return the triangle\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 38347,
                "title": "my-10-lines-c-code",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> generate(int numRows) {\\n            vector<vector<int> > ret(numRows, vector<int>());\\n            for(int i=0; i<numRows; i++) {\\n                for(int j=0; j<=i; j++) {\\n                    ret[i].push_back(j == 0 ? 1 : j == i ? 1 : ret[i-1][j-1] + ret[i-1][j]);\\n                }\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> generate(int numRows) {\\n            vector<vector<int> > ret(numRows, vector<int>());\\n            for(int i=0; i<numRows; i++) {\\n                for(int j=0; j<=i; j++) {\\n                    ret[i].push_back(j == 0 ? 1 : j == i ? 1 : ret[i-1][j-1] + ret[i-1][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2661799,
                "title": "python-simple-with-comments",
                "content": "\\n\\nRuntime: **18 ms, faster than 99.99%** of Python3 online submissions for Pascal\\'s Triangle.\\nMemory Usage: **13.8 MB, less than 100%** of Python3 online submissions for Pascal\\'s Triangle. \\n\\n![image.png](https://assets.leetcode.com/users/images/ddc2bff5-41a1-4665-a203-57270fde1710_1694198879.5958314.png)\\n\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a = []\\n        for x in range(numRows):\\n            a.append([1])\\n# \\t\\t\\tcreating the 2d array\\n# \\t\\t\\tappending the starting 1: [1, ...]\\n\\t\\t\\t\\n            if x > 1: \\n# \\t\\t\\tskipping the first two rows\\n\\t\\t\\t\\n                for c in range(x-1):\\n# \\t\\t\\t\\t\\tfor loop used to find info about previous row\\n\\t\\t\\t\\t\\t\\n                    a[x].append(a[x-1][c]+a[x-1][c+1])\\n# \\t\\t\\t\\t\\tmath for adding the c and the c+1 number from the previous row\\n\\n            if x > 0:\\n# \\t\\t\\tchecking if its not the first row\\n\\n                a[x].append(1)\\n# \\t\\t\\t\\tappending the ending 1: [1, ..., 1]\\n\\t\\t\\t\\t\\n        return a",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n\\nRuntime: **18 ms, faster than 99.99%** of Python3 online submissions for Pascal\\'s Triangle.\\nMemory Usage: **13.8 MB, less than 100%** of Python3 online submissions for Pascal\\'s Triangle. \\n\\n![image.png](https://assets.leetcode.com/users/images/ddc2bff5-41a1-4665-a203-57270fde1710_1694198879.5958314.png)\\n\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a = []\\n        for x in range(numRows):\\n            a.append([1])\\n# \\t\\t\\tcreating the 2d array\\n# \\t\\t\\tappending the starting 1: [1, ...]\\n\\t\\t\\t\\n            if x > 1: \\n# \\t\\t\\tskipping the first two rows\\n\\t\\t\\t\\n                for c in range(x-1):\\n# \\t\\t\\t\\t\\tfor loop used to find info about previous row\\n\\t\\t\\t\\t\\t\\n                    a[x].append(a[x-1][c]+a[x-1][c+1])\\n# \\t\\t\\t\\t\\tmath for adding the c and the c+1 number from the previous row\\n\\n            if x > 0:\\n# \\t\\t\\tchecking if its not the first row\\n\\n                a[x].append(1)\\n# \\t\\t\\t\\tappending the ending 1: [1, ..., 1]\\n\\t\\t\\t\\t\\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 2303537,
                "title": "java-easy-short-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>>res = new ArrayList<>();\\n        for (int i=0;i<numRows;i++){\\n            List<Integer>temp = new ArrayList<>();\\n            temp.add(1);\\n            if (i>0){\\n                List<Integer>prelast = res.get(i-1);\\n                for (int j=0;j<prelast.size()-1;j++){\\n                    temp.add(prelast.get(j)+prelast.get(j+1));\\n                }\\n                temp.add(1);\\n            }\\n            res.add(temp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>>res = new ArrayList<>();\\n        for (int i=0;i<numRows;i++){\\n            List<Integer>temp = new ArrayList<>();\\n            temp.add(1);\\n            if (i>0){\\n                List<Integer>prelast = res.get(i-1);\\n                for (int j=0;j<prelast.size()-1;j++){\\n                    temp.add(prelast.get(j)+prelast.get(j+1));\\n                }\\n                temp.add(1);\\n            }\\n            res.add(temp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301716,
                "title": "python-1-line-with-accumulate",
                "content": "```\\nclass Solution:\\n  def generate(self, n: int) -> List[List[int]]:\\n    return list(accumulate([[1]]*n, lambda a,b: [x+y for x,y in zip(a+[0],[0]+a)]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def generate(self, n: int) -> List[List[int]]:\\n    return list(accumulate([[1]]*n, lambda a,b: [x+y for x,y in zip(a+[0],[0]+a)]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287179,
                "title": "js-python-java-c-simple-iterative-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, we can do pretty much just as the instructions tell us. We\\'ll iterate through the building of **Pascal\\'s triangle** (**ans**), row by row. When we create each new **row**, we should initially fill it with **1**s so that we don\\'t have to worry about the logic of filling the edge cells that only have one number above.\\n\\nThen we can start on **j = 1** for each **row** and repeat the process of summing up the value of the current cell until we reach the midpoint (**mid**). Since the triangle is symmetrical, we can actually fill both halves of the row at once, while we work inward.\\n\\nOnce we reach the end of the last row, we can **return ans**.\\n\\n - _**Time Complexity: O(N)** where **N** is the **numRows**th **triangular number**_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar generate = function(numRows) {\\n    let ans = new Array(numRows)\\n    for (let i = 0; i < numRows; i++) {\\n        let row = new Uint32Array(i+1).fill(1),\\n            mid = i >> 1\\n        for (let j = 1; j <= mid; j++) {\\n            let val = ans[i-1][j-1] + ans[i-1][j]\\n            row[j] = val, row[row.length-j-1] = val\\n        }\\n        ans[i] = row\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans = [None] * numRows\\n        for i in range(numRows):\\n            row, mid = [1] * (i + 1), (i >> 1) + 1\\n            for j in range(1, mid):\\n                val = ans[i-1][j-1] + ans[i-1][j]\\n                row[j], row[len(row)-j-1] = val, val\\n            ans[i] = row\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>(i+1);\\n            while (row.size() <= i) row.add(1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans.get(i-1).get(j-1) + ans.get(i-1).get(j);\\n                row.set(j, val);\\n                row.set(row.size()-j-1, val);\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i+1, 1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans[i-1][j-1] + ans[i-1][j];\\n                row[j] = val;\\n                row[row.size()-j-1] = val;\\n            }\\n            ans[i] = row;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar generate = function(numRows) {\\n    let ans = new Array(numRows)\\n    for (let i = 0; i < numRows; i++) {\\n        let row = new Uint32Array(i+1).fill(1),\\n            mid = i >> 1\\n        for (let j = 1; j <= mid; j++) {\\n            let val = ans[i-1][j-1] + ans[i-1][j]\\n            row[j] = val, row[row.length-j-1] = val\\n        }\\n        ans[i] = row\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans = [None] * numRows\\n        for i in range(numRows):\\n            row, mid = [1] * (i + 1), (i >> 1) + 1\\n            for j in range(1, mid):\\n                val = ans[i-1][j-1] + ans[i-1][j]\\n                row[j], row[len(row)-j-1] = val, val\\n            ans[i] = row\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>(i+1);\\n            while (row.size() <= i) row.add(1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans.get(i-1).get(j-1) + ans.get(i-1).get(j);\\n                row.set(j, val);\\n                row.set(row.size()-j-1, val);\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans(numRows);\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i+1, 1);\\n            int mid = i >> 1;\\n            for (int j = 1; j <= mid; j++) {\\n                int val = ans[i-1][j-1] + ans[i-1][j];\\n                row[j] = val;\\n                row[row.size()-j-1] = val;\\n            }\\n            ans[i] = row;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276140,
                "title": "generate-parentheses-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nWe can make short work of this problem with a basic branching **recursive** function (**dfs**). Our recursive function will iterate through the index positions (**pos**) of a possible result. At each **pos**, we can add an open parenthesis if there\\'s more remaining space than unclosed parentheses (**open**) and we can add a closed parenthesis if there are any unclosed parentheses. Once we reach the end of the result, we can add it to our answer array (**ans**).\\n\\nTo make things easier, we can use **bit manipulation** to pass the sequence of parentheses (**seq**) for our potential result as an integer to each new recursion level. Then we just have to translate **seq** to a parentheses string before adding it to **ans**.\\n\\nOnce we\\'re all done, we can just **return ans**.\\n\\n - _**Time Complexity: O((2 * N)!/(N! * N!)** reflecting the **2N choose N** possible arrangements of parentheses_\\n - _**Space Complexity: O(N)** for the recursion stack and **res**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 40.4MB** (beats 96% / 25%).\\n```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 96% / 96%).\\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.7MB** (beats 100% / 93%).\\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 13.7MB** (beats 100% / 57%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar generateParenthesis = function(N) {\\n    let ans = [], m = 2 * N\\n    \\n    const dfs = (pos, open, seq) => {\\n        if (pos === m) {\\n            let res = new Array(m)\\n            for (let i = 0; i < m; i++)\\n                res[i] = seq & 1 << i ? \"(\" : \")\"\\n            ans.push(res.join(\"\"))\\n            return\\n        }\\n        if (open) dfs(pos+1, open-1, seq)\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos)\\n    }\\n    \\n    dfs(0, 0, 0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def generateParenthesis(self, N: int) -> List[str]:\\n        ans, m = [], 2 * N\\n        \\n        def dfs(pos: int, opn: int, seq: int) -> None:\\n            if pos == m:\\n                res = [0] * m\\n                for i in range(m):\\n                    res[i] = \"(\" if seq & 1 << i else \")\"\\n                ans.append(\"\".join(res))\\n                return\\n            if opn: dfs(pos+1, opn-1, seq)\\n            if m - pos > opn: dfs(pos+1, opn+1, seq | 1 << pos)\\n            \\n        dfs(0, 0, 0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<String> generateParenthesis(int N) {\\n        ans = new ArrayList<>();\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\n    private List<String> ans;\\n    private int m;\\n    \\n    private void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            StringBuilder res = new StringBuilder();\\n            for (int i = 0; i < m; i++)\\n                res.append((seq & 1 << i) > 0 ? \"(\" : \")\");\\n            ans.add(res.toString());\\n            return;\\n        }\\n        if (open > 0) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> generateParenthesis(int N) {\\n        m = 2 * N;\\n        dfs(0, 0, 0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<string> ans;\\n    int m;\\n    \\n    void dfs(int pos, int open, int seq) {\\n        if (pos == m) {\\n            string res = \"\";\\n            for (int i = 0; i < m; i++)\\n                res += seq & 1 << i ? \"(\" : \")\";\\n            ans.push_back(res);\\n            return;\\n        }\\n        if (open) dfs(pos+1, open-1, seq);\\n        if (m - pos > open) dfs(pos+1, open+1, seq | 1 << pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241798,
                "title": "python-with-real-recursion",
                "content": "All top threads are anything but a recursive solution. Since this explore chapter is about recursion, I thought a recursive solution might be helpful:\\n```python\\nclass Solution:\\n    def generate(self, numRows: \\'int\\') -> \\'List[List[int]]\\':\\n        if numRows == 0: return [] # Base Case\\n        if numRows == 1: return [[1]] # Base Case\\n        row = []\\n        last = self.generate(numRows - 1) # Recursion\\n        for i in range(numRows):\\n            if i == 0 or i == numRows - 1: row.append(1)\\n            else: row.append(last[-1][i-1] + last[-1][i])\\n        last.append(row)\\n        return last\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def generate(self, numRows: \\'int\\') -> \\'List[List[int]]\\':\\n        if numRows == 0: return [] # Base Case\\n        if numRows == 1: return [[1]] # Base Case\\n        row = []\\n        last = self.generate(numRows - 1) # Recursion\\n        for i in range(numRows):\\n            if i == 0 or i == numRows - 1: row.append(1)\\n            else: row.append(last[-1][i-1] + last[-1][i])\\n        last.append(row)\\n        return last\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018127,
                "title": "c-beats-100-0ms-java-python-dp-combinatorics-commented-code",
                "content": "# Problem Description\\nGiven an integer numRows, return the first `numRows` of **Pascal\\'s triangle**.\\n\\nIn **Pascal\\'s triangle**, each number is the sum of the two numbers directly above it as shown:\\n\\n![PascalTriangleAnimated2.gif](https://assets.leetcode.com/users/images/c5f3440e-572a-4c43-a4b5-a8334b37c1a6_1694155184.236237.gif)\\n\\n\\n---\\n\\n\\n# Proposed Solutions\\n## 1. Dynamic Programming\\n\\n### Approach\\n1. **Initialize 2D Vector**: Create a 2D vector pascalTriangle with numRows rows to represent Pascal\\'s Triangle.\\n2. **Generate Rows**: Generate first row seperately then Loop through each row from 1 to numRows - 1.\\n3. **Set First and Last Elements**: Set the first and last elements of each row to 1.\\n4. **Calculate Middle Elements**: For each row, calculate and append the middle elements by adding the corresponding elements from the previous row.\\n5. **Return** Pascal\\'s Triangle.\\n\\n### Complexity\\n- **Time complexity:**\\nWe have two for-loops each of max size of `n`, then time complexity is `O(N^2)`.\\n- **Space complexity:**\\n`O(N^2)`, Since we are storing the triangle.\\n\\n\\n## 2. Combinatorics \\n\\n### Approach\\n1. **Initialize 2D Vector**: Create a 2D vector pascalTriangle with numRows rows to represent Pascal\\'s Triangle.\\n2. **Generate Rows**: Loop through each row from 0 to numRows-1.\\n3. **Calculate Middle Elements**: For each row, calculate and append the row elements by calculating combinatorics like the picture below :\\n![leet.PNG](https://assets.leetcode.com/users/images/60304d80-d884-40b3-afe9-9eafb6524d6d_1694155213.5776231.png)\\n\\n\\n4. **Return** Pascal\\'s Triangle.\\n\\n\\n### Complexity\\n- **Time complexity:**\\nWe have two for-loops each of max size of `n` and we have the for loop that generates the combinatorics, then time complexity is `O(N^3)`.\\nBut it won\\'t make any difference since `1 <= N <= 30`.\\n- **Space complexity:**\\n`O(N^2)`, Since we are storing the triangle.\\n\\n---\\n\\n\\n# Code\\n## 1. Dynamic Programming\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        // Initialize a 2D vector to represent Pascal\\'s Triangle\\n        vector<vector<int>> pascalTriangle(numRows);\\n\\n        // Initialize the first row with a single element \\'1\\'\\n        pascalTriangle[0].push_back(1);\\n\\n        // Generate the rest of the rows\\n        for (int currentRow = 1; currentRow < numRows; currentRow++) {\\n            // The first element of each row is always \\'1\\'\\n            pascalTriangle[currentRow].push_back(1);\\n\\n            // Get a reference to the current row and the previous row\\n            vector<int>& currentRowList = pascalTriangle[currentRow];\\n            const vector<int>& previousRowList = pascalTriangle[currentRow - 1];\\n\\n            // Calculate and populate the middle elements of the row\\n            for (int j = 1; j < previousRowList.size(); j++) {\\n                int sum = previousRowList[j] + previousRowList[j - 1];\\n                currentRowList.push_back(sum);\\n            }\\n\\n            // The last element of each row is also \\'1\\'\\n            currentRowList.push_back(1);\\n        }\\n\\n        return pascalTriangle;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        // Initialize the result as a list of lists\\n        List<List<Integer>> pascalTriangle = new ArrayList<>();\\n\\n        // Initialize the first row with a single element \\'1\\'\\n        pascalTriangle.add(new ArrayList<>());\\n        pascalTriangle.get(0).add(1);\\n\\n        // Generate the rest of the rows\\n        for (int currentRow = 1; currentRow < numRows; currentRow++) {\\n            // Create a new row for the current level\\n            pascalTriangle.add(new ArrayList<>());\\n\\n            // Get references to the current and previous rows\\n            List<Integer> currentRowList = pascalTriangle.get(currentRow);\\n            List<Integer> previousRowList = pascalTriangle.get(currentRow - 1);\\n\\n            // The first element of each row is always \\'1\\'\\n            currentRowList.add(1);\\n\\n            // Calculate and populate the middle elements of the row\\n            for (int j = 1; j < previousRowList.size(); j++) {\\n                int sum = previousRowList.get(j) + previousRowList.get(j - 1);\\n                currentRowList.add(sum);\\n            }\\n\\n            // The last element of each row is also \\'1\\'\\n            currentRowList.add(1);\\n        }\\n\\n        return pascalTriangle;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \"\"\"\\n        Generates Pascal\\'s Triangle up to the specified number of rows.\\n        :param numRows: The number of rows to generate in Pascal\\'s Triangle.\\n        :return: A list of lists representing Pascal\\'s Triangle.\\n        \"\"\"\\n        # Initialize Pascal\\'s Triangle with empty lists\\n        pascal_triangle = [[] for _ in range(numRows)]\\n\\n        # Set the first element of the first row to 1\\n        pascal_triangle[0].append(1)\\n\\n        # Generate the rest of the rows\\n        for i in range(1, numRows):\\n            current_row = pascal_triangle[i]\\n            prev_row = pascal_triangle[i - 1]\\n\\n            # The first element of each row is always 1\\n            current_row.append(1)\\n\\n            # Calculate and populate the middle elements of the row\\n            for j in range(1, len(prev_row)):\\n                element_sum = prev_row[j] + prev_row[j - 1]\\n                current_row.append(element_sum)\\n\\n            # The last element of each row is also 1\\n            current_row.append(1)\\n\\n        return pascal_triangle\\n\\n```\\n\\n## 2. Combinatorics\\n```C++ []\\nclass Solution {\\npublic:\\n    // Calculate n choose r (nCr) using a loop\\n    int calculateCombination(int n, int r) {\\n        int result = 1;\\n        for (int i = 0; i < r; i++) {\\n            result = result * (n - i) / (i + 1);\\n        }\\n        return result;\\n    }\\n\\n    // Generate Pascal\\'s Triangle with \\'numRows\\' rows\\n    vector<vector<int>> generate(int numRows) {\\n        // Initialize a 2D vector to represent Pascal\\'s Triangle\\n        vector<vector<int>> pascalTriangle(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                // Calculate and insert the binomial coefficient (nCr) into the current row\\n                pascalTriangle[i].push_back(calculateCombination(i, j));\\n            }\\n        }\\n        return pascalTriangle;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    // Calculate n choose r (nCr) using a loop\\n    public int calculateCombination(int n, int r) {\\n        int result = 1;\\n        for (int i = 0; i < r; i++) {\\n            result = result * (n - i) / (i + 1);\\n        }\\n        return result;\\n    }\\n\\n    // Generate Pascal\\'s Triangle with \\'numRows\\' rows\\n    public List<List<Integer>> generate(int numRows) {\\n        // Initialize a list of lists to represent Pascal\\'s Triangle\\n        List<List<Integer>> pascalTriangle = new ArrayList<>();\\n\\n        for (int i = 0; i < numRows; i++) {\\n            pascalTriangle.add(new ArrayList<>());\\n            List<Integer> currentRow = pascalTriangle.get(i);\\n\\n            for (int j = 0; j <= i; j++) {\\n                // Calculate and insert the binomial coefficient (nCr) into the current row\\n                currentRow.add(calculateCombination(i, j));\\n            }\\n        }\\n        return pascalTriangle;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n\\n    def calculate_combination(self, n: int, r: int) -> int:\\n        \"\"\"\\n        Calculate the combination (n choose r) using the formula C(n, r) = n! / (r! * (n - r)!).\\n        :param n: Total number of items.\\n        :param r: Number of items to choose.\\n        :return: The combination value C(n, r).\\n        \"\"\"\\n        result = 1\\n        for i in range(r):\\n            result = result * (n - i) // (i + 1)  # Use integer division to ensure an integer result\\n        return result\\n\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \"\"\"\\n        Generate Pascal\\'s Triangle up to a given number of rows.\\n        :param numRows: The number of rows in the Pascal\\'s Triangle.\\n        :return: A list of lists representing Pascal\\'s Triangle.\\n        \"\"\"\\n        pascal_triangle = [[] for _ in range(numRows)]\\n\\n        for i in range(numRows):\\n            for j in range(i + 1):\\n                pascal_triangle[i].append(self.calculate_combination(i, j))\\n\\n        return pascal_triangle\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        // Initialize a 2D vector to represent Pascal\\'s Triangle\\n        vector<vector<int>> pascalTriangle(numRows);\\n\\n        // Initialize the first row with a single element \\'1\\'\\n        pascalTriangle[0].push_back(1);\\n\\n        // Generate the rest of the rows\\n        for (int currentRow = 1; currentRow < numRows; currentRow++) {\\n            // The first element of each row is always \\'1\\'\\n            pascalTriangle[currentRow].push_back(1);\\n\\n            // Get a reference to the current row and the previous row\\n            vector<int>& currentRowList = pascalTriangle[currentRow];\\n            const vector<int>& previousRowList = pascalTriangle[currentRow - 1];\\n\\n            // Calculate and populate the middle elements of the row\\n            for (int j = 1; j < previousRowList.size(); j++) {\\n                int sum = previousRowList[j] + previousRowList[j - 1];\\n                currentRowList.push_back(sum);\\n            }\\n\\n            // The last element of each row is also \\'1\\'\\n            currentRowList.push_back(1);\\n        }\\n\\n        return pascalTriangle;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        // Initialize the result as a list of lists\\n        List<List<Integer>> pascalTriangle = new ArrayList<>();\\n\\n        // Initialize the first row with a single element \\'1\\'\\n        pascalTriangle.add(new ArrayList<>());\\n        pascalTriangle.get(0).add(1);\\n\\n        // Generate the rest of the rows\\n        for (int currentRow = 1; currentRow < numRows; currentRow++) {\\n            // Create a new row for the current level\\n            pascalTriangle.add(new ArrayList<>());\\n\\n            // Get references to the current and previous rows\\n            List<Integer> currentRowList = pascalTriangle.get(currentRow);\\n            List<Integer> previousRowList = pascalTriangle.get(currentRow - 1);\\n\\n            // The first element of each row is always \\'1\\'\\n            currentRowList.add(1);\\n\\n            // Calculate and populate the middle elements of the row\\n            for (int j = 1; j < previousRowList.size(); j++) {\\n                int sum = previousRowList.get(j) + previousRowList.get(j - 1);\\n                currentRowList.add(sum);\\n            }\\n\\n            // The last element of each row is also \\'1\\'\\n            currentRowList.add(1);\\n        }\\n\\n        return pascalTriangle;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \"\"\"\\n        Generates Pascal\\'s Triangle up to the specified number of rows.\\n        :param numRows: The number of rows to generate in Pascal\\'s Triangle.\\n        :return: A list of lists representing Pascal\\'s Triangle.\\n        \"\"\"\\n        # Initialize Pascal\\'s Triangle with empty lists\\n        pascal_triangle = [[] for _ in range(numRows)]\\n\\n        # Set the first element of the first row to 1\\n        pascal_triangle[0].append(1)\\n\\n        # Generate the rest of the rows\\n        for i in range(1, numRows):\\n            current_row = pascal_triangle[i]\\n            prev_row = pascal_triangle[i - 1]\\n\\n            # The first element of each row is always 1\\n            current_row.append(1)\\n\\n            # Calculate and populate the middle elements of the row\\n            for j in range(1, len(prev_row)):\\n                element_sum = prev_row[j] + prev_row[j - 1]\\n                current_row.append(element_sum)\\n\\n            # The last element of each row is also 1\\n            current_row.append(1)\\n\\n        return pascal_triangle\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Calculate n choose r (nCr) using a loop\\n    int calculateCombination(int n, int r) {\\n        int result = 1;\\n        for (int i = 0; i < r; i++) {\\n            result = result * (n - i) / (i + 1);\\n        }\\n        return result;\\n    }\\n\\n    // Generate Pascal\\'s Triangle with \\'numRows\\' rows\\n    vector<vector<int>> generate(int numRows) {\\n        // Initialize a 2D vector to represent Pascal\\'s Triangle\\n        vector<vector<int>> pascalTriangle(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                // Calculate and insert the binomial coefficient (nCr) into the current row\\n                pascalTriangle[i].push_back(calculateCombination(i, j));\\n            }\\n        }\\n        return pascalTriangle;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    // Calculate n choose r (nCr) using a loop\\n    public int calculateCombination(int n, int r) {\\n        int result = 1;\\n        for (int i = 0; i < r; i++) {\\n            result = result * (n - i) / (i + 1);\\n        }\\n        return result;\\n    }\\n\\n    // Generate Pascal\\'s Triangle with \\'numRows\\' rows\\n    public List<List<Integer>> generate(int numRows) {\\n        // Initialize a list of lists to represent Pascal\\'s Triangle\\n        List<List<Integer>> pascalTriangle = new ArrayList<>();\\n\\n        for (int i = 0; i < numRows; i++) {\\n            pascalTriangle.add(new ArrayList<>());\\n            List<Integer> currentRow = pascalTriangle.get(i);\\n\\n            for (int j = 0; j <= i; j++) {\\n                // Calculate and insert the binomial coefficient (nCr) into the current row\\n                currentRow.add(calculateCombination(i, j));\\n            }\\n        }\\n        return pascalTriangle;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n\\n    def calculate_combination(self, n: int, r: int) -> int:\\n        \"\"\"\\n        Calculate the combination (n choose r) using the formula C(n, r) = n! / (r! * (n - r)!).\\n        :param n: Total number of items.\\n        :param r: Number of items to choose.\\n        :return: The combination value C(n, r).\\n        \"\"\"\\n        result = 1\\n        for i in range(r):\\n            result = result * (n - i) // (i + 1)  # Use integer division to ensure an integer result\\n        return result\\n\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \"\"\"\\n        Generate Pascal\\'s Triangle up to a given number of rows.\\n        :param numRows: The number of rows in the Pascal\\'s Triangle.\\n        :return: A list of lists representing Pascal\\'s Triangle.\\n        \"\"\"\\n        pascal_triangle = [[] for _ in range(numRows)]\\n\\n        for i in range(numRows):\\n            for j in range(i + 1):\\n                pascal_triangle[i].append(self.calculate_combination(i, j))\\n\\n        return pascal_triangle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38236,
                "title": "python-solution-very-easy-to-understand",
                "content": "    class Solution(object):\\n    def generate(self, numRows):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        n,b,res=0,[1],[]\\n        while n<numRows:\\n            res.append(b)\\n            b=[1]+[b[i]+b[i+1] for i in xrange(len(b)-1)]+[1]\\n            n+=1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def generate(self, numRows):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        n,b,res=0,[1],[]\\n        while n<numRows:\\n            res.append(b)\\n            b=[1]+[b[i]+b[i+1] for i in xrange(len(b)-1)]+[1]\\n            n+=1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2301626,
                "title": "java-simple-and-easy-solution-100-faster-code",
                "content": "PLEASE UPVOTE If you like.\\n```\\nclass Solution {\\n   public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> lst = new ArrayList<>();\\n    List<Integer> pre = null;\\n    for(int i = 0;i<numRows;i++){\\n        List<Integer> a = new ArrayList<>();\\n        for(int j=0;j<=i;j++){\\n            if(j==0||j==i){\\n                a.add(1);\\n            }\\n            else{\\n                a.add(pre.get(j-1)+pre.get(j));\\n            }                \\n        }\\n        pre = a;\\n        lst.add(a);\\n    }        \\n    return lst;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> lst = new ArrayList<>();\\n    List<Integer> pre = null;\\n    for(int i = 0;i<numRows;i++){\\n        List<Integer> a = new ArrayList<>();\\n        for(int j=0;j<=i;j++){\\n            if(j==0||j==i){\\n                a.add(1);\\n            }\\n            else{\\n                a.add(pre.get(j-1)+pre.get(j));\\n            }                \\n        }\\n        pre = a;\\n        lst.add(a);\\n    }        \\n    return lst;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287145,
                "title": "pascal-s-triangle-short-simple-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Dynamic Programming - Iterative)***\\n\\nThe pascal triangle problem has a very simple and intuitive dynamic programming approach. As the definition states, every element of a row is formed by the sum of the two numbers directly above. So, we can just apply DP and use the previously stored rows of trianlge to calculate the new rows.\\n\\nWe can just initialize the start and end elements of each row as 1 and update only the elements between them. This will make the code simpler and avoid the need of having extra checks for edge elements of each row.\\n\\n<iframe src=\"https://leetcode.com/playground/e8owLiQV/shared\" width=\"100%\" height=270 frameBorder=\"0\"></iframe>\\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Top-Down Recursive)***\\n\\nHere, the same logic as above is applied, just using a recursive implementation. We will start from the bottom of triangle and recursively call the *`generate(n-1)`*, till the top-most row of trianlge is generated  and then construct the bottom rows one-by-one using the values from the above rows.\\n\\n\\n<iframe src=\"https://leetcode.com/playground/K8tqSfYu/shared\" frameBorder=\"0\" width=\"100%\" height=\"270\"></iframe>\\n\\n \\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "\\u2714\\uFE0F ***Solution - I (Dynamic Programming - Iterative)***\\n\\nThe pascal triangle problem has a very simple and intuitive dynamic programming approach. As the definition states, every element of a row is formed by the sum of the two numbers directly above. So, we can just apply DP and use the previously stored rows of trianlge to calculate the new rows.\\n\\nWe can just initialize the start and end elements of each row as 1 and update only the elements between them. This will make the code simpler and avoid the need of having extra checks for edge elements of each row.\\n\\n<iframe src=\"https://leetcode.com/playground/e8owLiQV/shared\" width=\"100%\" height=270 frameBorder=\"0\"></iframe>\\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Top-Down Recursive)***\\n\\nHere, the same logic as above is applied, just using a recursive implementation. We will start from the bottom of triangle and recursively call the *`generate(n-1)`*, till the top-most row of trianlge is generated  and then construct the bottom rows one-by-one using the values from the above rows.\\n\\n\\n<iframe src=\"https://leetcode.com/playground/K8tqSfYu/shared\" frameBorder=\"0\" width=\"100%\" height=\"270\"></iframe>\\n\\n \\n\\n\\n***Time Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n***Space Complexity :*** <b><code>O(n<sup>2</sup>)</code></b>\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "codeTag": "Unknown"
            },
            {
                "id": 1276582,
                "title": "generate-parentheses-short-easy-solution-w-explanation-beats-100",
                "content": "\\u2714\\uFE0F ***Solution - I (Brute - Force)***\\n\\nWe have `n` pair of parenthesis which means we are required to form a valid parenthesis string of `length == 2*n`. Let\\'s start with the brute-force way. At each position of the string, we can insert **`(`** or **`)`** brackets and so we will try both the options. Atlast, when the length of string becomes `2*n`, we will perform a check and insert into `ans` array if it is valid.\\n\\n```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup> * n)</code>**, for each index in string, we try both the parenthesis which is <code>2`*`2`*`2...2n times = O(2<sup>2n</sup>) = O(4<sup>n</sup>) </code> and lastly, we spend an `O(n)` time to check for the formed string\\'s validity. \\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>** (A tighter bound exists)\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Approach)***\\n\\nInstead of trying out both the brackets at each index of the string, we only try them at places which won\\'t outright invalidate the string. For eg. In the previous approach, we were trying to insert `)` even at the start which would surely not have generated a valid parenthesis. Here, we avoid that. We have 2 cases:\\n\\n* **`(`** can be inserted anywhere till its count is less than `n`\\n* **`)`** can be inserted whenever its count is less than `start` (number of openinig parenthesis)\\n\\nFinally, we will insert the string when its length reaches `2*n`.\\n\\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```\\n\\n***Time Complexity :*** **<code>O(4<sup>n</sup>)</code>** Here we save the time for string validation at the end and also avoid the extra recursive calls which we know are invalid anyway. \\n**Note**: There exists a tighter bound - <code>O(4<sup>n</sup> / &radic;n)</code>  but without deep analysis of the recursion structure, it\\'s very hard to arrive at it. So, <code>O(4<sup>n</sup>)</code> is good enough for quick estimations\\n**Space Complexity :** **<code>O(4<sup>n</sup>)</code>**, Tighter bound - **<code>O(4<sup>n</sup> / &radic;n)</code>**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/001e3d19-b69f-4c1b-96c9-f760343aef54_1623844459.7738905.png  /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<string> ans;\\nvector<string> generateParenthesis(int n) {\\n\\tsolve(\"\", 2*n);\\n\\treturn ans;\\n}\\nvoid solve(string s, int N){\\n\\tif(size(s) == N){\\n\\t\\tif(valid(s)) ans.push_back(s);\\n\\t\\treturn;\\n\\t}\\n\\tsolve(s + \\'(\\', N);\\n\\tsolve(s + \\')\\', N);\\n}\\nbool valid(string& s, int diff = 0) {\\n\\tfor(auto& ch: s) {\\n\\t\\tdiff += (ch == \\'(\\' ? 1 : -1);\\n\\t\\tif(diff < 0) return false;\\n\\t}\\n\\treturn !diff;\\n}\\n```\n```\\nvector<string> generateParenthesis(int n) {\\n\\tvector<string> ans;\\n\\tsolve(0, 0, n, \"\", ans);\\n\\treturn ans;\\n}\\nvoid solve(int start, int close, int n, string s, vector<string>& ans) {\\n\\tif(size(s) == 2*n) ans.push_back(move(s));  // use move to directly push the constructed string into vector instead of creating a copy\\n\\tif(start < n) solve(start + 1, close, n, s + \\'(\\', ans);\\n\\tif(close < start) solve(start, close + 1, n, s + \\')\\', ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 892136,
                "title": "very-simple-iterative-js-solution",
                "content": "```\\nvar generate = function(numRows) {\\n    if (!numRows) return [];\\n    let matrix = [[1]];\\n    for (let i = 1; i < numRows; i++) {\\n        let row = [1], j = 1;\\n        while (j < i) {\\n            row.push(matrix[i-1][j-1]+matrix[i-1][j]);\\n            j++;\\n        }\\n        row.push(1);\\n        matrix.push(row);\\n    }\\n    return matrix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generate = function(numRows) {\\n    if (!numRows) return [];\\n    let matrix = [[1]];\\n    for (let i = 1; i < numRows; i++) {\\n        let row = [1], j = 1;\\n        while (j < i) {\\n            row.push(matrix[i-1][j-1]+matrix[i-1][j]);\\n            j++;\\n        }\\n        row.push(1);\\n        matrix.push(row);\\n    }\\n    return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432944,
                "title": "c-short-simple-iterative-solution-100-time-100-space",
                "content": "Because recursion is not necessarily always the best approach!\\n\\nWe will create a result variable `res` that we will initialise with the value always expected on top of our triangle: `{{1}}`.\\n\\nWe will then proceed `n - 1` times like this:\\n* we will generate a new row `tmp` `1` cell longer than the previous, with all the values preset to `1`;\\n* we will then compute the value of all the internal cells of `tmp` as the sum of the two cells above it in the previous row (`res.back()`);\\n* finally, we will push `tmp` in `res`.\\n\\nOnce done, we can return `res` :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        // support variables\\n        vector<std::vector<int>> res = {{1}};\\n        while (--n) {\\n            // creating the new row tmp, bigger than the previous by 1\\n            vector<int> tmp(res.back().size() + 1, 1);\\n            // computing the value of all the cells not at the border\\n            for (int i = 1; i < tmp.size() - 1; i++) {\\n                tmp[i] = res.back()[i - 1] + res.back()[i];\\n            }\\n            // adding the new row to res\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        // support variables\\n        vector<std::vector<int>> res = {{1}};\\n        while (--n) {\\n            // creating the new row tmp, bigger than the previous by 1\\n            vector<int> tmp(res.back().size() + 1, 1);\\n            // computing the value of all the cells not at the border\\n            for (int i = 1; i < tmp.size() - 1; i++) {\\n                tmp[i] = res.back()[i - 1] + res.back()[i];\\n            }\\n            // adding the new row to res\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292962,
                "title": "c-using-lists",
                "content": "The C# signature wants the results as lists - this would be easier with arrays (and you could generated the arrays and then convert them into lists). This solution keeps it as just lists, though:\\n\\n```\\npublic IList<IList<int>> Generate(int numRows) {\\n    var result = new List<IList<int>>();\\n\\n    if (numRows == 0)\\n        return result;\\n\\n    // Seed the first list with a one.\\n    var previousRow = new List<int>();\\n    previousRow.Add(1);\\n    result.Add(previousRow);\\n\\n    for (int i = 1; i < numRows; i++)\\n    {\\n        var currentRow = new List<int>();\\n\\n        // Scan through each value in the previous row. Keep track of\\n        // the value and the one we previously looked at to sum to make\\n        // the new entry for the current row.\\n        int previous = 0;\\n        foreach (int val in previousRow)\\n        {\\n            currentRow.Add(previous + val);\\n            previous = val;\\n        }\\n\\n        // We need to add the final one to the new row.\\n        currentRow.Add(1);\\n\\n        result.Add(currentRow);\\n        previousRow = currentRow;\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic IList<IList<int>> Generate(int numRows) {\\n    var result = new List<IList<int>>();\\n\\n    if (numRows == 0)\\n        return result;\\n\\n    // Seed the first list with a one.\\n    var previousRow = new List<int>();\\n    previousRow.Add(1);\\n    result.Add(previousRow);\\n\\n    for (int i = 1; i < numRows; i++)\\n    {\\n        var currentRow = new List<int>();\\n\\n        // Scan through each value in the previous row. Keep track of\\n        // the value and the one we previously looked at to sum to make\\n        // the new entry for the current row.\\n        int previous = 0;\\n        foreach (int val in previousRow)\\n        {\\n            currentRow.Add(previous + val);\\n            previous = val;\\n        }\\n\\n        // We need to add the final one to the new row.\\n        currentRow.Add(1);\\n\\n        result.Add(currentRow);\\n        previousRow = currentRow;\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247967,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    if (numRows === 0) {\\n        return [];\\n    }\\n    const result = [];\\n    for (let i = 0; i < numRows; i++) {\\n        let currRow = [];\\n        for (let j = 0; j <= i; j++) {\\n            if (j === 0 || j === i){\\n                currRow.push(1);\\n            } else {\\n                currRow.push(result[i - 1][j - 1] + result[i - 1][j]);\\n            }\\n        }\\n        result.push(currRow);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    if (numRows === 0) {\\n        return [];\\n    }\\n    const result = [];\\n    for (let i = 0; i < numRows; i++) {\\n        let currRow = [];\\n        for (let j = 0; j <= i; j++) {\\n            if (j === 0 || j === i){\\n                currRow.push(1);\\n            } else {\\n                currRow.push(result[i - 1][j - 1] + result[i - 1][j]);\\n            }\\n        }\\n        result.push(currRow);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197701,
                "title": "python-solution",
                "content": "Time complexity O(numRows^2), space complexity: O(numRows^2)\\n```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[1]*i for i in range(1, numRows+1)]\\n        for i in range(2, numRows):\\n            for j in range(1, i):\\n                res[i][j] = res[i-1][j-1]+res[i-1][j]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[1]*i for i in range(1, numRows+1)]\\n        for i in range(2, numRows):\\n            for j in range(1, i):\\n                res[i][j] = res[i-1][j-1]+res[i-1][j]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016151,
                "title": "beats-100-c-c-python-iterative-dp-math-explain",
                "content": "# Intuition\\nHere is a real C solution provided which is really very rare.\\n\\nSolution via Pascal\\'s identity $$C^i_j=C^{i-1}_{j-1}+C^{i-1}_{j}$$& $$C^i_j=C^i_{i-j}$$\\n\\nDon\\'t use the built-in function comb(i, j) to compute, because it is very time consuming.\\n\\nIt is also not suggested direct to use the defintion to compute:\\n$$\\nC^i_j=\\\\frac{i!}{j!(i-j)!}\\n$$\\nwhere the compting for factorial $i!$ is very slow $O(i)$& will overflow when $i$ is more than 12 for 32-bit int. Pascal triangle is a theorem for computing binomial coefficients!\\n$$\\n(x+y)^i=\\\\sum_{j=0}^i C^i_jx^{i-j}y^j\\n$$\\n# Use binomial coefficients to prove Pascal\\'s triangle:\\n$$\\n(x+y)^i=\\\\sum_{j=0}^i C^i_jx^{i-j}y^j\\\\\\\\\\n=(x+y)^{i-1}(x+y)\\\\\\\\\\n=\\\\sum_{j=1}^i C^{i-1}_{j-1}x^ {i-j-1}y^j(x+y)\\\\\\\\\\n=\\\\sum_{j=1}^i C^{i-1}_{j-1}x^ {i-j}y^j+\\\\sum_{j=0}^{i-1} C^{i-1}_{j}x^ {i-j}y^j\\n$$\\nCompare the coefficients for term $x^{i-j}y^j$, one obtain \\n$$C^i_j=C^{i-1}_{j-1}+C^{i-1}_{j}$$ QED.\\n# Approach\\nIterative DP uses double for loop.\\n\\n[Please turn English subtitles if neccessary]\\n[https://www.youtube.com/watch?v=paoJGMYEEhA](https://www.youtube.com/watch?v=paoJGMYEEhA)\\n# Complexity\\n- Time complexity:\\n $$O(n^2)$$\\n\\n- Space complexity:\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n^2)$$ for returning answer. $$O(1)$$ for extra need.\\n\\n\\n# Code Runtime 0ms Beats 100%\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> a(numRows);\\n        for(int&& i=0; i<numRows; i++){\\n            a[i].assign(i+1, 1);// exact allocation once\\n            for(int&& j=1; j<=i/2; j++){\\n                  a[i][i-j]=a[i][j]=a[i-1][j-1]+a[i-1][j];\\n                        \\n            }              \\n        }\\n        return a;\\n    }\\n};\\n\\n```\\n# C code\\n```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes) {\\n    int** a = (int**)malloc(sizeof(int*) * numRows);\\n    *returnSize = numRows;\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*numRows); //Allocate for column sizes array\\n\\n    for (register int i=0; i<numRows; i++) {\\n        (*returnColumnSizes)[i] =i+1; // Set the size of each row in column sizes array\\n        a[i] = (int*)malloc(sizeof(int)*(i+1));\\n\\n        a[i][0] = a[i][i] = 1;\\n        for (register int j=1; j<=i/2; j++) {\\n            a[i][j]=a[i][i-j]= a[i-1][j-1]+a[i-1][j];\\n        }\\n    }\\n    return a;\\n}\\n```\\n# Python solution\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a=[[]]*numRows\\n        for i in range(numRows):\\n            a[i]=[1]*(i+1)\\n            for j in range(1,i//2+1):\\n                a[i][i-j]=a[i][j]=a[i-1][j-1]+a[i-1][j]\\n        return a\\n```\\n# Python code using lambda function\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a = [[1]]\\n        for i in range(1, numRows):\\n            a += [list(map(lambda x, y: x+y, a[-1] + [0], [0] + a[-1]))]\\n        return a[:numRows]\\n```\\n# Pascal Traingle can solve [62. Unique Paths](https://leetcode.com/problems/unique-paths/solutions/3994527/c-python-math-pascal-triangle-dp-beats-100/)\\n[Please turn on English subtitles if necessary]\\n[https://youtu.be/sgRvG0rhWGI?si=N7nEiMEw70QCsnLx](https://youtu.be/sgRvG0rhWGI?si=N7nEiMEw70QCsnLx)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> a(numRows);\\n        for(int&& i=0; i<numRows; i++){\\n            a[i].assign(i+1, 1);// exact allocation once\\n            for(int&& j=1; j<=i/2; j++){\\n                  a[i][i-j]=a[i][j]=a[i-1][j-1]+a[i-1][j];\\n                        \\n            }              \\n        }\\n        return a;\\n    }\\n};\\n\\n```\n```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes) {\\n    int** a = (int**)malloc(sizeof(int*) * numRows);\\n    *returnSize = numRows;\\n    *returnColumnSizes=(int*)malloc(sizeof(int)*numRows); //Allocate for column sizes array\\n\\n    for (register int i=0; i<numRows; i++) {\\n        (*returnColumnSizes)[i] =i+1; // Set the size of each row in column sizes array\\n        a[i] = (int*)malloc(sizeof(int)*(i+1));\\n\\n        a[i][0] = a[i][i] = 1;\\n        for (register int j=1; j<=i/2; j++) {\\n            a[i][j]=a[i][i-j]= a[i-1][j-1]+a[i-1][j];\\n        }\\n    }\\n    return a;\\n}\\n```\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a=[[]]*numRows\\n        for i in range(numRows):\\n            a[i]=[1]*(i+1)\\n            for j in range(1,i//2+1):\\n                a[i][i-j]=a[i][j]=a[i-1][j-1]+a[i-1][j]\\n        return a\\n```\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a = [[1]]\\n        for i in range(1, numRows):\\n            a += [list(map(lambda x, y: x+y, a[-1] + [0], [0] + a[-1]))]\\n        return a[:numRows]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459929,
                "title": "beats-87-84-16-145-top-interview-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*Dynamic Programming*\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a Python implementation of the Pascal\\'s Triangle. The function `generate` takes an integer `numRows` as input and returns a 2D list of integers that represents the Pascal\\'s Triangle up to the `numRows`th row.\\n\\nThe function first creates a `numRows` by `numRows` 2D list called `pascalTriangle`. Each element in the first `numRows` rows is set to 1, representing the first and last element of each row.\\n\\nThe outer loop iterates over each row from the third row (index 2) up to the `numRows`th row. The inner loop iterates over each column from the second column (index 1) up to the column before the last column in the row.\\n\\nFor each element in the `pascalTriangle` that is not in the first or last column of each row, its value is the sum of the two elements directly above it in the previous row. This is calculated using the formula: `pascalTriangle[row][col] = pascalTriangle[row-1][col] + pascalTriangle[row-1][col-1]`.\\n\\nAfter iterating through all the rows and columns, the function returns the `pascalTriangle` list, which represents the Pascal\\'s Triangle up to the `numRows`th row.\\n# Complexity\\n- Time complexity:\\n O(numRows^2)\\n\\n\\n- Space complexity:\\n O(numRows^2) *`can optimze to ^1`*\\n\\nThe `time complexity` of the `generate` function is `O(numRows^2)`. This is because we are creating a 2D list of size numRows x numRows, and we need to iterate over each element in the list to calculate its value. The outer loop iterates numRows times, and the inner loop iterates up to numRows times for each row. Therefore, the total number of iterations is the sum of the first numRows integers, which is `O(numRows^2)`.\\n\\nThe `space complexity` of the `generate` function is also `O(numRows^2)`. This is because we are creating a 2D list of size numRows x numRows to store the Pascal\\'s Triangle. Each element in the list is an integer, so the total number of integers we are storing is also `O(numRows^2)`. Therefore, the space complexity of the function is proportional to the size of the 2D list, which is `O(numRows^2)`.\\n\\n\\n*note : - minor optimizations we can make in terms of space complexity, such as using a 1D list to store only the previous row of the triangle instead of the entire triangle. This would reduce the space complexity to *`O(numRows)`*, but the time complexity would remain O(numRows^2). However, the code may become slightly more complex and harder to read with this optimization.*\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        pascalTriangle = [ [1] * x for x in range(1,numRows+1)]\\n\\n        \\n        for row in range(2, len(pascalTriangle)):\\n            for col in range(1, row):\\n                pascalTriangle[row][col] = pascalTriangle[row-1][col] + pascalTriangle[row-1][col-1]\\n        return pascalTriangle\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        pascalTriangle = [ [1] * x for x in range(1,numRows+1)]\\n\\n        \\n        for row in range(2, len(pascalTriangle)):\\n            for col in range(1, row):\\n                pascalTriangle[row][col] = pascalTriangle[row-1][col] + pascalTriangle[row-1][col-1]\\n        return pascalTriangle\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276703,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O( n^2 )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( n^2 )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int n) {\\n        \\n        List< List<Integer>> arr = new ArrayList<>();\\n        ArrayList<Integer> first = new ArrayList<>();\\n        first.add(1);\\n        arr.add(first);\\n\\n        for (int i = 1; i < n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(1);\\n            List<Integer> prev = arr.get(i-1);\\n            for (int j = 1; j < prev.size(); j++)\\n            {\\n                temp.add( prev.get(j-1)+prev.get(j) );\\n            }\\n            temp.add(1);\\n            arr.add( temp);\\n        }\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int n) {\\n        \\n        List< List<Integer>> arr = new ArrayList<>();\\n        ArrayList<Integer> first = new ArrayList<>();\\n        first.add(1);\\n        arr.add(first);\\n\\n        for (int i = 1; i < n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            temp.add(1);\\n            List<Integer> prev = arr.get(i-1);\\n            for (int j = 1; j < prev.size(); j++)\\n            {\\n                temp.add( prev.get(j-1)+prev.get(j) );\\n            }\\n            temp.add(1);\\n            arr.add( temp);\\n        }\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867803,
                "title": "beats-100-c-solution-upvote-if-you-like",
                "content": "# Intuition\\n## **Math**\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n           vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n        \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n           vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287235,
                "title": "python-short-and-easy-explained",
                "content": "In this problem we just need to use the definition of pascal\\'s triangle: to create next row we need to look at previoius row and compute elements. We can do it efficiently using `zip` functionality in python.\\n\\n#### Complexity\\nIt is `O(n^2)` both for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def generate(self, n):\\n        ans = [[1]]\\n        for i in range(n-1):\\n            ans.append([x+y for x,y in zip([0]+ans[-1], ans[-1] + [0])])     \\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def generate(self, n):\\n        ans = [[1]]\\n        for i in range(n-1):\\n            ans.append([x+y for x,y in zip([0]+ans[-1], ans[-1] + [0])])     \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077777,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> Generate(int numRows) {\\n        IList<IList<int>> res = new List<IList<int>>() { new List<int>() { 1 } };\\n        \\n        for (int i = 2; i <= numRows; i++)\\n        {\\n            List<int> cur = new List<int>() { 1 };\\n            \\n            for (int j = 1; j < i - 1; j++)\\n                cur.Add(res[i - 2][j - 1] + res[i - 2][j]);\\n            \\n            cur.Add(1);\\n            \\n            res.Add(cur);\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<IList<int>> Generate(int numRows) {\\n        IList<IList<int>> res = new List<IList<int>>() { new List<int>() { 1 }",
                "codeTag": "Java"
            },
            {
                "id": 1044166,
                "title": "java-solution-all-approach",
                "content": "**Single dimension Array**\\n\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] solve(int n) {\\n        int[] arr = new int[n + 1];\\n        arr[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            arr[i] = (arr[i - 1] * (n - i + 1)) / i;\\n        }\\n        return arr;\\n    }\\n}\\n```\\n\\n**Two dimension Array**\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] solve(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i = 0;i <= n; i++){\\n            for (int j = 0; j <= i; j++){\\n                if (j == 0 || j == i)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Using Java List**\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        if (numRows == 0)\\n            return result;\\n        \\n        List<Integer> row = null;\\n        List<Integer> prev = null;\\n        \\n        for (int i=0;i<numRows;i++){\\n            row = new ArrayList<>();\\n            \\n            for (int j = 0;j<=i;j++){\\n                if (j == 0 || j == i)\\n                    row.add(1);\\n                else\\n                    row.add(prev.get(j-1) + prev.get(j));\\n            }\\n            prev = row;\\n            result.add(row);\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```\\n**Short Version of List**\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        if (numRows == 0) return result;\\n        \\n        List<Integer> row = null;\\n        List<Integer> prev = null;\\n        \\n        for (int i=0;i<numRows;i++){\\n            row = new ArrayList<>();\\n            for (int j = 0;j<=i;j++)\\n                row.add((j == 0 || j == i) ? 1 : prev.get(j-1) + prev.get(j));\\n            prev = row;\\n            result.add(row);\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] solve(int n) {\\n        int[] arr = new int[n + 1];\\n        arr[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            arr[i] = (arr[i - 1] * (n - i + 1)) / i;\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] solve(int n) {\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i = 0;i <= n; i++){\\n            for (int j = 0; j <= i; j++){\\n                if (j == 0 || j == i)\\n                    dp[i][j] = 1;\\n                else\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        if (numRows == 0)\\n            return result;\\n        \\n        List<Integer> row = null;\\n        List<Integer> prev = null;\\n        \\n        for (int i=0;i<numRows;i++){\\n            row = new ArrayList<>();\\n            \\n            for (int j = 0;j<=i;j++){\\n                if (j == 0 || j == i)\\n                    row.add(1);\\n                else\\n                    row.add(prev.get(j-1) + prev.get(j));\\n            }\\n            prev = row;\\n            result.add(row);\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        if (numRows == 0) return result;\\n        \\n        List<Integer> row = null;\\n        List<Integer> prev = null;\\n        \\n        for (int i=0;i<numRows;i++){\\n            row = new ArrayList<>();\\n            for (int j = 0;j<=i;j++)\\n                row.add((j == 0 || j == i) ? 1 : prev.get(j-1) + prev.get(j));\\n            prev = row;\\n            result.add(row);\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003729,
                "title": "kotlin-one-liner",
                "content": "```kotlin\\nfun generate(numRows: Int): List<List<Int>> =\\n    generateSequence(listOf(1)) { prev -> listOf(1) + prev.windowed(2).map { it.sum() } + listOf(1) }.take(numRows).toList()\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nfun generate(numRows: Int): List<List<Int>> =\\n    generateSequence(listOf(1)) { prev -> listOf(1) + prev.windowed(2).map { it.sum() } + listOf(1) }.take(numRows).toList()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 912002,
                "title": "python3-just-1-line-using-binomial-theorem",
                "content": "comb function\\uFF1A**comb(n,m) = n!/(m!(n-m)!)**\\nFor line n in Pasca triangle, the numbers from left to right are:\\n`*comb(n-1,0), comb(n-1,1),......, comb(n-1, n-2), comb(n-1, n-1)*`\\nAnd this is [**Binomial Theorem**](https://en.wikipedia.org/wiki/Binomial_theorem)\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[comb(i,j) for j in range(i+1)] for i in range(numRows)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[comb(i,j) for j in range(i+1)] for i in range(numRows)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824688,
                "title": "javascript-solution-118",
                "content": "```\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nlet generate = function(numRows) {\\n    let final=[];\\n    for(let i=0;i<numRows;i++){\\n        final[i]=[];\\n        final[i][0]=final[i][i]=1;\\n        for(let j=1;j<i;j++){\\n            final[i][j]=final[i-1][j]+final[i-1][j-1];\\n        }\\n    }\\n    return final;\\n};\\n```\\n**Runtime: 76 ms, faster than 56.31% of JavaScript online submissions for Pascal\\'s Triangle.**\\n\\n**Memory Usage: 36.9 MB, less than 8.01% of JavaScript online submissions for Pascal\\'s Triangle.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nlet generate = function(numRows) {\\n    let final=[];\\n    for(let i=0;i<numRows;i++){\\n        final[i]=[];\\n        final[i][0]=final[i][i]=1;\\n        for(let j=1;j<i;j++){\\n            final[i][j]=final[i-1][j]+final[i-1][j-1];\\n        }\\n    }\\n    return final;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016585,
                "title": "java-solution-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> al = new ArrayList();\\n        List<Integer> prev = new ArrayList();\\n        prev.add(1);\\n        al.add(prev);\\n        for(int i = 0; i < numRows - 1; i++) {\\n            List<Integer> curr = new ArrayList();\\n            curr.add(1);\\n            for(int j = 0; j < prev.size() - 1; j++) {\\n                curr.add(prev.get(j) + prev.get(j + 1));\\n            }\\n            curr.add(1);\\n            al.add(curr);\\n            prev = curr;\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> al = new ArrayList();\\n        List<Integer> prev = new ArrayList();\\n        prev.add(1);\\n        al.add(prev);\\n        for(int i = 0; i < numRows - 1; i++) {\\n            List<Integer> curr = new ArrayList();\\n            curr.add(1);\\n            for(int j = 0; j < prev.size() - 1; j++) {\\n                curr.add(prev.get(j) + prev.get(j + 1));\\n            }\\n            curr.add(1);\\n            al.add(curr);\\n            prev = curr;\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872039,
                "title": "one-liner-code-pascal-triangle-brute-force-88-70-beats-in-runtime",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/bd2a7266-57a1-49c8-b411-09c0fd0300f7_1691325013.064194.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266352,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\nIt\\'s easier to solve when you view the triangle like this;\\n[1]\\n[1,1]\\n[1,2,1]\\n[1,3,3,1]\\n# Approach\\nOther than the first index, add a constant 1 at the start and the end of your array, and between those 1\\'s add the sum of the same index in the previous array + the previous index in the previous array.\\n[1]\\n[1,1]\\n[1,(val of same index in previous array + val of previous index in previous array = 2),1],\\netc.\\n\\n- Time complexity:\\nO(n^2)\\n\\n# Code\\n```\\nvar generate = function(numRows) {\\n    let triangle=[[1]]\\n    for (let i = 1; i < numRows; i++){\\n        const newArr =[1]\\n        for (let j = 1; j < i; j++){\\n            newArr.push(triangle[i-1][j] + triangle[i-1][j-1])\\n        }\\n        newArr.push(1)\\n        triangle.push(newArr)\\n    }\\n    return triangle\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generate = function(numRows) {\\n    let triangle=[[1]]\\n    for (let i = 1; i < numRows; i++){\\n        const newArr =[1]\\n        for (let j = 1; j < i; j++){\\n            newArr.push(triangle[i-1][j] + triangle[i-1][j-1])\\n        }\\n        newArr.push(1)\\n        triangle.push(newArr)\\n    }\\n    return triangle\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2883954,
                "title": "c-ezpz-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes) {\\n    int **canvas;\\n    *returnSize = numRows;\\n    canvas = (int**)(malloc(numRows * sizeof(int*)));\\n    *returnColumnSizes = (int*)malloc(numRows * sizeof(int));\\n    for (int i = 0; i < numRows; i += 1) {\\n        (*returnColumnSizes)[i] = i + 1;\\n    }\\n    canvas = (int**)malloc(numRows * sizeof(int*));\\n    for (int i = 0; i < numRows; i += 1) {\\n        canvas[i] = (int*)malloc(numRows * sizeof(int));\\n        canvas[i][i] = 1;\\n        canvas[i][0] = 1;\\n    }\\n    for (int i = 0; i < numRows; i += 1) {\\n        for (int k = 1; k < i; k += 1) {\\n            canvas[i][k] = canvas[(i - 1)][(k - 1)] + canvas[(i - 1)][k];\\n        }\\n    }\\n    return canvas;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes) {\\n    int **canvas;\\n    *returnSize = numRows;\\n    canvas = (int**)(malloc(numRows * sizeof(int*)));\\n    *returnColumnSizes = (int*)malloc(numRows * sizeof(int));\\n    for (int i = 0; i < numRows; i += 1) {\\n        (*returnColumnSizes)[i] = i + 1;\\n    }\\n    canvas = (int**)malloc(numRows * sizeof(int*));\\n    for (int i = 0; i < numRows; i += 1) {\\n        canvas[i] = (int*)malloc(numRows * sizeof(int));\\n        canvas[i][i] = 1;\\n        canvas[i][0] = 1;\\n    }\\n    for (int i = 0; i < numRows; i += 1) {\\n        for (int k = 1; k < i; k += 1) {\\n            canvas[i][k] = canvas[(i - 1)][(k - 1)] + canvas[(i - 1)][k];\\n        }\\n    }\\n    return canvas;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765159,
                "title": "c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int num) {\\n        vector<vector<int>> ans;\\n        for(int i=0;i<num;i++){\\n            vector<int> temp(i+1,1);\\n            if(i<=1){\\n                ans.push_back(temp);\\n            }\\n            else{\\n            for(int j=1;j<=i-1;j++)\\n                temp[j]=ans[i-1][j-1]+ans[i-1][j];                \\n            \\n            ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int num) {\\n        vector<vector<int>> ans;\\n        for(int i=0;i<num;i++){\\n            vector<int> temp(i+1,1);\\n            if(i<=1){\\n                ans.push_back(temp);\\n            }\\n            else{\\n            for(int j=1;j<=i-1;j++)\\n                temp[j]=ans[i-1][j-1]+ans[i-1][j];                \\n            \\n            ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731436,
                "title": "pascals-s-triangle-50-faster-solution-brute-force",
                "content": "**A pure brute force to build a tower **\\n** Taking some base conditions...then every time updating vector and adding elements**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) \\n    {\\n        int n=numRows;\\n        \\n        vector<vector<int>>v;\\n                 \\n        \\n      if(n==1)\\n      {\\n          vector<int>k1;\\n          k1.push_back(1);\\n          v.push_back(k1);  \\n          \\n          return v;\\n      }\\n        \\n      if(n==2)\\n      {\\n          vector<int>k1;\\n          k1.push_back(1);\\n          v.push_back(k1);\\n          \\n          vector<int>k2;\\n          k2.push_back(1);\\n          k2.push_back(1);\\n          v.push_back(k2); \\n          \\n          return v;\\n      }\\n        \\n      if(n==3)\\n      {\\n          vector<int>k1;\\n          k1.push_back(1);\\n          v.push_back(k1);\\n          \\n          vector<int>k2;\\n          k2.push_back(1);\\n          k2.push_back(1);\\n          v.push_back(k2);  \\n          \\n          vector<int>k3;\\n          k3.push_back(1);\\n          k3.push_back(2);\\n          k3.push_back(1);\\n          v.push_back(k3);\\n          \\n          return v;\\n          \\n      }\\n        \\n       vector<int>sp; \\n      \\n      for(int i=3;i<=n;i++)  \\n      {\\n          if(i==3)\\n          {\\n               vector<int>k1;\\n               k1.push_back(1);\\n               v.push_back(k1);\\n          \\n               vector<int>k2;\\n               k2.push_back(1);\\n               k2.push_back(1);\\n               v.push_back(k2);  \\n              \\n              \\n              \\n              sp.push_back(1);\\n              sp.push_back(2);\\n              sp.push_back(1);  \\n              v.push_back(sp);\\n          }\\n          else\\n          {\\n          vector<int>ssp;\\n          \\n          ssp.push_back(1);\\n          \\n          for(int j=0;j<i-2;j++)\\n          {\\n             ssp.push_back(sp[j]+sp[j+1]);\\n          }\\n          \\n          ssp.push_back(1);\\n          v.push_back(ssp);\\n          sp=ssp;\\n          ssp.clear();\\n          }\\n      }\\n      return v;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) \\n    {\\n        int n=numRows;\\n        \\n        vector<vector<int>>v;\\n                 \\n        \\n      if(n==1)\\n      {\\n          vector<int>k1;\\n          k1.push_back(1);\\n          v.push_back(k1);  \\n          \\n          return v;\\n      }\\n        \\n      if(n==2)\\n      {\\n          vector<int>k1;\\n          k1.push_back(1);\\n          v.push_back(k1);\\n          \\n          vector<int>k2;\\n          k2.push_back(1);\\n          k2.push_back(1);\\n          v.push_back(k2); \\n          \\n          return v;\\n      }\\n        \\n      if(n==3)\\n      {\\n          vector<int>k1;\\n          k1.push_back(1);\\n          v.push_back(k1);\\n          \\n          vector<int>k2;\\n          k2.push_back(1);\\n          k2.push_back(1);\\n          v.push_back(k2);  \\n          \\n          vector<int>k3;\\n          k3.push_back(1);\\n          k3.push_back(2);\\n          k3.push_back(1);\\n          v.push_back(k3);\\n          \\n          return v;\\n          \\n      }\\n        \\n       vector<int>sp; \\n      \\n      for(int i=3;i<=n;i++)  \\n      {\\n          if(i==3)\\n          {\\n               vector<int>k1;\\n               k1.push_back(1);\\n               v.push_back(k1);\\n          \\n               vector<int>k2;\\n               k2.push_back(1);\\n               k2.push_back(1);\\n               v.push_back(k2);  \\n              \\n              \\n              \\n              sp.push_back(1);\\n              sp.push_back(2);\\n              sp.push_back(1);  \\n              v.push_back(sp);\\n          }\\n          else\\n          {\\n          vector<int>ssp;\\n          \\n          ssp.push_back(1);\\n          \\n          for(int j=0;j<i-2;j++)\\n          {\\n             ssp.push_back(sp[j]+sp[j+1]);\\n          }\\n          \\n          ssp.push_back(1);\\n          v.push_back(ssp);\\n          sp=ssp;\\n          ssp.clear();\\n          }\\n      }\\n      return v;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301444,
                "title": "daily-leetcoding-challenge-july-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/pascals-triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/pascals-triangle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2013962,
                "title": "rust-iterators-one-linish",
                "content": "Compared to other solutions, I like this better, where I use `chain` and  `once` to get the 1s on the sides with iterators instead of `concat` on a row vector.\\n\\nEDIT 2022-07-19: Celebrating that this is the problem of the day by doing a minor tweak for the functional solution (`.map(...)` changed to the dedicated `.copied()` function), and adding a fully imperative solution just for fun. :)\\n\\n**Functional solution**\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        (2..=num_rows).fold(vec![vec![1]], |mut acc, _| {\\n            acc.push(once(1)\\n                .chain(acc.last().unwrap().windows(2).map(|n| n.iter().copied().sum()))\\n                .chain(once(1))\\n                .collect::<Vec<_>>());\\n            acc\\n        })\\n    }\\n}\\n```\\n\\n**Imperative solution**\\n\\n```\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut rez: Vec<Vec<i32>> = Vec::with_capacity(num_rows as usize);\\n        for i in 0..num_rows as usize {\\n            let mut row = vec![1; i + 1];\\n            for j in 1..i {\\n                row[j] = rez[i - 1][j] + rez[i - 1][j - 1];\\n            }\\n            rez.push(row);\\n        }\\n        rez\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        (2..=num_rows).fold(vec![vec![1]], |mut acc, _| {\\n            acc.push(once(1)\\n                .chain(acc.last().unwrap().windows(2).map(|n| n.iter().copied().sum()))\\n                .chain(once(1))\\n                .collect::<Vec<_>>());\\n            acc\\n        })\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut rez: Vec<Vec<i32>> = Vec::with_capacity(num_rows as usize);\\n        for i in 0..num_rows as usize {\\n            let mut row = vec![1; i + 1];\\n            for j in 1..i {\\n                row[j] = rez[i - 1][j] + rez[i - 1][j - 1];\\n            }\\n            rez.push(row);\\n        }\\n        rez\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821815,
                "title": "c-super-easy-100-faster-0ms",
                "content": "//Please UpVote, Thankyou :) \\nclass Solution {\\npublic:\\n\\n   vector<vector<int>> generate(int numRows) {\\n\\tvector<vector<int>> pas;\\n\\tfor (int i = 0; i < numRows; i++) {\\n\\t\\tvector<int> init(i + 1, 1);                                                                                                                                                                                                                          \\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tinit[j] = pas[i - 1][j-1] + pas[i - 1][j];\\n\\t\\t}\\n\\t\\tpas.push_back(init);\\n\\t}\\n\\treturn pas;\\n}\\n};\\n![image](https://assets.leetcode.com/users/images/7a0a9472-3e2a-4f1b-a895-1b3475e5ef76_1646491199.3711739.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n   vector<vector<int>> generate(int numRows) {\\n\\tvector<vector<int>> pas;\\n\\tfor (int i = 0; i < numRows; i++) {\\n\\t\\tvector<int> init(i + 1, 1);                                                                                                                                                                                                                          \\n\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\tinit[j] = pas[i - 1][j-1] + pas[i - 1][j];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1786374,
                "title": "most-easy-solution-100-faster-solution-java",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            List<Integer> temp = new ArrayList<>();\\n            int val = 1;\\n            for(int j=0;j<=i;j++)\\n            {\\n             temp.add(val);\\n             val = val*(i-j)/(j+1);\\n            }\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nThe only conceot is the Pascals Formula i.e. val = val*(i-j)/(j+1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            List<Integer> temp = new ArrayList<>();\\n            int val = 1;\\n            for(int j=0;j<=i;j++)\\n            {\\n             temp.add(val);\\n             val = val*(i-j)/(j+1);\\n            }\\n            ans.add(temp);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742176,
                "title": "python-3-40ms-iterative-easy-approach",
                "content": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        res=[]\\n        for i in range(numRows):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        res=[]\\n        for i in range(numRows):\\n            res.append([])\\n            for j in range(i+1):\\n                if j == 0 or j == i:\\n                    res[i].append(1)\\n                else:\\n                    res[i].append(res[i - 1][j - 1] + res[i - 1][j])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287154,
                "title": "short-simple-0-ms-100-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        for(int i = 1;i<=numRows;i++){\\n            vector<int> temp;\\n            if(i==1){\\n                temp.push_back(1);\\n            } else if(i==2){\\n                temp = {1,1};\\n            } else {\\n                int n = ans[i-1-1].size();\\n                temp.push_back(1);\\n                for(int j = 1;j<n;j++){\\n                    temp.push_back(ans[i-1-1][j-1] + ans[i-1-1][j]);\\n                }\\n                temp.push_back(1);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        for(int i = 1;i<=numRows;i++){\\n            vector<int> temp;\\n            if(i==1){\\n                temp.push_back(1);\\n            } else if(i==2){\\n                temp = {1,1};\\n            } else {\\n                int n = ans[i-1-1].size();\\n                temp.push_back(1);\\n                for(int j = 1;j<n;j++){\\n                    temp.push_back(ans[i-1-1][j-1] + ans[i-1-1][j]);\\n                }\\n                temp.push_back(1);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237612,
                "title": "rust-solution-beginner-expert",
                "content": "I\\'m new to rust so here is my solution. The first row value is one, and then the rest are computed based upon the values of the previous row.\\n```\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut vec = vec![vec![1]];\\n        for n in 1..num_rows {\\n            let mut sub_vec = vec![1];\\n            let mut previous_row = (n - 1) as usize;\\n            let mut previous_row_length = vec[previous_row].len();\\n            for i in 0..previous_row_length {\\n                if i == 0 {\\n                    sub_vec.push(vec[previous_row][i]);\\n                } else {\\n                    sub_vec.push(vec[previous_row][i]);\\n                    sub_vec[i] += vec[previous_row][i];\\n                }\\n            }\\n            vec.push(sub_vec);\\n        }\\n        vec\\n    }\\n}\\n```\\n\\nA better answer I saw looking through discussions and the submission details is the following. It uses clever built in functions to create a sliding window along the previous row to generate the inner portion of the next row. It even automatically takes care of edge cases thanks to the behavior of the windows function.\\n```\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut cur = vec![vec![1i32]];\\n        \\n        for row in 1..num_rows {\\n            let mut new_row: Vec<i32> = cur.last().unwrap().windows(2).map(|x| x[0] + x[1]).collect();\\n            cur.push([&[1], new_row.as_slice(), &[1]].concat());\\n        }\\n        \\n        cur\\n    }\\n}\\n```\\n\\nHappy Coding!\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut vec = vec![vec![1]];\\n        for n in 1..num_rows {\\n            let mut sub_vec = vec![1];\\n            let mut previous_row = (n - 1) as usize;\\n            let mut previous_row_length = vec[previous_row].len();\\n            for i in 0..previous_row_length {\\n                if i == 0 {\\n                    sub_vec.push(vec[previous_row][i]);\\n                } else {\\n                    sub_vec.push(vec[previous_row][i]);\\n                    sub_vec[i] += vec[previous_row][i];\\n                }\\n            }\\n            vec.push(sub_vec);\\n        }\\n        vec\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut cur = vec![vec![1i32]];\\n        \\n        for row in 1..num_rows {\\n            let mut new_row: Vec<i32> = cur.last().unwrap().windows(2).map(|x| x[0] + x[1]).collect();\\n            cur.push([&[1], new_row.as_slice(), &[1]].concat());\\n        }\\n        \\n        cur\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38358,
                "title": "2-simple-python-solutions",
                "content": "solution 1 uses python map() function. \\n\\nsolution 2 uses python List Comprehensions.\\n\\n\\n\\n    class Solution:\\n        def generate(self, numRows):\\n            answer = list()\\n            if numRows == 0: return answer\\n            answer.append([1])\\n            if numRows == 1: return answer\\n            \\n            from operator import add  # for solution 1\\n            for i in range(1, numRows):\\n                new = map(add, (answer[i-1] + [0]), ([0] + answer[i-1]))  # solution 1\\n                # new = [sum(x) for x in zip((answer[i-1] + [0]), ([0] + answer[i-1]))]  # solution 2\\n                \\n                answer.append(new)\\n        \\n            return answer",
                "solutionTags": [
                    "Python"
                ],
                "code": "solution 1 uses python map() function. \\n\\nsolution 2 uses python List Comprehensions.\\n\\n\\n\\n    class Solution:\\n        def generate(self, numRows):\\n            answer = list()\\n            if numRows == 0: return answer\\n            answer.append([1])\\n            if numRows == 1: return answer\\n            \\n            from operator import add  # for solution 1\\n            for i in range(1, numRows):\\n                new = map(add, (answer[i-1] + [0]), ([0] + answer[i-1]))  # solution 1\\n                # new = [sum(x) for x in zip((answer[i-1] + [0]), ([0] + answer[i-1]))]  # solution 2\\n                \\n                answer.append(new)\\n        \\n            return answer",
                "codeTag": "Java"
            },
            {
                "id": 4055619,
                "title": "simple-java-solutions-runtime-1ms-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        list.add(Arrays.asList(1));\\n\\n        for (int i = 1; i < numRows; i++) {\\n            List<Integer> list1 = new LinkedList<>();\\n                list1.add(1);\\n                List<Integer> list2 = list.get(i-1);\\n\\n                for (int k = 0; k < list2.size() - 1 ; k++)\\n                {\\n                    list1.add(list2.get(k) + list2.get(k+1));\\n                }\\n                list1.add(1);\\n\\n            list.add(list1);\\n        }\\n\\n\\n        return list;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/759d8b1e-174f-480f-bada-b20a51c2e711_1694951604.6566267.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        list.add(Arrays.asList(1));\\n\\n        for (int i = 1; i < numRows; i++) {\\n            List<Integer> list1 = new LinkedList<>();\\n                list1.add(1);\\n                List<Integer> list2 = list.get(i-1);\\n\\n                for (int k = 0; k < list2.size() - 1 ; k++)\\n                {\\n                    list1.add(list2.get(k) + list2.get(k+1));\\n                }\\n                list1.add(1);\\n\\n            list.add(list1);\\n        }\\n\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016496,
                "title": "100-00-beats-c-easy-to-understand-c-python-javascript-java-go-beginner",
                "content": "# Objective:\\n - The code aims to generate a Pascal\\'s Triangle up to a specified number of rows (`numRows`).\\n\\n# Strategies to Tackle the Problem:\\n1. **Understand the Goal**: First, understand that the code\\'s goal is to generate Pascal\\'s Triangle up to a specified number of rows (`numRows`).\\n\\n1. **Visualize Pascal\\'s Triangle:** It\\'s helpful to visualize Pascal\\'s Triangle to see the pattern of numbers.\\n\\n1. **Step Through the Code:** Go through the code step by step, keeping track of the ans vector and how each row is generated.\\n\\n**Use Test Cases:** Try running the code with different values of `numRows` to see the generated Pascal\\'s Triangles and observe how they change.\\n\\n1. **Check the Math:** Understand that each number in a row is the sum of the two numbers directly above it.\\n\\n1. **Look for Optimization:** Consider how the code could be optimized or improved for efficiency.\\n\\n# Intuition\\n- **The code generates each row of Pascal\\'s Triangle** iteratively, starting with the first row (which contains only 1) and using the values from the previous row to **calculate the values of the current row.** \\n-** The inner loop calculates the non-edge **values by adding two values from the previous row. \\n- **This process continues** until all rows up to `numRows` are generated.\\n\\n# Approach\\n1. Initialize an empty vector `ans` to store the rows of Pascal\\'s Triangle.\\n\\n1. For each row from `i = 0` to `i = numRows - 1`:\\na. Initialize a vector `row` with `i + 1` elements, all set to `1`.\\nb. For each element in `row` from `j = 1` to `j = i - 1`, calculate its value by adding two values from the previous row (`ans[i - 1][j]` and `ans[i - 1][j - 1`]).\\nc. Add the completed `row` to the `ans` vector.\\n\\n1. Return the ans vector containing the Pascal\\'s Triangle up to numRows.\\n\\nThis approach builds Pascal\\'s Triangle row by row, and the final result is a 2D vector representing the complete triangle.\\n\\n# Code Explanation:\\n1. `vector<vector<int>> ans;`: Initialize an empty 2D vector `ans` to store the rows of Pascal\\'s Triangle.\\n\\n1. `for (int i = 0; i < numRows; i++) {`: Start a loop that iterates from `i = 0` to `i = numRows - 1`. This loop will generate each row of Pascal\\'s Triangle.\\n\\n1. `vector<int> row(i + 1, 1);`: Initialize a vector `row` with `i + 1` elements, all initialized to `1`. This represents the current row being generated.\\n\\n1. `for (int j = 1; j < i; j++) {`: Start a nested loop that iterates from `j = 1` to `j = i - 1`. This loop fills in the values of `row` between the first and last `1` of the row.\\n\\n1. `row[j] = ans[i - 1][j] + ans[i - 1][j - 1];`: Calculate the value at position `row[j]` by adding the values from the previous row (`ans[i - 1][j]` and `ans[i - 1][j - 1]`) and assign it to `row[j]`.\\n\\n1. `ans.push_back(row);`: Add the completed row to the ans vector, representing the current row of Pascal\\'s Triangle.\\n\\n1. Repeat steps 3-6 for each row from `i = 0` to `i = numRows - 1`.\\n\\n1. Finally, return the ans vector containing the complete Pascal\\'s Triangle.\\n\\n# Comlexity\\n**Time Complexity:** `O(numRows^2)`\\n**Space Complexity:** `O(numRows^2)`\\n\\n\\n\\n# Complexity Explanation:\\n**- Time complexity:**\\nThe time complexity of the code is` O(numRows^2),` where `numRows` is the `input argument` specifying how many rows of Pascal\\'s Triangle to generate.\\n\\n- `**The outer loop runs for numRows iterations**`, and for each iteration, it performs operations proportional to the current row number (i).\\n\\n- `The inner loop runs for i - 1 iterations` (excluding the first and last elements of each row), and within the inner loop, there are constant time operations (addition and assignment).\\n\\n**Therefore, the overall time complexity is determined by the sum of operations for each row, which is roughly 1 + 2 + 3 + ... + numRows. This sum is proportional to numRows^2/2**, resulting in a `time complexity of O(numRows^2)`.\\n\\n**- Space complexity:**\\n\\n\\n- The space complexity of the code is `O(numRows^2) `as well.\\n\\n- **The main space usage comes from the ans vector,** which stores the entire Pascal\\'s Triangle. \\n- **The number of rows in the triangle is equal to numRows,** and for each row, there are on average numRows/2 elements (since the number of elements increases linearly with the row number). \\n- Therefore, the space complexity is `O(numRows * numRows/2)`, which simplifies to O(numRows^2).\\n\\n- Additionally, t**here\\'s a constant amount of space used for integer variables i, j, and the temporary row vector.**\\n\\n- In summary,** both the time and space complexity of the code are O(numRows^2) with respect to the input argument numRows.**\\n\\n# PLEASE UPVOTE\\u2763\\uD83D\\uDE0D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n            for (int j = 1; j < i; j++) {\\n                row[j] = ans[i - 1][j] + ans[i - 1][j - 1];\\n            }\\n            ans.push_back(row);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# JAVA\\n```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) {\\n                    row.add(1);\\n                } else {\\n                    int val = ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j);\\n                    row.add(val);\\n                }\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n# PYTHON3\\n```\\nclass Solution:\\n    def generate(self, numRows):\\n        ans = []\\n        for i in range(numRows):\\n            row = [1] * (i + 1)\\n            for j in range(1, i):\\n                row[j] = ans[i - 1][j] + ans[i - 1][j - 1]\\n            ans.append(row)\\n        return ans\\n\\n```\\n# JAVASCRIPT\\n```\\nvar generate = function(numRows) {\\n    let ans = [];\\n    for (let i = 0; i < numRows; i++) {\\n        let row = new Array(i + 1).fill(1);\\n        for (let j = 1; j < i; j++) {\\n            row[j] = ans[i - 1][j] + ans[i - 1][j - 1];\\n        }\\n        ans.push(row);\\n    }\\n    return ans;\\n};\\n\\n```\\n# GO\\n```\\npackage main\\n\\nimport \"fmt\"\\n\\nfunc generate(numRows int) [][]int {\\n    ans := make([][]int, numRows)\\n    for i := 0; i < numRows; i++ {\\n        row := make([]int, i+1)\\n        for j := 1; j < i; j++ {\\n            row[j] = ans[i-1][j] + ans[i-1][j-1]\\n        }\\n        row[0], row[i] = 1, 1\\n        ans[i] = row\\n    }\\n    return ans\\n}\\n\\nfunc main() {\\n    numRows := 5 // You can change this value as needed\\n    result := generate(numRows)\\n    \\n    for _, row := range result {\\n        fmt.Println(row)\\n    }\\n}\\n\\n```\\n# PLEASE UPVOTE\\u2763\\uD83D\\uDE0D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n            for (int j = 1; j < i; j++) {\\n                row[j] = ans[i - 1][j] + ans[i - 1][j - 1];\\n            }\\n            ans.push_back(row);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < numRows; i++) {\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) {\\n                    row.add(1);\\n                } else {\\n                    int val = ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j);\\n                    row.add(val);\\n                }\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def generate(self, numRows):\\n        ans = []\\n        for i in range(numRows):\\n            row = [1] * (i + 1)\\n            for j in range(1, i):\\n                row[j] = ans[i - 1][j] + ans[i - 1][j - 1]\\n            ans.append(row)\\n        return ans\\n\\n```\n```\\nvar generate = function(numRows) {\\n    let ans = [];\\n    for (let i = 0; i < numRows; i++) {\\n        let row = new Array(i + 1).fill(1);\\n        for (let j = 1; j < i; j++) {\\n            row[j] = ans[i - 1][j] + ans[i - 1][j - 1];\\n        }\\n        ans.push(row);\\n    }\\n    return ans;\\n};\\n\\n```\n```\\npackage main\\n\\nimport \"fmt\"\\n\\nfunc generate(numRows int) [][]int {\\n    ans := make([][]int, numRows)\\n    for i := 0; i < numRows; i++ {\\n        row := make([]int, i+1)\\n        for j := 1; j < i; j++ {\\n            row[j] = ans[i-1][j] + ans[i-1][j-1]\\n        }\\n        row[0], row[i] = 1, 1\\n        ans[i] = row\\n    }\\n    return ans\\n}\\n\\nfunc main() {\\n    numRows := 5 // You can change this value as needed\\n    result := generate(numRows)\\n    \\n    for _, row := range result {\\n        fmt.Println(row)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677656,
                "title": "c-python-iterative-dp-solutions-beats-100-math",
                "content": "# Intuition\\nSolution via Pascal\\'s identity $$C^i_j=C^{i-1}_{j-1}+C^{i-1}_{j}$$& $$C^i_j=C^i_{i-j}$$\\n\\n# Approach\\nIterative DP uses double for loop.\\n\\n[Please turn English subtitles if neccessary]\\n[https://www.youtube.com/watch?v=paoJGMYEEhA](https://www.youtube.com/watch?v=paoJGMYEEhA)\\n# Complexity\\n- Time complexity:\\n $$O(n^2)$$\\n\\n- Space complexity:\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> a(numRows);\\n        for(int&& i=0; i<numRows; i++){\\n            a[i].assign(i+1, 1);\\n            for(int&& j=1; j<=i/2; j++){\\n                  a[i][i-j]=a[i][j]=a[i-1][j-1]+a[i-1][j];\\n                        \\n            }              \\n        }\\n        return a;\\n    }\\n};\\n\\n```\\n# Python solution\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a = [[1]]\\n        for i in range(1, numRows):\\n            a += [list(map(lambda x, y: x+y, a[-1] + [0], [0] + a[-1]))]\\n        return a[:numRows]\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> a(numRows);\\n        for(int&& i=0; i<numRows; i++){\\n            a[i].assign(i+1, 1);\\n            for(int&& j=1; j<=i/2; j++){\\n                  a[i][i-j]=a[i][j]=a[i-1][j-1]+a[i-1][j];\\n                        \\n            }              \\n        }\\n        return a;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a = [[1]]\\n        for i in range(1, numRows):\\n            a += [list(map(lambda x, y: x+y, a[-1] + [0], [0] + a[-1]))]\\n        return a[:numRows]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438740,
                "title": "c-easy-explanation-efficient-approach",
                "content": "# Approach\\n- Explained in the code\\n\\n# Complexity\\n- Time complexity: $O(numRows^2)$\\n\\n- Space complexity: $O(numRows^2)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // This function generates the first numRows of Pascal\\'s Triangle and returns it as a 2D vector of integers.\\nvector<vector<int>> generate(int numRows) {\\n    // Initialize an empty 2D vector\\n    vector<vector<int>> ans;\\n\\n    // Iterate numRows times to generate each row of Pascal\\'s Triangle\\n    for(int i=0;i<numRows;i++)\\n    {\\n        // Create a new row of integers with i+1 elements, all initialized to 1\\n        vector<int> newRow(i+1,1);\\n\\n        // Loop through each element in the newRow vector, starting from the second element, until the second-last element\\n        for(int col=1;col<i;col++)\\n        {\\n            // Calculate the value of the current element by adding the corresponding elements from the previous row\\n            // Specifically, the element in the i-th row and col-th column is equal to the sum of the (i-1)th row and col-th column\\n            // and the (i-1)th row and (col-1)th column\\n            newRow[col] = ans[i-1][col] + ans[i-1][col-1];\\n        }\\n\\n        // Push the newRow vector into the ans vector\\n        ans.push_back(newRow);\\n    }\\n\\n    // Return the ans vector\\n    return ans;\\n}\\n\\n};\\n```\\n**Thank You!** for reading . Do upvote if you like the explanation and if there is any room for improvement Do comment.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // This function generates the first numRows of Pascal\\'s Triangle and returns it as a 2D vector of integers.\\nvector<vector<int>> generate(int numRows) {\\n    // Initialize an empty 2D vector\\n    vector<vector<int>> ans;\\n\\n    // Iterate numRows times to generate each row of Pascal\\'s Triangle\\n    for(int i=0;i<numRows;i++)\\n    {\\n        // Create a new row of integers with i+1 elements, all initialized to 1\\n        vector<int> newRow(i+1,1);\\n\\n        // Loop through each element in the newRow vector, starting from the second element, until the second-last element\\n        for(int col=1;col<i;col++)\\n        {\\n            // Calculate the value of the current element by adding the corresponding elements from the previous row\\n            // Specifically, the element in the i-th row and col-th column is equal to the sum of the (i-1)th row and col-th column\\n            // and the (i-1)th row and (col-1)th column\\n            newRow[col] = ans[i-1][col] + ans[i-1][col-1];\\n        }\\n\\n        // Push the newRow vector into the ans vector\\n        ans.push_back(newRow);\\n    }\\n\\n    // Return the ans vector\\n    return ans;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111110,
                "title": "one-line-python-solution-using-binomial-coefficients",
                "content": "# Code\\n```\\nimport math\\n\\n\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [\\n            [math.comb(i, k) for k in range(i + 1)]\\n            for i in range(numRows)\\n        ]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\n\\n\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [\\n            [math.comb(i, k) for k in range(i + 1)]\\n            for i in range(numRows)\\n        ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319783,
                "title": "python-99-95-97-62-comments",
                "content": "Runtime: **18 ms, faster than 99.95%** of Python3 online submissions for Pascal\\'s Triangle.\\nMemory Usage: **13.8 MB, less than 97.62%** of Python3 online submissions for Pascal\\'s Triangle. \\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a = []\\n        for x in range(numRows):\\n            a.append([1])\\n# \\t\\t\\tcreating the 2d array\\n# \\t\\t\\tappending the starting 1: [1, ...]\\n\\t\\t\\t\\n            if x > 1: \\n# \\t\\t\\tskipping the first two rows\\n\\t\\t\\t\\n                for c in range(x-1):\\n# \\t\\t\\t\\t\\tfor loop used to find info about previous row\\n\\t\\t\\t\\t\\t\\n                    a[x].append(a[x-1][c]+a[x-1][c+1])\\n# \\t\\t\\t\\t\\tmath for adding the c and the c+1 number from the previous row\\n\\n            if x > 0:\\n# \\t\\t\\tchecking if its not the first row\\n\\n                a[x].append(1)\\n# \\t\\t\\t\\tappending the ending 1: [1, ..., 1]\\n\\t\\t\\t\\t\\n        return a\\n```\\n**Version with no comments**\\n```\\n        a = []\\n        for x in range(numRows):\\n            a.append([1])\\n            if x > 1:\\n                for c in range(x-1):\\n                    a[x].append(a[x-1][c]+a[x-1][c+1])\\n            if x > 0:\\n                a[x].append(1)\\n        return a",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        a = []\\n        for x in range(numRows):\\n            a.append([1])\\n# \\t\\t\\tcreating the 2d array\\n# \\t\\t\\tappending the starting 1: [1, ...]\\n\\t\\t\\t\\n            if x > 1: \\n# \\t\\t\\tskipping the first two rows\\n\\t\\t\\t\\n                for c in range(x-1):\\n# \\t\\t\\t\\t\\tfor loop used to find info about previous row\\n\\t\\t\\t\\t\\t\\n                    a[x].append(a[x-1][c]+a[x-1][c+1])\\n# \\t\\t\\t\\t\\tmath for adding the c and the c+1 number from the previous row\\n\\n            if x > 0:\\n# \\t\\t\\tchecking if its not the first row\\n\\n                a[x].append(1)\\n# \\t\\t\\t\\tappending the ending 1: [1, ..., 1]\\n\\t\\t\\t\\t\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945266,
                "title": "c-100-simple-solution-o-n-m",
                "content": "```\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = numRows;\\n    *returnColumnSizes = malloc(sizeof(int) * numRows);\\n    int **res = malloc(sizeof(int*) * numRows);\\n    for (int i = 0; i < numRows; i++) {\\n        (*returnColumnSizes)[i] = i + 1;\\n        res[i] = malloc(sizeof(int) * (i + 1));\\n        res[i][0] = 1;\\n        res[i][i] = 1;\\n    }\\n    \\n    for (int i = 2; i < numRows; i++)\\n        for (int j = 1; j < i; j++)\\n            res[i][j] = res[i - 1][j - 1] + res[i - 1][j];\\n\\n    return res;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = numRows;\\n    *returnColumnSizes = malloc(sizeof(int) * numRows);\\n    int **res = malloc(sizeof(int*) * numRows);\\n    for (int i = 0; i < numRows; i++) {\\n        (*returnColumnSizes)[i] = i + 1;\\n        res[i] = malloc(sizeof(int) * (i + 1));\\n        res[i][0] = 1;\\n        res[i][i] = 1;\\n    }\\n    \\n    for (int i = 2; i < numRows; i++)\\n        for (int j = 1; j < i; j++)\\n            res[i][j] = res[i - 1][j - 1] + res[i - 1][j];\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680149,
                "title": "c-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        //vector for storing the result\\n        vector<vector<int>> triangle;\\n        // invalid cases\\n        if(numRows <=0)\\n            return triangle;\\n        // for the first row we will insert it before hand\\n        triangle.push_back({1});\\n        \\n        // for the rest of the rows\\n        for(int i=1;i<numRows;i++){\\n            //initially curr will have 1 as next number will start from the 1\\n            vector<int> curr = {1};\\n            //one more vector for storing the prev triangle value for the further addition\\n            vector<int> prev = triangle[i-1];\\n            // if satisfies loop then we will calculate for each of the next values\\n            for(int j=0;j < prev.size() - 1; j++){\\n                // pushing next value which will we the addition of the previous vector two values\\n                curr.push_back(prev[j]+prev[j+1]);\\n            }\\n     // at last we have to store the number 1 as from 2 number itself every number will start and end by 1\\n            curr.push_back(1);\\n            // finally storing the value in the triangle vector\\n            triangle.push_back(curr);\\n        }\\n        // returning the list of pascal values for a given  number\\n        return triangle;\\n    }\\n};\\n```\\nIF YOU UNDERSTOOD IT COMPLETELY, DON\\'T FORGET TO UPVOTE. :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        //vector for storing the result\\n        vector<vector<int>> triangle;\\n        // invalid cases\\n        if(numRows <=0)\\n            return triangle;\\n        // for the first row we will insert it before hand\\n        triangle.push_back({1});\\n        \\n        // for the rest of the rows\\n        for(int i=1;i<numRows;i++){\\n            //initially curr will have 1 as next number will start from the 1\\n            vector<int> curr = {1};\\n            //one more vector for storing the prev triangle value for the further addition\\n            vector<int> prev = triangle[i-1];\\n            // if satisfies loop then we will calculate for each of the next values\\n            for(int j=0;j < prev.size() - 1; j++){\\n                // pushing next value which will we the addition of the previous vector two values\\n                curr.push_back(prev[j]+prev[j+1]);\\n            }\\n     // at last we have to store the number 1 as from 2 number itself every number will start and end by 1\\n            curr.push_back(1);\\n            // finally storing the value in the triangle vector\\n            triangle.push_back(curr);\\n        }\\n        // returning the list of pascal values for a given  number\\n        return triangle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38343,
                "title": "another-accepted-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> generate(int numRows) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            \\n            for (int i = 0; i < numRows; i++) {\\n                List<Integer> list = new ArrayList<Integer>(Arrays.asList(1));\\n                \\n                for (int j = 1; j < i; j++) \\n                    list.add(res.get(i - 1).get(j - 1) + res.get(i - 1).get(j));\\n                    \\n                if (i > 0) list.add(1);\\n                \\n                res.add(list);\\n            }\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> generate(int numRows) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            \\n            for (int i = 0; i < numRows; i++) {\\n                List<Integer> list = new ArrayList<Integer>(Arrays.asList(1));\\n                \\n                for (int j = 1; j < i; j++) \\n                    list.add(res.get(i - 1).get(j - 1) + res.get(i - 1).get(j));\\n                    \\n                if (i > 0) list.add(1);\\n                \\n                res.add(list);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38412,
                "title": "my-c-code-for-reference",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > generate(int numRows) {\\n            \\n            if(numRows==0) return vector<vector<int> >();\\n            \\n            vector<vector<int> > res;\\n            \\n            res.resize(numRows);\\n            \\n            res[0].push_back(1);\\n            \\n            if(numRows==1) return res;\\n            \\n            for(int i=1; i<numRows; i++){\\n                \\n                res[i].resize(i+1); // make vector for each row \\n                \\n                res[i][0]=res[i][i]=1; // put 1 to first and last element\\n                \\n                for(int j=1; j<i; j++) \\n                    res[i][j]=res[i-1][j]+res[i-1][j-1]; // generate other elements of the row\\n                \\n            }\\n            \\n            return res;\\n            \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > generate(int numRows) {\\n            \\n            if(numRows==0) return vector<vector<int> >();\\n            \\n            vector<vector<int> > res;\\n            \\n            res.resize(numRows);\\n            \\n            res[0].push_back(1);\\n            \\n            if(numRows==1) return res;\\n            \\n            for(int i=1; i<numRows; i++){\\n                \\n                res[i].resize(i+1); // make vector for each row \\n                \\n                res[i][0]=res[i][i]=1; // put 1 to first and last element\\n                \\n                for(int j=1; j<i; j++) \\n                    res[i][j]=res[i-1][j]+res[i-1][j-1]; // generate other elements of the row\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3354660,
                "title": "super-easy-pascals-triangle-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans(numRows);\\n        for(int i =0;i<numRows;i++){\\n            ans[i].resize(i+1);\\n            ans[i][0] = ans[i][i]=1;\\n            for(int j=1;j<i;j++){\\n                ans[i][j]= ans[i-1][j] + ans[i-1][j-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\\n\\n![image.png](https://assets.leetcode.com/users/images/22ef5af3-f4bd-4380-b09c-74d3d3916020_1680075517.7281501.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans(numRows);\\n        for(int i =0;i<numRows;i++){\\n            ans[i].resize(i+1);\\n            ans[i][0] = ans[i][i]=1;\\n            for(int j=1;j<i;j++){\\n                ans[i][j]= ans[i-1][j] + ans[i-1][j-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037842,
                "title": "simple-to-understand-python3",
                "content": "# Stats\\n- Runtime beats 65%\\n- Memory beats 60%\\n# Code with comments\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        k = 0\\n        list_rows = [] # here we store the output\\n        while k <= numRows:\\n            # edge cases\\n            if k==1:\\n                list_rows.append([1]) \\n            if k==2:\\n                list_rows.append([1,1])\\n            # actual solution\\n            if k>2: \\n                # the last row of a list_rows \\n                # [[1], [1,1]] at the first iteration\\n                latest_row = list_rows[len(list_rows)-1]\\n                # row to be added must contain calculation\\n                # and ones from the sides \\n                new_row = []\\n                new_row.append(1) # first one-element ([1])\\n                # here we sum up all neighbours from previous row\\n                # [1,1] --> [2] at the first iteration (after edges)\\n                # then we add ones from the sides [1,2,1]\\n                for i in range(len(latest_row)-1):\\n                    new_row.append(latest_row[i]+latest_row[i+1])\\n                new_row.append(1) # second one-element ([1])\\n                list_rows.append(new_row)\\n            k += 1\\n        return list_rows\\n        \\n\\n\\n```\\n# Code without comments\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        k = 0\\n        list_rows = []\\n        while k <= numRows:\\n            if k==1:\\n                list_rows.append([1])\\n            if k==2:\\n                list_rows.append([1,1])\\n            if k>2:\\n                latest_row = list_rows[len(list_rows)-1]\\n                new_row = []\\n                new_row.append(1)\\n                for i in range(len(latest_row)-1):\\n                    new_row.append(latest_row[i]+latest_row[i+1])\\n                new_row.append(1)\\n                list_rows.append(new_row)\\n            k += 1\\n        return list_rows\\n        \\n\\n\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        k = 0\\n        list_rows = [] # here we store the output\\n        while k <= numRows:\\n            # edge cases\\n            if k==1:\\n                list_rows.append([1]) \\n            if k==2:\\n                list_rows.append([1,1])\\n            # actual solution\\n            if k>2: \\n                # the last row of a list_rows \\n                # [[1], [1,1]] at the first iteration\\n                latest_row = list_rows[len(list_rows)-1]\\n                # row to be added must contain calculation\\n                # and ones from the sides \\n                new_row = []\\n                new_row.append(1) # first one-element ([1])\\n                # here we sum up all neighbours from previous row\\n                # [1,1] --> [2] at the first iteration (after edges)\\n                # then we add ones from the sides [1,2,1]\\n                for i in range(len(latest_row)-1):\\n                    new_row.append(latest_row[i]+latest_row[i+1])\\n                new_row.append(1) # second one-element ([1])\\n                list_rows.append(new_row)\\n            k += 1\\n        return list_rows\\n        \\n\\n\\n```\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        k = 0\\n        list_rows = []\\n        while k <= numRows:\\n            if k==1:\\n                list_rows.append([1])\\n            if k==2:\\n                list_rows.append([1,1])\\n            if k>2:\\n                latest_row = list_rows[len(list_rows)-1]\\n                new_row = []\\n                new_row.append(1)\\n                for i in range(len(latest_row)-1):\\n                    new_row.append(latest_row[i]+latest_row[i+1])\\n                new_row.append(1)\\n                list_rows.append(new_row)\\n            k += 1\\n        return list_rows\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771241,
                "title": "check-out-my-code-i-can-t-understand-what-i-wrote-but-it-works-1-sek",
                "content": "\\t* class Solution {\\n\\t\\t public  List<List<Integer>> generate(int numRows) {\\n\\t\\t\\tList<List<Integer>> lists = new ArrayList<>();\\n\\t\\t\\tList<Integer> integerList = new ArrayList<>();\\n\\t\\t\\tintegerList.add(1);\\n\\t\\t\\tlists.add(integerList);\\n\\t\\t\\twhile (lists.size() < numRows) {\\n\\t\\t\\t\\tList<Integer> integerList_2 = new ArrayList<>();\\n\\t\\t\\t\\tintegerList_2.add(1);\\n\\t\\t\\t\\tif (lists.size() >= 2) {\\n\\t\\t\\t\\t\\tfor (int j = 0; j < lists.get(lists.size() - 1).size() - 1; j++) {\\n\\t\\t\\t\\t\\t\\tintegerList_2.add(lists.get(lists.size() - 1).get(j) +\\n\\t\\t\\t\\t\\t\\t\\t\\tlists.get(lists.size() - 1).get(j + 1));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tintegerList_2.add(1);\\n\\t\\t\\t\\tlists.add(integerList_2);\\n\\t\\t\\t}\\n\\t\\t\\treturn lists;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\t\\t public  List<List<Integer>> generate(int numRows) {\\n\\t\\t\\tList<List<Integer>> lists = new ArrayList<>();\\n\\t\\t\\tList<Integer> integerList = new ArrayList<>();\\n\\t\\t\\tintegerList.add(1);\\n\\t\\t\\tlists.add(integerList);\\n\\t\\t\\twhile (lists.size() < numRows) {\\n\\t\\t\\t\\tList<Integer> integerList_2 = new ArrayList<>();\\n\\t\\t\\t\\tintegerList_2.add(1);\\n\\t\\t\\t\\tif (lists.size() >= 2) {\\n\\t\\t\\t\\t\\tfor (int j = 0; j < lists.get(lists.size() - 1).size() - 1; j++) {\\n\\t\\t\\t\\t\\t\\tintegerList_2.add(lists.get(lists.size() - 1).get(j) +\\n\\t\\t\\t\\t\\t\\t\\t\\tlists.get(lists.size() - 1).get(j + 1));\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2626110,
                "title": "my-easy-and-concise-solution-java",
                "content": "### *Please Upvote !!!* **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> currRow, prevRow = null;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            currRow = new ArrayList<>();\\n\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) currRow.add(1);\\n                else {\\n                    currRow.add(\\n                        prevRow.get(j - 1) + prevRow.get(j)\\n                    );\\n                }\\n            }\\n\\n            ans.add(currRow);\\n            prevRow = currRow;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n ^ 2)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> currRow, prevRow = null;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            currRow = new ArrayList<>();\\n\\n            for (int j = 0; j <= i; j++) {\\n                if (j == 0 || j == i) currRow.add(1);\\n                else {\\n                    currRow.add(\\n                        prevRow.get(j - 1) + prevRow.get(j)\\n                    );\\n                }\\n            }\\n\\n            ans.add(currRow);\\n            prevRow = currRow;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n ^ 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302477,
                "title": "c-time-o-n-no-extra-space-faster-than-100-00",
                "content": "**Time Complexity** : `O(N)`\\n**Space Complexity** : `O(N)`\\n\\n**Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> a(n);\\n        if(n==1)    return {{1}};\\n        a[0] = {1};\\n        a[1] = {1, 1};\\n        for(int i=2; i<n; i++){\\n            a[i].resize(i+1);\\n            a[i][0]=1;\\n            for(int j=1; j<i; j++){\\n                a[i][j] = a[i-1][j-1] + a[i-1][j];\\n            }\\n            a[i][i]=1;\\n        }\\n        return a;\\n    }\\n\\t// If you like please upvote\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> a(n);\\n        if(n==1)    return {{1}};\\n        a[0] = {1};\\n        a[1] = {1, 1};\\n        for(int i=2; i<n; i++){\\n            a[i].resize(i+1);\\n            a[i][0]=1;\\n            for(int j=1; j<i; j++){\\n                a[i][j] = a[i-1][j-1] + a[i-1][j];\\n            }\\n            a[i][i]=1;\\n        }\\n        return a;\\n    }\\n\\t// If you like please upvote\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992448,
                "title": "interview-point-of-view-noob-explanation-100-faster-c-cleancode",
                "content": "**Variations these questions can be asked:**\\n1. Print first `n rows` of a pascal triangle.\\n2. Print the ```n th row``` of the pascal triangle.\\n3. Print the element at the `rth row` and `cth column` in pascal traingle.\\n\\n**Pascal triangle in 2D Array Looks like:**\\n1\\n1 1\\n1 2 1\\n1 3 3 1\\n1 4 6 4 1\\n....\\n\\n\\n**Observation for Pascal Traingle:**\\n1. Every `ith` row has `i+1` items. Row 0 has 1 item, 1 has 2 items, 2 have 3 items.....\\n2. First and last element of each row is 1.\\n3. Element at (r,c) index = (r-1) **C** (c-1) \\n\\t* \\tExample: x[5][3](1 based indexing) = 4C2 = 4! / ( 2 ! . 2 ! ) --> ( 4 . 3 ) /  2 !  --> 6\\n4. In 2D Array, `x[row][col] = x[row-1][col-1] + x[row-1][col]`.\\n\\n**SOLUTION**\\n```\\nvector<vector<int>> generate(int numRows) {\\n      \\n        vector<vector<int>> triangle(numRows);\\n        \\n        for(int row = 0; row<numRows; row++){\\n            \\n            triangle[row].resize(row+1);\\n            triangle[row][0] = triangle[row][row] = 1; // Adding 1 to first and last index\\n// No need to decrement triangle[row][row-1] as we are already taking 0 based indexing. Thus,3rd row = T[2] and T[2][0] = T[2][2]\\n            \\n            // Traversing from 1st column to 2nd last column\\n            for(int col = 1; col < row; col++){\\n                triangle[row][col] = triangle[row-1][col-1] + triangle[row-1][col];\\n            }\\n            \\n        }\\n        \\n        return triangle;\\n    }\\n```\\n\\n**Time Complexity Analysis Key Points:**\\n* `nCr` can be computed for any element in O(n).\\n* Printing ith row only in pascal traingle is O(N* N).\\n\\n**Complexity Analysis for each variation:**\\n* Variation 1: TC: O(N.N) and SC: O( N.N) as we are storing the entire pascal triangle.\\n* Variation 2: TC: O(N) and SC: O(N) as we are storing the entire row.\\n* Variation 3: TC: O(N) and SC: O(1)\\n\\n\\n**Dont forget to up-vote \\uD83D\\uDC97 if you liked it**\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```n th row```\n```\\nvector<vector<int>> generate(int numRows) {\\n      \\n        vector<vector<int>> triangle(numRows);\\n        \\n        for(int row = 0; row<numRows; row++){\\n            \\n            triangle[row].resize(row+1);\\n            triangle[row][0] = triangle[row][row] = 1; // Adding 1 to first and last index\\n// No need to decrement triangle[row][row-1] as we are already taking 0 based indexing. Thus,3rd row = T[2] and T[2][0] = T[2][2]\\n            \\n            // Traversing from 1st column to 2nd last column\\n            for(int col = 1; col < row; col++){\\n                triangle[row][col] = triangle[row-1][col-1] + triangle[row-1][col];\\n            }\\n            \\n        }\\n        \\n        return triangle;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1323261,
                "title": "javascript-solution-60ms-runtime-beats-99-34-of-javascript-submissions",
                "content": "```\\nvar generate = function(numRows) {\\n    const res = [];\\n    let prevRow;\\n    \\n    for (let i = 1; i <= numRows; i++) {\\n        const row = new Array(i).fill(1);\\n\\n        if (prevRow) {\\n            for (let j = 1; j < prevRow.length; j++) {\\n                const cs = prevRow[j] + prevRow[j - 1];\\n                row[j] = cs;\\n            }\\n        }\\n        \\n        res.push(row);\\n        prevRow = row;\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generate = function(numRows) {\\n    const res = [];\\n    let prevRow;\\n    \\n    for (let i = 1; i <= numRows; i++) {\\n        const row = new Array(i).fill(1);\\n\\n        if (prevRow) {\\n            for (let j = 1; j < prevRow.length; j++) {\\n                const cs = prevRow[j] + prevRow[j - 1];\\n                row[j] = cs;\\n            }\\n        }\\n        \\n        res.push(row);\\n        prevRow = row;\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1296504,
                "title": "100-faster-code",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> res;\\n        for(int i = 0 ; i < numRows ; i++)\\n        {\\n            vector<int> v(i+1 , 1);\\n            for(int j = 1 ;  j < i ; j++)\\n            {\\n                v[j] = res[i-1][j-1] + res[i-1][j];\\n            }\\n             res.push_back(v);\\n        }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> res;\\n        for(int i = 0 ; i < numRows ; i++)\\n        {\\n            vector<int> v(i+1 , 1);\\n            for(int j = 1 ;  j < i ; j++)\\n            {\\n                v[j] = res[i-1][j-1] + res[i-1][j];\\n            }\\n             res.push_back(v);\\n        }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287149,
                "title": "c-simple-and-easy-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        if (numRows == 1) return {{1}};\\n        \\n        vector<vector<int>> triangle = {{1}, {1, 1}};\\n        \\n        for (int i = 2; i < numRows; i++) {\\n            vector<int> prev = triangle[i-1];\\n            vector<int> curr = {1};\\n            \\n            for (int j = 0; j < i-1; j++) {\\n                curr.push_back(prev[j]+prev[j+1]);\\n            }\\n            curr.push_back(1);\\n            \\n            triangle.push_back(curr);\\n        }\\n        return triangle;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        if (numRows == 1) return {{1}};\\n        \\n        vector<vector<int>> triangle = {{1}, {1, 1}};\\n        \\n        for (int i = 2; i < numRows; i++) {\\n            vector<int> prev = triangle[i-1];\\n            vector<int> curr = {1};\\n            \\n            for (int j = 0; j < i-1; j++) {\\n                curr.push_back(prev[j]+prev[j+1]);\\n            }\\n            curr.push_back(1);\\n            \\n            triangle.push_back(curr);\\n        }\\n        return triangle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695763,
                "title": "python-using-1-formula-and-2-simple-method-28-ms-low-memory",
                "content": "**USING FORMULA C=int(C*(i-j)/j)**\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        m=[]\\n        for i in range(1,numRows+1):\\n            c=1\\n            t=[]\\n            for j in range(1,i+1):\\n                t.append(c)\\n                c=int(c*(i-j)/j)\\n            m.append(t)\\n        return m\\n```\\n**Simple Method**\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        m=[]\\n        for i in range(numRows):\\n            if i==0:\\n                m.append([1])\\n            else:\\n                t=[]\\n                for j in range(i+1):\\n                    if j==0 or j==i:\\n                        t.append(1)\\n                    else:\\n                        t.append(m[i-1][j-1]+m[i-1][j])\\n                m.append(t)\\n        return m\\n                     \\n     ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        m=[]\\n        for i in range(1,numRows+1):\\n            c=1\\n            t=[]\\n            for j in range(1,i+1):\\n                t.append(c)\\n                c=int(c*(i-j)/j)\\n            m.append(t)\\n        return m\\n```\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        m=[]\\n        for i in range(numRows):\\n            if i==0:\\n                m.append([1])\\n            else:\\n                t=[]\\n                for j in range(i+1):\\n                    if j==0 or j==i:\\n                        t.append(1)\\n                    else:\\n                        t.append(m[i-1][j-1]+m[i-1][j])\\n                m.append(t)\\n        return m\\n                     \\n     ```",
                "codeTag": "Java"
            },
            {
                "id": 273716,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \\n        rows = [] \\n        \\n        def helper(i, j):\\n            if j == 0 or i == j:\\n                return 1\\n            else:\\n                return rows[i-1][j] + rows[i-1][j-1]\\n            \\n        for i in range(0,numRows,1):\\n            temp = []\\n            for j in range(i+1):\\n                temp.append(helper(i,j))\\n            rows.append(temp)\\n        \\n        return rows\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \\n        rows = [] \\n        \\n        def helper(i, j):\\n            if j == 0 or i == j:\\n                return 1\\n            else:\\n                return rows[i-1][j] + rows[i-1][j-1]\\n            \\n        for i in range(0,numRows,1):\\n            temp = []\\n            for j in range(i+1):\\n                temp.append(helper(i,j))\\n            rows.append(temp)\\n        \\n        return rows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 38211,
                "title": "clean-3ms-c-solution",
                "content": "It seems everyone is posting C++ solution. though the question is about boundary checking and array manipulation, memory allocation for c code might be tricky for beginners. Here I give a clean c solution\\nyou can NOT allocate extra space like the following code for dealing with boundary check. because free() might crash\\n``` c\\n// you can fool solution check but free will crash\\narr[i-1] = malloc((i+2) * sizeof(int)); arr[i-1]+1;\\narr[i-1][-1] = 0;\\narr[i-1][i] = 0;\\n```\\n\\n``` c\\nint** generate(int numRows, int** columnSizes) {\\n    int **arr = malloc(numRows*sizeof(int *));\\n    *columnSizes = malloc(numRows * sizeof(int));\\n    for(int i=1; i<=numRows; i++) {\\n        arr[i-1] = malloc(i * sizeof(int));\\n        (*columnSizes)[i-1] = i;\\n        if(i>1)\\n            for(int j=0; j<i; j++) \\n                arr[i-1][j] = (j-1>=0?arr[i-1-1][j-1]:0)+(j<i-1?arr[i-1-1][j]:0);\\n        else \\n            arr[0][0] = 1;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "``` c\\n// you can fool solution check but free will crash\\narr[i-1] = malloc((i+2) * sizeof(int)); arr[i-1]+1;\\narr[i-1][-1] = 0;\\narr[i-1][i] = 0;\\n```\n``` c\\nint** generate(int numRows, int** columnSizes) {\\n    int **arr = malloc(numRows*sizeof(int *));\\n    *columnSizes = malloc(numRows * sizeof(int));\\n    for(int i=1; i<=numRows; i++) {\\n        arr[i-1] = malloc(i * sizeof(int));\\n        (*columnSizes)[i-1] = i;\\n        if(i>1)\\n            for(int j=0; j<i; j++) \\n                arr[i-1][j] = (j-1>=0?arr[i-1-1][j-1]:0)+(j<i-1?arr[i-1-1][j]:0);\\n        else \\n            arr[0][0] = 1;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 38259,
                "title": "c-implementation-refered-to-mzchen",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> generate(int numRows) {\\n            vector<vector<int>> result(numRows);\\n            for(int i=0; i<numRows; i++){\\n                result[i].resize(i+1);\\n                result[i][0]=result[i][i]=1;\\n                for(int j=1; j<i; j++) \\n                    result[i][j]=result[i-1][j-1]+result[i-1][j];\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> generate(int numRows) {\\n            vector<vector<int>> result(numRows);\\n            for(int i=0; i<numRows; i++){\\n                result[i].resize(i+1);\\n                result[i][0]=result[i][i]=1;\\n                for(int j=1; j<i; j++) \\n                    result[i][j]=result[i-1][j-1]+result[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 38269,
                "title": "the-python-way-36ms",
                "content": "    class Solution(object):\\n        def generate(self, numRows):\\n            \"\"\"\\n            :type numRows: int;; rtype: List[List[int]]\\n            \"\"\"\\n            if not numRows: return []\\n            ret = [[1]]\\n            numRows -= 1\\n            while numRows:\\n                ret.append([1] + [a+b for a,b in zip(ret[-1][:-1], ret[-1][1:])] +[1])\\n                numRows-=1\\n            return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def generate(self, numRows):\\n            \"\"\"\\n            :type numRows: int;; rtype: List[List[int]]\\n            \"\"\"\\n            if not numRows: return []\\n            ret = [[1]]\\n            numRows -= 1\\n            while numRows:\\n                ret.append([1] + [a+b for a,b in zip(ret[-1][:-1], ret[-1][1:])] +[1])\\n                numRows-=1\\n            return ret",
                "codeTag": "Java"
            },
            {
                "id": 38265,
                "title": "1ms-java-solution-simple",
                "content": "    public List<List<Integer>> generate(int numRows) {\\n            List<List<Integer>> sol = new ArrayList<>();\\n            if (numRows == 0) return sol;\\n            \\n            List<Integer> row = new ArrayList<>();\\n            row.add(1);\\n            sol.add(row);\\n            \\n            for (int i = 1; i < numRows; i++) {\\n                List<Integer> r = new ArrayList<>();\\n                r.add(1);\\n                List<Integer> p = sol.get(i-1);\\n                for (int j = 0; j < p.size()-1; j++) {\\n                    r.add(p.get(j) + p.get(j+1));\\n                }\\n                r.add(1);\\n                sol.add(r);\\n            }        \\n            return sol;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> generate(int numRows) {\\n            List<List<Integer>> sol = new ArrayList<>();\\n            if (numRows == 0) return sol;\\n            \\n            List<Integer> row = new ArrayList<>();\\n            row.add(1);\\n            sol.add(row);\\n            \\n            for (int i = 1; i < numRows; i++) {\\n                List<Integer> r = new ArrayList<>();\\n                r.add(1);\\n                List<Integer> p = sol.get(i-1);\\n                for (int j = 0; j < p.size()-1; j++) {\\n                    r.add(p.get(j) + p.get(j+1));\\n                }\\n                r.add(1);\\n                sol.add(r);\\n            }        \\n            return sol;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 38293,
                "title": "beat-100-fastest-java-solution-with-brief-explanation",
                "content": "The trick is to use linked list because there is a lot of add operations that each costs o(n) time using array list. And to get the previous assigned before retriving value frequently from it.\\n\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\tif (numRows == 0)\\n\\t\\t\\treturn ans;\\n\\t\\t\\t\\n\\t\\tLinkedList<Integer> sub = new LinkedList<Integer>();\\n\\t\\tsub.add(1);\\n\\t\\tans.add(sub);\\n\\n\\t\\tfor (int i = 1; i < numRows; i++) {\\n\\t\\t\\tLinkedList<Integer> subAns = new LinkedList<Integer>();\\n\\t\\t\\tList<Integer> list = ans.get(i - 1);\\n\\t\\t\\tsubAns.addFirst(1);\\n\\t\\t\\tfor (int j = 1; j < i; j++)\\n\\t\\t\\t\\tsubAns.addFirst(list.get(j - 1) + list.get(j));\\n\\t\\t\\tsubAns.addFirst(1);\\n\\t\\t\\tans.add(subAns);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}",
                "solutionTags": [],
                "code": "The trick is to use linked list because there is a lot of add operations that each costs o(n) time using array list. And to get the previous assigned before retriving value frequently from it.\\n\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\tif (numRows == 0)\\n\\t\\t\\treturn ans;\\n\\t\\t\\t\\n\\t\\tLinkedList<Integer> sub = new LinkedList<Integer>();\\n\\t\\tsub.add(1);\\n\\t\\tans.add(sub);\\n\\n\\t\\tfor (int i = 1; i < numRows; i++) {\\n\\t\\t\\tLinkedList<Integer> subAns = new LinkedList<Integer>();\\n\\t\\t\\tList<Integer> list = ans.get(i - 1);\\n\\t\\t\\tsubAns.addFirst(1);\\n\\t\\t\\tfor (int j = 1; j < i; j++)\\n\\t\\t\\t\\tsubAns.addFirst(list.get(j - 1) + list.get(j));\\n\\t\\t\\tsubAns.addFirst(1);\\n\\t\\t\\tans.add(subAns);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 38339,
                "title": "python-easy-to-understand-solutions",
                "content": "```\\nclass Solution(object):\\n    def generate1(self, numRows):\\n        res = []\\n        for i in range(numRows):\\n            row = [1] * (i+1)\\n            for j in range(1, i):\\n                row[j] = res[-1][j-1] + res[-1][j]\\n            res.append(row)\\n        return res\\n    \\n    def generate(self, numRows):\\n        res = [[1 for _ in range(i+1)] for i in range(numRows)]\\n        for i in range(2, numRows):\\n            for j in range(1, i):\\n                res[i][j] = res[i-1][j-1] + res[i-1][j]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def generate1(self, numRows):\\n        res = []\\n        for i in range(numRows):\\n            row = [1] * (i+1)\\n            for j in range(1, i):\\n                row[j] = res[-1][j-1] + res[-1][j]\\n            res.append(row)\\n        return res\\n    \\n    def generate(self, numRows):\\n        res = [[1 for _ in range(i+1)] for i in range(numRows)]\\n        for i in range(2, numRows):\\n            for j in range(1, i):\\n                res[i][j] = res[i-1][j-1] + res[i-1][j]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016254,
                "title": "beats-100-c-easy-to-understand-easy-to-code-beginner-friendly-exhaustive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo get the next row of the pascal triangle, we simply add the 2 parent values. If it\\'s a side entry, it will be 1. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo make sure we don\\'t miss anything, it is best to exhaustively solve for every possible input. We can do this by manually writing out the triangle on a piece of paper and then translating it to code afterwards.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ since everything is hardcoded\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        if (numRows == 1) {\\n            return {{1}};\\n        }\\n        else if (numRows == 2) {\\n            return {{1}, {1, 1}};\\n        }\\n        else if (numRows == 3) {\\n            return {{1}, {1, 1}, {1, 2, 1}};\\n        }\\n        else if (numRows == 4) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}};\\n        }\\n        else if (numRows == 5) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}};\\n        }\\n        else if (numRows == 6) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}};\\n        }\\n        else if (numRows == 7) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}};\\n        }\\n        else if (numRows == 8) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}};\\n        }\\n        else if (numRows == 9) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}};\\n        }\\n        else if (numRows == 10) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}};\\n        }\\n        else if (numRows == 11) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}};\\n        }\\n        else if (numRows == 12) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}};\\n        }\\n        else if (numRows == 13) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}};\\n        }\\n        else if (numRows == 14) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}};\\n        }\\n        else if (numRows == 15) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}};\\n        }\\n        else if (numRows == 16) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}};\\n        }\\n        else if (numRows == 17) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}};\\n        }\\n        else if (numRows == 18) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}};\\n        }\\n        else if (numRows == 19) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}};\\n        }\\n        else if (numRows == 20) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}};\\n        }\\n        else if (numRows == 21) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}};\\n        }\\n        else if (numRows == 22) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}};\\n        }\\n        else if (numRows == 23) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}};\\n        }\\n        else if (numRows == 24) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}};\\n        }\\n        else if (numRows == 25) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}};\\n        }\\n        else if (numRows == 26) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}};\\n        }\\n        else if (numRows == 27) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}};\\n        }\\n        else if (numRows == 28) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}, {1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1}};\\n        }\\n        else if (numRows == 29) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}, {1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1}, {1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1}};\\n        }\\n        return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}, {1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1}, {1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1}, {1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1}};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        if (numRows == 1) {\\n            return {{1}};\\n        }\\n        else if (numRows == 2) {\\n            return {{1}, {1, 1}};\\n        }\\n        else if (numRows == 3) {\\n            return {{1}, {1, 1}, {1, 2, 1}};\\n        }\\n        else if (numRows == 4) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}};\\n        }\\n        else if (numRows == 5) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}};\\n        }\\n        else if (numRows == 6) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}};\\n        }\\n        else if (numRows == 7) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}};\\n        }\\n        else if (numRows == 8) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}};\\n        }\\n        else if (numRows == 9) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}};\\n        }\\n        else if (numRows == 10) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}};\\n        }\\n        else if (numRows == 11) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}};\\n        }\\n        else if (numRows == 12) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}};\\n        }\\n        else if (numRows == 13) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}};\\n        }\\n        else if (numRows == 14) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}};\\n        }\\n        else if (numRows == 15) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}};\\n        }\\n        else if (numRows == 16) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}};\\n        }\\n        else if (numRows == 17) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}};\\n        }\\n        else if (numRows == 18) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}};\\n        }\\n        else if (numRows == 19) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}};\\n        }\\n        else if (numRows == 20) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}};\\n        }\\n        else if (numRows == 21) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}};\\n        }\\n        else if (numRows == 22) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}};\\n        }\\n        else if (numRows == 23) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}};\\n        }\\n        else if (numRows == 24) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}};\\n        }\\n        else if (numRows == 25) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}};\\n        }\\n        else if (numRows == 26) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}};\\n        }\\n        else if (numRows == 27) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}};\\n        }\\n        else if (numRows == 28) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}, {1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1}};\\n        }\\n        else if (numRows == 29) {\\n            return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}, {1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1}, {1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1}};\\n        }\\n        return {{1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}, {1, 4, 6, 4, 1}, {1, 5, 10, 10, 5, 1}, {1, 6, 15, 20, 15, 6, 1}, {1, 7, 21, 35, 35, 21, 7, 1}, {1, 8, 28, 56, 70, 56, 28, 8, 1}, {1, 9, 36, 84, 126, 126, 84, 36, 9, 1}, {1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1}, {1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1}, {1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1}, {1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1}, {1, 14, 91, 364, 1001, 2002, 3003, 3432, 3003, 2002, 1001, 364, 91, 14, 1}, {1, 15, 105, 455, 1365, 3003, 5005, 6435, 6435, 5005, 3003, 1365, 455, 105, 15, 1}, {1, 16, 120, 560, 1820, 4368, 8008, 11440, 12870, 11440, 8008, 4368, 1820, 560, 120, 16, 1}, {1, 17, 136, 680, 2380, 6188, 12376, 19448, 24310, 24310, 19448, 12376, 6188, 2380, 680, 136, 17, 1}, {1, 18, 153, 816, 3060, 8568, 18564, 31824, 43758, 48620, 43758, 31824, 18564, 8568, 3060, 816, 153, 18, 1}, {1, 19, 171, 969, 3876, 11628, 27132, 50388, 75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1}, {1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1}, {1, 21, 210, 1330, 5985, 20349, 54264, 116280, 203490, 293930, 352716, 352716, 293930, 203490, 116280, 54264, 20349, 5985, 1330, 210, 21, 1}, {1, 22, 231, 1540, 7315, 26334, 74613, 170544, 319770, 497420, 646646, 705432, 646646, 497420, 319770, 170544, 74613, 26334, 7315, 1540, 231, 22, 1}, {1, 23, 253, 1771, 8855, 33649, 100947, 245157, 490314, 817190, 1144066, 1352078, 1352078, 1144066, 817190, 490314, 245157, 100947, 33649, 8855, 1771, 253, 23, 1}, {1, 24, 276, 2024, 10626, 42504, 134596, 346104, 735471, 1307504, 1961256, 2496144, 2704156, 2496144, 1961256, 1307504, 735471, 346104, 134596, 42504, 10626, 2024, 276, 24, 1}, {1, 25, 300, 2300, 12650, 53130, 177100, 480700, 1081575, 2042975, 3268760, 4457400, 5200300, 5200300, 4457400, 3268760, 2042975, 1081575, 480700, 177100, 53130, 12650, 2300, 300, 25, 1}, {1, 26, 325, 2600, 14950, 65780, 230230, 657800, 1562275, 3124550, 5311735, 7726160, 9657700, 10400600, 9657700, 7726160, 5311735, 3124550, 1562275, 657800, 230230, 65780, 14950, 2600, 325, 26, 1}, {1, 27, 351, 2925, 17550, 80730, 296010, 888030, 2220075, 4686825, 8436285, 13037895, 17383860, 20058300, 20058300, 17383860, 13037895, 8436285, 4686825, 2220075, 888030, 296010, 80730, 17550, 2925, 351, 27, 1}, {1, 28, 378, 3276, 20475, 98280, 376740, 1184040, 3108105, 6906900, 13123110, 21474180, 30421755, 37442160, 40116600, 37442160, 30421755, 21474180, 13123110, 6906900, 3108105, 1184040, 376740, 98280, 20475, 3276, 378, 28, 1}, {1, 29, 406, 3654, 23751, 118755, 475020, 1560780, 4292145, 10015005, 20030010, 34597290, 51895935, 67863915, 77558760, 77558760, 67863915, 51895935, 34597290, 20030010, 10015005, 4292145, 1560780, 475020, 118755, 23751, 3654, 406, 29, 1}};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649411,
                "title": "beats-100-most-optimized-solution-approach-explained-with-clean-code",
                "content": "\\n\\n# Approach\\nThe generateRow function takes an integer row as input and generates the values of that particular row in Pascal\\'s triangle. It uses a variable ans initialized to 1 to store the values of each element in the row. It also initializes a vector ansRow to store the row elements.\\n\\nStarting from column index 1, the function calculates each element in the row by multiplying ans with (row - col) and dividing it by col. It then appends the calculated element to ansRow. This process continues until all elements in the row are generated.\\n\\nFinally, the generate function takes an integer numRows as input and generates the complete Pascal\\'s triangle up to numRows rows. It initializes an empty 2D vector ans to store the triangle. It then iterates from 1 to numRows, calling the generateRow function for each row index and appending the resulting row to ans.\\n\\nIn the end, the generate function returns the complete Pascal\\'s triangle stored in ans.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> generateRow(int row){\\n        long long ans = 1;\\n        vector<int> ansRow;\\n        ansRow.push_back(1);\\n        for(int col = 1; col<row; col++){\\n            ans = ans*(row-col);\\n            ans = ans/(col);\\n            ansRow.push_back(ans);\\n        }\\n        return ansRow;\\n    }\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans;\\n        for(int i = 1; i <= numRows; i++){\\n            ans.push_back(generateRow(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> generateRow(int row){\\n        long long ans = 1;\\n        vector<int> ansRow;\\n        ansRow.push_back(1);\\n        for(int col = 1; col<row; col++){\\n            ans = ans*(row-col);\\n            ans = ans/(col);\\n            ansRow.push_back(ans);\\n        }\\n        return ansRow;\\n    }\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans;\\n        for(int i = 1; i <= numRows; i++){\\n            ans.push_back(generateRow(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565195,
                "title": "best-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> generateRow(int row) {\\n        int ans = 1;\\n        vector<int> ansRow;\\n        ansRow.push_back(1);\\n        for (int col = 1; col < row; col++) {\\n            ans = ans * (row - col);\\n            ans = ans / col;\\n            ansRow.push_back(ans);\\n        }\\n        return ansRow;\\n    }    \\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans;\\n        for (int row = 1; row <= numRows; row++) {\\n            ans.push_back(generateRow(row));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> generateRow(int row) {\\n        int ans = 1;\\n        vector<int> ansRow;\\n        ansRow.push_back(1);\\n        for (int col = 1; col < row; col++) {\\n            ans = ans * (row - col);\\n            ans = ans / col;\\n            ansRow.push_back(ans);\\n        }\\n        return ansRow;\\n    }    \\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans;\\n        for (int row = 1; row <= numRows; row++) {\\n            ans.push_back(generateRow(row));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545635,
                "title": "c-best-explanation",
                "content": "First is thing is first! `returnsSize` and `returnColumnSizes` pointers are absolutely useless. I dont know why they had to be passed down. Maybe for testing purposes :(\\n\\nAllocating and filling the array with values is super easy. \\n\\n1. On each row, first and last element value is always 0.\\n2. On each row, $$n^{th}$$ element value = previousRow[$n-1^{th}$] element + previousRow[$$n^{th}$$].\\n\\n\\n# Code\\n```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = numRows; // <-- whyyyyyy :(\\n\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int)); // <-- whyyyyyy :(\\n\\n    int **triangle = (int **)malloc(numRows * sizeof(int*));\\n\\n    for(int i = 1; i <= numRows;i++)\\n    {\\n        (*returnColumnSizes)[i-1] = i;   // <-- whyyyyyy :(\\n\\n        triangle[i-1] = (int *)malloc(i * sizeof(int));\\n\\n        triangle[i-1][0] = 1; // first element in row\\n        triangle[i-1][i-1] = 1; // last element in row\\n\\n        for(int j = 1; j < i - 1; j++)\\n            triangle[i-1][j] = triangle[i-2][j-1] + triangle[i-2][j];\\n    }\\n\\n    return triangle;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes)\\n{\\n    *returnSize = numRows; // <-- whyyyyyy :(\\n\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int)); // <-- whyyyyyy :(\\n\\n    int **triangle = (int **)malloc(numRows * sizeof(int*));\\n\\n    for(int i = 1; i <= numRows;i++)\\n    {\\n        (*returnColumnSizes)[i-1] = i;   // <-- whyyyyyy :(\\n\\n        triangle[i-1] = (int *)malloc(i * sizeof(int));\\n\\n        triangle[i-1][0] = 1; // first element in row\\n        triangle[i-1][i-1] = 1; // last element in row\\n\\n        for(int j = 1; j < i - 1; j++)\\n            triangle[i-1][j] = triangle[i-2][j-1] + triangle[i-2][j];\\n    }\\n\\n    return triangle;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465340,
                "title": "easiest-c-code-beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            vector<int> singleRow(i+1,1);//vector initialisation singleRow(size,element)\\n            for(int j=1;j<i;j++){\\n                singleRow[j]=ans[i-1][j]+ans[i-1][j-1];} // updating row in each iteration\\n                ans.push_back(singleRow); // pushing each row in our final vector of vector i.e ans\\n            }\\n            return ans;\\n        }\\n    };\\nDo UPVOTE if you get it\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            vector<int> singleRow(i+1,1);//vector initialisation singleRow(size,element)\\n            for(int j=1;j<i;j++){\\n                singleRow[j]=ans[i-1][j]+ans[i-1][j-1];} // updating row in each iteration\\n                ans.push_back(singleRow); // pushing each row in our final vector of vector i.e ans\\n            }\\n            return ans;\\n        }\\n    };\\nDo UPVOTE if you get it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303950,
                "title": "normal-math-approach-python3",
                "content": "# Normal Math Approach:\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans=[]\\n        for i in range(numRows):\\n            temp=[]\\n            for j in range(i+1):\\n                if j==0 or i==j:\\n                    temp.append(1)\\n                else:\\n                    temp.append(ans[i-1][j-1]+ans[i-1][j])\\n            ans.append(temp)\\n        return ans\\n        \\n```\\n# To find particular element from pascal triangle using formula --->nCr\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        col=2-1\\n        ans=1\\n        numRows-=1\\n        for i in range(col):\\n            ans=ans*(numRows-i)\\n            ans=ans//(i+1)\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        ans=[]\\n        for i in range(numRows):\\n            temp=[]\\n            for j in range(i+1):\\n                if j==0 or i==j:\\n                    temp.append(1)\\n                else:\\n                    temp.append(ans[i-1][j-1]+ans[i-1][j])\\n            ans.append(temp)\\n        return ans\\n        \\n```\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        col=2-1\\n        ans=1\\n        numRows-=1\\n        for i in range(col):\\n            ans=ans*(numRows-i)\\n            ans=ans//(i+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231378,
                "title": "easy-to-understand-simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> dp = new ArrayList<List<Integer>>();\\n        ArrayList<Integer> sp = new ArrayList<Integer>();\\n        sp.add(1);\\n        dp.add(sp);\\n        if(numRows == 1){\\n            return dp;\\n        }\\n        ArrayList<Integer> sp2 = new ArrayList<Integer>();\\n        sp2.add(1);\\n        sp2.add(1);\\n        dp.add(sp2);\\n        for(int i = 2; i < numRows; i++){\\n            ArrayList<Integer> sp3 = new ArrayList<Integer>();\\n            sp3.add(1);\\n            List<Integer> use = dp.get(i-1);\\n            int p1 = 0;\\n            int p2 = 1;\\n            while(p2 < use.size()){\\n                int sum = use.get(p1)+use.get(p2);\\n                sp3.add(sum);\\n                p1++;\\n                p2++;\\n            }\\n            sp3.add(1);\\n            dp.add(sp3);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> dp = new ArrayList<List<Integer>>();\\n        ArrayList<Integer> sp = new ArrayList<Integer>();\\n        sp.add(1);\\n        dp.add(sp);\\n        if(numRows == 1){\\n            return dp;\\n        }\\n        ArrayList<Integer> sp2 = new ArrayList<Integer>();\\n        sp2.add(1);\\n        sp2.add(1);\\n        dp.add(sp2);\\n        for(int i = 2; i < numRows; i++){\\n            ArrayList<Integer> sp3 = new ArrayList<Integer>();\\n            sp3.add(1);\\n            List<Integer> use = dp.get(i-1);\\n            int p1 = 0;\\n            int p2 = 1;\\n            while(p2 < use.size()){\\n                int sum = use.get(p1)+use.get(p2);\\n                sp3.add(sum);\\n                p1++;\\n                p2++;\\n            }\\n            sp3.add(1);\\n            dp.add(sp3);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198484,
                "title": "generating-pascal-s-triangle-in-python-using-nested-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using the concept of Pascal\\'s triangle, where each number in the triangle is the sum of the two numbers above it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start with an empty triangle list and loop through `numRows`. In each iteration, we create a new row with length `i+1` and initialize all its values to 1. We then loop through the row from the second to the second-last element and calculate its value by summing the corresponding values in the previous row. Finally, we append the row to the triangle. After the loop, we return the triangle.\\n# Complexity\\n- Time complexity: The outer loop iterates `numRows` times, and the inner loop iterates up to `i-2` times for each row. Therefore, the time complexity of the algorithm is O(numRows^2).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: We need to store the entire triangle, which has a total of `numRows*(numRows+1)/2` elements. Therefore, the space complexity of the algorithm is O(numRows^2).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \\n        triangle = []\\n        \\n        for i in range(numRows):\\n            row = [1] * (i + 1)  # create a new row and initialize all values to 1\\n            \\n            # calculate the values in the current row\\n            for j in range(1, i):\\n                row[j] = triangle[i-1][j-1] + triangle[i-1][j]\\n                \\n            triangle.append(row)  # add the current row to the triangle\\n        \\n        return triangle\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \\n        triangle = []\\n        \\n        for i in range(numRows):\\n            row = [1] * (i + 1)  # create a new row and initialize all values to 1\\n            \\n            # calculate the values in the current row\\n            for j in range(1, i):\\n                row[j] = triangle[i-1][j-1] + triangle[i-1][j]\\n                \\n            triangle.append(row)  # add the current row to the triangle\\n        \\n        return triangle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112866,
                "title": "pascals-traingle-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first- thoughts on how to solve this problem. -->\\nUsing the for loops and just iterating through it..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust observe the pattern and see for every row the leading and ending 1\\'s are in commmon..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n**2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, n: int) -> List[List[int]]:\\n        dp=[]\\n        for i in range(1,n+1):\\n            dp.append([0]*i)\\n        for i in range(0,n):\\n            for j in range(0,i+1):\\n                if(j==0 or j==i):\\n                    #For leading and trailing of the row the 1 should be appended....\\n                    dp[i][j]=1\\n                else:\\n                    #The previous values both are added together\\n                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j]\\n        return dp\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, n: int) -> List[List[int]]:\\n        dp=[]\\n        for i in range(1,n+1):\\n            dp.append([0]*i)\\n        for i in range(0,n):\\n            for j in range(0,i+1):\\n                if(j==0 or j==i):\\n                    #For leading and trailing of the row the 1 should be appended....\\n                    dp[i][j]=1\\n                else:\\n                    #The previous values both are added together\\n                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j]\\n        return dp\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687135,
                "title": "observation-logic-explained",
                "content": "**[EXPLANATION - EASIER TO UNDERSTAND]**\\n\\nre-write Pascal triangle so the computer can understand it! : index-wise\\n\\n1\\n1 1\\n1 2 1\\n1 3 3 1\\n1 4 6 4 1\\n\\nobservation : \\n1.first and last element is always 1\\n2.any middle element of row i  and col j ,is equal to sum of elements of row (i-1) at index j and (j-1) respectively.\\n\\n\\n    vector<vector<int>> generate(int row) {\\n        vector<vector<int>> ans(row);\\n        \\n        for (int i = 0; i < row; i++)\\n        {\\n            ans[i].resize(i+1);\\n            //starts with 1  \\n            ans[i][0] = 1;\\n            //middle \\n            for (int j = 1; j < i; j++) ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            //ends with 1 \\n            ans[i][i] = 1;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**[EXPLANATION - EASIER TO UNDERSTAND]**\\n\\nre-write Pascal triangle so the computer can understand it! : index-wise\\n\\n1\\n1 1\\n1 2 1\\n1 3 3 1\\n1 4 6 4 1\\n\\nobservation : \\n1.first and last element is always 1\\n2.any middle element of row i  and col j ,is equal to sum of elements of row (i-1) at index j and (j-1) respectively.\\n\\n\\n    vector<vector<int>> generate(int row) {\\n        vector<vector<int>> ans(row);\\n        \\n        for (int i = 0; i < row; i++)\\n        {\\n            ans[i].resize(i+1);\\n            //starts with 1  \\n            ans[i][0] = 1;\\n            //middle \\n            for (int j = 1; j < i; j++) ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            //ends with 1 \\n            ans[i][i] = 1;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2677272,
                "title": "java-pascals-triangle",
                "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> pre =null;\\n        for(int i=0;i<numRows;i++){\\n            List<Integer> row= new ArrayList<>();\\n            for(int j=0;j<=i;j++)\\n                if(j==0||j==i)\\n                    row.add(1);\\n                else\\n                    row.add(pre.get(j-1)+pre.get(j));\\n               pre =row;\\n                ans.add(row);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> pre =null;\\n        for(int i=0;i<numRows;i++){\\n            List<Integer> row= new ArrayList<>();\\n            for(int j=0;j<=i;j++)\\n                if(j==0||j==i)\\n                    row.add(1);\\n                else\\n                    row.add(pre.get(j-1)+pre.get(j));\\n               pre =row;\\n                ans.add(row);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2416733,
                "title": "0-ms-java-solution",
                "content": "```\\npublic class Solution {\\n\\tpublic List<List<Integer>> generate(int numRows) {\\n\\t\\tList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\tList<Integer> row, pre = null;\\n\\t\\tfor (int i = 0; i < numRows; ++i) {\\n\\t\\t\\trow = new ArrayList<Integer>();\\n\\t\\t\\tfor (int j = 0; j <= i; ++j)\\n\\t\\t\\t\\tif (j == 0 || j == i)\\n\\t\\t\\t\\t\\trow.add(1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\trow.add(pre.get(j - 1) + pre.get(j));\\n\\t\\t\\tpre = row;\\n\\t\\t\\tres.add(row);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\tpublic List<List<Integer>> generate(int numRows) {\\n\\t\\tList<List<Integer>> res = new ArrayList<List<Integer>>();\\n\\t\\tList<Integer> row, pre = null;\\n\\t\\tfor (int i = 0; i < numRows; ++i) {\\n\\t\\t\\trow = new ArrayList<Integer>();\\n\\t\\t\\tfor (int j = 0; j <= i; ++j)\\n\\t\\t\\t\\tif (j == 0 || j == i)\\n\\t\\t\\t\\t\\trow.add(1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\trow.add(pre.get(j - 1) + pre.get(j));\\n\\t\\t\\tpre = row;\\n\\t\\t\\tres.add(row);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126016,
                "title": "c-optimal-solution-faster-than-100",
                "content": "**Please upvote if you like the solution**\\n\\nTo solve the problem, we need to first create an array of size N or numRows (input value). This array is used to store each of the rows expected in the output, so, for example, array[1] = [1,1]. In this array, the number of columns (say, numCols) is equal to the number of the i-th row + 1 (Since, 0-indexed), i.e., for 0-th row, numCols = 1. So, the number of columns is different for each row.\\n\\nNext, we need to run a loop from i = 0 to numRows \\u2013 1 (inclusive) in order to store each row in our array. For each of iteration of this loop, we follow the below steps:\\n\\nCreate an array of size (i + 1) (For some languages such as C++, you need to create a 2D array at the start of the program and resize array[i] to (i + 1)).\\nSet the first and last value of array[i] to 1.\\nRun another loop from j = 1 to i \\u2013 1 (inclusive) and for each iteration put array[i][j] = array[i \\u2013 1][j \\u2013 1] + array[i \\u2013 1][j].\\nAfter iterating numRows times, you return the array.\\n\\nTime Complexity: We are creating a 2D array of size (numRows * numCols) (where 1 <= numCols <= numRows), and we are traversing through each of the cells to update it with its correct value, so Time Complexity = O(numRows2).\\n\\nSpace Complexity: Since we are creating a 2D array, space complexity = O(numRows2).\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v (n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            vector<int> v1 (i+1);\\n            v[i] = v1;\\n            v[i][0] = 1;\\n            v[i][i] = 1;\\n            for(int j = 1; j < i; j++)\\n            {\\n                v[i][j] = v[i-1][j-1] + v[i-1][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v (n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            vector<int> v1 (i+1);\\n            v[i] = v1;\\n            v[i][0] = 1;\\n            v[i][i] = 1;\\n            for(int j = 1; j < i; j++)\\n            {\\n                v[i][j] = v[i-1][j-1] + v[i-1][j];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001067,
                "title": "idiomatic-kotlin-solution",
                "content": "```\\nfun generate(numRows: Int): List<List<Int>> {\\n\\tval result = mutableListOf<List<Int>>()\\n\\trepeat(numRows) { depth ->\\n\\t\\tresult.add(MutableList(depth + 1) { i ->\\n\\t\\t\\twhen (i) {\\n\\t\\t\\t\\t0, depth -> 1\\n\\t\\t\\t\\telse -> result[depth - 1][i - 1] + result[depth - 1][i]\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun generate(numRows: Int): List<List<Int>> {\\n\\tval result = mutableListOf<List<Int>>()\\n\\trepeat(numRows) { depth ->\\n\\t\\tresult.add(MutableList(depth + 1) { i ->\\n\\t\\t\\twhen (i) {\\n\\t\\t\\t\\t0, depth -> 1\\n\\t\\t\\t\\telse -> result[depth - 1][i - 1] + result[depth - 1][i]\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909046,
                "title": "python-3",
                "content": "```class Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        m=[]\\n        for i in range(numRows):\\n            s=[]\\n            s.insert(0,1)\\n            m.append(s)\\n            \\n            if i!=0:\\n                s.insert(i,1)\\n                for j in range(1,i):\\n                    temp=m[i-1]\\n                    s.insert(j, temp[j-1]+temp[j])\\n        return m\\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        m=[]\\n        for i in range(numRows):\\n            s=[]\\n            s.insert(0,1)\\n            m.append(s)\\n            \\n            if i!=0:\\n                s.insert(i,1)\\n                for j in range(1,i):\\n                    temp=m[i-1]\\n                    s.insert(j, temp[j-1]+temp[j])\\n        return m\\n",
                "codeTag": "Java"
            },
            {
                "id": 1878753,
                "title": "0ms-2mb-golang-solution-easy-to-understand",
                "content": "```\\nfunc generate(numRows int) [][]int {\\n    ans:=[][]int{}\\n    for i:=0; i<numRows; i++{\\n        for j:=0; j<i+1; j++{\\n            if j==0{\\n                ans = append(ans, []int{1})\\n            }else{\\n                if j==i{\\n                    ans[i] = append(ans[i], 1)\\n                }else{\\n                    ans[i] = append(ans[i], ans[i-1][j]+ans[i-1][j-1])\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generate(numRows int) [][]int {\\n    ans:=[][]int{}\\n    for i:=0; i<numRows; i++{\\n        for j:=0; j<i+1; j++{\\n            if j==0{\\n                ans = append(ans, []int{1})\\n            }else{\\n                if j==i{\\n                    ans[i] = append(ans[i], 1)\\n                }else{\\n                    ans[i] = append(ans[i], ans[i-1][j]+ans[i-1][j-1])\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1843022,
                "title": "simple-sort-and-clear-solution-in-kotlin",
                "content": "To Generate **Pascals Triangle**, We have to head to the approach for getting the previous row value to generate next row.\\n\\nAnd we know the base case for first row will be always 1\\n\\nSo to generate the next row\\'s first and last element, We need to just add the previous row\\'s index 0\\'s value\\n\\nFor rest all value which comes in between(2nd position value to 2nd last value) for row will be sum of previous row\\'s sum of pair like` (0, 1)` index sum for current index 1, `(1, 2)` index sum for current index 2 as so on\\n\\nLet\\'s jump to the solution.\\n```Kotlin\\n    fun generate(numRows: Int): List<List<Int>> {\\n\\n\\n        //Taken a result List\\n        val result = ArrayList<List<Int>>()\\n\\n        //add the first row value\\n        result.add(listOf(1))\\n\\n        //start a loop from 2nd row to last row, as first row has been added in previous line\\n        for (i in 2 .. numRows) {\\n            //Grab the last row which will be required for generating current row i\\n            val lastRow = result.last()\\n\\n            //Created a new row\\n            val row = mutableListOf<Int>()\\n            //Store first value of current row \\n            row.add(lastRow[0])\\n            //Generate the 2nd value to 2nd last value of current row.\\n            for (j in 1..last.lastIndex) {\\n                row.add(lastRow[j - 1] + lastRow[j])\\n            }\\n            //Store last value of current row \\n            row.add(lastRow[0])\\n\\t\\t\\t//Add current row to result\\n            result.add(row)\\n        }\\n\\n        return result\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```Kotlin\\n    fun generate(numRows: Int): List<List<Int>> {\\n\\n\\n        //Taken a result List\\n        val result = ArrayList<List<Int>>()\\n\\n        //add the first row value\\n        result.add(listOf(1))\\n\\n        //start a loop from 2nd row to last row, as first row has been added in previous line\\n        for (i in 2 .. numRows) {\\n            //Grab the last row which will be required for generating current row i\\n            val lastRow = result.last()\\n\\n            //Created a new row\\n            val row = mutableListOf<Int>()\\n            //Store first value of current row \\n            row.add(lastRow[0])\\n            //Generate the 2nd value to 2nd last value of current row.\\n            for (j in 1..last.lastIndex) {\\n                row.add(lastRow[j - 1] + lastRow[j])\\n            }\\n            //Store last value of current row \\n            row.add(lastRow[0])\\n\\t\\t\\t//Add current row to result\\n            result.add(row)\\n        }\\n\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594557,
                "title": "c-easy-and-shortest-solution-easy-and-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> v(numRows);\\n        for(int i=0;i<numRows;i++){\\n            v[i].resize(i+1);\\n            v[i][0]=v[i][i]=1;\\n            for(int j=1;j<i;j++){\\n                v[i][j]=v[i-1][j-1]+v[i-1][j];\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```\\nHope you like it.\\nPlease upvote it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> v(numRows);\\n        for(int i=0;i<numRows;i++){\\n            v[i].resize(i+1);\\n            v[i][0]=v[i][i]=1;\\n            for(int j=1;j<i;j++){\\n                v[i][j]=v[i-1][j-1]+v[i-1][j];\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553739,
                "title": "a-succint-recursive-solution-in-python",
                "content": "```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        prevTriangle = self.generate(numRows-1)\\n        lastRow = prevTriangle[-1]\\n        \\n        newRow = []\\n        for i in range(len(lastRow)-1):\\n            newRow.append(lastRow[i] + lastRow[i+1])\\n        \\n        newRow = [1] + newRow + [1]\\n        return prevTriangle + [newRow]\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows == 1:\\n            return [[1]]\\n        \\n        prevTriangle = self.generate(numRows-1)\\n        lastRow = prevTriangle[-1]\\n        \\n        newRow = []\\n        for i in range(len(lastRow)-1):\\n            newRow.append(lastRow[i] + lastRow[i+1])\\n        \\n        newRow = [1] + newRow + [1]\\n        return prevTriangle + [newRow]\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428992,
                "title": "easy-c-solution-with-explanation-faster-than-95-solutions",
                "content": "```\\n// Do **upvote** if you like the solution it motivates me :)\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        // Declaring a 2D vector of given size\\n        vector<vector <int>> r(numRows);\\n        \\n        for(int i = 0; i < numRows; i++){\\n            // Resizing the current row\\n            r[i].resize(i + 1);\\n            \\n            // Initializing the first and last element to 1\\n            r[i][0] = r[i][i] = 1;\\n            \\n            // looping the row and calculating the value of current cell\\n            for(int j = 1; j < i; j++){\\n                r[i][j] = r[i-1][j] + r[i-1][j-1];\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Do **upvote** if you like the solution it motivates me :)\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        // Declaring a 2D vector of given size\\n        vector<vector <int>> r(numRows);\\n        \\n        for(int i = 0; i < numRows; i++){\\n            // Resizing the current row\\n            r[i].resize(i + 1);\\n            \\n            // Initializing the first and last element to 1\\n            r[i][0] = r[i][i] = 1;\\n            \\n            // looping the row and calculating the value of current cell\\n            for(int j = 1; j < i; j++){\\n                r[i][j] = r[i-1][j] + r[i-1][j-1];\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343121,
                "title": "c-basic-dp-100-faster",
                "content": "# SOLUTION\\nFollowing solution is done by using basic DP\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int dp[numRows][numRows] ;\\n        vector<vector<int>> ans ;\\n        for(int i = 0; i < numRows; i++)\\n        {\\n            vector<int> row;\\n            for(int j = 0; j < numRows; j++)\\n            {\\n                if(j == 0 || j == i)\\n                {\\n                    dp[i][j] = 1 ;\\n                }\\n                else if(i > 0 && j > 0)\\n                {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j] ;\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0 ;\\n                }\\n                if(dp[i][j])          //IF VALUE IN DP IS POSITIVE AND GREATER THAN 0\\n                {\\n                    row.push_back(dp[i][j]) ;\\n                }\\n            }\\n            ans.push_back(row);\\n        }  \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int dp[numRows][numRows] ;\\n        vector<vector<int>> ans ;\\n        for(int i = 0; i < numRows; i++)\\n        {\\n            vector<int> row;\\n            for(int j = 0; j < numRows; j++)\\n            {\\n                if(j == 0 || j == i)\\n                {\\n                    dp[i][j] = 1 ;\\n                }\\n                else if(i > 0 && j > 0)\\n                {\\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j] ;\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0 ;\\n                }\\n                if(dp[i][j])          //IF VALUE IN DP IS POSITIVE AND GREATER THAN 0\\n                {\\n                    row.push_back(dp[i][j]) ;\\n                }\\n            }\\n            ans.push_back(row);\\n        }  \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341804,
                "title": "100-faster-in-c-easy-peasy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n         int n=numRows;\\n        vector<vector<int>>finall;\\n       vector<int>temp;\\n        if(n==1)\\n       {\\n            temp.push_back(1);\\n            finall.push_back(temp);\\n           return finall;\\n       }\\n        if(n==2)\\n        {\\n            temp.push_back(1);\\n            finall.push_back(temp);\\n            temp.push_back(1);\\n           \\n            finall.push_back(temp);\\n            return finall;\\n        }\\n            //for inserting 1, 11\\n                temp.push_back(1);\\n                finall.push_back(temp);\\n                temp.push_back(1);\\n                finall.push_back(temp);\\n            \\n        int k=0;\\n        while(k<n-2)\\n        {\\n             vector<int>res;\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                if(i==0 ){\\n                    res.push_back(1);\\n                }\\n                else if( i==temp.size()-1){\\n                    res.push_back(1);\\n                    break;\\n                } \\n                    res.push_back(temp[i]+temp[i+1]);\\n            }\\n            temp=res;\\n            finall.push_back(temp);\\n            k++;\\n        }\\n        return finall;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n         int n=numRows;\\n        vector<vector<int>>finall;\\n       vector<int>temp;\\n        if(n==1)\\n       {\\n            temp.push_back(1);\\n            finall.push_back(temp);\\n           return finall;\\n       }\\n        if(n==2)\\n        {\\n            temp.push_back(1);\\n            finall.push_back(temp);\\n            temp.push_back(1);\\n           \\n            finall.push_back(temp);\\n            return finall;\\n        }\\n            //for inserting 1, 11\\n                temp.push_back(1);\\n                finall.push_back(temp);\\n                temp.push_back(1);\\n                finall.push_back(temp);\\n            \\n        int k=0;\\n        while(k<n-2)\\n        {\\n             vector<int>res;\\n            for(int i=0;i<temp.size();i++)\\n            {\\n                if(i==0 ){\\n                    res.push_back(1);\\n                }\\n                else if( i==temp.size()-1){\\n                    res.push_back(1);\\n                    break;\\n                } \\n                    res.push_back(temp[i]+temp[i+1]);\\n            }\\n            temp=res;\\n            finall.push_back(temp);\\n            k++;\\n        }\\n        return finall;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287138,
                "title": "python-c-easy-explained-solution-with-time-and-space-complexity",
                "content": "Idea: Let\\'s just say n = numRows\\nHere we will initially have some base cases: \\n1. For n==1, we directly have [[1]] as answer.\\n2. For n==2, we directly write [[1], [1,1]] as answer.\\n\\nWe start our algorithm from n >= 3.\\n1. Pick the previous array for n - 1.\\n2. Maintain an array which will store sum of two consecutive values.\\n3. Append 1 at the begin and end of the result obtained at step 2.\\n![image](https://assets.leetcode.com/users/images/616ed297-1dc5-4b78-98b7-f2b39cc4b2c0_1624260101.621285.png)\\n\\nPython Code:\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \\n        ans = [[1]]\\n        if numRows == 1:\\n            return ans\\n        \\n        ans.append([1,1])\\n        if numRows == 2:\\n            return ans\\n        \\n        for i in range(3, numRows+1):\\n            prev = ans[-1]\\n            \\n            temp = [1]\\n            for j in range(1, len(prev)):\\n                temp.append(prev[j] + prev[j-1])\\n            temp.append(1)\\n            \\n            ans.append(temp)\\n        return ans\\n ```\\n \\n C++ Code:\\n ```\\n class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans;\\n        ans.push_back({1});\\n        if(numRows == 1) return ans;\\n        ans.push_back({1,1});\\n        if(numRows == 2) return ans;\\n        \\n        for(int i=3;i<=numRows;i++){\\n            vector<int> temp, prev = ans[i-2];\\n            temp.push_back(1);\\n            for(int j=1;j<prev.size();j++){\\n                temp.push_back(prev[j] + prev[j-1]);\\n            }\\n            temp.push_back(1);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n \\n**Time Complexity:** O(n) for iterating through n number of rows and O(n) for getting the consecutive sum **= O(n^2)**.\\n**Space Complexity: O(n^2)** for the output array. \\n *Most People will not consider this as extra space, but remember the definition of Space Complexity. It says, any space that is required for executing the program, except the input that is provided. Hence, the output space will be considered.*",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        \\n        ans = [[1]]\\n        if numRows == 1:\\n            return ans\\n        \\n        ans.append([1,1])\\n        if numRows == 2:\\n            return ans\\n        \\n        for i in range(3, numRows+1):\\n            prev = ans[-1]\\n            \\n            temp = [1]\\n            for j in range(1, len(prev)):\\n                temp.append(prev[j] + prev[j-1])\\n            temp.append(1)\\n            \\n            ans.append(temp)\\n        return ans\\n ```\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> ans;\\n        ans.push_back({1});\\n        if(numRows == 1) return ans;\\n        ans.push_back({1,1});\\n        if(numRows == 2) return ans;\\n        \\n        for(int i=3;i<=numRows;i++){\\n            vector<int> temp, prev = ans[i-2];\\n            temp.push_back(1);\\n            for(int j=1;j<prev.size();j++){\\n                temp.push_back(prev[j] + prev[j-1]);\\n            }\\n            temp.push_back(1);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941293,
                "title": "python-a-different-approach",
                "content": "We can generate the nth row of pascals triangle in O(n) time, by taking advantage of some mathematical facts.\\n\\n1. Pascals triangle is just an arrangement of binomial coefficients. That is, the kth entry in the nth row of pascals triangle is just the coefficient of ![x^k](https://render.githubusercontent.com/render/math?math=x%5Ek) in ![(1 + x)^n](https://render.githubusercontent.com/render/math?math=(1%20%2B%20x)%5En). <br> _You can prove this by induction, showing that when you multiply again by ![1 + x](https://render.githubusercontent.com/render/math?math=1%20%2B%20x), the new coefficient of ![x^k](https://render.githubusercontent.com/render/math?math=x%5Ek) will now be the old coefficient of ![x^k](https://render.githubusercontent.com/render/math?math=x%5Ek) (multiplied by the 1) plus the old coefficient of ![x^(k - 1)](https://render.githubusercontent.com/render/math?math=x%5E%7Bk-1%7D) (multiplied by the x))_\\n2. The binomial coefficients are ![n choose k = n! / k!(n - k)!](https://render.githubusercontent.com/render/math?math=n%5Cchoose%7Bk%7D%3D%5Cfrac%7Bn!%7D%7Bk!(n-k)!%7D).\\n3. Calculating n choose k given n choose k - 1 can be done by multiplying by n - k and dividing by k.\\n\\nPutting these facts together, we can implement a method for calculating the nth row of pascal\\'s triangle:\\n\\n```python\\ndef generateRow(rowIdx):\\n\\tn = rowIdx + 1\\n\\tnCk = 1\\n\\tresult = [1]\\n\\t\\n\\tfor k in range(1, n):\\n\\t\\tnCk = (nCk * (n - k)) // k\\n\\t\\tresult.append(nCk)\\n\\n\\treturn result\\n```\\n\\nWe can then use python list comprehension to implement a very concise solution:\\n\\n```python\\ndef generateTriangle(numRows):\\n\\treturn [generateRow(i) for i in range(numRows)]\\n```",
                "solutionTags": [],
                "code": "```python\\ndef generateRow(rowIdx):\\n\\tn = rowIdx + 1\\n\\tnCk = 1\\n\\tresult = [1]\\n\\t\\n\\tfor k in range(1, n):\\n\\t\\tnCk = (nCk * (n - k)) // k\\n\\t\\tresult.append(nCk)\\n\\n\\treturn result\\n```\n```python\\ndef generateTriangle(numRows):\\n\\treturn [generateRow(i) for i in range(numRows)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 518339,
                "title": "c-simple-iterative-dp-solution",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> Generate(int numRows) {\\n        int[][] result = new int[numRows][];\\n        int i = 0;\\n        while(i < numRows) {\\n            result[i] = new int[i+1];\\n            result[i][0] = result[i][i] = 1;\\n            int j = 1;\\n            while (j < i) {\\n               result[i][j] = result[i-1][j-1] + result[i-1][j];\\n               j++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Generate(int numRows) {\\n        int[][] result = new int[numRows][];\\n        int i = 0;\\n        while(i < numRows) {\\n            result[i] = new int[i+1];\\n            result[i][0] = result[i][i] = 1;\\n            int j = 1;\\n            while (j < i) {\\n               result[i][j] = result[i-1][j-1] + result[i-1][j];\\n               j++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454123,
                "title": "c-easy-0ms-100-space-92-59-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        //creates a vector triangle with numRows number of inner vectors of size 1 and value 1\\n        vector<vector<int>> triangle(numRows, vector<int> (1,1));\\n        \\n        if(numRows == 0) return triangle; \\n        \\n        vector<int> prevRow;\\n\\t\\t\\n\\t\\t//We start the for loop from 1st index because the vector at 0th index of triangle is already intialized with 1\\n\\t\\t//if the numRows is 1, then we do not enter the for loop and simply skip to return triangle\\n        for(int currRow = 1; currRow<numRows ; currRow++)\\n        {\\n            prevRow = triangle[currRow-1]; \\n            for(int i=1;i<currRow;i++)\\n            {\\n\\t\\t\\t   //this loop fills up the elements apart from the 1st and last element of the vector\\n                triangle[currRow].push_back(prevRow[i] + prevRow[i-1]);\\n            }\\n            triangle[currRow].push_back(1);      //setting the last element of the vector as 1      \\n        }        \\n        return triangle;\\n    }\\n};\\n```\\n\\nTime complexity = O(n^2)\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Pascal\\'s Triangle.\\nMemory Usage: 8.7 MB, less than 92.59% of C++ online submissions for Pascal\\'s Triangle.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        //creates a vector triangle with numRows number of inner vectors of size 1 and value 1\\n        vector<vector<int>> triangle(numRows, vector<int> (1,1));\\n        \\n        if(numRows == 0) return triangle; \\n        \\n        vector<int> prevRow;\\n\\t\\t\\n\\t\\t//We start the for loop from 1st index because the vector at 0th index of triangle is already intialized with 1\\n\\t\\t//if the numRows is 1, then we do not enter the for loop and simply skip to return triangle\\n        for(int currRow = 1; currRow<numRows ; currRow++)\\n        {\\n            prevRow = triangle[currRow-1]; \\n            for(int i=1;i<currRow;i++)\\n            {\\n\\t\\t\\t   //this loop fills up the elements apart from the 1st and last element of the vector\\n                triangle[currRow].push_back(prevRow[i] + prevRow[i-1]);\\n            }\\n            triangle[currRow].push_back(1);      //setting the last element of the vector as 1      \\n        }        \\n        return triangle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291129,
                "title": "runtime-8-ms-faster-than-99-95-of-python-online-submissions-for-pascal-s-triangle",
                "content": "```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        response = [[1]*i for i in range(1, numRows+1)]\\n        \\n        for i in range(2, numRows):\\n            for j in range(1,i):\\n                response[i][j] = response[i-1][j] + response[i-1][j-1]\\n                \\n        return response\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def generate(self, numRows):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        response = [[1]*i for i in range(1, numRows+1)]\\n        \\n        for i in range(2, numRows):\\n            for j in range(1,i):\\n                response[i][j] = response[i-1][j] + response[i-1][j-1]\\n                \\n        return response\\n",
                "codeTag": "Java"
            },
            {
                "id": 238336,
                "title": "c-with-recursion",
                "content": "I couldn\\'t find an answer in C# that included any recursion.  It\\'s possible people were getting hung up on the List Interface, so I wanted to post this here as a reference for anyone else doing this with recursion.  Note that you have to pass in the IList into your sub-method and then cast that into a List to get this to work.\\n\\nI understand that there are simpler iterative solutions to get this to work, but since some people may be interested in using recursion, I posted this.\\n\\n```\\npublic class Solution {\\n    public IList<IList<int>> Generate(int numRows) {\\n        IList<IList<int>> returnList = new List<IList<int>>();\\n        if (numRows < 1)\\n            return returnList;\\n        List<int> rowList = new List<int>() {1};\\n        returnList.Add(rowList);\\n        \\n        Generate(numRows, returnList);\\n        return returnList;\\n    }\\n    \\n    private void Generate(int i, IList<IList<int>> myList)\\n    {\\n        if (i == 1)\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            Generate(i - 1, myList);\\n            List<int> rowList = new List<int>();\\n            List<int> prevRow = new List<int>();\\n            prevRow = myList[i-2].ToList<int>(); // i is length not index, so need to subtract 2\\n            for (int j = 1; j <= i; j++)\\n            {\\n                if (j == 1 || j == i)\\n                {\\n                    rowList.Add(1);\\n                }\\n                else\\n                    rowList.Add(prevRow[j-2] + prevRow[j-1]);\\n            }\\n            myList.Add(rowList);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Generate(int numRows) {\\n        IList<IList<int>> returnList = new List<IList<int>>();\\n        if (numRows < 1)\\n            return returnList;\\n        List<int> rowList = new List<int>() {1};\\n        returnList.Add(rowList);\\n        \\n        Generate(numRows, returnList);\\n        return returnList;\\n    }\\n    \\n    private void Generate(int i, IList<IList<int>> myList)\\n    {\\n        if (i == 1)\\n        {\\n            return;\\n        }\\n        else\\n        {\\n            Generate(i - 1, myList);\\n            List<int> rowList = new List<int>();\\n            List<int> prevRow = new List<int>();\\n            prevRow = myList[i-2].ToList<int>(); // i is length not index, so need to subtract 2\\n            for (int j = 1; j <= i; j++)\\n            {\\n                if (j == 1 || j == i)\\n                {\\n                    rowList.Add(1);\\n                }\\n                else\\n                    rowList.Add(prevRow[j-2] + prevRow[j-1]);\\n            }\\n            myList.Add(rowList);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219516,
                "title": "rust-answer-0ms",
                "content": "inner for loop implementation\\n```\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut res = Vec::new();\\n        for x in 0..num_rows as usize {\\n            res.push(vec![1; x+1]);\\n            for y in 1..x {\\n                res[x][y] = res[x-1][y-1] + res[x-1][y];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn generate(num_rows: i32) -> Vec<Vec<i32>> {\\n        let mut res = Vec::new();\\n        for x in 0..num_rows as usize {\\n            res.push(vec![1; x+1]);\\n            for y in 1..x {\\n                res[x][y] = res[x-1][y-1] + res[x-1][y];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158290,
                "title": "pure-functional-scala",
                "content": "```\\ndef generate(numRows: Int): List[List[Int]] = {\\n\\n  def constructFrom(prevRow: List[Int]): List[Int] = prevRow match {\\n    case x :: Nil => List(1)\\n    case x1 :: x2 :: xs => (x1 + x2) :: constructFrom(x2 :: xs)\\n  }\\n\\n  def genFromPrev(n: Int): List[List[Int]] = \\n    if (n == 1) List(List(1))\\n    else {\\n      val prev = genFromPrev(n - 1)\\n      (1 :: constructFrom(prev.head)) :: prev\\n    }\\n\\n  if (numRows == 0) Nil else genFromPrev(numRows).reverse\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef generate(numRows: Int): List[List[Int]] = {\\n\\n  def constructFrom(prevRow: List[Int]): List[Int] = prevRow match {\\n    case x :: Nil => List(1)\\n    case x1 :: x2 :: xs => (x1 + x2) :: constructFrom(x2 :: xs)\\n  }\\n\\n  def genFromPrev(n: Int): List[List[Int]] = \\n    if (n == 1) List(List(1))\\n    else {\\n      val prev = genFromPrev(n - 1)\\n      (1 :: constructFrom(prev.head)) :: prev\\n    }\\n\\n  if (numRows == 0) Nil else genFromPrev(numRows).reverse\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1753003,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1818802,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1804797,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1850187,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1571828,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 2048476,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1835223,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1567862,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1918773,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 2048536,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1753003,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1818802,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1804797,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1850187,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1571828,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 2048476,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1835223,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1567862,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 1918773,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 2048536,
                "content": [
                    {
                        "username": "zkerner1",
                        "content": "can we switch the animation to a static image? its really annoying"
                    },
                    {
                        "username": "Dev_Engg",
                        "content": "just read and scroll down \\n"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "why... the diagram literally shows you the algorithm "
                    },
                    {
                        "username": "Anshul29",
                        "content": "agree"
                    },
                    {
                        "username": "deleted_user",
                        "content": "You can delete the <img> element if you inspect the page if it\\'s bothering you that much. I agree, its distracting."
                    },
                    {
                        "username": "vivek2vks",
                        "content": "Take screenshot xD. This is what I did. And yes it\\'s annoying + distracting. "
                    },
                    {
                        "username": "ahmadheshamzaki",
                        "content": "Here\\'s a lazy one-liner since the constraint is relatively small :P\\n```python\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        return [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35,35,21,7,1],[1,8,28,56,70,56,28,8,1],[1,9,36,84,126,126,84,36,9,1],[1,10,45,120,210,252,210,120,45,10,1],[1,11,55,165,330,462,462,330,165,55,11,1],[1,12,66,220,495,792,924,792,495,220,66,12,1],[1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1],[1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1],[1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1],[1,16,120,560,1820,4368,8008,11440,12870,11440,8008,4368,1820,560,120,16,1],[1,17,136,680,2380,6188,12376,19448,24310,24310,19448,12376,6188,2380,680,136,17,1],[1,18,153,816,3060,8568,18564,31824,43758,48620,43758,31824,18564,8568,3060,816,153,18,1],[1,19,171,969,3876,11628,27132,50388,75582,92378,92378,75582,50388,27132,11628,3876,969,171,19,1],[1,20,190,1140,4845,15504,38760,77520,125970,167960,184756,167960,125970,77520,38760,15504,4845,1140,190,20,1],[1,21,210,1330,5985,20349,54264,116280,203490,293930,352716,352716,293930,203490,116280,54264,20349,5985,1330,210,21,1],[1,22,231,1540,7315,26334,74613,170544,319770,497420,646646,705432,646646,497420,319770,170544,74613,26334,7315,1540,231,22,1],[1,23,253,1771,8855,33649,100947,245157,490314,817190,1144066,1352078,1352078,1144066,817190,490314,245157,100947,33649,8855,1771,253,23,1],[1,24,276,2024,10626,42504,134596,346104,735471,1307504,1961256,2496144,2704156,2496144,1961256,1307504,735471,346104,134596,42504,10626,2024,276,24,1],[1,25,300,2300,12650,53130,177100,480700,1081575,2042975,3268760,4457400,5200300,5200300,4457400,3268760,2042975,1081575,480700,177100,53130,12650,2300,300,25,1],[1,26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657700,10400600,9657700,7726160,5311735,3124550,1562275,657800,230230,65780,14950,2600,325,26,1],[1,27,351,2925,17550,80730,296010,888030,2220075,4686825,8436285,13037895,17383860,20058300,20058300,17383860,13037895,8436285,4686825,2220075,888030,296010,80730,17550,2925,351,27,1],[1,28,378,3276,20475,98280,376740,1184040,3108105,6906900,13123110,21474180,30421755,37442160,40116600,37442160,30421755,21474180,13123110,6906900,3108105,1184040,376740,98280,20475,3276,378,28,1],[1,29,406,3654,23751,118755,475020,1560780,4292145,10015005,20030010,34597290,51895935,67863915,77558760,77558760,67863915,51895935,34597290,20030010,10015005,4292145,1560780,475020,118755,23751,3654,406,29,1]][:numRows]\\n```"
                    },
                    {
                        "username": "leson1106",
                        "content": "best solution ever xD"
                    },
                    {
                        "username": "amitak0707",
                        "content": "lol"
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "why does my O(n^2) sol uses less time and space then this, lol"
                    },
                    {
                        "username": "freezeen3",
                        "content": "As expected it\\'s one of those Python guys."
                    },
                    {
                        "username": "Alcas1",
                        "content": "Seems more like static programming lmao"
                    },
                    {
                        "username": "mohitairy1447",
                        "content": "Bro took one liners seriously"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "He took \"hard coded\" to another level."
                    },
                    {
                        "username": "oscar_y51",
                        "content": "lmao\\n"
                    },
                    {
                        "username": "shaun_D_ace",
                        "content": "bruhh"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Now, THIS, is Dynamic Programming at it\\'s FINEST."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "This solution is 5head. I would accept it on the interview cuz to generate the precomputed data you would need to solve the problem \"correct\" way."
                    },
                    {
                        "username": "t5810m",
                        "content": "Is this easy question? How many time it takes you to solve it? Anyone mind to answer? I could not solve it without the code from the solution...."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "It took me four hours nearly because I am a beginner"
                    },
                    {
                        "username": "tiger_coder",
                        "content": "around 15mins"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "Dont let these replies discourage you. Everyone is different. TBH its not very easy as I spent >30min on a non-matrix approach."
                    },
                    {
                        "username": "Balerii",
                        "content": "Idk. No more than 5 mins"
                    },
                    {
                        "username": "natitati",
                        "content": "About 10 minutes and I did it while playing csgo lol"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "I tried this problem for the first time too and got completely blank. I too had to look for solutions elsewhere. "
                    },
                    {
                        "username": "akash_vannam",
                        "content": "5 min "
                    },
                    {
                        "username": "khairnsaa",
                        "content": "first time i got into this problem, i couldn\\'t solve it on my own. 1 year later i cameback to this problem, finally i could solve it on my own (but it still took a long time to solve it tho)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I believe, one day you will come back to the same question, read your comment, and realise how much you have grown, how much you have learnt. We believe in you."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it took me around 10 min to solve the question"
                    },
                    {
                        "username": "gmaan2",
                        "content": "7 minutes seeing it first time, but I\\'ve been practicing leetcode for a bit.  It gets easier as you keep practicing.  Is not a race, but a marathon :)"
                    },
                    {
                        "username": "supreethpatrudu",
                        "content": "I guess you would have picked up the logic, but the problem is it takes alot of tries to implement it"
                    },
                    {
                        "username": "pyush98",
                        "content": "it\\'s all relative and everybody is different, just make sure u understand the solution well."
                    },
                    {
                        "username": "lmholland",
                        "content": "It\\'s an easy question for people who have seen and done these types of problems before. If you haven\\'t ever seen it before, obviously it will be very difficult."
                    },
                    {
                        "username": "nlvphu19",
                        "content": "Hmm, I have to revise pascal triangle to remember that it\\'s just some binomial coefficient. When you know that, you can do it as a normal iterative problem :V"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It took me 13 minutes (iterative solution). I consider that quite slow for an Easy.\\n\\nIt\\'s not the easiest Easy, but definitely not a Medium."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is straight forward enough if you know how Pascals\\' triangle works (each row is derived from the previous row). It all comes down to how good you are at manipulating matrices in the language of your choice."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "it is medium"
                    },
                    {
                        "username": "sameer89",
                        "content": "It is really not, why because puzzles like these are taught in introductory math/CS courses. I can understand that self taught people might disagree with it, but once you do it a couple of times it will be like imprinted in your head."
                    },
                    {
                        "username": "TimeToWakeUp",
                        "content": "I can't really understand what does the columnSizes mean,even it's explain that the sizes of the arrays are returned as *columnSizes array in the problem.Can anybody explain it to me in detail?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use DP to solve. 2D array !\nCompare with 62. Unique Paths \n![unigue_path.png](https://assets.leetcode.com/users/images/bab16c1d-e39a-4683-9bd4-fbe4085cff63_1693703164.5031812.png)"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "is this easy question ? :)"
                    },
                    {
                        "username": "gd4niele",
                        "content": "Yes man, it\\'s just a matter of practice. one day you will look this problem and say \"it\\'s easy\"."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Brother it\\'s an easy one. Dont worry if you didn\\'t get in the first go. Take your time. One you too will say that its easy."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "what do we call problem harder than hard "
                    },
                    {
                        "username": "tharunnelli",
                        "content": "its hard\\n"
                    },
                    {
                        "username": "vli02",
                        "content": "There are a few things not good for a c programmer.\\n\\n1. Frist, there is no need to return columnSizes, because the return data is a triangle, so the column size of each row equals the the row number, it is determined, there is no such a need to allocate memory and fill in the numbers 1, 2, 3, 4, ...\\n\\n2. The comments describe \"assume caller free the memory\", this is very wrong. Caller never know how callee allocates the memory, how can it free the memory? The right approach should be asking for user to write a function which caller can call for freeing the memory being allocated by user.\\n\\nIn this particular problem, the total element of the triangle is n * (n + 1) / 2. I like to allocate one buffer outside of loop by using one malloc, and reference to the different location of this buffer for each row of the array. pseudo code:\\n\\np = malloc(numRows * sizeof(int *)); // array\\nbuff = malloc(numRows * (numRows + 1) / 2 * sizeof(int)); // all element\\n//assert(p && buff);\\nfor (i = 1; i <= numRows; i ++) {\\n    p[i - 1] = buff;\\n    ....\\n    buff += i;\\n}\\n\\nwhen freeing the memory, it will be:\\n\\nfree(p[0]);\\nfree(p);"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Idk why the column param is a int pointer but not the row param in most of LC matrices problems\\n"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Functions involvig multidimensional arrays in C are very sloppy in leetcode. I just switch to C++ (or even python if you don\\'t want to get dirty) for these questions because you gain nothing from working with this terrible function design leetcode gives for C."
                    },
                    {
                        "username": "psionl0",
                        "content": "1. You are correct for this particular problem but this seems to be a general template for various matrix functions where each row may have a different size.\\n\\n2. A better solution would be for the caller to do the mallocing and pass pointers to the callee to use. Of course, you would also need the returnSize and *returnColumnSizes parameters if this were the case."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Am I the only one who couldn\\'t solve it on my own or its that easy with high acceptance rate?"
                    },
                    {
                        "username": "puneet762",
                        "content": "Yes, you are the only one."
                    },
                    {
                        "username": "shkhiab87",
                        "content": "[@lmholland](/lmholland)  which algorithm ..?\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "Try to come back later, I tried it again after some time just today didnt take 3 mins"
                    },
                    {
                        "username": "lmholland",
                        "content": "You need to study data structures and algorithms before attempting this one."
                    },
                    {
                        "username": "aDDyy",
                        "content": "This Pascals Triangle method can also be used to find nCr for given values of n & r\\uD83D\\uDE42"
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) oh, my bad reading. i thought you were saying about this problem.."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@ahrix268](/ahrix268) I am familiar with that method (I use a similar method to calculate nCr). But you are missing the point. The space complexity is O(1) only because Pascal's Triangle is the answer (whether you calculate the current cell from the previous cell or derive the current row from the previous row) and thus not included in the space complexity calculation.\nIf you were to generate the entire Pascal's Triangle (when not required as part of your answer) just to calculate a single nCr then the space complexity would indeed be O(n^2).\nIncidentally, you can run into integer overflow problems with your method since you multiply a coefficient before you do the division."
                    },
                    {
                        "username": "ahrix268",
                        "content": "[@psionl0](/psionl0) not really. \nit took me $O(n^2)$ Time Complexity but only $O(1)$ Space Complexity\nbtw, i calculated the current cell by its previous one, not call back the previous row of the triangle\nhere is my solution [no tracking previous row](https://leetcode.com/problems/pascals-triangle/solutions/4016436/0ms-java-solution-no-tracking-previous-row-pure-of-math/)"
                    },
                    {
                        "username": "psionl0",
                        "content": "True but it is an O(n^2) time and space solution. Unless you need to do a lot of nCr calculations, you would probably prefer another method."
                    }
                ]
            },
            {
                "id": 2047618,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 2049068,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 1766775,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 1574418,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 2049597,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 2049292,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 2049193,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 2049165,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 2048587,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 1958715,
                "content": [
                    {
                        "username": "tywarinabin",
                        "content": "How this question is tagged as Easy ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "They probably think that the animation gives the answer away."
                    },
                    {
                        "username": "HyperVision",
                        "content": "This shit is not easy..."
                    },
                    {
                        "username": "Rookie176",
                        "content": "Just don\\'t be upset buddy, it may has a easy lable but it does contain a lot of knowledge to think about. I first saw this question long way back to my college. At that time I can only solve this problem with my intuition which could be unreliable for many times. Then I learn dynamic programming I started to solve problems like this as one of them using the DP idea. After that, I knew more about graph theory and now I treat the solution of this problem as a DAG, which is on a higher level and in some sense more general than DP.\\n\\nYou see, everybody must go through this process in order to make progress, I\\'m still learning and I believe one year later I\\'ll see this problem in another way. Just like the old saying in ancient China: At first, I saw the world as it is. Years later, I saw the truth beyond the world. Finally, after all my struggle of learning, I still see the world as it is. It may in some way show the Tao of programming: always learning, always curious, always gain.\\n\\nAnd speak about why I have typed this long, I just had too much coffee and get too excited to sleep....How sad is that, right? :("
                    },
                    {
                        "username": "ogcooke",
                        "content": "Why? This question is basically solved once you understand how to build next iteration based on a previous one. And that is pretty easy to do in one array go."
                    },
                    {
                        "username": "TusharTrivedi13",
                        "content": "What is wrong with my code? please tell me, it\\'s giving wrong answer for 14 numRows input.\\n\\nCODE:\\n\\nclass Solution {\\n    public int factorial(int a){\\n\\tint ans=1;\\n\\tif(a>1){\\n\\t\\twhile(a>1){\\n\\t\\t\\tans*=a;\\n\\t\\t\\ta--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n    }\\n\\npublic int calculateNcR(int i,int j){\\n\\tint ncr = (factorial(i)/(factorial(i-j)*factorial(j)));\\n\\treturn ncr;\\n}\\n\\n\\n    public List<List<Integer>> generate(int numRows) {\\n        if(numRows==0){return new ArrayList();}\\n        List<List<Integer>> list = new ArrayList<>();\\n        int n=numRows;\\n        for(int i=0;i<n;i++){\\n            List<Integer> temp =  new ArrayList<>();\\n\\t        for(int j=0;j<=i;j++){\\n                temp.add(calculateNcR(i,j));\\n\\t        }\\n            list.add(temp);\\n\\t        \\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "First is fomatting."
                    },
                    {
                        "username": "m9ruf",
                        "content": "because of, in 14th row the value is too long ,which is not handle by int, you should use long then it will show correct ans "
                    },
                    {
                        "username": "HeIIo_world",
                        "content": "![image](https://assets.leetcode.com/users/images/8232cfba-c543-4219-bee3-a91bc751e2d8_1601184783.4159799.png)\\n"
                    },
                    {
                        "username": "bindalsourabh1",
                        "content": "[@chirag2000](/chirag2000)  its working \\n\\n\\n#include <bits/stdc++.h>\\n\\nvector<vector<long long int>> printPascal(int n) \\n{\\n  // Write your code here.\\n  vector<vector< long long int>> ans(n);\\n        for(int i=0; i<n; i++){\\n            ans[i].resize(i+1, 1);\\n        }\\n        for(int i=2; i<n; i++){\\n            for(int j=1; j<ans[i].size()-1; j++){\\n                ans[i][j] = ans[i-1][j-1] + ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n\\n}\\n"
                    },
                    {
                        "username": "chirag2000",
                        "content": "why this code is not running on codestudio\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/"
                    },
                    {
                        "username": "adityayada17",
                        "content": "looks like each row is 11 power 0, 11 power 1, 11 power 2 .... and so on"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "bruh, u just need to figure out how will u convert these numbers to digit array now and u good to go...\\n\\nbut good observation yeh"
                    },
                    {
                        "username": "obbl",
                        "content": "Wow, this daily question thing really works. A year ago, I felt like problems from leetcode are really hard. Now, after like a month of solving one or two daily it have become a habit and it is so much easier to solve these. Took like 5 mins to figure out and zero wrong attempts. Gotta go and try to join my college programming team"
                    },
                    {
                        "username": "Vasa_Pg",
                        "content": "I recommend to see a youtube video about Pascal\\xB4s triangle, it is a really interesting mathematical concept, besides it help me a ton to undertsand how to solve it. The problem explanation here at leetcode is kinda too simplistic for my own taste. Good luck! [Youtube video](https://www.youtube.com/watch?v=XMriWTvPXHI)"
                    },
                    {
                        "username": "vshivani1998",
                        "content": "the video is dope thanks man\\n"
                    },
                    {
                        "username": "Rookie176",
                        "content": "It\\'s not normal to see a easy task on Friday. Shouldn\\'t today give us a hard one and murder our weekends?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Guess it's finally guys in LeetCode show some mercy for rookies like me,haha"
                    },
                    {
                        "username": "ahrix268",
                        "content": "here is another approach if you don\\'t want to care about the previous row of the triangle\\n\\njust start with $1$ at each row and the next number will be calculated by:\\n\\n   $ list[i][j+1] = list[i][j] * (i-j) / j $"
                    },
                    {
                        "username": "strangepk07",
                        "content": "Can we do it without Dynamic Programming Approach?"
                    },
                    {
                        "username": "harishkumarn",
                        "content": "Yes, each cell represents a binomial coefficient. So the values of the n\\'th row would be nC0 to nCn"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "Yes, it\\'s simple brute force"
                    }
                ]
            },
            {
                "id": 1786271,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 1778339,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 1571243,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 2076252,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 2067313,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 2057096,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 2049400,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 2049394,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 2049363,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 2049317,
                "content": [
                    {
                        "username": "hexxlet",
                        "content": "It\\'s a bit tricky to estimate space & time complexity.\\nFrom the first glance both seem to be n*n\\nIs it correct & precise enough?"
                    },
                    {
                        "username": "ramyaraj307",
                        "content": "Hello! Why is this solution not working when numRows=14?\\n\\n `class Solution {\\n    private int factorial(int i) {\\n        if (i == 0) {\\n            return 1;\\n        }\\n        return i*factorial(i-1);\\n    }\\n    public List<List<Integer>> generate(int numRows) {\\n        // factorial method\\n        List<List<Integer>> answer = new ArrayList<>();\\n\\n        for (int i=0; i<numRows; i++) {\\n            List<Integer> innerList = new ArrayList<>();\\n            for (int j=0; j <=i; j++) {\\n                //nCr formula\\n                innerList.add(factorial(i)/(factorial(i-j)*factorial(j)));   \\n            }\\n            answer.add(innerList);\\n        }\\n        return answer;\\n    }\\n}`"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "i also have the same problem"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def generate(num_rows)\\n      num_rows.times.map{|n|[p=1]+(1..n).map{|k|p=p*(n-k+1)/k}}\\n    end"
                    },
                    {
                        "username": "Skeption",
                        "content": "it works totally fine when the \\'j\\' in the second loop is initialized with 0 , it doesn\\'t when it\\'s initialized with 1 , in case of i=1 and j=0 we would have:\\nArray[1][0]=Array[0][0]+Array[0][-1] which is equale to 2 no ? , could someone explain please why it doesn\\'t work in case of j=1.\\n\\n\\n `/**\\n * @param {number} numRows\\n * @return {number[][]}\\n */\\nvar generate = function(numRows) {\\n    let Array=[];\\n    for(let i=0 ; i<numRows ; i++){\\n        Array[i]=[];\\n        for(let j=0 ; j<numRows ; j++){\\n            Array[i][0]=1;\\n            Array[i][i]=1;\\n            if(i===j){\\n                break;\\n            }else{\\n                Array[i][j]=Array[i-1][j]+Array[i-1][j-1];\\n            }\\n        }\\n    }\\n    return Array;\\n};`"
                    },
                    {
                        "username": "shivanshbhat86",
                        "content": "[Easiest Approach and Solution](Easiest Approach and Solution)\\n\\n\\n\\n\\n1.Create  a  List List Data Structure.\\n\\n2.Two for loops , One to generate  lists and Another to add those list to the parent list.\\n\\n3. Create a new list and check if boundary hits or not\\nif yes,\\nadd a \\'1\\' to the list\\nelse \\ngo to the above list i.e i-1 and add j & j-1 .\\n\\n4. Return the list at the end.\\n\\n `public List<List<Integer>> generate(int numRows) {\\n        int n = numRows;\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j=0;j<=i;j++){\\n                if(j==i || j==0){\\n                    al.add(1);\\n                }else{\\n                    al.add(ans.get(i-1).get(j)+ans.get(i-1).get(j-1));\\n                }\\n            }  \\n            ans.add(al); \\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "842227130",
                        "content": "its no anyyyyyyy way a easy!!!!!!"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "could someone explain to me what the returnColumnSizes array and the returnSize array are for?\\nI understand the task but I dont understand those return variables."
                    },
                    {
                        "username": "Florian2002",
                        "content": "My solution is wrong (e.g.,[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] for numRowa=5)  because i get spaces between the numbers. Has anyone an idea how i can move them, because they seem to be standard for the print function?"
                    },
                    {
                        "username": "tsarasovapro",
                        "content": "def generate_pascals_triangle(numRows):\\n    if numRows <= 0:\\n        return []\\n\\n    triangle = []  \\n\\n    for i in range(numRows):\\n        row = []  \\n        if i == 0:\\n            row = [1] \\n        else:\\n            for j in range(i + 1):\\n                if j == 0 or j == i:\\n                    row.append(1)  \\n                else:\\n                 \\n                    row.append(triangle[i - 1][j - 1] + triangle[i - 1[j])\\n        triangle.append(row) \\n    return triangle\\n\\n\\nnumRows = 5\\nresult = generate_pascals_triangle(numRows)\\nfor row in result:\\n    print(row)"
                    },
                    {
                        "username": "Alessio16",
                        "content": "I don\\'t understand why my solution doesn\\'t work out, when i test it in local it works but on leetcode I receive an heap-buffer-overflow or an empty output.\\n\\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\\n    \\nint i = 0, j = 0, curr = 0, prec = 0, **array = NULL;\\n \\n    returnSize = (int *)malloc(sizeof(int));\\n    *returnSize = numRows;\\n \\n    //printf(\"%d \\\\n\",*returnSize);\\n \\n    array = (int **)malloc(numRows * sizeof(int *));\\n    *returnColumnSizes = (int *)malloc(numRows * sizeof(int));\\n    for(i = 0; i < numRows; i++){\\n        //returnColumnSizes[i] = (int *)malloc(sizeof(int));\\n        (*returnColumnSizes)[i] = i + 1;\\n        //printf(\"--%d--\\\\n\", (*returnColumnSizes)[i]);\\n        array[i] = (int *)malloc(((*returnColumnSizes)[i]) * sizeof(int));\\n        if(i == 0){\\n            array[i][0] = 1;\\n            //printf(\"%d\\\\n\",array[i][0]);\\n        }\\n        else{\\n            curr = 0;\\n            prec = curr - 1;\\n            for(j = 0; j < (*returnColumnSizes)[i]; j++){\\n                if(prec >= 0 && curr < (*returnColumnSizes)[i - 1]){\\n                    array[i][j] = array[i - 1][prec] + array[i - 1][curr];\\n                    //printf(\" %d \",array[i][j]);\\n                    curr++;\\n                    prec++;\\n                }\\n                else{\\n                    if(prec < 0){\\n                        array[i][j] = array[i - 1][curr];\\n                        //printf(\"%d\",array[i][j]);\\n                        curr++;\\n                        prec++;\\n                    }\\n                    else{\\n                        array[i][j] = array[i - 1][prec];\\n                        //printf(\"%d\\\\n\",array[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n \\n    return array;\\n}"
                    },
                    {
                        "username": "Rookie176",
                        "content": "[@URBeautiful](/URBeautiful) It\\'s because in C, we CANNOT actually know the size of an array returned by a function if we only got an array, maybe in this problem it is obvious that the size is the same as numRows, but it doesn\\'t always that simple since there is not something like a \\'\\\\0\\' at the end of the sequence in a char*, which you can find in some problems if you are asked to return a string, you don\\'t need to return a size, since the \\'\\\\0\\' just tell everything. Besides, if you look at the java version of this function, you also don\\'t need to return a size because we can use numRows.length to get it , how cool is that. :)"
                    },
                    {
                        "username": "URBeautiful",
                        "content": "[@Rookie176](/Rookie176) whats the purpose of giving us the pointer *returnSize then?"
                    },
                    {
                        "username": "Rookie176",
                        "content": "Man I haven't finished reading your code but your first two lines are unnecessery, all you need to do is *returnSize = numRows, as for the correct code you can find it in my newest post solution, glad if I can be helpful:)"
                    }
                ]
            },
            {
                "id": 2049293,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048950,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048883,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048794,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048774,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048716,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048714,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048644,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048608,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048581,
                "content": [
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Could it be done with a Map-Reduce implementation ?\\nI was just thinking about losing some memory for the sake of CPU."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "it\\'s a fun question truely"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Easy just Sum it and store If you want solution check mine and dont forget to upvote :-)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Atleast the question that my mind picked up nicely...\\n\\nIf there\\'s hint provided by question and not visible to you, then i got you \\nFor $i$ cell in a row , check $i - 1$ and $i$ cells of previous row\\nProbably i may not need to mention about checking bounds of $i$ to fall under `0` to `n`"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "The entries of a pascal triangle are Binomial Coefficients, so if you are thinking of calculating them and inserting in the vector.... It will give TLE! \\nSo make use of DP :)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "A hint - notice how numbers in ```ith row``` can be clubbed to make ```ith power of 11```"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "found [this to have a good explanation](https://leetcode.com/problems/pascals-triangle/solutions/4016726/beats-100-drawing-with-simple-explanation/) with drawing "
                    },
                    {
                        "username": "VAINOI",
                        "content": "very ez"
                    },
                    {
                        "username": "Taranum_01",
                        "content": "Leetcode problem 1569 provides a practical context to explore and apply this concept effectively!"
                    },
                    {
                        "username": "whatdafunk",
                        "content": "This is fucking bullshit! The assumption is already that Class is needed. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is always the case if you are using an OOP language. LeetCode will include your Solution class in its compilation and call the appropriate method in that class."
                    }
                ]
            },
            {
                "id": 2048534,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 2048505,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 2048497,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 2048483,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 2043617,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 2034608,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 2024358,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 2018448,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 2012430,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 1994975,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "Already done! Just resubmit :)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "let\\'s go sptember."
                    },
                    {
                        "username": "ListowelAdolwin",
                        "content": "Yet another problem I have already solved. Guess I\\'ll just resubmit."
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "283 days streak, It\\'s 5.45 A.M, Hakuna Matata"
                    },
                    {
                        "username": "JoeySlomowitz",
                        "content": "I think this question can only be considered \"easy\" if you have a math background. (I don\\'t)\\n\\nThe first thing I did is learn about Pascal\\'s triangle.\\n\\nA few rabbit holes in, I started to understand that the math expression for Pascal\\'s triangle aims to resolve how many \"combinations\" are derived from each position in the triangle.\\n\\nFor the mathematical approach, we can use this example;\\nHow many ways can we choose 2 objects from a set of 5\\n(row 5, column 2)\\n\\nwhen you have the row and the column, and you know the formula and you understand factorials, then the answer can be found quite easily.\\n\\nI won\\'t post the formula here, but it can be found online quite easily."
                    },
                    {
                        "username": "psionl0",
                        "content": "You will quickly run into integer overflow errors for even small n and r  if you use the raw formula."
                    },
                    {
                        "username": "jeevaathecoder",
                        "content": "can anyone explain this answer?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was able to solve using two-pointer after a hint. Annoying problem "
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "hey I am getting signed integer overflow. how can I overcome it?\\n"
                    },
                    {
                        "username": "mudit_98",
                        "content": "BRUTE FORCE HINT:\\n\\nYOU NEED TWO LOOPS and may be more than 2 arrays.\\n\\nFor each column j th element, think how you can find its parent array left and right value.\\nWhere j will be less than  equal to i.\\nWhere parent array means, the row above the current row in pascal triangle.\\n\\n [hint image](https://imgur.com/a/XmjTJBb)\\n\\nImage Credit: NeetCode"
                    },
                    {
                        "username": "nishant_singh_",
                        "content": "I guess this question is marked as hard problem in GFG and it\\'s marked here Easy."
                    }
                ]
            },
            {
                "id": 1991931,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1980610,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1946131,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1928862,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1912786,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1858315,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1834220,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1821966,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1811472,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1795153,
                "content": [
                    {
                        "username": "MrxNoobie",
                        "content": "I dont know but we cant use bigIntegers in this problem! please someone help me fix it! Or you just can't use it?"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "First time doing this kind of problem, it was hard for me to think of the algorithm, but once I established that, it wasn\\'t that bad to implement"
                    },
                    {
                        "username": "RenniOG",
                        "content": "Correct me if I\\'m wrong, but is the fastest way to solve this not just to make a vector of the first 30 pascals triangle rows, and just return a vector with as many vectors as numRows? This question seems very silly."
                    },
                    {
                        "username": "lmholland",
                        "content": "I submitted that just to see what happened. One of the worst submitted in terms of run time."
                    },
                    {
                        "username": "meet08",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>> triangle;\\n\\n        for (int i = 0; i < numRows; i++) {\\n            vector<int> row(i + 1, 1);\\n\\n            for (int j = 1; j < i; j++) {\\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\\n            }\\n\\n            triangle.push_back(row);\\n        }\\n        return triangle;\\n    }\\n};"
                    },
                    {
                        "username": "Beerus6514",
                        "content": "//what is problem in my program\\n//only 13/30 test cases is running\\n\\nclass Solution {\\n\\n     int fact(int num){\\n        if(num==0){\\n            return 1;\\n        }\\n        return num * fact(num-1);\\n    }\\n  \\n    public List<List<Integer>> generate(int numRows) {\\n\\n          List<List<Integer>> l1 = new ArrayList<>(100);\\n          List<Integer> l2; \\n          int i=0;\\n          int j=0;\\n          for(i=0; i<numRows && numRows<=30; i++){\\n             l2= new ArrayList<>();\\n             for(j=0; j<=i; j++){\\n                \\n                int n = fact(i);\\n                int r = fact(j);\\n                int nr = fact(i-j);\\n                int result = n/(r * nr);\\n                l2.add(result);\\n                \\n            }\\n            l1.add(l2);\\n        }\\n        return l1;\\n    }\\n   \\n}"
                    },
                    {
                        "username": "Shukla_Yash",
                        "content": "sometimes i thought a approch that will defnetly work in the given problem . but when i started to code my approch i got a error my mind that how i write my approch in code .so any one tell me how i improve this ??"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "same happens to me "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        int n=numRows;\\n        vector<vector<int>>v(n);\\n         \\n         for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(j==0 || j==i){\\n                        v[i].push_back(1);\\n                    }\\n                    else{\\n                        v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n                    }\\n                }\\n            }\\n            return v;\\n         }\\n};"
                    },
                    {
                        "username": "Sherpa94",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for(int level = 0; level < numRows; level++){\\n            List<Integer> newLevel = new ArrayList<>();\\n            for(int l = 0; l <= level; l++){\\n                if(l ==0 || l == level){\\n                  newLevel.add(1);  \\n                }\\n                else{\\n                    List<Integer> prevlevel = result.get(level-1);\\n                    newLevel.add(prevlevel.get(l) + prevlevel.get(l-1));\\n                }\\n                \\n            }   \\n            result.add(newLevel);        \\n        }\\n        return result;\\n    }\\n}"
                    },
                    {
                        "username": "psionl0",
                        "content": "For C programmers, the returnColumnSizes array may be a little confusing.\\n\\nThe idea is that in a rectangular matrix, the number of columns is a constant meaning that each row is the same length. However, as problems like this show, we can have a matrix where each row has a different length. Hence, instead of a single variable, we need an array to store the lengths of each row which is misleading labeled \"returnColumnSizes\".\\n\\nIn short,\\nreturnSize = number of rows\\nreturnColumnSizes = array of row sizes."
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "Yeah, this comment is very helpful for anyone who is confused by this. I figured it out on my own, but when I did got really tempted to not bother and switch to other language. Why can\\'t we just dump the stuff into flat array like a reasonable person would? "
                    },
                    {
                        "username": "rishavm",
                        "content": "Solving this problem in arrays instead of lists, reduce time complexity.\\nI had used list to solve this problem solution took 1 ms to execute.\\nwhile i checked the solution which was solved in 0 ms. The solution was simply solved in arrays and result was returned by casting arrays into list.\\nSo, whosoever trying to solve this in minimal time.\\nApproach array to list method."
                    }
                ]
            },
            {
                "id": 1793500,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1773701,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1765151,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754494,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1754165,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753513,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1752680,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1752033,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1742658,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1740790,
                "content": [
                    {
                        "username": "yl_gai",
                        "content": "I found someone's Java solution works well, but don't know why. Please help explain if you know... He initiated `pascal` as  `int[][]`, and finally return `(List)Arrays.toList(pascal)` and it works.\n\nI think `Arrays.toList` will change `int[][]` to `List<int[]>`  right? But how does the casting make it to `List<List<Integer>>` then?  "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/118_Pascal\\'s_Triangle.cpp"
                    },
                    {
                        "username": "chirag2000",
                        "content": "Compilation Failed\\nIn file included from runner.cpp:9:0:\\nsolution.h: In function \\'std::vector > printPascal(int)\\':\\nsolution.h:13:12: error: could not convert \\'ans\\' from \\'std::vector >\\' to \\'std::vector >\\'\\n     return ans;\\n\\n\\n\\nAnyone please advice what is wrong here"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "//cpp solution (beats 100%)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int> >v(numRows);\\n        \\n        for(int i=0; i<numRows; i++){\\n            for(int j=0; j<=i; j++){\\n               if((j==0) || (j==i)){\\n                   v[i].push_back(1);\\n               }\\n               else{\\n                   v[i].push_back(v[i-1][j-1]+v[i-1][j]);\\n               }\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "pranjalnama",
                        "content": "Can anyone help me out i cant understand what\\'s the issue in this code i have written. It\\'s giving wrong output for numRows > 2.\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> l1 = new ArrayList<>();\\n        l1.add(1);\\n        list.add(l1);\\n        if(numRows==1){return list;}\\n        List<Integer> copy = new ArrayList<>();\\n        copy.add(1);\\n        copy.add(1);\\n        list.add(copy);\\n        int j=0;\\n        for(int i=2; i<numRows; i++){\\n            List<Integer> l = new ArrayList<>();\\n            j=0;\\n            l.add(1);\\n            while(j<copy.size()-1){\\n                l.add(copy.get(j)+copy.get(j+1));\\n                j++;\\n            }\\n            l.add(1);\\n            list.add(l);\\n            copy.clear();\\n            copy.addAll(l);\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/pascals-triangle-leet-code-118/"
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "God this took me way longer than it should have. I was trying to come up with all these mathematical relationships...and I didn\\'t need them at all."
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int n) {\\n       List<List<Integer>> a = new ArrayList<List<Integer>>();\\n        List<Integer>h = new ArrayList<Integer>(); \\n        h.add(1);\\n    a.add(h);\\n        if(n==1){ return a;\\n        }\\n        h= new ArrayList<>();\\n    h.add(1);\\n    h.add(1);\\n    a.add(h);\\nif(n==2){\\nreturn a;\\n  }\\n  for(int i=2;i<n;i++){\\n        h= new ArrayList<>();\\n    h.add(1);\\n      for(int j=0;j<i-1;j++){\\n          int x=a.get(i-1).get(j)+a.get(i-1).get(j+1);\\n          h.add(x);\\n      }\\nh.add(1);\\na.add(h);\\n  }\\n  return a;\\n       \\n\\n    }\\n}"
                    },
                    {
                        "username": "deadheaven007",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans(numRows);\\n        for(int i=0;i<numRows;i++){\\n            ans[i].resize(i+1,1);\\n        }\\n        for(int i=2;i<numRows;i++){\\n            for(int j=1;j<ans[i].size()-1;j++){\\n                ans[i][j]=ans[i-1][j-1]+ans[i-1][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1739198,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1730197,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1721580,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1720604,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1718183,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1715822,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1709125,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1707735,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1704115,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            },
            {
                "id": 1687827,
                "content": [
                    {
                        "username": "NarayanBhawar",
                        "content": "///With java\\nclass Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n\\n\\t\\tList<Integer> row= new ArrayList<>();\\n        List<List<Integer>> res = new ArrayList<>();\\n        row.add(1);\\n        res.add(row);\\n        if(numRows==1)\\n        return res;\\n\\n        row= new ArrayList<>();\\n        row.add(1);\\n        row.add(1);\\n        res.add(row);\\n        \\n        if(numRows==2)\\n        return res;\\n        \\n        for(int i=2;i<numRows;i++)\\n        {\\n        \\trow= new ArrayList<>();\\n        \\tList<Integer> previous = res.get(i-1);\\n\\n            //inserting 1st index with 1 \\n        \\trow.add(1);\\n        \\t\\n            //loop for sum \\n        \\tfor(int j=0;j<previous.size()-1;j++)\\n        \\t{\\n        \\t\\tint sum=previous.get(j)+previous.get(j+1);\\n        \\t\\trow.add(sum);\\n        \\t}\\n        \\t\\n            //inserting last index with 1\\n        \\trow.add(1);\\n        \\t\\n        \\t\\n        \\tres.add(row);\\n        }\\n      \\n   return res;        \\n    }\\n}"
                    },
                    {
                        "username": "vijayakumar7991",
                        "content": "Beats 71%  \\n\\nclass Solution(object):\\n    def generate(self, numRows, data=[[1], [1,1]]):\\n        \"\"\"\\n        :type numRows: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if numRows < len(data):\\n            return data[0:numRows]\\n        else:\\n            temp = [1]\\n            last_data = data[len(data)-1]\\n            for x in range(0, len(last_data)-1):\\n                temp.append(last_data[x]+last_data[x+1])\\n            temp += [1]\\n            data.append(temp)\\n            return self.generate(numRows, data)"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best explanation for the problem\\n\\nhttps://www.youtube.com/watch?v=gUnE87SXUk0"
                    },
                    {
                        "username": "mijung007",
                        "content": "In Python and not in LeetCode, how do i invoke the generate function?  i get an error when i do this:\\n\\nx=Solution\\nx.generate(4)"
                    },
                    {
                        "username": "sonicsplasher",
                        "content": "Solution()*"
                    },
                    {
                        "username": "hrishabh2002",
                        "content": "Beats 100% solution\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>ans;\\n        vector<int>prev;\\n\\n        int n=1;\\n        while(n<=numRows){\\n            vector<int>out;\\n            int i=0;\\n           while(i<n){\\n               if(i==0||i==n-1)\\n               out.push_back(1);\\n               else\\n               out.push_back(prev[i-1]+prev[i]);\\n\\n               i++;\\n           }\\n         \\n         prev=out;\\n         ans.push_back(out);\\n         n++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mijung007",
                        "content": "class Solution:\n    def generate(self, numRows: int):\n        n=numRows\n        if n==1:\n       some codes.......\n..........\n..............\n \nwhen i run try to run like this:\nx=Solution\nx.generate(4)         \n  i get this error:\n\nTraceback (most recent call last):\n  File \"/Users/andrewlee/docker/sum.py\", line 39, in <module>\n    x.generate(4)\nTypeError: generate() missing 1 required positional argument: 'numRows'\n\nwhy?"
                    },
                    {
                        "username": "dev_heman",
                        "content": "Well  you don\\'t need to run code here. You just need to define the function here. The execution part is handled by leetcode"
                    },
                    {
                        "username": "rmznkrc",
                        "content": "Easy Understanding || Java \n\n `Easy Understanding || Java `\n\nclass Solution { \n  public List<List<Integer>> generate(int numRows) {\n       \n       List<List<Integer>> triangle=new ArrayList();\n        List<Integer> firstRow=new ArrayList();\n         firstRow.add(1);\n         triangle.add(firstRow);\n        if(numRows==0) return triangle;\n        for(int i=1;i<numRows;i++){\n        List<Integer>prev=triangle.get(i-1);\n        List<Integer>row=new ArrayList();\n        row.add(1);\n    \n        for(int j=1;j<i;j++){\n            row.add(prev.get(j-1)+prev.get(j));\n        }\n        row.add(1);\n        triangle.add(row);\n        }\n        return triangle;\n    }\n}\n\n\n\n\n"
                    },
                    {
                        "username": "mehdiwadiwala1",
                        "content": "class Solution {\\n    public List<List<Integer>> generate(int numRows) {\\n         List<List<Integer>> triangle = new ArrayList<>();\\n        \\n        List<Integer> row1 = new ArrayList<>();\\n        row1.add(1);\\n        triangle.add(row1);\\n        \\n        for(int i=1;i<numRows;i++){\\n            List<Integer> prev_row= triangle.get(i-1);\\n            List<Integer> row= new ArrayList<>();\\n            \\n            row.add(1);\\n            \\n            for(int j=1;j<i;j++){\\n                row.add(prev_row.get(j-1)+prev_row.get(j));\\n            }\\n            row.add(1);\\n            triangle.add(row);\\n        }\\n        return triangle;\\n    }\\n};\\n\\nSolution code for java"
                    },
                    {
                        "username": "Bharat2044",
                        "content": "vector<vector<int>> generate(int n) {\\n        vector<vector<int>> v;\\n        for(int r=1;r<=n;r++){\\n            int num=1;\\n            vector<int>t;\\n            for(int c=1;c<=r;c++){\\n                t.push_back(num);\\n                num=num*(r-c)/c;\\n            }\\n            v.push_back(t);\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON | APPLE SDE-1 INTERVIEW SIMPLE OPTIMIZED SOLN.\nhttps://leetcode.com/problems/pascals-triangle/solutions/2364881/amazon-apple-sde-1-interview-simple-optimized-soln/\n\n\n# #STRIVER \n# #Take You Forward"
                    }
                ]
            }
        ]
    }
]