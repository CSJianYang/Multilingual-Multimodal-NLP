[
    {
        "title": "Recover the Original Array",
        "question_content": "Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner:\n\n\tlower[i] = arr[i] - k, for every index i where 0 <= i < n\n\thigher[i] = arr[i] + k, for every index i where 0 <= i < n\n\nUnfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array.\nGiven an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array.\nNote: The test cases are generated such that there exists at least one valid array arr.\n&nbsp;\nExample 1:\n\nInput: nums = [2,10,6,4,8,12]\nOutput: [3,7,11]\nExplanation:\nIf arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12].\nCombining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums.\nAnother valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. \n\nExample 2:\n\nInput: nums = [1,1,3,3]\nOutput: [2,2]\nExplanation:\nIf arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3].\nCombining lower and higher gives us [1,1,3,3], which is equal to nums.\nNote that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0.\nThis is invalid since k must be positive.\n\nExample 3:\n\nInput: nums = [5,435]\nOutput: [220]\nExplanation:\nThe only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435].\n\n&nbsp;\nConstraints:\n\n\t2 * n == nums.length\n\t1 <= n <= 1000\n\t1 <= nums[i] <= 109\n\tThe test cases are generated such that there exists at least one valid array arr.",
        "solutions": [
            {
                "id": 1647452,
                "title": "python-short-solution-explained",
                "content": "Notice, that what we have in the end is sum array `X` and array `X + 2k`. It seems very familiar and you can use the greedy idea of 954. Array of Doubled Pairs, but now pairs are not doubled but with constant difference. How to find difference? It can be one of `n-1` numbers: `a1 - a0, a2 - a0, ...`. Also we need to make sure that difference is positive and can be divided by `2`.\\n\\n#### Complexity\\nTime complexity is `O(n^2)`, space is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def recoverArray(self, nums):\\n        def check(nums, k):\\n            cnt, ans = Counter(nums), []\\n            for num in nums:\\n                if cnt[num] == 0: continue\\n                if cnt[num + k] == 0: return False, []\\n                cnt[num] -= 1\\n                cnt[num + k] -= 1\\n                ans += [num + k//2]\\n            return True, ans\\n            \\n        nums = sorted(nums)\\n        n = len(nums)\\n        for i in range(1, n):\\n            k = nums[i] - nums[0]\\n            if k != 0 and k % 2 == 0:\\n                a, b = check(nums, k)\\n                if a: return b\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def recoverArray(self, nums):\\n        def check(nums, k):\\n            cnt, ans = Counter(nums), []\\n            for num in nums:\\n                if cnt[num] == 0: continue\\n                if cnt[num + k] == 0: return False, []\\n                cnt[num] -= 1\\n                cnt[num + k] -= 1\\n                ans += [num + k//2]\\n            return True, ans\\n            \\n        nums = sorted(nums)\\n        n = len(nums)\\n        for i in range(1, n):\\n            k = nums[i] - nums[0]\\n            if k != 0 and k % 2 == 0:\\n                a, b = check(nums, k)\\n                if a: return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647743,
                "title": "100-50ms-without-map",
                "content": "First sort the nums array,  nums[0] belong to low array. \\nTry every possible diff in array, and diff must be even. k = diff / 2;\\nEach element in low array (v) should have its equivalent in  high arrray (v + k + k). \\nMaintain a pointer for the last element in low array that haven\\'t found its equalient in high array yet, \\n1 If pointer is valid and next element\\'s value is pointer\\'s value + k + k, then next element is the in high array. pointer++;\\n2 Otherwise next element is in low array.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n2 = nums.size();\\n        n = n2/2;\\n        int a = nums[0];\\n        vector<int> v1, v2, ans;\\n        v1.reserve(n);v2.reserve(n);\\n        for (int i = 1; i < n2; i++)\\n        {\\n            int k = nums[i] - a;\\n            if (k % 2 == 1 || k == 0 || nums[i] == nums[i - 1]) continue;       \\n            v1.clear();v2.clear();\\n            v1.push_back(a);\\n            int x = 0;\\n            for (int j = 1; j < n2; j++)\\n            {\\n                if (x < v1.size() && (nums[j] == v1[x] + k)) {\\n                    v2.push_back(nums[j]);\\n                    x++;\\n                } else  v1.push_back(nums[j]);\\n            \\n                if (v1.size() > n || v2.size() > n) break;\\n            }\\n            if (v1.size() != n || v2.size() != n) continue;\\n            for (int i = 0; i < n; i++) ans.push_back((v1[i] + v2[i]) / 2);\\n            return ans;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n2 = nums.size();\\n        n = n2/2;\\n        int a = nums[0];\\n        vector<int> v1, v2, ans;\\n        v1.reserve(n);v2.reserve(n);\\n        for (int i = 1; i < n2; i++)\\n        {\\n            int k = nums[i] - a;\\n            if (k % 2 == 1 || k == 0 || nums[i] == nums[i - 1]) continue;       \\n            v1.clear();v2.clear();\\n            v1.push_back(a);\\n            int x = 0;\\n            for (int j = 1; j < n2; j++)\\n            {\\n                if (x < v1.size() && (nums[j] == v1[x] + k)) {\\n                    v2.push_back(nums[j]);\\n                    x++;\\n                } else  v1.push_back(nums[j]);\\n            \\n                if (v1.size() > n || v2.size() > n) break;\\n            }\\n            if (v1.size() != n || v2.size() != n) continue;\\n            for (int i = 0; i < n; i++) ans.push_back((v1[i] + v2[i]) / 2);\\n            return ans;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647487,
                "title": "try-possible-k",
                "content": "The smallest element in `nums` must be in the lower array. If we sort the array, our `k` can be `(nums[i] - nums[0]) / 2`.\\n\\nFor each such `k`, we try to match all pairs, going from smallest to larger and removing pairs. If we match all pairs, we return the original array.\\n\\n**C++**\\n```cpp\\nvector<int> recoverArray(vector<int>& nums) {\\n    multiset<int> s(begin(nums), end(nums));\\n    int start = *begin(s);\\n    for (auto it = next(begin(s)); it != end(s); ++it) {\\n        int k = (*it - start) / 2;\\n        if (k > 0 && start + 2 * k == *it) {\\n            vector<int> res;\\n            auto ss = s;\\n            while(!ss.empty()) {\\n                auto it_h = ss.find(*begin(ss) + 2 * k);\\n                if (it_h == end(ss))\\n                    break;\\n                res.push_back(*begin(ss) + k);\\n                ss.erase(begin(ss));\\n                ss.erase(it_h);\\n            }\\n            if (ss.empty())\\n                return res;\\n        }\\n    }\\n    return {};\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> recoverArray(vector<int>& nums) {\\n    multiset<int> s(begin(nums), end(nums));\\n    int start = *begin(s);\\n    for (auto it = next(begin(s)); it != end(s); ++it) {\\n        int k = (*it - start) / 2;\\n        if (k > 0 && start + 2 * k == *it) {\\n            vector<int> res;\\n            auto ss = s;\\n            while(!ss.empty()) {\\n                auto it_h = ss.find(*begin(ss) + 2 * k);\\n                if (it_h == end(ss))\\n                    break;\\n                res.push_back(*begin(ss) + k);\\n                ss.erase(begin(ss));\\n                ss.erase(it_h);\\n            }\\n            if (ss.empty())\\n                return res;\\n        }\\n    }\\n    return {};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647758,
                "title": "easy-to-understand-explanation-with-c-code-multiset-tle-why",
                "content": "Question Summary - There is an array arr. You created two different arrays, say Low and High. Low contains all the elements of arr but all the elements are decremented by a positive no k. Same as Low, High contains all the elements of arr but they are incremented by k. You are given an array which contains all the elements of Low and High array(with duplicates). You need to construct the original array.\\n\\nApproach:\\n\\nAs the size of given array was at max 10^3, we can construct a O(n^2) algo and it will do the job. \\nNow first we sort the given array. \\n\\nIf we can get the value of k by any means then the original array can be reconstructed.\\nHow?\\nWe take all the element of given array in a multiset. Now the smallest element of multiset will always be in the form of X-k, where X is a element of our original array. \\nNow since we have X, we can search X+k in our multiset and if it is present, we can remove these both elements and add X to the ans vector. Futher we continue the same algo until the size of multiset is greater than 0.\\n\\nNow how can we get k?\\nSay the smallest element of the original array be Y. If we have sorted our array then the element at 0 index will be Y-k.\\nNow if we can find Y+k in the given array, then by adding these values we can get 2*Y and thus we can also get value of k.\\nSince Y+k can be any value of the array, we will iterate entire array and consider every index from 1 to n-1 as Y+k.\\n\\nNote: Some multiset solutions are giving TLE because some test cases were added recently. It all boils down to reducing number of operations. I reduced operations by passing multiset by reference and hence it is giving Accepted verdict.\\n\\nC++ Code:\\n```\\ntypedef long long ll;\\ntypedef long double ld;\\n#define mod 1000000007\\n#define F first\\n#define S second\\n#define all(x) begin(x),end(x)\\n\\nclass Solution {\\npublic:\\n\\tvector<int> canMakeIt(multiset<int>& st, int k) {\\n\\t\\tif (k <= 0)\\n\\t\\t\\treturn { -1};\\n\\t\\tmultiset<int> erased;\\n\\t\\tvector<int> ans;\\n\\t\\twhile (st.size() > 0) {\\n\\t\\t\\tauto it = st.begin();\\n\\t\\t\\tint val = *it;\\n\\t\\t\\tint org = val + k;\\n\\t\\t\\tst.erase(st.find(val));\\n            erased.insert(val);\\n\\t\\t\\tif (st.find(org + k) != st.end()) {\\n\\t\\t\\t\\tans.push_back(org);\\n\\t\\t\\t\\tst.erase(st.find(org + k));\\n\\t\\t\\t\\terased.insert(org + k);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int x:erased)\\n\\t\\t\\t\\t\\tst.insert(x);\\n\\t\\t\\t\\treturn { -1};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvector<int> recoverArray(vector<int>& nums) {\\n\\t\\tsort(all(nums));\\n\\t\\tmultiset<int> st(all(nums));\\n\\t\\tint smallest = nums[0];\\n\\t\\tfor (int j = 1; j < nums.size(); ++j) {\\n\\t\\t\\tint addi = smallest + nums[j];\\n\\t\\t\\tif (addi % 2 == 0) {\\n\\t\\t\\t\\tint org = addi / 2;\\n\\t\\t\\t\\tint k = nums[j] - org;\\n\\t\\t\\t\\tvector<int> ans = canMakeIt(st, k);\\n\\t\\t\\t\\tif (ans[0] != -1)\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn { -1};\\n\\t}\\n};\\n```\\nTIme complexity will be O(n^2logn) as I am using multiset.\\nIf you have any doubts, you can ask in the comment section.\\nIf you found this post helpful consider upvoting so that others can also undestand this question.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\ntypedef long double ld;\\n#define mod 1000000007\\n#define F first\\n#define S second\\n#define all(x) begin(x),end(x)\\n\\nclass Solution {\\npublic:\\n\\tvector<int> canMakeIt(multiset<int>& st, int k) {\\n\\t\\tif (k <= 0)\\n\\t\\t\\treturn { -1};\\n\\t\\tmultiset<int> erased;\\n\\t\\tvector<int> ans;\\n\\t\\twhile (st.size() > 0) {\\n\\t\\t\\tauto it = st.begin();\\n\\t\\t\\tint val = *it;\\n\\t\\t\\tint org = val + k;\\n\\t\\t\\tst.erase(st.find(val));\\n            erased.insert(val);\\n\\t\\t\\tif (st.find(org + k) != st.end()) {\\n\\t\\t\\t\\tans.push_back(org);\\n\\t\\t\\t\\tst.erase(st.find(org + k));\\n\\t\\t\\t\\terased.insert(org + k);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int x:erased)\\n\\t\\t\\t\\t\\tst.insert(x);\\n\\t\\t\\t\\treturn { -1};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvector<int> recoverArray(vector<int>& nums) {\\n\\t\\tsort(all(nums));\\n\\t\\tmultiset<int> st(all(nums));\\n\\t\\tint smallest = nums[0];\\n\\t\\tfor (int j = 1; j < nums.size(); ++j) {\\n\\t\\t\\tint addi = smallest + nums[j];\\n\\t\\t\\tif (addi % 2 == 0) {\\n\\t\\t\\t\\tint org = addi / 2;\\n\\t\\t\\t\\tint k = nums[j] - org;\\n\\t\\t\\t\\tvector<int> ans = canMakeIt(st, k);\\n\\t\\t\\t\\tif (ans[0] != -1)\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn { -1};\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647663,
                "title": "java-clean",
                "content": "from N = 1000, we know we can try something similar to O(n2)\\nwe find out K is actually a limited number, it would be the difference between first element with all the rest number, one by one, when we have this list of k, we can try them one by one.\\n\\nwhen we have a possible k to guess, we will see if both low (nums[i]) and high (nums[i] + 2 * k) exist, and we increase counter by 1 (here in code has use tmp array), if counter is N / 2 in the end, we will conclue that we find one possible answer.\\n\\n```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        int N = nums.length;\\n        Arrays.sort(nums);\\n        List<Integer> diffList = new ArrayList<>();\\n        for (int i = 1; i < N; i++) {\\n            int diff = Math.abs(nums[i] - nums[0]);\\n            if (diff % 2 == 0 && diff > 0) diffList.add(diff / 2);\\n        }\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < N; i++)\\n            map1.put(nums[i], map1.getOrDefault(nums[i], 0) + 1);\\n        for (int diff : diffList) {\\n            Map<Integer, Integer> map = new HashMap<>(map1);\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int i = 0; i < N; i++) {\\n\\t\\t\\t    if (tmp.size() == N / 2) break;\\n                int low = nums[i];\\n                int high = low + 2 * diff;\\n                if (map.containsKey(low) && map.containsKey(high)) {\\n                    tmp.add(low + diff);\\n                    map.put(low, map.get(low) - 1); \\n                    map.put(high, map.get(high) - 1);\\n                    if (map.get(low) == 0) map.remove(low);\\n                    if (map.get(high) == 0) map.remove(high);\\n                }\\n            }\\n            if (tmp.size() == N / 2) return tmp.stream().mapToInt(i -> i).toArray();\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        int N = nums.length;\\n        Arrays.sort(nums);\\n        List<Integer> diffList = new ArrayList<>();\\n        for (int i = 1; i < N; i++) {\\n            int diff = Math.abs(nums[i] - nums[0]);\\n            if (diff % 2 == 0 && diff > 0) diffList.add(diff / 2);\\n        }\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < N; i++)\\n            map1.put(nums[i], map1.getOrDefault(nums[i], 0) + 1);\\n        for (int diff : diffList) {\\n            Map<Integer, Integer> map = new HashMap<>(map1);\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int i = 0; i < N; i++) {\\n\\t\\t\\t    if (tmp.size() == N / 2) break;\\n                int low = nums[i];\\n                int high = low + 2 * diff;\\n                if (map.containsKey(low) && map.containsKey(high)) {\\n                    tmp.add(low + diff);\\n                    map.put(low, map.get(low) - 1); \\n                    map.put(high, map.get(high) - 1);\\n                    if (map.get(low) == 0) map.remove(low);\\n                    if (map.get(high) == 0) map.remove(high);\\n                }\\n            }\\n            if (tmp.size() == N / 2) return tmp.stream().mapToInt(i -> i).toArray();\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648815,
                "title": "python-simple-o-n-2-solution-detailed-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n`The time complexity is O(N^2)`\\n\\n```\\nclass Solution(object):\\n    def recoverArray(self, nums):\\n        nums.sort()\\n        mid = len(nums) // 2\\n        # All possible k are (nums[j] - nums[0]) // 2, otherwise there is no num that satisfies nums[0] + k = num - k.\\n        # For nums is sorted, so that any 2 elements (x, y) in nums[1:j] cannot satisfy x + k = y - k.\\n        # In other words, for any x in nums[1:j], it needs to find y from nums[j + 1:] to satisfy x + k = y - k, but\\n        # unfortunately if j > mid, then len(nums[j + 1:]) < mid <= len(nums[1:j]), nums[j + 1:] are not enough.\\n        # The conclusion is j <= mid.\\n\\t\\t# If you think it\\u2019s not easy to understand why mid is enough, len(nums) can also work well\\n\\t\\t# for j in range(1, len(nums)):  \\n        for j in range(1, mid + 1):  # O(N)\\n            if nums[j] - nums[0] > 0 and (nums[j] - nums[0]) % 2 == 0:  # Note the problem described k is positive.\\n                k, counter, ans = (nums[j] - nums[0]) // 2, collections.Counter(nums), []\\n                # For each number in lower, we try to find the corresponding number from higher list.\\n                # Because nums is sorted, current n is always the current lowest num which can only come from lower\\n                # list, so we search the corresponding number of n which equals to n + 2 * k in the left\\n                # if it can not be found, change another k and continue to try.\\n                for n in nums:  # check if n + 2 * k available as corresponding number in higher list of n\\n                    if counter[n] == 0:  # removed by previous num as its corresponding number in higher list\\n                        continue\\n                    if counter[n + 2 * k] == 0:  # not found corresponding number in higher list\\n                        break\\n                    ans.append(n + k)\\n                    counter[n] -= 1  # remove n\\n                    counter[n + 2 * k] -= 1  # remove the corresponding number in higher list\\n                if len(ans) == mid:\\n                    return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverArray(self, nums):\\n        nums.sort()\\n        mid = len(nums) // 2\\n        # All possible k are (nums[j] - nums[0]) // 2, otherwise there is no num that satisfies nums[0] + k = num - k.\\n        # For nums is sorted, so that any 2 elements (x, y) in nums[1:j] cannot satisfy x + k = y - k.\\n        # In other words, for any x in nums[1:j], it needs to find y from nums[j + 1:] to satisfy x + k = y - k, but\\n        # unfortunately if j > mid, then len(nums[j + 1:]) < mid <= len(nums[1:j]), nums[j + 1:] are not enough.\\n        # The conclusion is j <= mid.\\n\\t\\t# If you think it\\u2019s not easy to understand why mid is enough, len(nums) can also work well\\n\\t\\t# for j in range(1, len(nums)):  \\n        for j in range(1, mid + 1):  # O(N)\\n            if nums[j] - nums[0] > 0 and (nums[j] - nums[0]) % 2 == 0:  # Note the problem described k is positive.\\n                k, counter, ans = (nums[j] - nums[0]) // 2, collections.Counter(nums), []\\n                # For each number in lower, we try to find the corresponding number from higher list.\\n                # Because nums is sorted, current n is always the current lowest num which can only come from lower\\n                # list, so we search the corresponding number of n which equals to n + 2 * k in the left\\n                # if it can not be found, change another k and continue to try.\\n                for n in nums:  # check if n + 2 * k available as corresponding number in higher list of n\\n                    if counter[n] == 0:  # removed by previous num as its corresponding number in higher list\\n                        continue\\n                    if counter[n + 2 * k] == 0:  # not found corresponding number in higher list\\n                        break\\n                    ans.append(n + k)\\n                    counter[n] -= 1  # remove n\\n                    counter[n + 2 * k] -= 1  # remove the corresponding number in higher list\\n                if len(ans) == mid:\\n                    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648288,
                "title": "c-very-easy-solution",
                "content": "## Approach\\n\\nThe idea is very simple, we know the minimum element in the permutation belongs to lower and maximum element belongs to higher. So , we\\'ll push minimum element in our ans array, then for each remaining element we\\'ll try it to make first element of b and find k as\\n\\n\\t\\t\\t\\t\\t\\t\\t\\thigher[i] - lower[i] = arr[i] + k - (arr[i] - k) = 2*k\\n\\nusing this we can find possible values of k and check if we can form the array using this value of k.\\n\\n\\n## Code\\n\\n```\\nvector<int> recoverArray(vector<int>& nums) {\\n        \\n\\t\\t//sorting the nums array\\n        sort(nums.begin(),nums.end());\\n        \\n\\t\\t//we\\'ll try every nums[i] as first element of higher array excpet nums[0]\\n\\t\\t//as it is first element of lower\\n        for(int i=1;i<size(nums);i++)\\n        {\\n            vector<int> a;\\n\\t\\t\\t//pushing minimum element in lowest\\n            a.push_back(nums[0]);\\n\\t\\t\\t\\n\\t\\t\\t//calculating k after assuming nums[i] as first element of higher\\n            int k = nums[i] - a.back();\\n            \\n\\t\\t\\t//in case k is odd or k = 0, skip !\\n            if(k&1 || k == 0) continue;\\n            \\n            multiset<int> st(nums.begin(),nums.end());\\n\\t\\t\\t\\n\\t\\t\\t//delete used elements ,ie, nums[0] and nums[i]\\n            st.erase(st.find(a.back())) , st.erase(st.find(nums[i]));\\n\\t\\t\\t\\n            while(!st.empty())\\n            {\\n                // now current minimum value will be part of lower array, so pushing it to a\\n\\t\\t\\t\\t// and deleting from multiset\\n                a.push_back(*st.begin());\\n                st.erase(st.begin());\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//now corresponding element in higher should be\\n\\t\\t\\t\\t// last pushed element in lower + current k\\n                auto it = st.find(a.back() + k);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if we cann\\'t find corresponding element in higher, we\\'ll break the loop\\n                if(it == st.end()) break;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//else delete it from multiset\\n                st.erase(it);\\n            }\\n            \\n\\t\\t\\t//now if our multiset is empty, ie , we have used all the elements then\\n\\t\\t\\t// it is clear that current value of k is the right choice\\n\\t\\t\\t// increment every value of lower by k/2 as higher[i] - lower[i] = 2*k\\n\\t\\t\\t// and we need to add k to lower[i] to make current array\\n            if(st.empty())\\n            {\\n                for(auto &val : a) val += k/2;\\n                // cout<<\"\\\\n\";\\n                return a;\\n            }\\n            \\n        }\\n        \\n        assert(false);\\n        \\n    }\\n```\\n\\n**Time Complexity :** O(nlogn + n^2)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> recoverArray(vector<int>& nums) {\\n        \\n\\t\\t//sorting the nums array\\n        sort(nums.begin(),nums.end());\\n        \\n\\t\\t//we\\'ll try every nums[i] as first element of higher array excpet nums[0]\\n\\t\\t//as it is first element of lower\\n        for(int i=1;i<size(nums);i++)\\n        {\\n            vector<int> a;\\n\\t\\t\\t//pushing minimum element in lowest\\n            a.push_back(nums[0]);\\n\\t\\t\\t\\n\\t\\t\\t//calculating k after assuming nums[i] as first element of higher\\n            int k = nums[i] - a.back();\\n            \\n\\t\\t\\t//in case k is odd or k = 0, skip !\\n            if(k&1 || k == 0) continue;\\n            \\n            multiset<int> st(nums.begin(),nums.end());\\n\\t\\t\\t\\n\\t\\t\\t//delete used elements ,ie, nums[0] and nums[i]\\n            st.erase(st.find(a.back())) , st.erase(st.find(nums[i]));\\n\\t\\t\\t\\n            while(!st.empty())\\n            {\\n                // now current minimum value will be part of lower array, so pushing it to a\\n\\t\\t\\t\\t// and deleting from multiset\\n                a.push_back(*st.begin());\\n                st.erase(st.begin());\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//now corresponding element in higher should be\\n\\t\\t\\t\\t// last pushed element in lower + current k\\n                auto it = st.find(a.back() + k);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if we cann\\'t find corresponding element in higher, we\\'ll break the loop\\n                if(it == st.end()) break;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//else delete it from multiset\\n                st.erase(it);\\n            }\\n            \\n\\t\\t\\t//now if our multiset is empty, ie , we have used all the elements then\\n\\t\\t\\t// it is clear that current value of k is the right choice\\n\\t\\t\\t// increment every value of lower by k/2 as higher[i] - lower[i] = 2*k\\n\\t\\t\\t// and we need to add k to lower[i] to make current array\\n            if(st.empty())\\n            {\\n                for(auto &val : a) val += k/2;\\n                // cout<<\"\\\\n\";\\n                return a;\\n            }\\n            \\n        }\\n        \\n        assert(false);\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1649026,
                "title": "detailed-explanation-binary-search-c-java",
                "content": "*Read the whole post and solution code to get clear understanding.*\\n\\n**Question explanation :**\\nAlice has array nums with n elements which is not given us. He chooses a **positive** integer **k** and created two new array of **same size** from the array he has\\n1.) **lower array**\\n2.) **higher array**\\n\\nfor each **i** to n:\\n\\nlower[i]  = **nums[i] - k**; \\nhigher[i] = **nums[i] + k**;\\n\\n* we neither given nums nor lower and higher array but \\n* we are given an array of size 2n which is **combination** of elements of array **lower** and **higher**\\n* here elements are arranged **randomly** we not know which element belongs which array (lower or higher)\\n* we have to create an array Alice has.\\n\\n**Solution Explaination:**\\n\\n* For any valid k value we take lower[i] element and search for their higher[i]  in nums\\n*  such that lower[i] =  higher[i] + 2*k   explain below\\n\\nI would like to explain you with example \\n\\n   ```nums =  [11, 6, 3, 4, 8, 7, 8, 7, 9, 8, 9, 10, 10, 2, 1, 9] n = 16```\\n\\n* since k is subtracting and adding from each nums[i] to create lower and higher array respectively.\\n* k is same for all so the smallest value belongs to the lower array.\\n\\nfirstly we sort the given array so it becomes\\n\\t\\t\\t```[1, 2, 3, 4, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11]```\\n\\n***Little Maths Equations***\\n```\\t\\t\\t    \\t\\t\\t\\nlower[i] =   nums[i] - k\\t\\t (given in ques)                 \\nnums[i]  =  lower[i] + k        ....1)       \\t   \\n \\nhigher[i] =  nums[i]  + k        (given in ques)\\nnums[i]  =   higher[i] - k      ....2)   \\n\\nusing 1 and  2\\n  lower[i] + k     =  higher[i] - k\\n  lower[i] + 2k    =  higher[i]   \\n  \\n``` \\n ***higher[i] = lower[i] + 2k***   // so we  can say that for every higher **there is a match** in lower or vice versa.\\n  \\n we use above equation to find the match with every lower\\n\\n```\\nalso for getting k value\\nk = (higher[i] - lower[i])/2  (using above equation)\\n```\\n\\n**Instead** of trying for every possible value we only need to try with **smallest** element to find a **valid k** value. (since **at** **least** one ans possible)\\n\\nSo lets **dry** run the above example \\n     ```nums[] =  [1, 2, 3, 4, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11]```\\n\\n **smallest**  = nums[0] = 1\\n ``` \\n   k = (nums[i] - smallest)/2\\n```\\n  for **checking** valid k \\n ```        we check  if k>0 && smallest + 2*k == nums[i] ```\\n\\nfrom **each** index  i = 1 to n in nums:\\n```\\ni= 1:\\n\\n\\t\\t\\t nums[i] = 2\\n\\t\\t\\t k = (2 - 1)/2;\\n\\t\\t\\t k = 0 (not valid); \\n\\n\\ni = 2:\\n\\n\\t\\t\\t nums[i] = 3\\n\\t\\t\\t k = (3-1)/2;\\n\\t\\t\\t k = 1 (valid)\\n```\\t\\t \\n **Now we try to find match of every lower with higher**\\n\\nfor **each** i = 0 to n in nums \\n\\n\\t\\ttarget = nums[i] + 2*k;  // we search  target value in nums (since for every lower there is a match in higher if we find valid k)\\n\\t\\tans =  [] \\n\\n\\ti= 0:\\n\\t\\tnums[i] =1\\n\\n\\t\\t\\ttarget =  1 + 2*1 = 3 (present in nums[2] mark as visited)\\n\\t\\t\\tpush (nums[i] + k) in ans array\\n\\n\\t\\t\\tnums[i] + k = 2\\n\\t\\t\\tans = [2]\\n\\n\\ti= 1: \\n\\t\\tnums[i] =2\\n\\n\\t\\t\\ttarget =  2 + 2*1 = 4 (present in nums[3] mark as visited)\\n\\t\\t\\tpush (nums[i] + k) in ans array\\n\\n\\t\\t\\tnums[i] + k =3\\n\\t\\t\\tans = [2,3]\\n\\n\\ti= 2:\\n\\t\\t   nums[i] = 3  (already visited (matched with index 0) so  skip it\\n\\n\\ti= 3:\\n\\t\\t\\tnums[i] = 4 (already visited (matched with index 1) so  skip it\\n\\n\\ti= 4:\\n\\t\\t\\tnums[i] = 6\\n\\n\\t\\t\\ttarget =  6 + 2*1 = 8 (present in nums[7] mark as visited)\\n\\t\\t\\tNote : here we find multiple 8 but we start from the leftmost.\\n\\n\\t\\t\\tpush (nums[i] + k ) in ans array\\n\\n\\t\\t\\tnums[i] + k = 7;\\n\\t\\t\\tans = [2,3,7]\\n\\n\\ti= 5:\\n\\t\\tnums[i] = 7\\n\\n\\t\\t\\ttarget =  7 + 2*1 = 9 (present in nums[10] mark as visited)\\n\\t\\t\\tagain we find multiple value equals to target but start from the leftmost\\n\\n\\t\\t\\tpush (nums[i] + k) in ans array\\n\\n\\t\\t\\tnums[i] + k = 8\\n\\t\\t\\tans = [2,3,7,8]\\n\\n\\ti= 6:\\n\\t\\tnums[i] = 7\\n\\n\\t\\t\\ttarget =  7 + 2*1 = 9 (present in nums[11] mark as visited)\\n\\t\\t\\tpush (nums[i] + k) in ans array\\n\\n\\t\\t\\tnums[i] + k = 8\\n\\t\\t\\tans = [2,3,7,8,8]\\n\\n\\ti=7:\\n\\t\\t\\tnums[i] = 8 (already visited (matched with index 4) so  skip it\\n\\n\\n\\ti=8:\\n\\t\\tnums[i] = 8\\n\\n\\t\\t\\ttarget =  8 + 2*1 = 10 (present in nums[13] mark as visited)\\n\\t\\t\\tpush (nums[i] + k) in ans array\\n\\n\\t\\t\\tnums[i] + k = 9\\n\\t\\t\\tans = [2,3,7,8,8,9]\\n\\n\\ti=9:\\n\\t\\tnums[i] = 8\\n\\n\\t\\t\\ttarget =  8 + 2*1 = 10 (present in nums[14] mark as visited)\\n\\t\\t\\tpush (nums[i] + k which 9) in ans array\\n\\n\\t\\t\\tnums[i] + k = 9\\n\\t\\t\\tans = [2,3,7,8,8,9,9]\\n\\n\\ti=10:\\n\\t\\t\\tnums[i] = 9 (already visited (matched with index 5) so  skip it\\n\\n\\ti=11:\\n\\t\\t\\tnums[i] = 9 (already visited (matched with index 6) so  skip it\\n\\n\\ti=12:\\n\\t\\tnums[i] = 9\\n\\n\\t\\t\\ttarget =  9 + 2*1 = 11 (present in nums[15] mark as visited)\\n\\t\\t\\tpush (nums[i] + k) in ans array\\n\\n\\t\\t\\tnums[i] + k = 10\\n\\t\\t\\tans = [2,3,7,8,8,9,9,10]\\n\\n\\n\\ti = 13,14 15   \\n\\t\\t\\t\\t\\talready visited so skip it\\n\\n\\t\\tans = [2,3,7,8,8,9,9,10] // bingo  our ans array size equals to n/2  hence we found a valid array.\\n\\t\\t\\n\\n***Solution Code :-***\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int search(vector<int> &nums, vector<bool> visit, int low, int high, int target)\\n    {\\n        int index = -1;\\n\\n        while (low <= high)\\n        {\\n\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target)\\n            {\\n                if (visit[mid])\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    index = mid;  \\n                    high = mid - 1; \\n                }\\n\\n                continue;\\n            }\\n\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n\\n        return index;\\n    }\\n\\n    vector<int> recoverArray(vector<int> &nums)\\n    {\\n\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int smallest = nums[0];\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n\\n            int k = (nums[i] - smallest) / 2; \\n            if (k <= 0 || smallest + 2 * k != nums[i]) \\n                continue;\\n\\n            vector<bool> visit(n);\\n            vector<int> ans;\\n\\n            for (int j = 0; j < n; j++)\\n            {\\n\\n                if (visit[j]) \\n                    continue;\\n\\n                int target = nums[j] + 2 * k;\\n\\n                int index = search(nums, visit, j + 1, n - 1, target);\\n\\n                if (index == -1) \\n                    break;\\n\\n                visit[index] = true; \\n                ans.push_back(nums[j] + k); \\n            }\\n\\n            if (ans.size() == n / 2)\\n                return ans;\\n        }\\n\\n        return {};\\n    }\\n};\\n\\n```\\n\\n```\\n\\nclass Solution {\\n    \\n int search(int nums[],boolean visit[] ,int low,int high,int target){\\n     int index  = -1;\\n     \\n      while(low <= high){\\n          int mid =  (low + high)/2;\\n            if(nums[mid]==target){\\n                if(visit[mid]){\\n                   low = mid +1;\\n                 }\\n                 else{\\n                      index = mid;    \\n                      high = mid-1; \\n                    }\\n                   continue;\\n                }\\n\\n                if(nums[mid] > target)\\n                   high = mid-1;\\n                else\\n                   low = mid +1;\\n     }\\n      return index;\\n}\\n    \\n    public int[] recoverArray(int[]nums) {\\n        \\n       int n  = nums.length;\\n       Arrays.sort(nums);\\n       \\n       int smallest = nums[0];\\n       \\n         for(int i =1;i<n;i++){\\n               \\n              int k = (nums[i] - smallest)/2; \\n               \\n               if(k<=0 || smallest + 2*k != nums[i]) \\n                     continue;\\n             \\n                       boolean visit[] = new boolean[n];\\n                       int ans[] = new int[n/2];        \\n                       int cnt = 0;\\n                       for(int j=0;j<n;j++){\\n                       \\n                           if(visit[j]) \\n                              continue;\\n                       \\n                           int target = nums[j] + 2*k; \\n                           int index = search(nums,visit,j+1,n-1, target);                  \\n                           if(index==-1)\\n                               break;\\n                        \\n                           visit[index] = true; \\n                           ans[cnt++] = nums[j] + k; \\n            \\n                       }\\n                         if(cnt==n/2) \\n                             return ans;\\n         }\\n       \\n       return new int[0];\\n     }\\n}\\n\\n```\\n\\n\\n***Time Complexity : - O(n^2 logn)\\n Space Complexity :- O(n)  (for maintaining visited array)***\\n\\n ***If you Like this post please do upvote so other people can also take benefit of this.\\n any doubt welcome in comment section.***\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```nums =  [11, 6, 3, 4, 8, 7, 8, 7, 9, 8, 9, 10, 10, 2, 1, 9] n = 16```\n```[1, 2, 3, 4, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11]```\n```\\t\\t\\t    \\t\\t\\t\\nlower[i] =   nums[i] - k\\t\\t (given in ques)                 \\nnums[i]  =  lower[i] + k        ....1)       \\t   \\n \\nhigher[i] =  nums[i]  + k        (given in ques)\\nnums[i]  =   higher[i] - k      ....2)   \\n\\nusing 1 and  2\\n  lower[i] + k     =  higher[i] - k\\n  lower[i] + 2k    =  higher[i]   \\n  \\n```\n```\\nalso for getting k value\\nk = (higher[i] - lower[i])/2  (using above equation)\\n```\n```nums[] =  [1, 2, 3, 4, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11]```\n``` \\n   k = (nums[i] - smallest)/2\\n```\n```        we check  if k>0 && smallest + 2*k == nums[i] ```\n```\\ni= 1:\\n\\n\\t\\t\\t nums[i] = 2\\n\\t\\t\\t k = (2 - 1)/2;\\n\\t\\t\\t k = 0 (not valid); \\n\\n\\ni = 2:\\n\\n\\t\\t\\t nums[i] = 3\\n\\t\\t\\t k = (3-1)/2;\\n\\t\\t\\t k = 1 (valid)\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int search(vector<int> &nums, vector<bool> visit, int low, int high, int target)\\n    {\\n        int index = -1;\\n\\n        while (low <= high)\\n        {\\n\\n            int mid = (low + high) / 2;\\n\\n            if (nums[mid] == target)\\n            {\\n                if (visit[mid])\\n                {\\n                    low = mid + 1;\\n                }\\n                else\\n                {\\n                    index = mid;  \\n                    high = mid - 1; \\n                }\\n\\n                continue;\\n            }\\n\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;\\n        }\\n\\n        return index;\\n    }\\n\\n    vector<int> recoverArray(vector<int> &nums)\\n    {\\n\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int smallest = nums[0];\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n\\n            int k = (nums[i] - smallest) / 2; \\n            if (k <= 0 || smallest + 2 * k != nums[i]) \\n                continue;\\n\\n            vector<bool> visit(n);\\n            vector<int> ans;\\n\\n            for (int j = 0; j < n; j++)\\n            {\\n\\n                if (visit[j]) \\n                    continue;\\n\\n                int target = nums[j] + 2 * k;\\n\\n                int index = search(nums, visit, j + 1, n - 1, target);\\n\\n                if (index == -1) \\n                    break;\\n\\n                visit[index] = true; \\n                ans.push_back(nums[j] + k); \\n            }\\n\\n            if (ans.size() == n / 2)\\n                return ans;\\n        }\\n\\n        return {};\\n    }\\n};\\n\\n```\n```\\n\\nclass Solution {\\n    \\n int search(int nums[],boolean visit[] ,int low,int high,int target){\\n     int index  = -1;\\n     \\n      while(low <= high){\\n          int mid =  (low + high)/2;\\n            if(nums[mid]==target){\\n                if(visit[mid]){\\n                   low = mid +1;\\n                 }\\n                 else{\\n                      index = mid;    \\n                      high = mid-1; \\n                    }\\n                   continue;\\n                }\\n\\n                if(nums[mid] > target)\\n                   high = mid-1;\\n                else\\n                   low = mid +1;\\n     }\\n      return index;\\n}\\n    \\n    public int[] recoverArray(int[]nums) {\\n        \\n       int n  = nums.length;\\n       Arrays.sort(nums);\\n       \\n       int smallest = nums[0];\\n       \\n         for(int i =1;i<n;i++){\\n               \\n              int k = (nums[i] - smallest)/2; \\n               \\n               if(k<=0 || smallest + 2*k != nums[i]) \\n                     continue;\\n             \\n                       boolean visit[] = new boolean[n];\\n                       int ans[] = new int[n/2];        \\n                       int cnt = 0;\\n                       for(int j=0;j<n;j++){\\n                       \\n                           if(visit[j]) \\n                              continue;\\n                       \\n                           int target = nums[j] + 2*k; \\n                           int index = search(nums,visit,j+1,n-1, target);                  \\n                           if(index==-1)\\n                               break;\\n                        \\n                           visit[index] = true; \\n                           ans[cnt++] = nums[j] + k; \\n            \\n                       }\\n                         if(cnt==n/2) \\n                             return ans;\\n         }\\n       \\n       return new int[0];\\n     }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647488,
                "title": "python3-brute-force",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/338b3e50d12cc0067b8b85e8e27c1b0c10fd91c6) for solutions of weely 273. \\n\\n```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        cnt = Counter(nums)\\n        for i in range(1, len(nums)): \\n            diff = nums[i] - nums[0]\\n            if diff and diff&1 == 0: \\n                ans = []\\n                freq = cnt.copy()\\n                for k, v in freq.items(): \\n                    if v: \\n                        if freq[k+diff] < v: break \\n                        ans.extend([k+diff//2]*v)\\n                        freq[k+diff] -= v\\n                else: return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        cnt = Counter(nums)\\n        for i in range(1, len(nums)): \\n            diff = nums[i] - nums[0]\\n            if diff and diff&1 == 0: \\n                ans = []\\n                freq = cnt.copy()\\n                for k, v in freq.items(): \\n                    if v: \\n                        if freq[k+diff] < v: break \\n                        ans.extend([k+diff//2]*v)\\n                        freq[k+diff] -= v\\n                else: return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647882,
                "title": "java-explained-check-valid-k-with-two-pointers-6ms-beats-100",
                "content": "Let\\'s assume that the original array was `[x, y, z] (x <= y <= z)`, and after subtracting and adding `k` we\\'ve got an array of pairs `[x-k, x+k, y-k, y+k, z-k, z+k]`. We can make the following observations:\\n1. The smallest number `x` in the original array will produce the smallest number `x - k` in the generated array.\\n2. All generated pairs will have the same fixed difference: `(x+k) - (x-k) = x + k - x + k = 2 * k`. \\n3. This difference `2 * k` must be even and positive (because `k` is positive).\\n4. Sequential numbers in the original array `x < y` generate 2 pairs in one of the following sorted orders: `[x-k, x+k, y-k, y+k]` or `[x-k, y-k, x+k, y+k]`, because `x-k < y-k` and `x+k < y+k`\\n5. Thus, we can sort the array and use a sliding window of fixed difference = `2 * k` with `i` = index of the lower element and `j` = index of the higher element of the pair, both of them are strictly increasing.\\n5. Introduce `visited` array to ensure that each number is processed only once.\\n ```java\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] res = new int[nums.length / 2];\\n        int prev = 0; // used to process each diff of 2*k only once\\n        // try finding a pair element x+2*k for the smallest one x\\n        for (int i = 1; i < nums.length; i++) {\\n            int diff = nums[i] - nums[0]; // 2*k, must be positive and even\\n            if (diff != prev && diff > 0 && diff % 2 == 0 && check(nums, i, diff / 2, res)) break;\\n            prev = diff;\\n        }\\n        return res;\\n    }\\n    \\n\\t // j points to the higher element of the pair\\n    private boolean check(int[] nums, int j, int k, int[] res) {\\n        int idx = 0;\\n        boolean[] visited = new boolean[nums.length];\\n        // i points to the lower element of the pair\\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            int target = nums[i] + 2 * k;\\n            // find the target = the higher element of the pair\\n            while (j < nums.length && (nums[j] < target || (nums[j] == target && visited[j]))) j++;\\n            if (j == nums.length || nums[j] != target) return false;\\n            visited[j] = true;\\n            // both elements of the pair are confirmed, update the result\\n            res[idx++] = nums[i] + k;\\n        }\\n        return true;\\n    }\\n}\\n```\\nSimilar problems:\\n[954. Array of Doubled Pairs](https://leetcode.com/problems/array-of-doubled-pairs/)\\n[2007. Find Original Array From Doubled Array](https://leetcode.com/problems/find-original-array-from-doubled-array/)\\n\\n**PLEASE UPVOTE if you liked this post. THANKS!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] res = new int[nums.length / 2];\\n        int prev = 0; // used to process each diff of 2*k only once\\n        // try finding a pair element x+2*k for the smallest one x\\n        for (int i = 1; i < nums.length; i++) {\\n            int diff = nums[i] - nums[0]; // 2*k, must be positive and even\\n            if (diff != prev && diff > 0 && diff % 2 == 0 && check(nums, i, diff / 2, res)) break;\\n            prev = diff;\\n        }\\n        return res;\\n    }\\n    \\n\\t // j points to the higher element of the pair\\n    private boolean check(int[] nums, int j, int k, int[] res) {\\n        int idx = 0;\\n        boolean[] visited = new boolean[nums.length];\\n        // i points to the lower element of the pair\\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            int target = nums[i] + 2 * k;\\n            // find the target = the higher element of the pair\\n            while (j < nums.length && (nums[j] < target || (nums[j] == target && visited[j]))) j++;\\n            if (j == nums.length || nums[j] != target) return false;\\n            visited[j] = true;\\n            // both elements of the pair are confirmed, update the result\\n            res[idx++] = nums[i] + k;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654924,
                "title": "o-n-2-time-solution-without-hashmap",
                "content": "The idea is similar to most of the Solutions on Discuss page, Only difference is function used to find the original array given a value of k.\\nInstead of using a Hashmap or multiset. This solution uses to 2-pointer approch which is guaranteed O(N) time, getting rid of hash colliosions in case of HashMap.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> recoverArray(vector<int>& a) {\\n        sort(a.begin(), a.end());\\n        int n = a.size();\\n        for(int i = 1; i < n; i++) {\\n            \\n            int dif = a[i] - a[0];\\n            if(!dif || dif&1)\\n                continue;\\n            int k = dif/2;\\n            \\n            vector<int> resultArray = getResultArray(a, n, k);\\n            if(resultArray.size() == n/2)\\n                return resultArray;\\n        }\\n        \\n        return {};\\n    }\\n    \\n    vector<int> getResultArray(vector<int> &a, int n, int k) {\\n        \\n        int left = 0, right = 1;\\n        vector<bool> done(n);\\n            \\n        vector<int> resultArray;\\n        \\n        while(right < n) {\\n            if(done[left]) {\\n                left++;\\n                continue;\\n            }\\n            if(done[right]) {\\n                right++;\\n                continue;\\n            }\\n            int dif = a[right] - a[left];\\n            if(dif < 2*k) {\\n                right++;\\n            }\\n            else if(dif > 2*k) {\\n                left++;\\n            }\\n            else {\\n                done[left] = 1; done[right] = 1;\\n                resultArray.push_back(a[left]+k);\\n                left++;\\n                right++;\\n            }\\n        }\\n        \\n        return resultArray;\\n    }\\n    \\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> recoverArray(vector<int>& a) {\\n        sort(a.begin(), a.end());\\n        int n = a.size();\\n        for(int i = 1; i < n; i++) {\\n            \\n            int dif = a[i] - a[0];\\n            if(!dif || dif&1)\\n                continue;\\n            int k = dif/2;\\n            \\n            vector<int> resultArray = getResultArray(a, n, k);\\n            if(resultArray.size() == n/2)\\n                return resultArray;\\n        }\\n        \\n        return {};\\n    }\\n    \\n    vector<int> getResultArray(vector<int> &a, int n, int k) {\\n        \\n        int left = 0, right = 1;\\n        vector<bool> done(n);\\n            \\n        vector<int> resultArray;\\n        \\n        while(right < n) {\\n            if(done[left]) {\\n                left++;\\n                continue;\\n            }\\n            if(done[right]) {\\n                right++;\\n                continue;\\n            }\\n            int dif = a[right] - a[left];\\n            if(dif < 2*k) {\\n                right++;\\n            }\\n            else if(dif > 2*k) {\\n                left++;\\n            }\\n            else {\\n                done[left] = 1; done[right] = 1;\\n                resultArray.push_back(a[left]+k);\\n                left++;\\n                right++;\\n            }\\n        }\\n        \\n        return resultArray;\\n    }\\n    \\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652403,
                "title": "c-simple-maths-with-explanation",
                "content": "```\\n/* so array elements are  of form\\nA-K   B-K  C-K   A+K     B+K        C+K  but we dont  know actual sequence\\nsubstrate A-K   from the whole so\\n0       B-A  C-A   2K     B-A+2K   C-A+2K\\nso we calculate  2k that is the Doublediff and store in  doublediff  vector \\n\\nso we put all possibel value of double diff in doublediff vector\\nwe iterate through every diff in double diff and try to form our ans\\nfor  diff :doubeldiff\\n    iteration 1:  \\n\\t                getsolution      // Explantion of getsolution function\\n\\t\\t\\t\\t\\t{\\n\\t                we store freq of every element in map\\n\\t                 we assume A-K as the first element in nums\\n\\t\\t\\t\\t\\t and we calculate wheteher a+k is present or not bu A-K+ diff       where diff= 2k\\n\\t\\t\\t\\t\\t if\\n\\t\\t\\t\\t\\t {we find A+K  we decrement its freq by 1\\n\\t\\t\\t\\t\\t and we calculate the A as   A=A-K + diff/2;\\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t\\t\\t else    we return \\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t\\t\\t if (ans.size()== nums.size()/2)     return ans\\n\\t\\t\\t\\t\\t \\n\\titeration 2....\\n\\titeration 3..\\n\\t return empty array  */\\n\\t\\t\\t\\t\\t \\n\\nclass Solution {\\npublic:\\n    vector<int> getdoublediff(vector<int> nums)\\n    {\\n        int n= nums.size(),dif;\\n        vector<int> diff;\\n        \\n        for (int i=0;i<n;i++)\\n        {\\n            dif= nums[i]-nums[0];\\n            if (dif >0  && (dif %2==0))   diff.push_back(dif);\\n        }\\n        return diff;\\n    }\\n    vector<int> getsolution(vector<int> nums,int diff)\\n    {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        vector<int> res;\\n        for (auto x: nums) mp[x]++;\\n        for (int i=0;i<n;i++)\\n        {\\n            if (mp.find(nums[i])!=mp.end())\\n            {\\n                mp[nums[i]]--;\\n                if (mp[nums[i]]==0)  mp.erase(nums[i]);\\n                \\n                int val= nums[i]+diff;\\n                if (mp.find(val)==mp.end())   return res;\\n                else\\n                {\\n                    mp[val]--;\\n                    if (mp[val]==0)  mp.erase(val);\\n                    \\n                    res.push_back(nums[i]+(diff)/2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        \\n            int n= nums.size();\\n            sort(nums.begin(),nums.end());\\n        \\n        vector<int> doublediff= getdoublediff(nums);\\n        \\n        for (auto diff : doublediff)\\n        {\\n            vector<int> ans= getsolution(nums,diff);\\n            if (ans.size()  == (n/2))    return ans;\\n        }\\n        vector<int>res;\\n        return res;\\n        \\n    }\\n};\\n\\n// Plz upvote as it encourage me to write more detailed solution",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> getdoublediff(vector<int> nums)\\n    {\\n        int n= nums.size(),dif;\\n        vector<int> diff;\\n        \\n        for (int i=0;i<n;i++)\\n        {\\n            dif= nums[i]-nums[0];\\n            if (dif >0  && (dif %2==0))   diff.push_back(dif);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1647491,
                "title": "java-find-and-check-k-fits-or-not-priorityqueue",
                "content": "````\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        \\n    \\tint i,n=nums.length;\\n    \\tint ans[]=new int[n/2];\\n    \\tArrays.sort(nums);\\n    \\tPriorityQueue<Integer> pq=new PriorityQueue<>();\\n    \\tfor(i=0;i<n;i++)\\n    \\t\\tpq.add(nums[i]);\\n    \\tfor(i=1;i<n;i++)\\n    \\t{\\n    \\t\\tPriorityQueue<Integer> pq1=new PriorityQueue<>(pq);\\n    \\t\\tint p=0;\\n    \\t\\tif((nums[0]+nums[i])%2==0)\\n    \\t\\t{\\n    \\t\\t\\tint k=(nums[0]+nums[i])/2-nums[0];\\n    \\t\\t\\tif(k==0)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tint curr=pq1.poll();\\n    \\t\\t\\twhile(pq1.contains((curr+k+k))) {\\n    \\t\\t\\t\\n    \\t\\t\\t\\tpq1.remove(curr+k+k); \\n\\t\\t\\t\\t\\tans[p++]=curr+k;\\n\\t\\t\\t\\t\\tif(p==n/2)\\n\\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\tcurr=pq1.poll();\\n    \\t\\t\\t}\\n    \\t\\t\\tif(p==n/2)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }\\n}\\n````\\n\\nIf you guys get it then please upvote it:))",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "````\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        \\n    \\tint i,n=nums.length;\\n    \\tint ans[]=new int[n/2];\\n    \\tArrays.sort(nums);\\n    \\tPriorityQueue<Integer> pq=new PriorityQueue<>();\\n    \\tfor(i=0;i<n;i++)\\n    \\t\\tpq.add(nums[i]);\\n    \\tfor(i=1;i<n;i++)\\n    \\t{\\n    \\t\\tPriorityQueue<Integer> pq1=new PriorityQueue<>(pq);\\n    \\t\\tint p=0;\\n    \\t\\tif((nums[0]+nums[i])%2==0)\\n    \\t\\t{\\n    \\t\\t\\tint k=(nums[0]+nums[i])/2-nums[0];\\n    \\t\\t\\tif(k==0)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tint curr=pq1.poll();\\n    \\t\\t\\twhile(pq1.contains((curr+k+k))) {\\n    \\t\\t\\t\\n    \\t\\t\\t\\tpq1.remove(curr+k+k); \\n\\t\\t\\t\\t\\tans[p++]=curr+k;\\n\\t\\t\\t\\t\\tif(p==n/2)\\n\\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\tcurr=pq1.poll();\\n    \\t\\t\\t}\\n    \\t\\t\\tif(p==n/2)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647484,
                "title": "simple-c-solution-with-explanation-n-2",
                "content": "since it\\'s given that atleast one valid answer is always possible , therefore for every index  i  of array there is one index j (i!=j) \\nsuch that   |array[ j ]  - array[ i ] | == 2*k ,\\nwhere k is the positive integer given in question.\\n\\nlets first sort the array to simplify things for us.\\n\\nnow let\\'s say we start checking for all valid k\\'s   from  first element ( 0th element index wise) . there can be as many as n-1 different k we can get  \\ni.e    (arr[ 1 ] -arr [ 0 ] ), (arr[ 2 ] -arr [ 0 ] ) , (arr[ 3 ] -arr [ 0 ] ) ..................... (arr[ n-1 ] -arr [ 0 ] )\\nat max  this number can be 1000 as given in constraints.\\n\\nnow for each such even value of k we try to build our original array  in  O(n) time  and if possible we will return that array as \\nour answer . we will try to find our valid answer till we get one  using these ( n-1 ) k\\'s.\\n\\nTime -   as there can be n-1 values of k and for each k to check valid ans o(n) time will require \\n          O(n^2)\\n\\t\\t  \\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n             int k=(nums[i]-nums[0])/2;\\n            if((nums[i]-nums[0])%2==1 || k<1)continue;\\n\\n            bool possible=true;\\n            vector<bool> left(n,true);\\n            vector<int> temAns;\\n            int upper=i;\\n        \\n            for(int lower=0;lower<n;lower++){\\n                if(!left[lower])continue;\\n                if(upper==lower)upper++;\\n                while(upper<n && nums[upper]-nums[lower]<=2*k){\\n                if(nums[upper]-nums[lower]==2*k){\\n                    temAns.push_back(nums[lower]+k);\\n                    left[upper]=left[lower]=false;\\n                    upper++;\\n                    break;\\n                }\\n                    upper++;\\n                }\\n                if(left[lower]){\\n                    possible=false;\\n                    break;\\n                }\\n                \\n            }\\n            if(possible){\\n                ans=temAns;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n             int k=(nums[i]-nums[0])/2;\\n            if((nums[i]-nums[0])%2==1 || k<1)continue;\\n\\n            bool possible=true;\\n            vector<bool> left(n,true);\\n            vector<int> temAns;\\n            int upper=i;\\n        \\n            for(int lower=0;lower<n;lower++){\\n                if(!left[lower])continue;\\n                if(upper==lower)upper++;\\n                while(upper<n && nums[upper]-nums[lower]<=2*k){\\n                if(nums[upper]-nums[lower]==2*k){\\n                    temAns.push_back(nums[lower]+k);\\n                    left[upper]=left[lower]=false;\\n                    upper++;\\n                    break;\\n                }\\n                    upper++;\\n                }\\n                if(left[lower]){\\n                    possible=false;\\n                    break;\\n                }\\n                \\n            }\\n            if(possible){\\n                ans=temAns;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694677,
                "title": "c-o-n-2-identify-all-k-and-use-the-concept-of-954-array-of-doubled-pairs",
                "content": "Logic:\\nSimilar to \"[954. Array of Doubled Pairs](https://leetcode.com/problems/array-of-doubled-pairs/)\" or \"[2007. Find Original Array From Doubled Array](https://leetcode.com/problems/find-original-array-from-doubled-array/)\"\\n\\nStep 1: Identify the possible K\\'s\\nStep 2: Maintain a counter of all values of array\\nStep 3: Check if for given K, the array can be divided into two arrays(smaller and larger arrays)\\nStep 3.1: for any certain K, if \\'arr[i]\\' is present in arr, then \\'arr[i] + 2k\\' should also be present in arr\\n\\nFor Step 1: \\nWe need to sort the arr, for example for nums = [2,10,6,4,8,12], we should make nums = [2,4,6,8,10,12]\\nNote 1: 2 and 10 can\\'t be a pair, as 2 is minimum of array and hence we can never be able to find the pair for 6 or 8\\nNote 2: For a valid K, nums[0] + 2K, which is 2 + 2K can either be 4,6, or 8 (which are nums[1] to nums[3])\\nNote 3: We can easily ignore other values than 2(nums[0]) to identify K\\n\\nFor Step 3.1: We can use hashmap, multiset etc. One should try either of the following problems to understand the concept:\\n* [954. Array of Doubled Pairs](https://leetcode.com/problems/array-of-doubled-pairs/)\\n* [2007. Find Original Array From Doubled Array](https://leetcode.com/problems/find-original-array-from-doubled-array/)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findOriginalArray(vector<int>& arr, int k, unordered_map<int, int> counter) {\\n        vector<int> ans;\\n        vector<int> emptyArr;\\n        /*Step 3.1\\n            For each J, reduce the counter of arr[i] and arr[i] + 2*K by 1\\n            If for some arr[i], arr[i] + 2*K doesn\\'t exist or it\\'s count can\\'t be reduced further, then the K is invalid\\n        */\\n        for(int i = 0; i < arr.size(); i++){\\n            if(counter[arr[i]] > 0){\\n                ans.push_back(arr[i] + k);\\n                counter[arr[i]]--;\\n                if(counter[arr[i] + 2*k] <= 0)\\n                    return emptyArr;\\n                counter[arr[i] + 2*k]--;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans;\\n        vector<int> listOfValidKs;\\n        /*Step 1: Find the list of valid K\\'s*/\\n        for(int i = 1; i <= nums.size()/2; i++){\\n            if(nums[i] != nums[0] && (nums[i] - nums[0])%2 == 0){\\n                listOfValidKs.push_back((nums[i] - nums[0])/2);\\n            }\\n        }\\n        /*!Step 1*/\\n        /*Step 2: Maintain the counter*/\\n        unordered_map<int, int> counter;\\n        for(int i = 0; i < nums.size(); i++)\\n            counter[nums[i]]++;\\n        /*!Step 2*/\\n        /*Step 3: Validate each K*/\\n        for(int i = 0; i < listOfValidKs.size(); i++){\\n            ans = findOriginalArray(nums, listOfValidKs[i], counter);\\n            if(ans.size() > 0)\\n                return ans;\\n        }\\n        /*!Step 3*/\\n        ans.clear();\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease share your feedbacks if any.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findOriginalArray(vector<int>& arr, int k, unordered_map<int, int> counter) {\\n        vector<int> ans;\\n        vector<int> emptyArr;\\n        /*Step 3.1\\n            For each J, reduce the counter of arr[i] and arr[i] + 2*K by 1\\n            If for some arr[i], arr[i] + 2*K doesn\\'t exist or it\\'s count can\\'t be reduced further, then the K is invalid\\n        */\\n        for(int i = 0; i < arr.size(); i++){\\n            if(counter[arr[i]] > 0){\\n                ans.push_back(arr[i] + k);\\n                counter[arr[i]]--;\\n                if(counter[arr[i] + 2*k] <= 0)\\n                    return emptyArr;\\n                counter[arr[i] + 2*k]--;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans;\\n        vector<int> listOfValidKs;\\n        /*Step 1: Find the list of valid K\\'s*/\\n        for(int i = 1; i <= nums.size()/2; i++){\\n            if(nums[i] != nums[0] && (nums[i] - nums[0])%2 == 0){\\n                listOfValidKs.push_back((nums[i] - nums[0])/2);\\n            }\\n        }\\n        /*!Step 1*/\\n        /*Step 2: Maintain the counter*/\\n        unordered_map<int, int> counter;\\n        for(int i = 0; i < nums.size(); i++)\\n            counter[nums[i]]++;\\n        /*!Step 2*/\\n        /*Step 3: Validate each K*/\\n        for(int i = 0; i < listOfValidKs.size(); i++){\\n            ans = findOriginalArray(nums, listOfValidKs[i], counter);\\n            if(ans.size() > 0)\\n                return ans;\\n        }\\n        /*!Step 3*/\\n        ans.clear();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652204,
                "title": "java-check-all-possible-ks",
                "content": "- **nums** contains permutation of **{a-k,a+k, b-k,b+k,...,z-k,z+k}**\\n- we can sort permutation array and find all possible **K** : **(nums[i]-nums[0])/2**, for **i>=1** and **even (nums[i]-nums[0])**\\n- we can map all occurrences of values into **value:count**\\n- we have to iterate though all possible **K**s and check whether every **K** fits **nums** array\\n- we can check by removing faced **nums** {**value**} and {**value +2 * k**} from map, if there is no corresponding {**value +2 * k**}, then **K** doesn\\'t fit nums array\\n```\\n    public int[] recoverArray(int[] nums) {\\n        int len = nums.length;\\n        int[] res = new int[len/2];\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Set<Integer> setK = new HashSet<>();\\n\\n        for(int n : nums)\\n            map.put(n, map.getOrDefault(n,0)+1);\\n\\n        Arrays.sort(nums);\\n\\n        for(int i=1;i<len;i++){\\n            int diff2k = nums[i]-nums[0];\\n            if(diff2k%2==0 && diff2k!=0)\\n                setK.add(diff2k/2);\\n        }\\n\\n        for(int k : setK){\\n            int i=0,j=0;\\n            while(j<len/2){\\n                int low = nums[i];\\n                if(map.get(low)!=0) {\\n                    int high = low + 2 * k;\\n                    if(map.getOrDefault(high,0)!=0){\\n                        map.put(low, map.get(low)-1);\\n                        map.put(high, map.get(high)-1);\\n                        res[j++] = low+k;\\n                    }else{\\n                        while(--j >= 0){\\n                            map.put(res[j]+k, map.getOrDefault(res[j]+k, 0)+1);\\n                            map.put(res[j]-k, map.getOrDefault(res[j]-k,0)+1);\\n                        }\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            if(j==len/2)\\n                return res;\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] recoverArray(int[] nums) {\\n        int len = nums.length;\\n        int[] res = new int[len/2];\\n        Map<Integer,Integer> map = new HashMap<>();\\n        Set<Integer> setK = new HashSet<>();\\n\\n        for(int n : nums)\\n            map.put(n, map.getOrDefault(n,0)+1);\\n\\n        Arrays.sort(nums);\\n\\n        for(int i=1;i<len;i++){\\n            int diff2k = nums[i]-nums[0];\\n            if(diff2k%2==0 && diff2k!=0)\\n                setK.add(diff2k/2);\\n        }\\n\\n        for(int k : setK){\\n            int i=0,j=0;\\n            while(j<len/2){\\n                int low = nums[i];\\n                if(map.get(low)!=0) {\\n                    int high = low + 2 * k;\\n                    if(map.getOrDefault(high,0)!=0){\\n                        map.put(low, map.get(low)-1);\\n                        map.put(high, map.get(high)-1);\\n                        res[j++] = low+k;\\n                    }else{\\n                        while(--j >= 0){\\n                            map.put(res[j]+k, map.getOrDefault(res[j]+k, 0)+1);\\n                            map.put(res[j]-k, map.getOrDefault(res[j]-k,0)+1);\\n                        }\\n                        break;\\n                    }\\n                }\\n                i++;\\n            }\\n            if(j==len/2)\\n                return res;\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647469,
                "title": "java-hashmap-trying-all-possible-k",
                "content": "After sorting, k can be (nums[i]-nums[0])/2 for any i in 1 ~ n, then use a HashMap<element, count> to check if such k is valid.\\n\\n```\\nclass Solution {\\n    Map<Integer, Integer> countMap;\\n    public int[] recoverArray(int[] nums) {\\n        int n = nums.length/2;\\n        Arrays.sort(nums);\\n        countMap = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) {\\n            countMap.put(nums[i], countMap.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        for(int i=1; i<=n; i++) {\\n            int k = (nums[i]-nums[0])/2;\\n            if(k == 0) continue; // k is positive\\n            int[] ret = helper(nums, k);\\n            if(ret != null) {\\n                return ret;\\n            }\\n        }\\n\\n        return null;\\n    }\\n    \\n    int[] helper(int[] nums, int k) { // check if k is valid and generate return array\\n        Map<Integer, Integer> map = new HashMap<>(countMap);\\n        List<Integer> list = new ArrayList<>();\\n        for(int i:nums) {\\n            if(!map.containsKey(i)) continue;\\n            int counterPart = i + 2*k;\\n            if(!map.containsKey(counterPart)) return null;\\n            list.add(i+k);\\n            \\n            map.put(i, map.get(i) - 1);\\n            if(map.get(i) == 0) map.remove(i);\\n            map.put(counterPart, map.get(counterPart) - 1);\\n            if(map.get(counterPart) == 0) map.remove(counterPart);\\n        }\\n        int[] ret = new int[list.size()];\\n        for(int j=0; j<list.size(); j++) {\\n            ret[j] = list.get(j);\\n        }\\n        return ret;\\n    }\\n} \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> countMap;\\n    public int[] recoverArray(int[] nums) {\\n        int n = nums.length/2;\\n        Arrays.sort(nums);\\n        countMap = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) {\\n            countMap.put(nums[i], countMap.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        for(int i=1; i<=n; i++) {\\n            int k = (nums[i]-nums[0])/2;\\n            if(k == 0) continue; // k is positive\\n            int[] ret = helper(nums, k);\\n            if(ret != null) {\\n                return ret;\\n            }\\n        }\\n\\n        return null;\\n    }\\n    \\n    int[] helper(int[] nums, int k) { // check if k is valid and generate return array\\n        Map<Integer, Integer> map = new HashMap<>(countMap);\\n        List<Integer> list = new ArrayList<>();\\n        for(int i:nums) {\\n            if(!map.containsKey(i)) continue;\\n            int counterPart = i + 2*k;\\n            if(!map.containsKey(counterPart)) return null;\\n            list.add(i+k);\\n            \\n            map.put(i, map.get(i) - 1);\\n            if(map.get(i) == 0) map.remove(i);\\n            map.put(counterPart, map.get(counterPart) - 1);\\n            if(map.get(counterPart) == 0) map.remove(counterPart);\\n        }\\n        int[] ret = new int[list.size()];\\n        for(int j=0; j<list.size(); j++) {\\n            ret[j] = list.get(j);\\n        }\\n        return ret;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670442,
                "title": "step-by-step-explaination",
                "content": "## Logic\\nThis Problem is all about finding K which is subtracted from original array (lower[i] = ar[i] - K) or added to the original array (higher[i] = ar[i] + K)\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n//         step - 1: arrange elements in ascending order\\n        sort(nums.begin(), nums.end());\\n//         Now, the smallest element will always belong to \"lower\" array\\n//         so, let it be lower[0]\\n//         now 2c = higher[0] - lower[0] \\n//         step - 2: find higher[0]\\n        for(int i = 1; i < n; i++){\\n            vector<int> v;\\n            v.push_back(nums[0]);\\n//             lets say ar[i] is highest[0] then\\n//             say k = 2c\\n//             1. k should be even and not equal to 0\\n//             2. for every element present in lower there must exist an element in higher\\n//             as lower[i] = higher[i] + k\\n//             Step-3: find k\\n            int k = nums[i] - v.back();\\n//             Step-4: check condition 1\\n            if(k & 1 || k == 0){\\n                continue;\\n            }\\n            // cout << k << \" \";\\n//             Step-5: Check condition 2\\n//             Create a Multiset to check if the element exist or not in log n time\\n            multiset<int> s(nums.begin(), nums.end());\\n//             now we don\\'t need the used elements so remove nums[0] and nums[i]\\n            s.erase(s.find(nums[0])), s.erase(s.find(nums[i]));\\n//             check if k is valid for all remaining elements of set\\n            while(!s.empty()){\\n//                 get lowerest element\\n                int x = *(s.begin());\\n//                 and push x in answer vector\\n                v.push_back(x);       \\n//                 remove x from se to avoid repeating elements\\n                s.erase(s.find(x));\\n//                 find if x + k exist\\n                if(s.find(x+k) == s.end()){\\n//                 if is doesn\\'t exist then k is invalid\\n                   break;\\n                }\\n//              if it exist then remove x + k\\n                s.erase(s.find(x + k));\\n                }\\n            if(s.empty()){\\n//                 this means k is valid\\n//                 original array = arr[i]\\n//                 lower = arr[i] - c\\n//                 k = 2c;\\n                for(int j = 0; j < v.size(); j++){\\n                    v[j] += k/2;\\n                }\\n                return v;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\nI wasn\\'t able to solve the Question on my own at first, But then I read and understood all the discussions and finally created this solution which seems like the easiest possible solution to me. Hopefully, this solution can help you better understand and solve this problem.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n//         step - 1: arrange elements in ascending order\\n        sort(nums.begin(), nums.end());\\n//         Now, the smallest element will always belong to \"lower\" array\\n//         so, let it be lower[0]\\n//         now 2c = higher[0] - lower[0] \\n//         step - 2: find higher[0]\\n        for(int i = 1; i < n; i++){\\n            vector<int> v;\\n            v.push_back(nums[0]);\\n//             lets say ar[i] is highest[0] then\\n//             say k = 2c\\n//             1. k should be even and not equal to 0\\n//             2. for every element present in lower there must exist an element in higher\\n//             as lower[i] = higher[i] + k\\n//             Step-3: find k\\n            int k = nums[i] - v.back();\\n//             Step-4: check condition 1\\n            if(k & 1 || k == 0){\\n                continue;\\n            }\\n            // cout << k << \" \";\\n//             Step-5: Check condition 2\\n//             Create a Multiset to check if the element exist or not in log n time\\n            multiset<int> s(nums.begin(), nums.end());\\n//             now we don\\'t need the used elements so remove nums[0] and nums[i]\\n            s.erase(s.find(nums[0])), s.erase(s.find(nums[i]));\\n//             check if k is valid for all remaining elements of set\\n            while(!s.empty()){\\n//                 get lowerest element\\n                int x = *(s.begin());\\n//                 and push x in answer vector\\n                v.push_back(x);       \\n//                 remove x from se to avoid repeating elements\\n                s.erase(s.find(x));\\n//                 find if x + k exist\\n                if(s.find(x+k) == s.end()){\\n//                 if is doesn\\'t exist then k is invalid\\n                   break;\\n                }\\n//              if it exist then remove x + k\\n                s.erase(s.find(x + k));\\n                }\\n            if(s.empty()){\\n//                 this means k is valid\\n//                 original array = arr[i]\\n//                 lower = arr[i] - c\\n//                 k = 2c;\\n                for(int j = 0; j < v.size(); j++){\\n                    v[j] += k/2;\\n                }\\n                return v;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1647558,
                "title": "need-help-o-n-2-sol-getting-tle",
                "content": "I am checking for all the possible differences which may give answer in O(n) so expected time complexity should be O(n^2) but its getting tle , can someone point out the mistake\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        set<int>diff;\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            diff.insert(abs(nums[i] - nums[0]));\\n        }\\n        vector<int>ans(n/2,0);\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp1;\\n        for(auto x:diff){\\n            if(x==0 || x&1){\\n                continue;\\n            }\\n            mp1.clear();\\n            int cnt = 0;\\n            for(int i=0;i<n;i++){\\n                mp1[nums[i]]++;\\n            }\\n            for(int i=0;i<n;i++){\\n                if(mp1[nums[i]] && mp1[nums[i] + x]){\\n                    mp1[nums[i]]--;\\n                    mp1[nums[i] + x]--;\\n                    cnt++;\\n                }\\n                else if(mp1[nums[i]]){\\n                    break;\\n                }\\n            }\\n            if(cnt==n/2){\\n                for(int i=0;i<n;i++){\\n                    mp1[nums[i]]++;\\n                }\\n                cnt =0;\\n                for(int i=0;i<n;i++){\\n                    if(mp1[nums[i]] && mp1[nums[i] + x]){\\n                        mp1[nums[i]]--;\\n                        mp1[nums[i] + x]--;\\n                        ans[cnt] = nums[i] + x/2;\\n                        cnt++;\\n                    }\\n                }           \\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        set<int>diff;\\n        int n = nums.size();\\n        for(int i=1;i<n;i++){\\n            diff.insert(abs(nums[i] - nums[0]));\\n        }\\n        vector<int>ans(n/2,0);\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>mp1;\\n        for(auto x:diff){\\n            if(x==0 || x&1){\\n                continue;\\n            }\\n            mp1.clear();\\n            int cnt = 0;\\n            for(int i=0;i<n;i++){\\n                mp1[nums[i]]++;\\n            }\\n            for(int i=0;i<n;i++){\\n                if(mp1[nums[i]] && mp1[nums[i] + x]){\\n                    mp1[nums[i]]--;\\n                    mp1[nums[i] + x]--;\\n                    cnt++;\\n                }\\n                else if(mp1[nums[i]]){\\n                    break;\\n                }\\n            }\\n            if(cnt==n/2){\\n                for(int i=0;i<n;i++){\\n                    mp1[nums[i]]++;\\n                }\\n                cnt =0;\\n                for(int i=0;i<n;i++){\\n                    if(mp1[nums[i]] && mp1[nums[i] + x]){\\n                        mp1[nums[i]]--;\\n                        mp1[nums[i] + x]--;\\n                        ans[cnt] = nums[i] + x/2;\\n                        cnt++;\\n                    }\\n                }           \\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691177,
                "title": "java-hashmap-o-n-2-with-comments-and-explaination",
                "content": "\\n\\nThe idea is smallest element in the array would always be part of lower array so we can fix that element and iterate through rest of array to find possible k values, k would be equal to (nums[i]-nums[0])/2, now the next step is to verify if the taken k value is correct or not. For that we iterate over the array again and check if nums[j]+2*k or nums[j]-2*k element is present or not if none of this entries are present then k value we have taken is incorrect and we can move to new k value. If the element were present then we decrease frequency in hashmap so we can keep track if it was already checked or not.\\n\\n\\n\\n\\n\\n```\\n\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1); //Stroing frequency of elements in hashmap\\n        }\\n        int ans[]=new int[nums.length/2];\\n        for(int i=1;i<nums.length;i++){\\n            int k=(nums[i]-nums[0])/2;  // Finding k values\\n            if(k==0)\\n                continue;    //K should be positive only\\n            HashMap<Integer,Integer> hm2=new HashMap<>(hm); //Making copy of original hashmap\\n            int index=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(hm2.get(nums[j])>=1){\\n\\t\\t\\t\\t\\t//If element was not previously checked\\n                    if(hm2.getOrDefault(nums[j]+2*k,0)>=1){\\n                        ans[index]=nums[j]+k; //Original element is nums[j]+k\\n                        hm2.put(nums[j],hm2.get(nums[j])-1);\\n                        hm2.put(nums[j]+2*k,hm2.get(nums[j]+2*k)-1); // Decreasing frequency of both nums[j]&&nums[j]+k\\n                    }\\n                    else if(hm2.getOrDefault(nums[j]-2*k,0)>=1){\\n                        ans[index]=nums[j]-k;   //Original element was nums[j]-k\\n                        hm2.put(nums[j],hm2.get(nums[j])-1); \\n                        hm2.put(nums[j]-2*k,hm2.get(nums[j]-2*k)-1); //Decreasing frequency of both nums[j]&&nums[j]+k\\n                        \\n                    }\\n                    else{\\n\\t\\t\\t\\t\\t\\t//Invalid k value \\n                        break;\\n                    }\\n                    index++;\\n                }\\n            }\\n            if(index==nums.length/2)\\n                break; //Found the solution\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1); //Stroing frequency of elements in hashmap\\n        }\\n        int ans[]=new int[nums.length/2];\\n        for(int i=1;i<nums.length;i++){\\n            int k=(nums[i]-nums[0])/2;  // Finding k values\\n            if(k==0)\\n                continue;    //K should be positive only\\n            HashMap<Integer,Integer> hm2=new HashMap<>(hm); //Making copy of original hashmap\\n            int index=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(hm2.get(nums[j])>=1){\\n\\t\\t\\t\\t\\t//If element was not previously checked\\n                    if(hm2.getOrDefault(nums[j]+2*k,0)>=1){\\n                        ans[index]=nums[j]+k; //Original element is nums[j]+k\\n                        hm2.put(nums[j],hm2.get(nums[j])-1);\\n                        hm2.put(nums[j]+2*k,hm2.get(nums[j]+2*k)-1); // Decreasing frequency of both nums[j]&&nums[j]+k\\n                    }\\n                    else if(hm2.getOrDefault(nums[j]-2*k,0)>=1){\\n                        ans[index]=nums[j]-k;   //Original element was nums[j]-k\\n                        hm2.put(nums[j],hm2.get(nums[j])-1); \\n                        hm2.put(nums[j]-2*k,hm2.get(nums[j]-2*k)-1); //Decreasing frequency of both nums[j]&&nums[j]+k\\n                        \\n                    }\\n                    else{\\n\\t\\t\\t\\t\\t\\t//Invalid k value \\n                        break;\\n                    }\\n                    index++;\\n                }\\n            }\\n            if(index==nums.length/2)\\n                break; //Found the solution\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577521,
                "title": "c-simple-solution-using-queue",
                "content": "**Approach**\\nWe need to find **K** such that orginalArray[i] - k , orginalArray[i] + k both exist in the *nums* array but we have *low* and *high* arrays merged so we can say *high[i] - 2k = low[i]*.Since *N* is just 1000 we can try to find elements in low and high arrays for all possible values of *K*.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if((nums[i] - nums[0])%2 == 0 && (nums[i] - nums[0]) > 0)\\n            {\\n                int k = nums[i]-nums[0];\\n                queue<int> q;\\n                q.push(nums[0]);\\n                vector<int> ans;\\n                for(int i=1;i<nums.size();i++)\\n                {\\n                    if(!q.empty() && nums[i] - k == q.front())\\n                    {\\n                        ans.push_back(nums[i] - k/2);\\n                        q.pop();\\n                    }\\n                    else\\n                    {\\n                        q.push(nums[i]);\\n                    }\\n                }\\n                if(q.empty())\\n                {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\nsolve the given below simple version of this problem using queue:\\n[https://leetcode.com/problems/find-original-array-from-doubled-array/](http://)\\n",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if((nums[i] - nums[0])%2 == 0 && (nums[i] - nums[0]) > 0)\\n            {\\n                int k = nums[i]-nums[0];\\n                queue<int> q;\\n                q.push(nums[0]);\\n                vector<int> ans;\\n                for(int i=1;i<nums.size();i++)\\n                {\\n                    if(!q.empty() && nums[i] - k == q.front())\\n                    {\\n                        ans.push_back(nums[i] - k/2);\\n                        q.pop();\\n                    }\\n                    else\\n                    {\\n                        q.push(nums[i]);\\n                    }\\n                }\\n                if(q.empty())\\n                {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372413,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> mp, mpp;\\n        for(int i = 0; i < nums.size(); i++) {\\n            mp[nums[i]]++;\\n            mpp[nums[i]]++;\\n        }\\n        for(int i = 1; i < n; i++) {\\n            bool ok = true;\\n            int k = (nums[i]-nums[0])/2;\\n            if(k == 0) continue;\\n            vector<int> res;\\n            for(int j = 0; j < n; j++) {\\n                if(mpp[nums[j]] == 0) continue;\\n                if(mpp[nums[j]+2*k] == 0) {\\n                    ok = false;\\n                    break;\\n                }\\n                mpp[nums[j]]--, mpp[nums[j]+2*k]--;\\n                res.push_back(nums[j]+k);\\n            }\\n            mpp = mp;\\n            if(ok) return res;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> mp, mpp;\\n        for(int i = 0; i < nums.size(); i++) {\\n            mp[nums[i]]++;\\n            mpp[nums[i]]++;\\n        }\\n        for(int i = 1; i < n; i++) {\\n            bool ok = true;\\n            int k = (nums[i]-nums[0])/2;\\n            if(k == 0) continue;\\n            vector<int> res;\\n            for(int j = 0; j < n; j++) {\\n                if(mpp[nums[j]] == 0) continue;\\n                if(mpp[nums[j]+2*k] == 0) {\\n                    ok = false;\\n                    break;\\n                }\\n                mpp[nums[j]]--, mpp[nums[j]+2*k]--;\\n                res.push_back(nums[j]+k);\\n            }\\n            mpp = mp;\\n            if(ok) return res;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326118,
                "title": "go-o-n-2-trying-all-values-of-k-full-explanation-with-optimizations",
                "content": "**Approach:**\\nThe problem is twofold -- firstly, we need to find a valid value of `k`, and secondly, we need to pair terms up in a way such that each pair has a difference of `2k`.\\n\\nSo, how can we find values of `k` to test? Well, if a value of `k` is valid, two numbers in `nums` must have difference `2k`, since one has had `k` added and one has had `k` subtracted from the original number. There are up to `O(n^2)` differences, so this is going to take too long. The first observation we need to make is that there is always a lowest member of `nums`, let this be called `x`. Then `x + 2k` must be in the array, since `k > 0`. Therefore, we can check each of the other members of `nums` and find the corresponding `k` for each. This is only `O(n)` potential values of `k` to check, which is already a pretty good improvement.\\n\\nNext, we need to find whether a value of `k` works or not. To do this, we proceed iteratively. Remember when we considered the lowest value of `nums` earlier to find a value of `k`? Well, we\\'re going to use the lowest member again. In particular, let\\'s think about this by iterating through a sorted version of `nums`. Let the current element be `c`. If `c` has already been used because `c - 2k` is also in the array, we continue. Otherwise, we see if `c + 2k` is in the array and has not yet been used. If `c + 2k` is not in the array, then we know that this value of `k` does not work -- we know a corresponding `c - 2k` is not in the array, since it would otherwise have used up this `c` already. If `c + 2k` is in the array, then we mark both as used and move to the next value. If we can empty out the array without any problems, then this is a valid value of `k`.\\n\\nWell, now we want to efficiently check if a value is in an array. We could use binary search, but this adds an extra log factor for no good reason. What\\'s a data structure that supports `O(1)` checking whether an integer is contained? Hash maps! In particular, in our hash map, we store each number in the array and how many of them there are (so `[1, 1, 3, 3]` would have a hash map `{1 -> 2, 3 -> 2}`. When we want to \"use up\" a number, we can just subtract 1 from the value stored in the hash map.\\n\\nTo make getting the final result easier, every time we identify a pair `c` and `c + 2k`, we add `c + k` to an array `res`, keeping track of where we are as we go. Once we finish processing all of `nums`, we will have completely filled in `res`, which can be directly returned.\\n\\n**Optimizations:**\\n\\nInstead of counting the number of times each number appears in `nums` on every iteration of the main loop, which would be inefficient, we do the counting once and create a \"master copy\" of the hash table, which is `origCounts` in my code. Afterward, we create another hash table `remaining`. On each iteration, we copy the values from `origCounts` into `remaining`, which represents the number of each number we still have left. By re-using `remaining` we are able to avoid having to allocate an extra hash table each iteration, which is expensive.\\n\\nOur further optimizations deal with limiting the number of times each loop runs, and determining when an iteration can be skipped.\\n\\nTo reduce the number of iterations the main loop runs, we cap it at `n / 2` rather than `n` where `n` is the length of `nums`. Why? Consider if the value of `k` was created by pairing up element `0` and element `n / 2 + 1`. There are then too many elements left below index `n / 2 + 1`, each of which needs to get paired up with an element above index `n / 2 + 1` or else their difference is less than `nums[n / 2 + 1] - nums[0]`. (This doesn\\'t actually end up mattering because there is always one valid solution guaranteed.)\\n\\nWe also skip an `i` if `nums[i] == nums[i - 1]`, because this means `nums[i] - nums[0] == nums[i - 1] - nums[0]`, indicating that the corresponding value of `k` has been checked already, or `i == 1` and we would get that `k` is 0, which is not allowed. Likewise, if the difference between `nums[i]` and `nums[0]` is odd, then we cannot divide by `2` to find the corresponding value of `k`, so we bail out early of an iteration in this situation.\\n\\nFinally, we use the value of `k` as a flag to show whether pairing up numbers was successful. If we aren\\'t able to pair up a number, then we set `k = -1`, and break out of the inner loop (which pairs up numbers). If we see that `k > 0` after the inner loop, then we know that we have found a valid `k` and can return the contents of `res`, otherwise, we know that this value of `k` failed and we need to test the next one.\\n\\n**Code:**\\n```\\nfunc recoverArray(nums []int) []int {\\n    sort.Ints(nums)\\n    n := len(nums)\\n    origCounts := make(map[int]int)\\n    for _, b := range nums {\\n        origCounts[b]++\\n    }\\n    remaining := make(map[int]int)\\n    res := make([]int, n / 2)\\n    \\n    for i := 1; i <= n / 2; i++ {\\n        if nums[i] == nums[i - 1] {\\n            continue\\n        }\\n        for a, b := range origCounts {\\n            remaining[a] = b\\n        }\\n        k := nums[i] - nums[0]\\n        if k % 2 == 1 {\\n            continue\\n        }\\n        k /= 2\\n        rp := 0\\n        for j := 0; j < n; j++ {\\n            if remaining[nums[j]] == 0 {\\n                continue\\n            }\\n            candidate := nums[j] + 2 * k\\n            if remaining[candidate] == 0 {\\n                k = -1\\n                break\\n            }\\n            res[rp] = nums[j] + k\\n            rp++\\n            remaining[nums[j]]--\\n            remaining[candidate]--\\n        }\\n        if k > 0 {\\n            break\\n        }\\n    }\\n    return res\\n}\\n```\\n\\nIf this helped you, please upvote!",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc recoverArray(nums []int) []int {\\n    sort.Ints(nums)\\n    n := len(nums)\\n    origCounts := make(map[int]int)\\n    for _, b := range nums {\\n        origCounts[b]++\\n    }\\n    remaining := make(map[int]int)\\n    res := make([]int, n / 2)\\n    \\n    for i := 1; i <= n / 2; i++ {\\n        if nums[i] == nums[i - 1] {\\n            continue\\n        }\\n        for a, b := range origCounts {\\n            remaining[a] = b\\n        }\\n        k := nums[i] - nums[0]\\n        if k % 2 == 1 {\\n            continue\\n        }\\n        k /= 2\\n        rp := 0\\n        for j := 0; j < n; j++ {\\n            if remaining[nums[j]] == 0 {\\n                continue\\n            }\\n            candidate := nums[j] + 2 * k\\n            if remaining[candidate] == 0 {\\n                k = -1\\n                break\\n            }\\n            res[rp] = nums[j] + k\\n            rp++\\n            remaining[nums[j]]--\\n            remaining[candidate]--\\n        }\\n        if k > 0 {\\n            break\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126361,
                "title": "easy-to-understand-hashmap-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[nums[i]]++;\\n        int l=0;\\n        int r=(n/2);\\n        int gap=0;\\n        while(l<r)\\n        {\\n            int dif=nums[r]-nums[l];\\n            if(dif%2!=0)\\n            {\\n                r--;\\n                continue;\\n            }\\n            map<int,int> temp=mp;\\n            for(auto it=temp.begin();it!=temp.end();it++)\\n            {\\n                if(temp[it->first]==0)\\n                    continue;\\n                int ele1=it->first;\\n                int ele2=it->first+dif;\\n                if(temp.find(ele2)==temp.end())\\n                    break;\\n                if(temp[ele1]>temp[ele2])\\n                    break;\\n                else\\n                {\\n                    temp[ele2]-=temp[ele1];\\n                    temp[ele1]=0;\\n                }\\n                \\n            }\\n            bool is=true;\\n            for(auto it=temp.begin();it!=temp.end();it++)\\n            {\\n                if(temp[it->first]>0)\\n                {\\n                    is=false;\\n                    break;\\n                }\\n                    \\n            }\\n            if(is && dif%2==0)\\n            {\\n                gap=dif;\\n                break;\\n            }\\n            r--;\\n        }\\n        \\n        vector<int> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++)\\n        {\\n           if(mp[it->first]==0)\\n               continue;\\n            int sz=mp[it->first];\\n            int ele2=it->first+gap;\\n            for(int i=0;i<sz;i++)\\n                ans.push_back((it->first+ele2)/2);\\n            mp[ele2]-=mp[it->first];\\n                \\n        }\\n    \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[nums[i]]++;\\n        int l=0;\\n        int r=(n/2);\\n        int gap=0;\\n        while(l<r)\\n        {\\n            int dif=nums[r]-nums[l];\\n            if(dif%2!=0)\\n            {\\n                r--;\\n                continue;\\n            }\\n            map<int,int> temp=mp;\\n            for(auto it=temp.begin();it!=temp.end();it++)\\n            {\\n                if(temp[it->first]==0)\\n                    continue;\\n                int ele1=it->first;\\n                int ele2=it->first+dif;\\n                if(temp.find(ele2)==temp.end())\\n                    break;\\n                if(temp[ele1]>temp[ele2])\\n                    break;\\n                else\\n                {\\n                    temp[ele2]-=temp[ele1];\\n                    temp[ele1]=0;\\n                }\\n                \\n            }\\n            bool is=true;\\n            for(auto it=temp.begin();it!=temp.end();it++)\\n            {\\n                if(temp[it->first]>0)\\n                {\\n                    is=false;\\n                    break;\\n                }\\n                    \\n            }\\n            if(is && dif%2==0)\\n            {\\n                gap=dif;\\n                break;\\n            }\\n            r--;\\n        }\\n        \\n        vector<int> ans;\\n        for(auto it= mp.begin();it!=mp.end();it++)\\n        {\\n           if(mp[it->first]==0)\\n               continue;\\n            int sz=mp[it->first];\\n            int ele2=it->first+gap;\\n            for(int i=0;i<sz;i++)\\n                ans.push_back((it->first+ele2)/2);\\n            mp[ele2]-=mp[it->first];\\n                \\n        }\\n    \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026955,
                "title": "26ms-compression-solution-with-explanation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        Hint:\\n            PLEASE AS A PREREQUISITE DO SOLVE: https://leetcode.com/problems/find-original-array-from-doubled-array/ \\n            1. There are basically 2 types of elements (X + k) or (X - k), and the problem is you don\\'t know which is which or do you?\\n            2. You can atleast say the smallest element in the array is a (X - k) type and the biggest element is a (X + k) type\\n            3. And if you do know that the smallest element is (smallest - k) how can you use that?\\n            4. If there is a (smallest - k) in the array that means there must be a (smallest + k) as well.\\n            5. (smallest + k) - (smallest - k) = 2 * k\\n            6. You can try with all other elements assuming that it is the (smallest + k) element, and guess a [possible_k]\\n            7. Then you need to check if enough freq of [arr_val + possilbe_k] and [arr_val - possible_k] exists or not.\\n            8. If you have already solved the prerequisite problem then the last part would be a piece of cake.\\n        \\n        Complexity:\\n            Time: O(N * logN + N * N)\\n            Space: O(N)\\n    */\\n    \\n    \\n    #define inf             0x3f3f3f3f\\n    #define all(a)          a.begin(),a.end()\\n    #define Unique(a)       sort(all(a)),a.erase(unique(all(a)),a.end())\\n    int org_frq[2001], frq[2001];\\n    unordered_map <int, int> val_to_id;\\n    vector<int> recoverArray(vector<int>& nums) {\\n        vector <int> compressed; compressed.push_back(-inf);\\n        for (int &val: nums) compressed.push_back(val); Unique(compressed);\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            int index = lower_bound(compressed.begin(), compressed.end(), nums[i]) - compressed.begin();\\n            val_to_id[ nums[i] ] = index;\\n            nums[i] = index;\\n            org_frq[ index ]++;\\n        }\\n        \\n        vector <int> result;\\n        for (int arr_plus_k_id = 2; arr_plus_k_id < compressed.size(); arr_plus_k_id++) {\\n            int possible_k = (compressed[arr_plus_k_id] - compressed[1]);\\n            if (possible_k & 1) continue;\\n            possible_k /= 2;\\n            \\n            memcpy(frq, org_frq, sizeof org_frq);\\n            \\n            for (int plus_k_id = compressed.size() - 1; plus_k_id > 0; plus_k_id--) {\\n                if (frq[ plus_k_id ] == 0) continue;\\n                int minus_k_id = val_to_id[ compressed[plus_k_id] - 2 * possible_k ];\\n                if (minus_k_id == 0 || frq[ minus_k_id ] < frq[ plus_k_id ]) {\\n                    result.clear();\\n                    break;\\n                } \\n                \\n                frq[minus_k_id] -= frq[ plus_k_id ];\\n                for (int time = 0; time < frq[ plus_k_id ]; time++) result.push_back(compressed[plus_k_id] - possible_k);\\n                if (result.size() * 2 == nums.size()) break;\\n            }\\n            \\n            if (result.size()) break;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        Hint:\\n            PLEASE AS A PREREQUISITE DO SOLVE: https://leetcode.com/problems/find-original-array-from-doubled-array/ \\n            1. There are basically 2 types of elements (X + k) or (X - k), and the problem is you don\\'t know which is which or do you?\\n            2. You can atleast say the smallest element in the array is a (X - k) type and the biggest element is a (X + k) type\\n            3. And if you do know that the smallest element is (smallest - k) how can you use that?\\n            4. If there is a (smallest - k) in the array that means there must be a (smallest + k) as well.\\n            5. (smallest + k) - (smallest - k) = 2 * k\\n            6. You can try with all other elements assuming that it is the (smallest + k) element, and guess a [possible_k]\\n            7. Then you need to check if enough freq of [arr_val + possilbe_k] and [arr_val - possible_k] exists or not.\\n            8. If you have already solved the prerequisite problem then the last part would be a piece of cake.\\n        \\n        Complexity:\\n            Time: O(N * logN + N * N)\\n            Space: O(N)\\n    */\\n    \\n    \\n    #define inf             0x3f3f3f3f\\n    #define all(a)          a.begin(),a.end()\\n    #define Unique(a)       sort(all(a)),a.erase(unique(all(a)),a.end())\\n    int org_frq[2001], frq[2001];\\n    unordered_map <int, int> val_to_id;\\n    vector<int> recoverArray(vector<int>& nums) {\\n        vector <int> compressed; compressed.push_back(-inf);\\n        for (int &val: nums) compressed.push_back(val); Unique(compressed);\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            int index = lower_bound(compressed.begin(), compressed.end(), nums[i]) - compressed.begin();\\n            val_to_id[ nums[i] ] = index;\\n            nums[i] = index;\\n            org_frq[ index ]++;\\n        }\\n        \\n        vector <int> result;\\n        for (int arr_plus_k_id = 2; arr_plus_k_id < compressed.size(); arr_plus_k_id++) {\\n            int possible_k = (compressed[arr_plus_k_id] - compressed[1]);\\n            if (possible_k & 1) continue;\\n            possible_k /= 2;\\n            \\n            memcpy(frq, org_frq, sizeof org_frq);\\n            \\n            for (int plus_k_id = compressed.size() - 1; plus_k_id > 0; plus_k_id--) {\\n                if (frq[ plus_k_id ] == 0) continue;\\n                int minus_k_id = val_to_id[ compressed[plus_k_id] - 2 * possible_k ];\\n                if (minus_k_id == 0 || frq[ minus_k_id ] < frq[ plus_k_id ]) {\\n                    result.clear();\\n                    break;\\n                } \\n                \\n                frq[minus_k_id] -= frq[ plus_k_id ];\\n                for (int time = 0; time < frq[ plus_k_id ]; time++) result.push_back(compressed[plus_k_id] - possible_k);\\n                if (result.size() * 2 == nums.size()) break;\\n            }\\n            \\n            if (result.size()) break;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768723,
                "title": "easy-to-understand-all-possible-k-tc-o-k-n-k-is-all-possible-k-values",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size(); \\n        if(n==2) return {(nums[0]+nums[1])/2};\\n        sort(nums.begin(), nums.end()); \\n        \\n        set<int> lower; \\n        for(int i = 1; i < n; i++) {\\n            if((nums[i]-nums[0])%2==0 and nums[i]!=nums[0]) lower.insert((nums[i]-nums[0])/2);\\n        }\\n                \\n        unordered_map<int, int> temp; \\n        for(int i = 0; i < n; i++) {\\n            temp[nums[i]]++;\\n        }\\n        \\n        unordered_map<int, int> check; \\n        for(auto &it : lower) {\\n            int low = it; \\n            \\n            vector<int> res; \\n            int size = 4;\\n            \\n            check = temp; \\n            \\n            res.push_back(nums[0]+low);\\n            check[nums[0]]--;\\n            check[nums[0]+2*low]--; \\n            \\n            \\n            res.push_back(nums[n-1]-low);\\n            check[nums[n-1]]--;\\n            \\n            if(!check[nums[n-1]-2*low]) continue; \\n            \\n            check[nums[n-1]-2*low]--;\\n\\n            for(int i = 0; i < n; i++) {\\n                \\n                if(!check[nums[i]]) continue; \\n                \\n                if(check[nums[i]+2*low]) {\\n                    res.push_back(nums[i]+low);\\n                    check[nums[i]]--;\\n                    check[nums[i]+2*low]--;\\n                    size += 2;\\n                }\\n\\n                else if(check[nums[i]-2*low]){\\n                    res.push_back(nums[i]-low);\\n                    check[nums[i]]--;\\n                    check[nums[i]-2*low]--;\\n                    size += 2;\\n                }\\n\\n            }       \\n            if(size == n) {\\n                return res; \\n            }\\n        }\\n        \\n        return {}; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size(); \\n        if(n==2) return {(nums[0]+nums[1])/2};\\n        sort(nums.begin(), nums.end()); \\n        \\n        set<int> lower; \\n        for(int i = 1; i < n; i++) {\\n            if((nums[i]-nums[0])%2==0 and nums[i]!=nums[0]) lower.insert((nums[i]-nums[0])/2);\\n        }\\n                \\n        unordered_map<int, int> temp; \\n        for(int i = 0; i < n; i++) {\\n            temp[nums[i]]++;\\n        }\\n        \\n        unordered_map<int, int> check; \\n        for(auto &it : lower) {\\n            int low = it; \\n            \\n            vector<int> res; \\n            int size = 4;\\n            \\n            check = temp; \\n            \\n            res.push_back(nums[0]+low);\\n            check[nums[0]]--;\\n            check[nums[0]+2*low]--; \\n            \\n            \\n            res.push_back(nums[n-1]-low);\\n            check[nums[n-1]]--;\\n            \\n            if(!check[nums[n-1]-2*low]) continue; \\n            \\n            check[nums[n-1]-2*low]--;\\n\\n            for(int i = 0; i < n; i++) {\\n                \\n                if(!check[nums[i]]) continue; \\n                \\n                if(check[nums[i]+2*low]) {\\n                    res.push_back(nums[i]+low);\\n                    check[nums[i]]--;\\n                    check[nums[i]+2*low]--;\\n                    size += 2;\\n                }\\n\\n                else if(check[nums[i]-2*low]){\\n                    res.push_back(nums[i]-low);\\n                    check[nums[i]]--;\\n                    check[nums[i]-2*low]--;\\n                    size += 2;\\n                }\\n\\n            }       \\n            if(size == n) {\\n                return res; \\n            }\\n        }\\n        \\n        return {}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739969,
                "title": "python-hash-table-sorting-with-detailed-explanation-fast-and-efficient",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        counter = Counter(nums)  # counter\\n        nums = sorted(counter)   # sorted unique numbers\\n\\n        hm = nums[-1]            # the max number must be the max in the \"higher\" group\\n        for num in nums[:-1]:    # test the corresponding number in the \"lower\" group. Not necessarily the min.\\n            k, m = divmod(hm - num, 2)  # derived \"k\"\\n            if m:                       # there is a remainder, so they are partners\\n                continue\\n            ans = []                    # to store the answer in case this will succeed\\n            cnt = counter.copy()        # not sure if there is a better way than this\\n            for n in nums:              # validation starts now.  start with the smallest value\\n                c = cnt.pop(n)          # its number\\n                if c == 0:              # this value must have been fully considered in the \"higher\" group\\n                    continue\\n                o = n + k                # derived origin\\n                p = o + k                # derived partner\\n                if cnt[p] >= c:          # \"p\" should have enough number. If it has more, the remaining join \"lower\".\\n                    cnt[p] -= c          # reduce the count\\n                    ans.extend([o] * c)  # add them into \"ans\"\\n                else:                    # validation failed\\n                    break\\n            else:\\n                return ans\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        counter = Counter(nums)  # counter\\n        nums = sorted(counter)   # sorted unique numbers\\n\\n        hm = nums[-1]            # the max number must be the max in the \"higher\" group\\n        for num in nums[:-1]:    # test the corresponding number in the \"lower\" group. Not necessarily the min.\\n            k, m = divmod(hm - num, 2)  # derived \"k\"\\n            if m:                       # there is a remainder, so they are partners\\n                continue\\n            ans = []                    # to store the answer in case this will succeed\\n            cnt = counter.copy()        # not sure if there is a better way than this\\n            for n in nums:              # validation starts now.  start with the smallest value\\n                c = cnt.pop(n)          # its number\\n                if c == 0:              # this value must have been fully considered in the \"higher\" group\\n                    continue\\n                o = n + k                # derived origin\\n                p = o + k                # derived partner\\n                if cnt[p] >= c:          # \"p\" should have enough number. If it has more, the remaining join \"lower\".\\n                    cnt[p] -= c          # reduce the count\\n                    ans.extend([o] * c)  # add them into \"ans\"\\n                else:                    # validation failed\\n                    break\\n            else:\\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708136,
                "title": "java-o-n-2-pruning-same-differences",
                "content": "We can see the range of the array is so small. The largest array length is just **1000**. So we can guess the **k** by two different indices elements, and then use hash map to check the answer is right or not.\\nSpecifically, the smallest element must be in the lower array,if it in the higher array,  we can not find the smaller one put in the lower. If the second element is the same as previous, it means it must not be the right answer, because we checked the previous by same value.\\nAnother noteworthy thing is the **k** is positive, so we cannot assign **k** to **0**.\\n\\n``` java\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        // the first index element, must be one of the lower elements,so we just need to calculate all the difference between the first element with other\\n        for(int i = 1; i < n; i++){\\n            //If the seond element is the same as the previous, don\\'t check it\\n            if(i>1&&nums[i]==nums[i-1])\\n                continue;\\n\\n            int diff = nums[i]-nums[0];\\n            //If the difference between two elements is odd, it means we cannot find the answer here\\n            //k cannot be zero\\n            if(diff%2!=0 || diff == 0)\\n                continue;\\n            int[] tmp = findOriginalArray(nums,diff/2);\\n            if(tmp.length>0)\\n                return tmp;\\n        }\\n        return nums;\\n    }\\n\\n    public int[] findOriginalArray(int[] changed,int t) {\\n        int n = changed.length;\\n        if(n%2!=0)\\n            return new int[0];\\n\\n        int[] ans = new int[n/2];\\n        int i = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int item:changed){\\n            //if we find the smaller elements saved ever before,delete it\\n            //otherwise, save it in the hash map\\n            if(!map.containsKey(item-2*t)){\\n                map.putIfAbsent(item,0);\\n                map.put(item,map.get(item)+1);\\n            }else if(map.get(item-2*t)==1){\\n                map.remove(item-2*t);\\n                ans[i++]=item-t;\\n            }else{\\n                map.put(item-2*t,map.get(item-2*t)-1);\\n                ans[i++]=item-t;\\n            }\\n        }\\n\\n        return i==n/2&&map.isEmpty()?ans:new int[0];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        // the first index element, must be one of the lower elements,so we just need to calculate all the difference between the first element with other\\n        for(int i = 1; i < n; i++){\\n            //If the seond element is the same as the previous, don\\'t check it\\n            if(i>1&&nums[i]==nums[i-1])\\n                continue;\\n\\n            int diff = nums[i]-nums[0];\\n            //If the difference between two elements is odd, it means we cannot find the answer here\\n            //k cannot be zero\\n            if(diff%2!=0 || diff == 0)\\n                continue;\\n            int[] tmp = findOriginalArray(nums,diff/2);\\n            if(tmp.length>0)\\n                return tmp;\\n        }\\n        return nums;\\n    }\\n\\n    public int[] findOriginalArray(int[] changed,int t) {\\n        int n = changed.length;\\n        if(n%2!=0)\\n            return new int[0];\\n\\n        int[] ans = new int[n/2];\\n        int i = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int item:changed){\\n            //if we find the smaller elements saved ever before,delete it\\n            //otherwise, save it in the hash map\\n            if(!map.containsKey(item-2*t)){\\n                map.putIfAbsent(item,0);\\n                map.put(item,map.get(item)+1);\\n            }else if(map.get(item-2*t)==1){\\n                map.remove(item-2*t);\\n                ans[i++]=item-t;\\n            }else{\\n                map.put(item-2*t,map.get(item-2*t)-1);\\n                ans[i++]=item-t;\\n            }\\n        }\\n\\n        return i==n/2&&map.isEmpty()?ans:new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651817,
                "title": "golang-simple-brute-force-solution",
                "content": "```go\\nfunc recoverArray(nums []int) []int {\\n\\tsort.Ints(nums)\\n\\tfor pairIndex0 := 1; pairIndex0 < len(nums); pairIndex0++ {\\n\\t\\tif (nums[pairIndex0]-nums[0])%2 != 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tk := (nums[pairIndex0] - nums[0]) / 2\\n\\t\\tif k == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tpairs := make(map[int]int, len(nums))\\n\\t\\toriginal := make([]int, 0, len(nums)/2)\\n\\t\\tfor _, v := range nums {\\n\\t\\t\\tif pairs[v] > 0 {\\n\\t\\t\\t\\tpairs[v]--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpairs[v+k+k]++\\n\\t\\t\\t\\toriginal = append(original, v+k)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tok := true\\n\\t\\tfor _, v := range pairs {\\n\\t\\t\\tif v != 0 {\\n\\t\\t\\t\\tok = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ok {\\n\\t\\t\\treturn original\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc recoverArray(nums []int) []int {\\n\\tsort.Ints(nums)\\n\\tfor pairIndex0 := 1; pairIndex0 < len(nums); pairIndex0++ {\\n\\t\\tif (nums[pairIndex0]-nums[0])%2 != 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tk := (nums[pairIndex0] - nums[0]) / 2\\n\\t\\tif k == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tpairs := make(map[int]int, len(nums))\\n\\t\\toriginal := make([]int, 0, len(nums)/2)\\n\\t\\tfor _, v := range nums {\\n\\t\\t\\tif pairs[v] > 0 {\\n\\t\\t\\t\\tpairs[v]--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpairs[v+k+k]++\\n\\t\\t\\t\\toriginal = append(original, v+k)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tok := true\\n\\t\\tfor _, v := range pairs {\\n\\t\\t\\tif v != 0 {\\n\\t\\t\\t\\tok = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ok {\\n\\t\\t\\treturn original\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1650549,
                "title": "super-easy-to-understand-c-code-beat-100",
                "content": "Idea is straight forward - try every possible k.\\n1. First we sort array and get minimum value - minV in this array, then try all possible `high` value of minV to calculate k.\\nTo get k, minV plus its high value s hould be even, and k can only be larger than 0.\\n2. Then we need to verify if k is valid. Here I use a `used` vector to make sure we didn\\'t use same index again, then use just two pointers to iterate the sorted array. If we can\\'t find matching, just break and try other k.\\n3. During iteration, fill in result array. If we can iterate `n` times, then we found the result.\\n\\n```\\nclass Solution {\\npublic:\\n    bool kernel(int n, vector<int>& nums, int k, vector<bool>& used, vector<int>& result){\\n        int k2 = k + k;\\n        int i = 0;\\n        int lIndex = 0;\\n        int hIndex = 0;\\n        int v1, v2, v;\\n        int n2 = n * 2;\\n        for(; i < n; i++){\\n            while(lIndex < n2 && used[lIndex]){\\n                lIndex++;\\n            }\\n            if(lIndex == n2){\\n                break;\\n            }\\n            v1 = nums[lIndex];\\n            used[lIndex] = true;\\n            v = v1 + k2;\\n            while(hIndex < n2 && (used[hIndex] || nums[hIndex] != v)){\\n                hIndex++;\\n            }\\n            if(hIndex == n2){\\n                break;\\n            }\\n            used[hIndex] = true;\\n            result[i] = v1 + k;\\n        }\\n        \\n        return i == n;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        \\n        int n = nums.size() / 2;\\n        int minV = nums[0];\\n        vector<int> result(n);\\n        int total = n + n;\\n        vector<bool> used(total);\\n        for(int i = 1; i <= n; i++){\\n            if((minV + nums[i]) % 2 == 0){\\n                int k = (nums[i] - minV) / 2;\\n                if(k == 0){\\n                    continue;\\n                }\\n                fill(begin(used), end(used), false);\\n                bool found = kernel(n, nums, k, used, result);\\n                if(found){\\n                    break;\\n                }    \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool kernel(int n, vector<int>& nums, int k, vector<bool>& used, vector<int>& result){\\n        int k2 = k + k;\\n        int i = 0;\\n        int lIndex = 0;\\n        int hIndex = 0;\\n        int v1, v2, v;\\n        int n2 = n * 2;\\n        for(; i < n; i++){\\n            while(lIndex < n2 && used[lIndex]){\\n                lIndex++;\\n            }\\n            if(lIndex == n2){\\n                break;\\n            }\\n            v1 = nums[lIndex];\\n            used[lIndex] = true;\\n            v = v1 + k2;\\n            while(hIndex < n2 && (used[hIndex] || nums[hIndex] != v)){\\n                hIndex++;\\n            }\\n            if(hIndex == n2){\\n                break;\\n            }\\n            used[hIndex] = true;\\n            result[i] = v1 + k;\\n        }\\n        \\n        return i == n;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        \\n        int n = nums.size() / 2;\\n        int minV = nums[0];\\n        vector<int> result(n);\\n        int total = n + n;\\n        vector<bool> used(total);\\n        for(int i = 1; i <= n; i++){\\n            if((minV + nums[i]) % 2 == 0){\\n                int k = (nums[i] - minV) / 2;\\n                if(k == 0){\\n                    continue;\\n                }\\n                fill(begin(used), end(used), false);\\n                bool found = kernel(n, nums, k, used, result);\\n                if(found){\\n                    break;\\n                }    \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650467,
                "title": "java-solution-using-2-pointer-along-with-every-possible-value-of-k-11ms",
                "content": "```\\nclass Solution {\\n    \\n    int[] res;\\n    public int[] recoverArray(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        ArrayList<Integer> diffs = new ArrayList<>();\\n        int smallest = nums[0];\\n        for(int i = 1; i < n; i++){\\n            int k =(nums[i] - smallest) / 2;\\n            if((nums[i] - smallest) % 2 == 0 && k !=0){\\n                diffs.add(k);\\n            }\\n        }\\n        for(int k : diffs){\\n            if(check(n,k,nums)) break;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean check(int n, int k, int[] nums){\\n        res = new int[n/2];\\n        boolean[] visited = new boolean[n];\\n        int lower = 0;\\n        int higher = 1;\\n        int count = 0;\\n        while(lower < n){\\n            \\n            if(visited[lower]){\\n                lower++;\\n                continue;\\n            }\\n            int lowerVal = nums[lower];\\n            int higherVal = lowerVal + (2 * k);\\n            while(higher < n){\\n                if(nums[higher] == higherVal && !visited[higher]) break;\\n                higher++;\\n            }\\n            if(higher == n) return false;\\n            visited[lower] = true;\\n            visited[higher] = true;\\n            res[count] = lowerVal + k;\\n            count++;\\n            if(count == n/2) return true;\\n            lower++;\\n            higher++;\\n        }\\n        return false;\\n    } \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] res;\\n    public int[] recoverArray(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        ArrayList<Integer> diffs = new ArrayList<>();\\n        int smallest = nums[0];\\n        for(int i = 1; i < n; i++){\\n            int k =(nums[i] - smallest) / 2;\\n            if((nums[i] - smallest) % 2 == 0 && k !=0){\\n                diffs.add(k);\\n            }\\n        }\\n        for(int k : diffs){\\n            if(check(n,k,nums)) break;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean check(int n, int k, int[] nums){\\n        res = new int[n/2];\\n        boolean[] visited = new boolean[n];\\n        int lower = 0;\\n        int higher = 1;\\n        int count = 0;\\n        while(lower < n){\\n            \\n            if(visited[lower]){\\n                lower++;\\n                continue;\\n            }\\n            int lowerVal = nums[lower];\\n            int higherVal = lowerVal + (2 * k);\\n            while(higher < n){\\n                if(nums[higher] == higherVal && !visited[higher]) break;\\n                higher++;\\n            }\\n            if(higher == n) return false;\\n            visited[lower] = true;\\n            visited[higher] = true;\\n            res[count] = lowerVal + k;\\n            count++;\\n            if(count == n/2) return true;\\n            lower++;\\n            higher++;\\n        }\\n        return false;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649338,
                "title": "python-o-n-2",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        n = int(len(nums) / 2)\\n        nums.sort()        \\n        \\n        for i in range(1, n * 2):\\n            k = nums[i] - nums[0]\\n            if k != 0 and not k % 2:\\n                higher = collections.defaultdict(int)\\n                original = []\\n                for num in nums:\\n                    if num in higher and higher[num]:\\n                        higher[num] -= 1\\n                    else:\\n                        higher[num + k] += 1\\n                        original.append(num + int(k / 2))\\n                if len(original) == n:\\n                    return original",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        n = int(len(nums) / 2)\\n        nums.sort()        \\n        \\n        for i in range(1, n * 2):\\n            k = nums[i] - nums[0]\\n            if k != 0 and not k % 2:\\n                higher = collections.defaultdict(int)\\n                original = []\\n                for num in nums:\\n                    if num in higher and higher[num]:\\n                        higher[num] -= 1\\n                    else:\\n                        higher[num + k] += 1\\n                        original.append(num + int(k / 2))\\n                if len(original) == n:\\n                    return original",
                "codeTag": "Java"
            },
            {
                "id": 1649132,
                "title": "check-common-possible-k-from-both-sides-java-8ms-100",
                "content": "**Idea**\\nIf we sort `nums`, then `nums[0]` must be is the `lower` value of the smallest value of the original array(`min(arr) - k`).\\nThen, we can check the differences `nums[i] - nums[0]`  for the one that matches all pairs. The differences to consider must be positive and even.\\n\\n**Optimizations**\\n1. We can check only the differences  `nums[i] - nums[0]` for  `1 <= i < n`, since nums[n] is the rightmost possible match for `nums[0]`.\\n2. Similarly to `nums[0]` being the `lower` value of the smallest number in te original array, `nums[2n - 1]` must be the `higher` value of the largest number in the original array(`max(arr) + k`). So we can also find the (positive and even) differences `nums[2n - 1] - nums[i]` (`2n - 1 - n <= i < 2n`) and check only the ones that appear also in the differences found from `nums[i] - nums[0]`.\\n\\n**Complexity**\\nTime: O(n^2)\\nSpace: O(n)\\n\\n**Code**\\n```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        int n2 = nums.length;\\n        int n = n2 / 2;\\n        int[] arr = new int[n];\\n        \\n        Arrays.sort(nums);\\n        // find valid differences: nums[i] - nums[0]\\n        Set<Integer> diffs1 = new HashSet<>();\\n        for (int i = 1; i <= n; i++) {\\n            int cand = nums[i] - nums[0];\\n            if (cand > 0 && (cand & 1) == 0) {\\n                diffs1.add(cand);\\n            }\\n        }\\n        \\n        // find valid differences: nums[2n - 1] - nums[i] that also appear in the nums[i] - nums[0] differences\\n\\t\\t// \\n        Set<Integer> diffs2 = new HashSet<>();\\n        for (int i = n2 - n - 1; i < n2 - 1; i++) {\\n            int cand = nums[n2 - 1] - nums[i];\\n            if (cand > 0 && (cand & 1) == 0 && diffs1.contains(cand)) {\\n                diffs2.add(cand);\\n            }\\n        }\\n        \\n        // check each candidate difference\\n        outer:\\n        for (int diff : diffs2) {\\n            Deque<Integer> dq = new ArrayDeque<>();\\n            int p = 0;\\n            int k = diff / 2;\\n            for (int num : nums) {\\n                if (!dq.isEmpty() && num == dq.peekFirst()) {\\n                    dq.pollFirst();\\n                    continue;\\n                } else {\\n                    if (p == n) continue outer;\\n                    arr[p++] = num + k;\\n                    dq.addLast(num + diff);\\n                }\\n                \\n            }\\n            if (p == n) break;\\n        }\\n        \\n        return arr;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        int n2 = nums.length;\\n        int n = n2 / 2;\\n        int[] arr = new int[n];\\n        \\n        Arrays.sort(nums);\\n        // find valid differences: nums[i] - nums[0]\\n        Set<Integer> diffs1 = new HashSet<>();\\n        for (int i = 1; i <= n; i++) {\\n            int cand = nums[i] - nums[0];\\n            if (cand > 0 && (cand & 1) == 0) {\\n                diffs1.add(cand);\\n            }\\n        }\\n        \\n        // find valid differences: nums[2n - 1] - nums[i] that also appear in the nums[i] - nums[0] differences\\n\\t\\t// \\n        Set<Integer> diffs2 = new HashSet<>();\\n        for (int i = n2 - n - 1; i < n2 - 1; i++) {\\n            int cand = nums[n2 - 1] - nums[i];\\n            if (cand > 0 && (cand & 1) == 0 && diffs1.contains(cand)) {\\n                diffs2.add(cand);\\n            }\\n        }\\n        \\n        // check each candidate difference\\n        outer:\\n        for (int diff : diffs2) {\\n            Deque<Integer> dq = new ArrayDeque<>();\\n            int p = 0;\\n            int k = diff / 2;\\n            for (int num : nums) {\\n                if (!dq.isEmpty() && num == dq.peekFirst()) {\\n                    dq.pollFirst();\\n                    continue;\\n                } else {\\n                    if (p == n) continue outer;\\n                    arr[p++] = num + k;\\n                    dq.addLast(num + diff);\\n                }\\n                \\n            }\\n            if (p == n) break;\\n        }\\n        \\n        return arr;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648908,
                "title": "c-2122-recover-the-original-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); \\n        \\n        map<int, int> cnt; \\n        for (auto& x : nums) ++cnt[x]; \\n        \\n        vector<int> ans; \\n        for (int i = 1; i < nums.size(); ++i) {\\n            int diff = nums[i] - nums[0]; \\n            if (diff && diff % 2 == 0) {\\n                ans.clear(); \\n                bool found = true; \\n                map<int, int> freq = cnt; \\n                for (auto& [k, v] : freq) {\\n                    if (v) {\\n                        if (freq[k + diff] < v) {found = false; break;}\\n                        freq[k+diff] -= v; \\n                        for (; v; --v) ans.push_back(k+diff/2); \\n                    }\\n                }\\n                if (found) break; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end()); \\n        \\n        map<int, int> cnt; \\n        for (auto& x : nums) ++cnt[x]; \\n        \\n        vector<int> ans; \\n        for (int i = 1; i < nums.size(); ++i) {\\n            int diff = nums[i] - nums[0]; \\n            if (diff && diff % 2 == 0) {\\n                ans.clear(); \\n                bool found = true; \\n                map<int, int> freq = cnt; \\n                for (auto& [k, v] : freq) {\\n                    if (v) {\\n                        if (freq[k + diff] < v) {found = false; break;}\\n                        freq[k+diff] -= v; \\n                        for (; v; --v) ans.push_back(k+diff/2); \\n                    }\\n                }\\n                if (found) break; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648237,
                "title": "golang",
                "content": "we know the smallest number in nums, is the smallest number in result + k. From there, try out all possible k from nums[i] - nums[0].\\n\\n```\\nfunc recoverArray(nums []int) []int {\\n    sort.Ints(nums)\\n    freq := make(map[int]int)\\n    for _, n := range nums {\\n        freq[n]++\\n    }\\n    for i := 1; i<len(nums); i++ {\\n        k := nums[i] - nums[0]\\n        if k % 2 == 1 || k == 0 {  // k must be positive\\n            continue\\n        }\\n        k /= 2\\n        temp := make(map[int]int)\\n        for k, v := range freq {\\n            temp[k] = v\\n        }\\n        res := make([]int, 0)\\n        for _, v := range nums {\\n            if temp[v] > 0 {\\n                temp[v]--\\n                if temp[v + 2*k] == 0 {  // invalid k\\n                    break\\n                }\\n                temp[v + 2*k]--\\n                res = append(res, v + k)\\n            }\\n        }\\n        if len(res) == len(nums) / 2 {\\n            return res\\n        }\\n    }\\n    \\n    return nil\\n}\\n\\n\\n/*\\n\\nwe know the smallest number in nums is lowest val in res + k\\n\\nwe can reduce bounds of k to try\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nfunc recoverArray(nums []int) []int {\\n    sort.Ints(nums)\\n    freq := make(map[int]int)\\n    for _, n := range nums {\\n        freq[n]++\\n    }\\n    for i := 1; i<len(nums); i++ {\\n        k := nums[i] - nums[0]\\n        if k % 2 == 1 || k == 0 {  // k must be positive\\n            continue\\n        }\\n        k /= 2\\n        temp := make(map[int]int)\\n        for k, v := range freq {\\n            temp[k] = v\\n        }\\n        res := make([]int, 0)\\n        for _, v := range nums {\\n            if temp[v] > 0 {\\n                temp[v]--\\n                if temp[v + 2*k] == 0 {  // invalid k\\n                    break\\n                }\\n                temp[v + 2*k]--\\n                res = append(res, v + k)\\n            }\\n        }\\n        if len(res) == len(nums) / 2 {\\n            return res\\n        }\\n    }\\n    \\n    return nil\\n}\\n\\n\\n/*\\n\\nwe know the smallest number in nums is lowest val in res + k\\n\\nwe can reduce bounds of k to try\\n\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647894,
                "title": "java-sort-and-try-all-ks-brute-force-with-two-pointers-6ms",
                "content": "Sort the mixed up array and use two pointers within it (i1, i2) to point to elements of the smaller and larger arrays.\\nTry all possible Ks: the first element of the larger array after sorting can be at index in range [1...n]. K is then equal to (nums[i2]-nums[i1])/2  (must be positive).\\n```\\n // i - index of resulting array (ans)\\n // i1/i2next - indexes of smaller array (as subsequence of nums)\\n // i2/i2next - indexes of larger array (as subsequence of nums)\\n\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans[]= null, n= nums.length/2;\\n        for(int i2=1; i2<=n; i2++)\\n            if((ans= attempt(nums, i2))!=null) break;\\n        return ans;\\n    }\\n\\n    int[] attempt(int[] nums, int i2){\\n        int twoN= nums.length, n= twoN/2, i=0, i1= 0;\\n        boolean[] used= new boolean[twoN];\\n        used[i1]= used[i2]= true;\\n\\n        int twoK= nums[i2]-nums[i1], k= twoK/2;\\n        if(twoK==0 || twoK%2==1) return null;\\n        \\n        int[] ans= new int[n];\\n        ans[i++]= nums[i1]+k;\\n        while(i<n){\\n            int i1next= i1+1;\\n            while(i1next<twoN && used[i1next]) i1next++;\\n            if(i1next==twoN) return null;\\n            used[i1next]= true;\\n            \\n            int diff= nums[i1next]-nums[i1], num2next= nums[i2]+diff;\\n            int i2next= i2+1;\\n            while(i2next<twoN && nums[i2next]<num2next) i2next++;\\n            if(i2next==twoN || nums[i2next]!=num2next) return null;\\n            used[i2next]= true;\\n            \\n            ans[i++]= nums[i1next]+k;\\n            i1= i1next;\\n            i2= i2next;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans[]= null, n= nums.length/2;\\n        for(int i2=1; i2<=n; i2++)\\n            if((ans= attempt(nums, i2))!=null) break;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1647692,
                "title": "python3-try-all-valid-k-values",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums):\\n        self.n, self.nums = len(nums) // 2, sorted(nums)\\n\\n        small = self.nums[0]\\n        for x in self.nums[1:]:\\n            k = x - small # this represents 2 * k from the problem statement\\n            if k % 2 or not k: continue\\n            temp = self.valid(k)\\n            if temp: return temp\\n        return []\\n\\n    def valid(self, k):\\n        counts = defaultdict(list)\\n        for i in range(len(self.nums) - 1, -1, -1):\\n            counts[self.nums[i]].append(i)\\n\\n        # go through each value from smallest to largest\\n        # at each value check for corresponding (val + k)\\n        # keep track of which values are used when checking\\n        # ahead for the (val + k)\\n        # finally add (val + k / 2) if we find the corresponding\\n\\t\\t# (val + k) as it is the value from the original array\\n        ans, used = [], [False] * len(self.nums)\\n        for i, v in enumerate(self.nums):\\n            if used[i]: continue\\n            if not counts[v + k]: return []\\n            used[counts[v + k].pop()] = True\\n            ans.append(v + k // 2)\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums):\\n        self.n, self.nums = len(nums) // 2, sorted(nums)\\n\\n        small = self.nums[0]\\n        for x in self.nums[1:]:\\n            k = x - small # this represents 2 * k from the problem statement\\n            if k % 2 or not k: continue\\n            temp = self.valid(k)\\n            if temp: return temp\\n        return []\\n\\n    def valid(self, k):\\n        counts = defaultdict(list)\\n        for i in range(len(self.nums) - 1, -1, -1):\\n            counts[self.nums[i]].append(i)\\n\\n        # go through each value from smallest to largest\\n        # at each value check for corresponding (val + k)\\n        # keep track of which values are used when checking\\n        # ahead for the (val + k)\\n        # finally add (val + k / 2) if we find the corresponding\\n\\t\\t# (val + k) as it is the value from the original array\\n        ans, used = [], [False] * len(self.nums)\\n        for i, v in enumerate(self.nums):\\n            if used[i]: continue\\n            if not counts[v + k]: return []\\n            used[counts[v + k].pop()] = True\\n            ans.append(v + k // 2)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1647551,
                "title": "can-t-we-use-binary-search-on-k-need-help-why-this-fails",
                "content": "i did binary search on value of k (0 to (maxelement-minelement)) \\nif more elements r less than our current assumed k than high=k-1\\nelse low=k+1\\n\\nANSWER:\\nthis fails because our function here is not monotonic in nature\\ni thought maybe counting elements will be enough to steer in one direction but it doesn\\'t gaurantee the solution in that case\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        unordered_map<int,vector<int>> ump;\\n        int n=nums.size();\\n        int low=nums[0],high=nums[0];\\n        for(int i=0;i<n;++i){\\n            ump[nums[i]].push_back(i);\\n            low=min(low,nums[i]);\\n            high=max(high,nums[i]);\\n        }\\n        vector<int> ans(n/2,0);\\n        \\n        high=(high-low);\\n        const int mini=low;\\n        low=0;\\n        \\n        while(low<=high){\\n            int k=low+((high-low)>>1);\\n            vector<int> ans;\\n            int count=n/2,lt=0,gt=0;\\n            vector<int> index(n,0);\\n            \\n            for(int i=0;i<n;++i){\\n                if(index[i]!=0)continue;\\n                if(nums[i]>k+mini)gt++;\\n                else lt++;\\n                \\n                if(ump.find(2*k+nums[i])!=ump.end()){\\n                    bool s=0;\\n                    for(int go:ump[2*k+nums[i]]){\\n                        if(index[go]==0){\\n                            s=1;\\n                            index[go]+=1;\\n                            break;\\n                        }\\n                    }\\n                    if(s){\\n                        ans.push_back(nums[i]+k);\\n                        index[i]+=1;\\n                        count--;\\n                    }\\n                }\\n                \\n            }\\n            \\n            cout<<k<<\" \";\\n            if(count==0){\\n                return ans;\\n            }else{\\n                if(lt>=gt){\\n                    high=k-1;\\n                }else{\\n                    low=k+1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        unordered_map<int,vector<int>> ump;\\n        int n=nums.size();\\n        int low=nums[0],high=nums[0];\\n        for(int i=0;i<n;++i){\\n            ump[nums[i]].push_back(i);\\n            low=min(low,nums[i]);\\n            high=max(high,nums[i]);\\n        }\\n        vector<int> ans(n/2,0);\\n        \\n        high=(high-low);\\n        const int mini=low;\\n        low=0;\\n        \\n        while(low<=high){\\n            int k=low+((high-low)>>1);\\n            vector<int> ans;\\n            int count=n/2,lt=0,gt=0;\\n            vector<int> index(n,0);\\n            \\n            for(int i=0;i<n;++i){\\n                if(index[i]!=0)continue;\\n                if(nums[i]>k+mini)gt++;\\n                else lt++;\\n                \\n                if(ump.find(2*k+nums[i])!=ump.end()){\\n                    bool s=0;\\n                    for(int go:ump[2*k+nums[i]]){\\n                        if(index[go]==0){\\n                            s=1;\\n                            index[go]+=1;\\n                            break;\\n                        }\\n                    }\\n                    if(s){\\n                        ans.push_back(nums[i]+k);\\n                        index[i]+=1;\\n                        count--;\\n                    }\\n                }\\n                \\n            }\\n            \\n            cout<<k<<\" \";\\n            if(count==0){\\n                return ans;\\n            }else{\\n                if(lt>=gt){\\n                    high=k-1;\\n                }else{\\n                    low=k+1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1647449,
                "title": "c-solution-use-brute-foce-to-try-each-k",
                "content": "\\n\\n1. sort the array\\n2. because nums[0] is orginal[0] - k, then we can assume that nums[i] (i > 0) is original[0] + k, then k = `(nums[i] - nums[0]) / 2`\\n3. try all k to find the valid answer.\\n    \\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        multiset<int> ms;\\n        for(auto x : nums) ms.insert(x);\\n        for(int i = 1; i < nums.size(); i++) {\\n            int d = nums[i] - nums[0];\\n            if(d == 0 || d % 2) continue;\\n            int k = d / 2;\\n            auto t = ms;\\n            vector<int> ans;\\n            for(int i = 0; i < nums.size(); i++) {\\n                auto it = t.find(nums[i]);\\n                if(it == t.end()) continue;\\n                if(nums[i] != *t.begin()) break;\\n                auto it2 = t.find(nums[i] + 2 * k);\\n                if(it2 == t.end()) continue;\\n                t.erase(it);\\n                t.erase(it2);\\n                ans.push_back(nums[i] + k);\\n            }\\n            if(t.size() == 0) return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        multiset<int> ms;\\n        for(auto x : nums) ms.insert(x);\\n        for(int i = 1; i < nums.size(); i++) {\\n            int d = nums[i] - nums[0];\\n            if(d == 0 || d % 2) continue;\\n            int k = d / 2;\\n            auto t = ms;\\n            vector<int> ans;\\n            for(int i = 0; i < nums.size(); i++) {\\n                auto it = t.find(nums[i]);\\n                if(it == t.end()) continue;\\n                if(nums[i] != *t.begin()) break;\\n                auto it2 = t.find(nums[i] + 2 * k);\\n                if(it2 == t.end()) continue;\\n                t.erase(it);\\n                t.erase(it2);\\n                ans.push_back(nums[i] + k);\\n            }\\n            if(t.size() == 0) return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762105,
                "title": "my-solutions",
                "content": "**1. Use the `std::map`**\\n```\\n/**\\n * Time Complexity: O(n * n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> recoverArray(vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size()) / 2;\\n    sort(nums.begin(), nums.end());\\n    map<int, int> num_to_count;\\n    for (const int num : nums) {\\n      ++num_to_count[num];\\n    }\\n    \\n    vector<int> ret;\\n    for (int i = 1; i < n + 1; ++i) {\\n      const int twice_k = nums[i] - nums.front();\\n      if (twice_k > 0 && twice_k % 2 == 0 && valid(num_to_count, twice_k, ret)) {\\n        return ret;\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n  \\n private:\\n  bool valid(map<int, int> num_to_count, const int twice_k, vector<int> &result) {\\n    while (!num_to_count.empty()) {\\n      const auto [lower, lower_count] = *num_to_count.begin();\\n      const int higher = lower + twice_k;\\n      auto itr = num_to_count.find(higher);\\n      if (itr == num_to_count.end() || itr->second < lower_count) {\\n        result.clear();\\n        return false;\\n      }\\n      \\n      for (int i = 0; i < lower_count; ++i) {\\n        result.emplace_back((lower + higher) / 2);\\n      }\\n      num_to_count.erase(num_to_count.begin());\\n      itr->second -= lower_count;\\n      if (itr->second == 0) {\\n        num_to_count.erase(itr);\\n      }\\n    }\\n    return true;\\n  }\\n};\\n```\\n**2. Don\\'t use the `std::map`**\\n```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> recoverArray(vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size()) / 2;\\n    sort(nums.begin(), nums.end());\\n    vector<int> ret;\\n    for (int i = 1; i < n + 1; ++i) {\\n      const int twice_k = nums[i] - nums.front();\\n      if (twice_k > 0 && twice_k % 2 == 0) {\\n        ret.clear();\\n        bool visited[2 * n];\\n        memset(visited, 0, sizeof(visited));\\n        int i_lower = 0;\\n        int i_higher = i;\\n        while (static_cast<int>(ret.size()) < n &&\\n               i_higher < 2 * n &&\\n               nums[i_higher] - nums[i_lower] == twice_k) {\\n          visited[i_lower] = true;\\n          visited[i_higher] = true;\\n          ret.emplace_back(nums[i_lower] + twice_k / 2);\\n          for (; i_lower < 2 * n && visited[i_lower]; ++i_lower) {\\n          }\\n          for (;\\n               i_higher < 2 * n && (visited[i_higher] || nums[i_higher] < nums[i_lower] + twice_k);\\n               ++i_higher) {\\n          }\\n        }\\n        if (static_cast<int>(ret.size()) == n) {\\n          return ret;\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> recoverArray(vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size()) / 2;\\n    sort(nums.begin(), nums.end());\\n    map<int, int> num_to_count;\\n    for (const int num : nums) {\\n      ++num_to_count[num];\\n    }\\n    \\n    vector<int> ret;\\n    for (int i = 1; i < n + 1; ++i) {\\n      const int twice_k = nums[i] - nums.front();\\n      if (twice_k > 0 && twice_k % 2 == 0 && valid(num_to_count, twice_k, ret)) {\\n        return ret;\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n  \\n private:\\n  bool valid(map<int, int> num_to_count, const int twice_k, vector<int> &result) {\\n    while (!num_to_count.empty()) {\\n      const auto [lower, lower_count] = *num_to_count.begin();\\n      const int higher = lower + twice_k;\\n      auto itr = num_to_count.find(higher);\\n      if (itr == num_to_count.end() || itr->second < lower_count) {\\n        result.clear();\\n        return false;\\n      }\\n      \\n      for (int i = 0; i < lower_count; ++i) {\\n        result.emplace_back((lower + higher) / 2);\\n      }\\n      num_to_count.erase(num_to_count.begin());\\n      itr->second -= lower_count;\\n      if (itr->second == 0) {\\n        num_to_count.erase(itr);\\n      }\\n    }\\n    return true;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> recoverArray(vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size()) / 2;\\n    sort(nums.begin(), nums.end());\\n    vector<int> ret;\\n    for (int i = 1; i < n + 1; ++i) {\\n      const int twice_k = nums[i] - nums.front();\\n      if (twice_k > 0 && twice_k % 2 == 0) {\\n        ret.clear();\\n        bool visited[2 * n];\\n        memset(visited, 0, sizeof(visited));\\n        int i_lower = 0;\\n        int i_higher = i;\\n        while (static_cast<int>(ret.size()) < n &&\\n               i_higher < 2 * n &&\\n               nums[i_higher] - nums[i_lower] == twice_k) {\\n          visited[i_lower] = true;\\n          visited[i_higher] = true;\\n          ret.emplace_back(nums[i_lower] + twice_k / 2);\\n          for (; i_lower < 2 * n && visited[i_lower]; ++i_lower) {\\n          }\\n          for (;\\n               i_higher < 2 * n && (visited[i_higher] || nums[i_higher] < nums[i_lower] + twice_k);\\n               ++i_higher) {\\n          }\\n        }\\n        if (static_cast<int>(ret.size()) == n) {\\n          return ret;\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701980,
                "title": "simple-approach-using-map-and-all-possible-values-of-k-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problesm. -->\\nFinding all the possible values of K from the nums and then using map tp find out whether given vlue of K is posiible or not.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Sort nums.\\nStep 2: Storing all possible values of K by finding (nums[i]-nums[0])/2;\\nStep 3: Storing frequency of each element of nums in unordered map.\\nStep 4: Using map to figure out whether given value of K is valid.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   /* void solve(int ans)\\n    {\\n        ans = ans - 1;\\n        cout<<ans<<\"\\\\n\";\\n    }*/\\n    \\n    int solve(unordered_map<int , int> m , vector<int>& ans , int k  , vector<int>&nums)\\n    {\\n        \\n        int i,j,l , p;\\n        p = 0;\\n        for(i=0;i<=nums.size()-1;i++)\\n        {\\n            if(m[nums[i]]>0)\\n            {\\n                cout<<\"here\"<<\"\\\\n\";\\n                m[nums[i]]--;\\n                l= nums[i] +2*k;\\n                if(m[l]>0)\\n                {\\n                    m[l]--;\\n                    \\n                    ans.push_back(nums[i] + k);\\n                }else{\\n                    p  = -1;\\n                    break;\\n                }\\n                \\n                \\n                \\n                \\n                \\n            }\\n        }\\n        if(ans.size()>0)\\n        { for(i=0;i<=ans.size()-1;i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n        }}\\n        if(p==-1)\\n        {\\n            return -1;\\n        }\\n        return 1;\\n        \\n        \\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int i,j,k,l;\\n        vector<int> ans;\\n        vector<int> v;\\n       sort(nums.begin() , nums.end());\\n        \\n        for(i =1;i<=nums.size()-1;i++)\\n        {\\n            if((nums[i]-nums[0])%2==0)\\n            {\\n                k = (nums[i] - nums[0])/2;\\n                if(k>0)\\n                {v.push_back(k);}\\n            }\\n        }\\n        \\n        unordered_map<int, int> m;\\n        for(i=0;i<=nums.size()-1;i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        l =-1;\\n        for(i=0;i<=v.size()-1;i++)\\n        {\\n            vector<int> v1;\\n            \\n            if(solve(m ,v1 , v[i] ,nums)==1)\\n            {\\n                cout<<v[i]<<\"\\\\n\";\\n                \\n                return v1;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   /* void solve(int ans)\\n    {\\n        ans = ans - 1;\\n        cout<<ans<<\"\\\\n\";\\n    }*/\\n    \\n    int solve(unordered_map<int , int> m , vector<int>& ans , int k  , vector<int>&nums)\\n    {\\n        \\n        int i,j,l , p;\\n        p = 0;\\n        for(i=0;i<=nums.size()-1;i++)\\n        {\\n            if(m[nums[i]]>0)\\n            {\\n                cout<<\"here\"<<\"\\\\n\";\\n                m[nums[i]]--;\\n                l= nums[i] +2*k;\\n                if(m[l]>0)\\n                {\\n                    m[l]--;\\n                    \\n                    ans.push_back(nums[i] + k);\\n                }else{\\n                    p  = -1;\\n                    break;\\n                }\\n                \\n                \\n                \\n                \\n                \\n            }\\n        }\\n        if(ans.size()>0)\\n        { for(i=0;i<=ans.size()-1;i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n        }}\\n        if(p==-1)\\n        {\\n            return -1;\\n        }\\n        return 1;\\n        \\n        \\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int i,j,k,l;\\n        vector<int> ans;\\n        vector<int> v;\\n       sort(nums.begin() , nums.end());\\n        \\n        for(i =1;i<=nums.size()-1;i++)\\n        {\\n            if((nums[i]-nums[0])%2==0)\\n            {\\n                k = (nums[i] - nums[0])/2;\\n                if(k>0)\\n                {v.push_back(k);}\\n            }\\n        }\\n        \\n        unordered_map<int, int> m;\\n        for(i=0;i<=nums.size()-1;i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        l =-1;\\n        for(i=0;i<=v.size()-1;i++)\\n        {\\n            vector<int> v1;\\n            \\n            if(solve(m ,v1 , v[i] ,nums)==1)\\n            {\\n                cout<<v[i]<<\"\\\\n\";\\n                \\n                return v1;\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3657388,
                "title": "85-in-speed-and-memory-using-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        smallest, largest = nums[0], nums[-1]\\n        nums_counter = Counter(nums)\\n        knums = list(nums_counter.keys())\\n\\n        for knum in knums[1:]:\\n            K = knum - smallest\\n            if K & 1 or smallest + K not in nums_counter or largest - K not in nums_counter:\\n                continue\\n            \\n            ans = []\\n            numsc = nums_counter.copy()\\n                        \\n            for num in knums:\\n                if numsc[num] == 0:\\n                    continue\\n                if num + K not in numsc or numsc[num + K] == 0:\\n                    break\\n            \\n                count = min(numsc[num], numsc[num + K])        \\n                numsc[num] -= count\\n                numsc[num + K] -= count\\n\\n                ans += [num + K//2]*count\\n       \\n            if len(ans) == len(nums) // 2:\\n                return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        smallest, largest = nums[0], nums[-1]\\n        nums_counter = Counter(nums)\\n        knums = list(nums_counter.keys())\\n\\n        for knum in knums[1:]:\\n            K = knum - smallest\\n            if K & 1 or smallest + K not in nums_counter or largest - K not in nums_counter:\\n                continue\\n            \\n            ans = []\\n            numsc = nums_counter.copy()\\n                        \\n            for num in knums:\\n                if numsc[num] == 0:\\n                    continue\\n                if num + K not in numsc or numsc[num + K] == 0:\\n                    break\\n            \\n                count = min(numsc[num], numsc[num + K])        \\n                numsc[num] -= count\\n                numsc[num + K] -= count\\n\\n                ans += [num + K//2]*count\\n       \\n            if len(ans) == len(nums) // 2:\\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559609,
                "title": "simple-solution-using-multiset",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(multiset<int>ms,int n,int k,vector<int>&ans){\\n        while(!ms.empty()){\\n            int smallest1=*ms.begin();\\n            int smallest2=smallest1+2*k;\\n            if(ms.find(smallest2)==ms.end())return false;\\n            ans.push_back(smallest1+k);\\n            ms.erase(ms.begin());\\n            auto it=ms.find(smallest2);\\n            ms.erase(it);\\n        }\\n        return true;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        multiset<int>ms(nums.begin(),nums.end());\\n        int lowest=nums[0];\\n        for(int i=1;i<n;i++){\\n            vector<int>ans;\\n            int highest=nums[i];\\n            if((highest-lowest)%2)continue;\\n            int k=(highest-lowest)/2;\\n            if(k && f(ms,n,k,ans))return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(multiset<int>ms,int n,int k,vector<int>&ans){\\n        while(!ms.empty()){\\n            int smallest1=*ms.begin();\\n            int smallest2=smallest1+2*k;\\n            if(ms.find(smallest2)==ms.end())return false;\\n            ans.push_back(smallest1+k);\\n            ms.erase(ms.begin());\\n            auto it=ms.find(smallest2);\\n            ms.erase(it);\\n        }\\n        return true;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        multiset<int>ms(nums.begin(),nums.end());\\n        int lowest=nums[0];\\n        for(int i=1;i<n;i++){\\n            vector<int>ans;\\n            int highest=nums[i];\\n            if((highest-lowest)%2)continue;\\n            int k=(highest-lowest)/2;\\n            if(k && f(ms,n,k,ans))return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559430,
                "title": "c-hash-table-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought we may have by looking a this question may have binary search. But as we see, we have no criteria to decide when to move left or right in binary search. But by looking at the question, we can see the relation between the elements. Each element is either some element + 2k or - 2k. All we have to do is to find a k that fits. But how can we check if a k fits? Also, how to find possible values of k?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe answer to the first question is, we can check if k satisfies if we take all unique elements of the nums in a sorted order in a array called **vec**. Also we need to store the number of times the unique value has been repeated. To store this we can use an unordered_map called **mp**. Now, when we iterate over the sorted unique values, we check if for any **unique value vec[i]**, does there exist an vec[i] + 2k, as we have already seen the relation. If not, then the k is wrong. Else, we can subtract 1 from the mp[vec[i] + 2k] for each occurence of vec[i]. If we successfully iterate the whole array, then the k is correct. The reason to sort is, we now do not need to care about vec[i] -2k as they have already been visited and they have compensated from vec[i].\\n\\nComing to the second question, how to find possible values of k? For vec[0], there must exist some vec[i] such that vec[i] - vec[0] = 2k, where k is valid, as we there is a guarantee that a valid k exists. So we start iterating from i = 1 to i = vec.size() - 1. For each i, we take a possible value of k = (vec[i] - vec[0])/2. We test for this k. If successful, we are done and found a k. Else we try for next value.\\n\\n**Now, how to find the original array from this k?** We so something similar to the first question, the one where we define the test of k. But here instead of checking if k is correct, we know the k is correct. We take another array to store result called res. In the verification, we subtract 1 from mp[vec[i + 2k]] for each mp[vec[i]], we do the same here, **but we also push vec[i] + k in res for each mp[vec[i]]**. This way the res array contains the final solution.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe sorting of vec array takes $$O(nlogn)$$ time. Finding possible values of k and testing them takes $$O(n^2)$$ time. All unordered map operations are of $$O(1)$$. Obtaining final array takes $$O(n)$$ time. Hence the time complexity is $$O(n^2)$$. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe additional space required is order of $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {        \\n        unordered_map<int, int> m;        \\n        for (auto x: nums) m[x]++;\\n        int ans = -1;\\n        vector<int> vec;\\n        for (auto it = m.begin(); it != m.end(); it++) vec.push_back(it->first);\\n        sort(vec.begin(), vec.end());\\n        int n = vec.size();\\n        for (int i = 1; i < (n); i++){\\n            int val = vec[i] - vec[0];\\n            if (val&1) continue;\\n            unordered_map<int, int> mp;\\n            mp.insert(m.begin(), m.end());\\n            bool fail = false;\\n            for (auto x: vec){\\n                if (mp[x] == 0) continue;\\n                auto it = mp.find(x + val);\\n                if (it == mp.end() || mp[x] > it->second){\\n                    fail = true;\\n                    break;\\n                } \\n                it->second -= mp[x];\\n                mp[x] = 0;\\n            }\\n            if (!fail){\\n                ans = val;\\n                break;\\n            }            \\n        }\\n        vector<int> res;\\n        //cout << ans;\\n        int val = ans/2;\\n        for (auto x: vec){\\n            if (m[x] == 0) continue;\\n            //cout << ans << \" \"; \\n            int clc = x + val;\\n            auto it = m.find(x + ans);\\n            it->second -= m[x];\\n            int z = m[x];\\n            m[x] = 0;\\n            while (z--){\\n                res.push_back(clc);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {        \\n        unordered_map<int, int> m;        \\n        for (auto x: nums) m[x]++;\\n        int ans = -1;\\n        vector<int> vec;\\n        for (auto it = m.begin(); it != m.end(); it++) vec.push_back(it->first);\\n        sort(vec.begin(), vec.end());\\n        int n = vec.size();\\n        for (int i = 1; i < (n); i++){\\n            int val = vec[i] - vec[0];\\n            if (val&1) continue;\\n            unordered_map<int, int> mp;\\n            mp.insert(m.begin(), m.end());\\n            bool fail = false;\\n            for (auto x: vec){\\n                if (mp[x] == 0) continue;\\n                auto it = mp.find(x + val);\\n                if (it == mp.end() || mp[x] > it->second){\\n                    fail = true;\\n                    break;\\n                } \\n                it->second -= mp[x];\\n                mp[x] = 0;\\n            }\\n            if (!fail){\\n                ans = val;\\n                break;\\n            }            \\n        }\\n        vector<int> res;\\n        //cout << ans;\\n        int val = ans/2;\\n        for (auto x: vec){\\n            if (m[x] == 0) continue;\\n            //cout << ans << \" \"; \\n            int clc = x + val;\\n            auto it = m.find(x + ans);\\n            it->second -= m[x];\\n            int z = m[x];\\n            m[x] = 0;\\n            while (z--){\\n                res.push_back(clc);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3494732,
                "title": "java-like-leetcode-954-and-2007-hashmap-with-comments",
                "content": "// b <=============2122. Recover the Original Array ============>\\n    // https://leetcode.com/problems/recover-the-original-array/description/\\n\\n    // Consider [a,b,c,d] to be the original array.\\n    // [a-k,b-k,c-k,d-k] will be the lower array\\n    // [a+k,b+k,c+k,d+k] will be the higher array.\\n\\n    // Humne agar array ko sort kiya, to hume pata hai ki nums[0] humesha lower\\n    // array mai he aayega, kyunki wo smallest value hogi.\\n\\n    // So consider a-k to be the smallest element in the sorted array.\\n    // then (a+k)- (a-k)=2k.\\n\\n    // We know that (a-k) is nums[0].\\n\\n    // So the formula becomes (nums[i] - nums[0]) /2 for getting the various values\\n    // of k.\\n\\n    // Now for each values of k, check if all the pairs are formed. If yes, then\\n    // return the array.\\n\\n```\\npublic int[] recoverArray(int[] nums) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        for (int ele : nums) {\\n            map.put(ele, map.getOrDefault(ele, 0) + 1); // getting the frequency.\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        int[] ans = new int[n / 2];\\n        for (int i = 1; i < n; i++) {\\n            int k = (nums[i] - nums[0]) / 2; // getting all the values of k.\\n\\n            if (k <= 0)\\n                continue; // k cannot be -ve or 0.\\n\\n            HashMap<Integer, Integer> cmap = new HashMap<>(map);\\n            int idx = 0;\\n            for (int ele : nums) {\\n                if (cmap.get(ele) == 0) // Agar kisi element ki frequency 0 hai, to wo already paired hai.\\n                    continue;\\n\\n                int higher = ele + 2 * k;\\n                int lower = ele - 2 * k;\\n\\n                // If a elements gets paired, then we are decreasing the frequency of both\\n                // elements of the pair.\\n                if (cmap.getOrDefault(higher, 0) > 0) {\\n                    cmap.put(ele, cmap.get(ele) - 1);\\n                    cmap.put(higher, cmap.get(higher) - 1);\\n                    ans[idx++] = ele + k;\\n                } else if (cmap.getOrDefault(lower, 0) > 0) {\\n                    cmap.put(ele, cmap.get(ele) - 1);\\n                    cmap.put(lower, cmap.get(lower) - 1);\\n                    ans[idx++] = ele - k;\\n                } else {\\n                    // if the higher or lower cease to exist in the map, then the k value is wrong.\\n                    break;\\n                }\\n            }\\n\\n            // if all the values are paired, then idx will reach to n/2.\\n            if (idx == n / 2)\\n                return ans;\\n        }\\n\\n        return new int[] {};\\n    }\\n```\\n\\n\\n // b <==========954. Array of Doubled Pairs ==========>\\n    // https://leetcode.com/problems/array-of-doubled-pairs/description/\\n\\n    // [0,0,2,4,1,8], [-16,-2,-8,-4] : Test cases to dry run\\n\\n    // Hume basically yahan pe pucha hai ki can we rearrange array such that array\\n    // ` becomes like [a,2a,b,2b,c,2c,d,2d].\\n\\n    // So hume basically har ek element ke liye uska pair dhundhna hai. Aur agar har\\n    // ek element ke liye uska pair mil jata hai to wo rearrange ho sakta hai.\\n\\n    // Humne hashmap mai har ek element ki frequency nikali\\n    // Ab agar humne array ko normally sort kiya to hume array aise milega.\\n    // -16,-8,-4,-2,0,0,1,2,4,8,. Jisme hume -ve elements ke liye unka half check\\n    // karna padega aur +ve elements ke liye unka double.\\n\\n    // Ab agar mai chahta hun ki mujhe har element ka double he check karna page, to\\n    // isiliye maine Arr ko apne hisab se sorrt karunga. To do this, mujhe Apna ek\\n    // Integer class ka array banana padega since int is a primitive type.\\n\\n    // So now the array will be sorted like treating the -ve number as +ve.\\n\\n    // 0,0,1,2,-2,4,-4,-8,8,-16.\\n\\n```\\npublic boolean canReorderDoubled(int[] arr) {\\n\\n        int n = arr.length;\\n        Integer[] Arr = new Integer[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n            Arr[i] = arr[i];\\n        }\\n\\n        Arrays.sort(Arr, (a, b) -> { // Sorting the array as if the -ve number are +ve.\\n            return Math.abs(a) - Math.abs(b);\\n        });\\n\\n        for (int ele : Arr) {\\n            if (map.get(ele) == 0) // If frequency is zero, the element has already been paired.\\n                continue;\\n            if (map.getOrDefault(ele * 2, 0) <= 0) // If we cannot find a 2*ele, we cannot pair this element. Hence\\n                                                   // returning false.\\n                return false;\\n\\n            // Since a pairing requires both elements, decreasing the frequency of both the\\n            // elements of the pair.\\n            map.put(ele, map.get(ele) - 1);\\n            map.put(2 * ele, map.get(ele * 2) - 1);\\n        }\\n\\n        return true;\\n    }\\n```\\n\\n    \\n// b <=========== 2007. Find Original Array From Doubled Array ==========>\\n    // https://leetcode.com/problems/find-original-array-from-doubled-array/description/\\n\\n    // # Logic is same as above.\\n    // # But here no -ve elements, so just normally sort the array.\\n\\n```\\npublic int[] findOriginalArray(int[] arr) {\\n\\n        int n = arr.length;\\n        if (n % 2 == 1)\\n            return new int[] {};\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int ele : arr)\\n            map.put(ele, map.getOrDefault(ele, 0) + 1);\\n\\n        Arrays.sort(arr);\\n\\n        int[] ans = new int[n / 2];\\n        int i = 0;\\n        for (int ele : arr) {\\n            if (map.get(ele) == 0)\\n                continue;\\n\\n            if (map.getOrDefault(ele * 2, 0) <= 0)\\n                return new int[] {};\\n\\n            map.put(ele, map.get(ele) - 1);\\n            map.put(2 * ele, map.get(ele * 2) - 1);\\n            ans[i++] = ele;\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] recoverArray(int[] nums) {\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        for (int ele : nums) {\\n            map.put(ele, map.getOrDefault(ele, 0) + 1); // getting the frequency.\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        int[] ans = new int[n / 2];\\n        for (int i = 1; i < n; i++) {\\n            int k = (nums[i] - nums[0]) / 2; // getting all the values of k.\\n\\n            if (k <= 0)\\n                continue; // k cannot be -ve or 0.\\n\\n            HashMap<Integer, Integer> cmap = new HashMap<>(map);\\n            int idx = 0;\\n            for (int ele : nums) {\\n                if (cmap.get(ele) == 0) // Agar kisi element ki frequency 0 hai, to wo already paired hai.\\n                    continue;\\n\\n                int higher = ele + 2 * k;\\n                int lower = ele - 2 * k;\\n\\n                // If a elements gets paired, then we are decreasing the frequency of both\\n                // elements of the pair.\\n                if (cmap.getOrDefault(higher, 0) > 0) {\\n                    cmap.put(ele, cmap.get(ele) - 1);\\n                    cmap.put(higher, cmap.get(higher) - 1);\\n                    ans[idx++] = ele + k;\\n                } else if (cmap.getOrDefault(lower, 0) > 0) {\\n                    cmap.put(ele, cmap.get(ele) - 1);\\n                    cmap.put(lower, cmap.get(lower) - 1);\\n                    ans[idx++] = ele - k;\\n                } else {\\n                    // if the higher or lower cease to exist in the map, then the k value is wrong.\\n                    break;\\n                }\\n            }\\n\\n            // if all the values are paired, then idx will reach to n/2.\\n            if (idx == n / 2)\\n                return ans;\\n        }\\n\\n        return new int[] {};\\n    }\\n```\n```\\npublic boolean canReorderDoubled(int[] arr) {\\n\\n        int n = arr.length;\\n        Integer[] Arr = new Integer[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);\\n            Arr[i] = arr[i];\\n        }\\n\\n        Arrays.sort(Arr, (a, b) -> { // Sorting the array as if the -ve number are +ve.\\n            return Math.abs(a) - Math.abs(b);\\n        });\\n\\n        for (int ele : Arr) {\\n            if (map.get(ele) == 0) // If frequency is zero, the element has already been paired.\\n                continue;\\n            if (map.getOrDefault(ele * 2, 0) <= 0) // If we cannot find a 2*ele, we cannot pair this element. Hence\\n                                                   // returning false.\\n                return false;\\n\\n            // Since a pairing requires both elements, decreasing the frequency of both the\\n            // elements of the pair.\\n            map.put(ele, map.get(ele) - 1);\\n            map.put(2 * ele, map.get(ele * 2) - 1);\\n        }\\n\\n        return true;\\n    }\\n```\n```\\npublic int[] findOriginalArray(int[] arr) {\\n\\n        int n = arr.length;\\n        if (n % 2 == 1)\\n            return new int[] {};\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int ele : arr)\\n            map.put(ele, map.getOrDefault(ele, 0) + 1);\\n\\n        Arrays.sort(arr);\\n\\n        int[] ans = new int[n / 2];\\n        int i = 0;\\n        for (int ele : arr) {\\n            if (map.get(ele) == 0)\\n                continue;\\n\\n            if (map.getOrDefault(ele * 2, 0) <= 0)\\n                return new int[] {};\\n\\n            map.put(ele, map.get(ele) - 1);\\n            map.put(2 * ele, map.get(ele * 2) - 1);\\n            ans[i++] = ele;\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467994,
                "title": "ruby-solution-in-o-n-2-100-100",
                "content": "# Intuition\\nIt\\'s easy to check if a possible value of k works, and to create the array if you know k.  Find all possible values of k, find one that works, and generate the array.\\n\\n# Approach\\n1. Sort the numbers (to better iterate later)\\n2. Find how often each number occurs in the array\\n3. Find the possibilities for j.  (I\\'m using j to represent 2k.  Note that j must be even.  Also, it can\\'t be 0, so we shift to remove 0 from the array.)\\n4. Check possible j values until finding one that works\\n    a. Start with the first element ele, and decrement ele and ele + j in the count.  If this isn\\'t possible, the value of j is wrong.\\n    b. Go through the rest of the elements in the array (as long as they haven\\'t been removed yet).  If you get through all the elements, return true.\\n5. Find the array for that j value\\n    a. Basically the same process as checking j, but in addition to decrementing the count, add ele + k to an array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef recover_array(nums)\\n    nums.sort!\\n    count = Hash.new(0)\\n    nums.each { |num| count[num] += 1 }\\n\\n    possibilities = nums.uniq.map { |num| num - nums[0] }\\n    possibilities.shift\\n    possibilities.reject! { |j| j % 2 == 1 }\\n\\n    j = false\\n    i = 0\\n\\n    until j\\n        if valid?(nums,count.dup,possibilities[i])\\n            j = possibilities[i]\\n        end\\n        i += 1\\n    end\\n\\n    find_arr(nums,count,j)\\nend\\n\\ndef valid?(nums,count,j)\\n    n = nums.length / 2\\n    i = 0\\n\\n    while n > 0\\n        if count[nums[i]] > 0\\n            count[nums[i]] -= 1\\n            count[nums[i] + j] -= 1\\n            return false if count[nums[i] + j] < 0\\n            n -= 1\\n        end\\n        i += 1\\n    end\\n    true\\nend\\n\\ndef find_arr(nums,count,j)\\n    arr = []\\n    n = nums.length / 2\\n    k = j / 2\\n    i = 0\\n\\n    while n > 0\\n        if count[nums[i]] > 0\\n            count[nums[i]] -= 1\\n            count[nums[i] + j] -= 1\\n            arr << nums[i] + k\\n            n -= 1\\n        end\\n        i += 1\\n    end\\n    arr\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef recover_array(nums)\\n    nums.sort!\\n    count = Hash.new(0)\\n    nums.each { |num| count[num] += 1 }\\n\\n    possibilities = nums.uniq.map { |num| num - nums[0] }\\n    possibilities.shift\\n    possibilities.reject! { |j| j % 2 == 1 }\\n\\n    j = false\\n    i = 0\\n\\n    until j\\n        if valid?(nums,count.dup,possibilities[i])\\n            j = possibilities[i]\\n        end\\n        i += 1\\n    end\\n\\n    find_arr(nums,count,j)\\nend\\n\\ndef valid?(nums,count,j)\\n    n = nums.length / 2\\n    i = 0\\n\\n    while n > 0\\n        if count[nums[i]] > 0\\n            count[nums[i]] -= 1\\n            count[nums[i] + j] -= 1\\n            return false if count[nums[i] + j] < 0\\n            n -= 1\\n        end\\n        i += 1\\n    end\\n    true\\nend\\n\\ndef find_arr(nums,count,j)\\n    arr = []\\n    n = nums.length / 2\\n    k = j / 2\\n    i = 0\\n\\n    while n > 0\\n        if count[nums[i]] > 0\\n            count[nums[i]] -= 1\\n            count[nums[i] + j] -= 1\\n            arr << nums[i] + k\\n            n -= 1\\n        end\\n        i += 1\\n    end\\n    arr\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3455845,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def recoverArray(self, nums):\\n        n = len(nums)\\n\\n        nums.sort()\\n\\n        def dfs(k):\\n            dict1, res = Counter(nums), []\\n\\n            for num in nums:\\n                if dict1[num] and dict1[num+2*k]:\\n                    res.append(num+k)\\n                    dict1[num] -= 1\\n                    dict1[num+2*k] -= 1\\n\\n            if len(res) == n//2: return res\\n\\n            return []\\n\\n        for i in range(n):\\n            if (nums[i]-nums[0]) > 0 and (nums[i]-nums[0])%2 == 0:\\n                res = dfs((nums[i]-nums[0])//2)\\n                if res: return res\\n\\n        return []\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums):\\n        n = len(nums)\\n\\n        nums.sort()\\n\\n        def dfs(k):\\n            dict1, res = Counter(nums), []\\n\\n            for num in nums:\\n                if dict1[num] and dict1[num+2*k]:\\n                    res.append(num+k)\\n                    dict1[num] -= 1\\n                    dict1[num+2*k] -= 1\\n\\n            if len(res) == n//2: return res\\n\\n            return []\\n\\n        for i in range(n):\\n            if (nums[i]-nums[0]) > 0 and (nums[i]-nums[0])%2 == 0:\\n                res = dfs((nums[i]-nums[0])//2)\\n                if res: return res\\n\\n        return []\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440001,
                "title": "python-counter-use-it-to-its-fullest-98ms-fastest-solution-yet-for-slow-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany solutions here cleverly create a counter, and yet iterate through each num in the full array to subtract matching pairs. We can do a little better though. Since we *have* the counter, we can iterate through that instead and remove whole chunks of matched sets in one step\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe same basic O(n^2) solution in most other posts, with a twist. Iterate through counter keys rather than the num array. Subtract counter vals to account for EVERY match of num and num + k in one step.\\n\\nIts a pretty minor optimization, but is neat and you may as well. \\n\\n\\nOriginally I did try deleting key:val pairs in the dict so the dictionary actually gets smaller, and we can exit once its empty (knowing we have the right answer), but this is slower than just checking if the value in the dict == 0. \\n\\n# Complexity\\nInstead of O(n^2), this is technically O(len(counter.keys())^2), though worst case that IS O(n^2). It improves the average and best case analysis though. \\n\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        smallest, largest = nums[0], nums[-1]\\n        nums_counter = Counter(nums)\\n        knums = list(nums_counter.keys())\\n\\n        for knum in knums[1:]:\\n            #technically this is 2k here, but thats less useful.\\n            #Lets say K = 2k\\n            K = knum - smallest\\n            #We know smallest MUST be in the LOWER array, so smallest + K must exist or we have the wrong K. \\n            # Same logic for largest. We can directly test this and maybe stop early\\n            # This test accounts for hundreds of ms in runtime speedup\\n            if K & 1 or smallest + K not in nums_counter or largest - K not in nums_counter:\\n                continue\\n            \\n            #make new copies, dont recreate the counter each time. \\n            ans = []\\n            numsc = nums_counter.copy()\\n                        \\n            for num in knums:\\n                #already accounted for all these\\n                if numsc[num] == 0:\\n                    continue\\n                #Wrong K\\n                if num + K not in numsc or numsc[num + K] == 0:\\n                    break\\n\\n                #Update ALL matched pairs in one step                \\n                count = min(numsc[num], numsc[num + K])        \\n                numsc[num] -= count\\n                numsc[num + K] -= count\\n\\n                # Need to add count many copies of our new num\\n                ans += [num + K//2]*count\\n       \\n            if len(ans) == len(nums) // 2:\\n                return ans                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        smallest, largest = nums[0], nums[-1]\\n        nums_counter = Counter(nums)\\n        knums = list(nums_counter.keys())\\n\\n        for knum in knums[1:]:\\n            #technically this is 2k here, but thats less useful.\\n            #Lets say K = 2k\\n            K = knum - smallest\\n            #We know smallest MUST be in the LOWER array, so smallest + K must exist or we have the wrong K. \\n            # Same logic for largest. We can directly test this and maybe stop early\\n            # This test accounts for hundreds of ms in runtime speedup\\n            if K & 1 or smallest + K not in nums_counter or largest - K not in nums_counter:\\n                continue\\n            \\n            #make new copies, dont recreate the counter each time. \\n            ans = []\\n            numsc = nums_counter.copy()\\n                        \\n            for num in knums:\\n                #already accounted for all these\\n                if numsc[num] == 0:\\n                    continue\\n                #Wrong K\\n                if num + K not in numsc or numsc[num + K] == 0:\\n                    break\\n\\n                #Update ALL matched pairs in one step                \\n                count = min(numsc[num], numsc[num + K])        \\n                numsc[num] -= count\\n                numsc[num + K] -= count\\n\\n                # Need to add count many copies of our new num\\n                ans += [num + K//2]*count\\n       \\n            if len(ans) == len(nums) // 2:\\n                return ans                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254091,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn recover_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut nums = nums;\\n        nums.sort();\\n        let n = nums.len() / 2;\\n        let a = nums[0];\\n        let mut v1 = Vec::with_capacity(n);\\n        let mut v2 = Vec::with_capacity(n);\\n        for i in 1..nums.len() {\\n            let k = nums[i] - a;\\n            if k % 2 == 1 || k == 0 || nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n            v1.clear();\\n            v2.clear();\\n            v1.push(a);\\n            let mut x = 0;\\n            for &num in nums.iter().skip(1) {\\n                if x < v1.len() && num == v1[x] + k {\\n                    v2.push(num);\\n                    x += 1;\\n                } else {\\n                    v1.push(num);\\n                }\\n                if v1.len() > n || v2.len() > n {\\n                    break;\\n                }\\n            }\\n            if v1.len() != n || v2.len() != n {\\n                continue;\\n            }\\n            let mut ans = Vec::with_capacity(n);\\n            for i in 0..n {\\n                ans.push((v1[i] + v2[i]) / 2);\\n            }\\n            return ans;\\n        }\\n        vec![]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn recover_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut nums = nums;\\n        nums.sort();\\n        let n = nums.len() / 2;\\n        let a = nums[0];\\n        let mut v1 = Vec::with_capacity(n);\\n        let mut v2 = Vec::with_capacity(n);\\n        for i in 1..nums.len() {\\n            let k = nums[i] - a;\\n            if k % 2 == 1 || k == 0 || nums[i] == nums[i - 1] {\\n                continue;\\n            }\\n            v1.clear();\\n            v2.clear();\\n            v1.push(a);\\n            let mut x = 0;\\n            for &num in nums.iter().skip(1) {\\n                if x < v1.len() && num == v1[x] + k {\\n                    v2.push(num);\\n                    x += 1;\\n                } else {\\n                    v1.push(num);\\n                }\\n                if v1.len() > n || v2.len() > n {\\n                    break;\\n                }\\n            }\\n            if v1.len() != n || v2.len() != n {\\n                continue;\\n            }\\n            let mut ans = Vec::with_capacity(n);\\n            for i in 0..n {\\n                ans.push((v1[i] + v2[i]) / 2);\\n            }\\n            return ans;\\n        }\\n        vec![]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973080,
                "title": "python-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort nums\\n\\ncreate a dictionary with Counter of all vals\\n\\ncreate a test array testing abs(nums[0] - nums[i]) for i in range(1,n//2+1)\\n\\nthe n//2+1 upperbound is included because if n == 10, and nums is sorted, for nums[0], the maximum index for which nums[0] could be paired up with is nums[5]. \\n\\nThen run a for loop testing each possibility.  the difference has to be divisible by 2 and > 1. Divisible by 2 because the differences we are testing are 2*k, so if the differnece is 7, k would have to be 3.5 which is not an integer and invalid.\\n\\ni copy the dicitonary, and -=1 in the copied dictionary for each [val] and  [val + c], and i break the forloop as soon i encounter a  [val+c] either not in dictionary or with value 0.  \\n\\nbreak the testing for loop as soon as you identify a value that will work, then build the array bestans.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        from collections import Counter\\n        nums.sort()\\n        n = len(nums)\\n        vals = Counter(nums)\\n                \\n        test = [abs(x-nums[0]) for x in nums[1:len(nums)//2+1]]\\n        \\n        ans = 0\\n        for c in test:\\n            if c % 2 != 0 or c==0:\\n                continue\\n            cvals = dict(vals)\\n            flag = 0\\n            for num in nums:\\n                if cvals[num] > 0:\\n                    if num+c in cvals and cvals[num + c] > 0:\\n                        cvals[num] -= 1\\n                        cvals[num+c] -= 1\\n                    else:\\n                        flag = 1\\n                        break\\n            if not flag:\\n                ans = c\\n                break\\n                \\n        bestans = []\\n        for num in nums:\\n            if vals[num] > 0:\\n                bestans.append(num+ans//2)\\n                vals[num] -= 1\\n                vals[num+c] -= 1\\n                \\n        return bestans\\n        \\n            \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        from collections import Counter\\n        nums.sort()\\n        n = len(nums)\\n        vals = Counter(nums)\\n                \\n        test = [abs(x-nums[0]) for x in nums[1:len(nums)//2+1]]\\n        \\n        ans = 0\\n        for c in test:\\n            if c % 2 != 0 or c==0:\\n                continue\\n            cvals = dict(vals)\\n            flag = 0\\n            for num in nums:\\n                if cvals[num] > 0:\\n                    if num+c in cvals and cvals[num + c] > 0:\\n                        cvals[num] -= 1\\n                        cvals[num+c] -= 1\\n                    else:\\n                        flag = 1\\n                        break\\n            if not flag:\\n                ans = c\\n                break\\n                \\n        bestans = []\\n        for num in nums:\\n            if vals[num] > 0:\\n                bestans.append(num+ans//2)\\n                vals[num] -= 1\\n                vals[num+c] -= 1\\n                \\n        return bestans\\n        \\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905893,
                "title": "dart-implementation-o-n-2",
                "content": "# Intuition\\nIf we sort the array, the very first(i.e. min) element will belong to the low array, while one of the i-th elements belongs to the high array.\\nSo we can iterate trough difference b/w first and i-th element and check our array for the match.\\n\\n# Approach\\nUse containers (splay tree map and hash map) to efficiently find pair element within O(N^2)\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  List<int> recoverArray(List<int> nums) {\\n    final nm = SplayTreeMap<int, int>();\\n    nums.forEach((n) { // n * log(n)\\n      if (!nm.containsKey(n))\\n        nm[n] = 1;\\n      else\\n        nm[n] = nm[n]! + 1;\\n    });\\n\\n    int low = nm.firstKey()!;\\n    for (int high in nm.keys) // N\\n    {\\n      int k = high - low;\\n      if (k == 0 || k % 2 != 0) continue;\\n      final check = Map<int, int>.fromEntries(nm.entries);\\n      bool passed = true;\\n      for (var v in nm.keys) { // * N\\n        if (check[v] == 0) continue;\\n        if (!check.containsKey(v + k) || check[v + k]! < check[v]!) {\\n          passed = false;\\n          break;\\n        }\\n        check[v + k] = check[v + k]! - check[v]!;\\n      }\\n      if (passed) {\\n        return check.entries\\n            .where((e) => e.value != 0)\\n            .map((e) => List.generate(e.value, (index) => e.key + k ~/ 2))\\n            .expand((element) => element)\\n            .toList();\\n      }\\n    }\\n    return [];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  List<int> recoverArray(List<int> nums) {\\n    final nm = SplayTreeMap<int, int>();\\n    nums.forEach((n) { // n * log(n)\\n      if (!nm.containsKey(n))\\n        nm[n] = 1;\\n      else\\n        nm[n] = nm[n]! + 1;\\n    });\\n\\n    int low = nm.firstKey()!;\\n    for (int high in nm.keys) // N\\n    {\\n      int k = high - low;\\n      if (k == 0 || k % 2 != 0) continue;\\n      final check = Map<int, int>.fromEntries(nm.entries);\\n      bool passed = true;\\n      for (var v in nm.keys) { // * N\\n        if (check[v] == 0) continue;\\n        if (!check.containsKey(v + k) || check[v + k]! < check[v]!) {\\n          passed = false;\\n          break;\\n        }\\n        check[v + k] = check[v + k]! - check[v]!;\\n      }\\n      if (passed) {\\n        return check.entries\\n            .where((e) => e.value != 0)\\n            .map((e) => List.generate(e.value, (index) => e.key + k ~/ 2))\\n            .expand((element) => element)\\n            .toList();\\n      }\\n    }\\n    return [];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752169,
                "title": "python-solution",
                "content": "```\\ndef recoverArray(self, nums: List[int]) -> List[int]:\\n\\tm, cnter = min(nums), Counter(sorted(nums))\\n\\tfor x in cnter.keys():\\n\\t\\td = x-m\\n\\t\\tif d>0 and d%2==0:\\n\\t\\t\\tcnt, arr = cnter.copy(), []\\n\\t\\t\\tfor n, v in cnt.items():\\n\\t\\t\\t\\tif v:\\n\\t\\t\\t\\t\\tif v<=cnt[n+d]:\\n\\t\\t\\t\\t\\t\\tarr.extend([n+d//2]*v)\\n\\t\\t\\t\\t\\t\\tcnt[n+d] -= v\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif len(arr)==len(nums)//2:\\n\\t\\t\\t\\treturn arr\\n```",
                "solutionTags": [],
                "code": "```\\ndef recoverArray(self, nums: List[int]) -> List[int]:\\n\\tm, cnter = min(nums), Counter(sorted(nums))\\n\\tfor x in cnter.keys():\\n\\t\\td = x-m\\n\\t\\tif d>0 and d%2==0:\\n\\t\\t\\tcnt, arr = cnter.copy(), []\\n\\t\\t\\tfor n, v in cnt.items():\\n\\t\\t\\t\\tif v:\\n\\t\\t\\t\\t\\tif v<=cnt[n+d]:\\n\\t\\t\\t\\t\\t\\tarr.extend([n+d//2]*v)\\n\\t\\t\\t\\t\\t\\tcnt[n+d] -= v\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif len(arr)==len(nums)//2:\\n\\t\\t\\t\\treturn arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2748790,
                "title": "two-solutions-explained-python",
                "content": "**Try all k**\\n**Time: O(n^2)**\\n2 <= 2*k <= max(nums) - min(nums)\\nthe diff higher[i] - lower[i] == 2*k, so even is important.\\nsort the nums and try all differences nums[i] - nums[0].\\nYou can check if a difference is valid in O(N) time. Just use two pointers (i, j). \\ni is a pointer for elements in lower and j is a pointer for elements in higher.\\nif nums[j] - nums[i] == diff then save the j pointer in a set.\\nAt the end of iteration when (j == n) if the size of higher set == size of original array, then its a valid difference.\\n\\n```\\ndef recoverArray(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    nums.sort()\\n\\n    def isValid(diff):\\n        i = j = 0\\n        higher = set()\\n        while j < n:\\n            while i in higher:\\n                i += 1\\n            if j == i:\\n                j = i + 1\\n                continue\\n            if nums[j] - nums[i] == diff:\\n                higher.add(j)\\n                i += 1; j += 1\\n            else: j += 1\\n\\n        if len(higher) == n//2:\\n            return higher\\n    \\n    for i in range(1, n):\\n        k = nums[i] - nums[0]\\n        if k and not k%2:\\n            higher = isValid(k)\\n            if higher:\\n                diff = k//2\\n                return [nums[i] - diff for i in higher]\\n    \\n    return []\\n```\\n**Diff Counter** -- TLE\\n**Time: O(n^2)**\\nthe most common difference for each pair in nums, must be a valid difference value. There is no need to check its validity because question states that a valid answer must exist. \\n```\\ndef recoverArray(self, nums):\\n    n = len(nums)\\n    nums.sort()\\n    \\n    diffFreq = defaultdict(int)\\n    max_freq = 0\\n    for i in range(n):\\n        for j in range(i+1, n):\\n            diff = nums[j] - nums[i]\\n            if diff and not(diff)%2:\\n                diffFreq[diff] += 1\\n\\n                if diffFreq[diff] > max_freq:\\n                    max_freq_diff = diff\\n                    max_freq = diffFreq[diff]\\n    \\n    i = j = 0\\n    higher = set()\\n    while j < n:\\n        while i in higher:\\n            i += 1\\n        if j == i:\\n            j = i + 1\\n            continue\\n        if nums[j] - nums[i] == max_freq_diff:\\n            higher.add(j)\\n            i += 1; j += 1\\n        else:\\n            j += 1\\n\\n    max_freq_diff //= 2\\n    return [nums[i] - max_freq_diff for i in higher]\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\ndef recoverArray(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    nums.sort()\\n\\n    def isValid(diff):\\n        i = j = 0\\n        higher = set()\\n        while j < n:\\n            while i in higher:\\n                i += 1\\n            if j == i:\\n                j = i + 1\\n                continue\\n            if nums[j] - nums[i] == diff:\\n                higher.add(j)\\n                i += 1; j += 1\\n            else: j += 1\\n\\n        if len(higher) == n//2:\\n            return higher\\n    \\n    for i in range(1, n):\\n        k = nums[i] - nums[0]\\n        if k and not k%2:\\n            higher = isValid(k)\\n            if higher:\\n                diff = k//2\\n                return [nums[i] - diff for i in higher]\\n    \\n    return []\\n```\n```\\ndef recoverArray(self, nums):\\n    n = len(nums)\\n    nums.sort()\\n    \\n    diffFreq = defaultdict(int)\\n    max_freq = 0\\n    for i in range(n):\\n        for j in range(i+1, n):\\n            diff = nums[j] - nums[i]\\n            if diff and not(diff)%2:\\n                diffFreq[diff] += 1\\n\\n                if diffFreq[diff] > max_freq:\\n                    max_freq_diff = diff\\n                    max_freq = diffFreq[diff]\\n    \\n    i = j = 0\\n    higher = set()\\n    while j < n:\\n        while i in higher:\\n            i += 1\\n        if j == i:\\n            j = i + 1\\n            continue\\n        if nums[j] - nums[i] == max_freq_diff:\\n            higher.add(j)\\n            i += 1; j += 1\\n        else:\\n            j += 1\\n\\n    max_freq_diff //= 2\\n    return [nums[i] - max_freq_diff for i in higher]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2745627,
                "title": "python-sort-and-try-every-possible-k-while-recover-origin-on-the-fly",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        for i in range(1, len(nums)):\\n\\t\\t\\t# skip the same k or k is odd\\n            if nums[i] == nums[i - 1] or (nums[i] - nums[0]) & 1: continue\\n            k = (nums[i] - nums[0]) // 2\\n            dt = defaultdict(int)\\n            cur = [] # cur to store origin\\n            for v in nums:\\n                if dt[v]:\\n                    dt[v] -= 1\\n                    cur.append(v - k)\\n                else: dt[v + 2 * k] += 1\\n            if len(cur) == len(nums) // 2: return cur\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        for i in range(1, len(nums)):\\n\\t\\t\\t# skip the same k or k is odd\\n            if nums[i] == nums[i - 1] or (nums[i] - nums[0]) & 1: continue\\n            k = (nums[i] - nums[0]) // 2\\n            dt = defaultdict(int)\\n            cur = [] # cur to store origin\\n            for v in nums:\\n                if dt[v]:\\n                    dt[v] -= 1\\n                    cur.append(v - k)\\n                else: dt[v + 2 * k] += 1\\n            if len(cur) == len(nums) // 2: return cur\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725446,
                "title": "c-sort-2-pointers-beats-100",
                "content": "1. find all possible `k`\\n2. sort `nums`\\n3. iterate all possible `k` and use two pointers to check if it works\\n\\nTC : O(n^2)\\nSC : O(n)\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t// find all possible k\\n        unordered_set<long> ks;\\n        for (int i = 1; i < n; i++) {\\n            long sum = nums[i]+nums[0];\\n            if (!(sum&1))\\n                ks.insert(max(nums[0], nums[i])-(sum>>1));\\n        }\\n        sort(nums.begin(), nums.end());\\n        \\n\\t\\t// iterate all possible k and use two pointers to check if it works\\n        vector<int> ans;\\n        for (auto k : ks) {\\n            if (!k) continue;\\n            \\n            long k2 = k<<1;\\n\\t\\t\\t// find the start position of upper to nums[0]\\n            int upperi = lower_bound(nums.begin(), nums.end(), nums[0]+k2) - nums.begin();\\n            if (upperi == n || nums[upperi] != nums[0]+k2) continue; // no such upper\\n            \\n            bool used[2000] = {};\\n            used[0] = used[upperi++] = true;\\n            ans.push_back(nums[0]+k);\\n            \\n            for (int loweri = 1; upperi < n; loweri++) {\\n                if (used[loweri]) continue;\\n                \\n                long upper = nums[loweri]+k2;\\n                while (upperi < n && (upper > nums[upperi] || used[upperi])) upperi++;\\n                \\n                if (upperi == n || upper != nums[upperi]) break;\\n                    \\n                used[upperi++] = true;\\n                ans.push_back(nums[loweri]+k);\\n            }\\n            \\n            if (ans.size() == (n>>1)) break;\\n            \\n            ans.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t// find all possible k\\n        unordered_set<long> ks;\\n        for (int i = 1; i < n; i++) {\\n            long sum = nums[i]+nums[0];\\n            if (!(sum&1))\\n                ks.insert(max(nums[0], nums[i])-(sum>>1));\\n        }\\n        sort(nums.begin(), nums.end());\\n        \\n\\t\\t// iterate all possible k and use two pointers to check if it works\\n        vector<int> ans;\\n        for (auto k : ks) {\\n            if (!k) continue;\\n            \\n            long k2 = k<<1;\\n\\t\\t\\t// find the start position of upper to nums[0]\\n            int upperi = lower_bound(nums.begin(), nums.end(), nums[0]+k2) - nums.begin();\\n            if (upperi == n || nums[upperi] != nums[0]+k2) continue; // no such upper\\n            \\n            bool used[2000] = {};\\n            used[0] = used[upperi++] = true;\\n            ans.push_back(nums[0]+k);\\n            \\n            for (int loweri = 1; upperi < n; loweri++) {\\n                if (used[loweri]) continue;\\n                \\n                long upper = nums[loweri]+k2;\\n                while (upperi < n && (upper > nums[upperi] || used[upperi])) upperi++;\\n                \\n                if (upperi == n || upper != nums[upperi]) break;\\n                    \\n                used[upperi++] = true;\\n                ans.push_back(nums[loweri]+k);\\n            }\\n            \\n            if (ans.size() == (n>>1)) break;\\n            \\n            ans.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702685,
                "title": "python-greedy-hashmap-priority-queue",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        heapify(nums)\\n        n0, h0 = len(nums), Counter(nums)\\n        for kk in map(lambda x: x - nums[0], nums):\\n            if kk <= 0 or kk % 2: continue\\n            ans, nms, n, h = [], nums[:], n0, h0.copy()\\n            while True:\\n                if n == 0: return ans\\n                while not h[nms[0]]: heappop(nms)\\n                num = heappop(nms)\\n                if not h[num + kk]: break\\n                h[num] -= 1\\n                h[num + kk] -= 1\\n                ans.append(num + kk // 2)\\n                n -= 2\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        heapify(nums)\\n        n0, h0 = len(nums), Counter(nums)\\n        for kk in map(lambda x: x - nums[0], nums):\\n            if kk <= 0 or kk % 2: continue\\n            ans, nms, n, h = [], nums[:], n0, h0.copy()\\n            while True:\\n                if n == 0: return ans\\n                while not h[nms[0]]: heappop(nms)\\n                num = heappop(nms)\\n                if not h[num + kk]: break\\n                h[num] -= 1\\n                h[num + kk] -= 1\\n                ans.append(num + kk // 2)\\n                n -= 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668994,
                "title": "rust-105ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn recover_array(nums: Vec<i32>) -> Vec<i32> {\\n        use std::collections::HashMap;\\n        let mut nums = nums.clone();\\n        nums.sort();\\n        let smallest = nums[0];\\n        let mut last_k = -1;\\n        let mut left = HashMap::new();\\n        for &n in &nums {\\n            if !left.contains_key(&n) { left.insert(n, 1); }\\n            else { left.insert(n, left.get(&n).unwrap() + 1); }\\n        }\\n        \\'out: for &n in (&nums[1..]).iter() {\\n            let k = n - smallest;\\n            if k == last_k || k % 2 != 0 || k == 0 { continue; }\\n            last_k = k;\\n            // enumeration\\n            let mut table = left.clone();\\n            let mut ret = Vec::new();\\n            for &n in nums.iter() {\\n                if table.get(&n).unwrap().clone() == 0 { continue; }\\n                let counterpart = n + k;\\n                if !table.contains_key(&counterpart) || table.get(&counterpart).unwrap().clone() == 0\\n                { continue \\'out; }\\n                ret.push(n + k / 2);\\n                table.insert(n, table.get(&n).unwrap() - 1);\\n                table.insert(counterpart, table.get(&counterpart).unwrap() - 1);\\n            }\\n            return ret;\\n        }\\n        return Vec::new();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn recover_array(nums: Vec<i32>) -> Vec<i32> {\\n        use std::collections::HashMap;\\n        let mut nums = nums.clone();\\n        nums.sort();\\n        let smallest = nums[0];\\n        let mut last_k = -1;\\n        let mut left = HashMap::new();\\n        for &n in &nums {\\n            if !left.contains_key(&n) { left.insert(n, 1); }\\n            else { left.insert(n, left.get(&n).unwrap() + 1); }\\n        }\\n        \\'out: for &n in (&nums[1..]).iter() {\\n            let k = n - smallest;\\n            if k == last_k || k % 2 != 0 || k == 0 { continue; }\\n            last_k = k;\\n            // enumeration\\n            let mut table = left.clone();\\n            let mut ret = Vec::new();\\n            for &n in nums.iter() {\\n                if table.get(&n).unwrap().clone() == 0 { continue; }\\n                let counterpart = n + k;\\n                if !table.contains_key(&counterpart) || table.get(&counterpart).unwrap().clone() == 0\\n                { continue \\'out; }\\n                ret.push(n + k / 2);\\n                table.insert(n, table.get(&n).unwrap() - 1);\\n                table.insert(counterpart, table.get(&counterpart).unwrap() - 1);\\n            }\\n            return ret;\\n        }\\n        return Vec::new();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592433,
                "title": "python-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        sz = len(nums)\\n        nums.sort()\\n        for i in range(1, sz):\\n            k, hashMap = nums[i] - nums[0], Counter(nums)\\n            if k % 2 or k == 0:\\n                continue\\n            ans, gotIt = [], True\\n            for j in range(sz):\\n                if hashMap[nums[j]]:\\n                    if nums[j] + k in hashMap and hashMap[nums[j] + k] > 0:\\n                        ans.append(nums[j] + k // 2)\\n                        hashMap[nums[j]] -= 1\\n                        hashMap[nums[j] + k] -= 1\\n                    else:\\n                        gotIt = False\\n                        break\\n            if gotIt:\\n                return ans\\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        sz = len(nums)\\n        nums.sort()\\n        for i in range(1, sz):\\n            k, hashMap = nums[i] - nums[0], Counter(nums)\\n            if k % 2 or k == 0:\\n                continue\\n            ans, gotIt = [], True\\n            for j in range(sz):\\n                if hashMap[nums[j]]:\\n                    if nums[j] + k in hashMap and hashMap[nums[j] + k] > 0:\\n                        ans.append(nums[j] + k // 2)\\n                        hashMap[nums[j]] -= 1\\n                        hashMap[nums[j] + k] -= 1\\n                    else:\\n                        gotIt = False\\n                        break\\n            if gotIt:\\n                return ans\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581293,
                "title": "simple-python-solution",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findOriginalArray(self, changed: List[int], target : int):\\n        changed.sort()\\n        c1,c2,length = 0,0,len(changed)\\n        count_map = Counter(changed)\\n        original = []\\n        if length%2 :\\n            return original\\n        while (c1 != length//2 and c2 < length):\\n            if count_map[changed[c2]] > 0 :\\n                count_map[changed[c2]] -= 1\\n                if count_map[changed[c2] + 2*target] > 0:\\n                    original.append(changed[c2])\\n                    count_map[changed[c2] + 2*target] -= 1\\n                    c1 += 1\\n                else:\\n                    return []\\n            elif (c2 == length-1):\\n                return []\\n            c2 += 1 \\n        return original\\n    def getk(self,nums: List[int], k):\\n        nums_cache = defaultdict(bool)\\n        for i in nums:\\n            nums_cache[i] = True\\n        for i in nums[1:]:\\n            k = (i-nums[0])//2 if i != nums[0] and (i-nums[0])%2==0 else k+1\\n            print(k)\\n            if nums_cache[nums[-1] - 2*k]:\\n                break\\n        return k\\n    \\n    \\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        k = 1\\n        original = []\\n        nums_cache = defaultdict(bool)\\n        for i in nums:\\n            nums_cache[i] = True\\n        while(len(original) == 0):\\n            for i in nums[1:]:\\n                k = (i-nums[0])//2 if (i - nums[0]) >= 2 else k+1\\n                if nums_cache[nums[-1] - 2*k] and nums_cache[nums[0] + 2*k]:\\n                    original = self.findOriginalArray(nums, k)\\n                if len(original):\\n                    break\\n        return map(lambda x:x+k, original)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findOriginalArray(self, changed: List[int], target : int):\\n        changed.sort()\\n        c1,c2,length = 0,0,len(changed)\\n        count_map = Counter(changed)\\n        original = []\\n        if length%2 :\\n            return original\\n        while (c1 != length//2 and c2 < length):\\n            if count_map[changed[c2]] > 0 :\\n                count_map[changed[c2]] -= 1\\n                if count_map[changed[c2] + 2*target] > 0:\\n                    original.append(changed[c2])\\n                    count_map[changed[c2] + 2*target] -= 1\\n                    c1 += 1\\n                else:\\n                    return []\\n            elif (c2 == length-1):\\n                return []\\n            c2 += 1 \\n        return original\\n    def getk(self,nums: List[int], k):\\n        nums_cache = defaultdict(bool)\\n        for i in nums:\\n            nums_cache[i] = True\\n        for i in nums[1:]:\\n            k = (i-nums[0])//2 if i != nums[0] and (i-nums[0])%2==0 else k+1\\n            print(k)\\n            if nums_cache[nums[-1] - 2*k]:\\n                break\\n        return k\\n    \\n    \\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        k = 1\\n        original = []\\n        nums_cache = defaultdict(bool)\\n        for i in nums:\\n            nums_cache[i] = True\\n        while(len(original) == 0):\\n            for i in nums[1:]:\\n                k = (i-nums[0])//2 if (i - nums[0]) >= 2 else k+1\\n                if nums_cache[nums[-1] - 2*k] and nums_cache[nums[0] + 2*k]:\\n                    original = self.findOriginalArray(nums, k)\\n                if len(original):\\n                    break\\n        return map(lambda x:x+k, original)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581218,
                "title": "c-multiset-brute-force",
                "content": "***Approach***\\nstep 1:- Sort the array.\\nstep 2:- The smallest element will be the first element of lower array. So find every possible of values of K with respect to the smallest element.\\nstep 3:- If the total number of count is equal to the size of the array for any K then simply return the array.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            int k=nums[i]-nums[0];\\n            if(k==0 || k%2!=0){\\n                continue;\\n            }\\n\\t\\t\\t// multiset to avoid the problem of duplicate elements in the array.\\n            multiset<int> ms(nums.begin(),nums.end());\\n            int cnt=0;\\n            vector<int> ans;\\n            while(!ms.empty()){\\n                int low=*ms.begin();\\n                int high=low+k;\\n                if(ms.find(high)!=ms.end()){\\n                    ans.push_back(low+(k/2));\\n                    ms.erase(ms.begin());\\n                    auto it=ms.find(high);\\n                    ms.erase(it);\\n                    cnt+=2;\\n                }\\n                else break;\\n            }\\n            if(cnt==n){\\n                return ans;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            int k=nums[i]-nums[0];\\n            if(k==0 || k%2!=0){\\n                continue;\\n            }\\n\\t\\t\\t// multiset to avoid the problem of duplicate elements in the array.\\n            multiset<int> ms(nums.begin(),nums.end());\\n            int cnt=0;\\n            vector<int> ans;\\n            while(!ms.empty()){\\n                int low=*ms.begin();\\n                int high=low+k;\\n                if(ms.find(high)!=ms.end()){\\n                    ans.push_back(low+(k/2));\\n                    ms.erase(ms.begin());\\n                    auto it=ms.find(high);\\n                    ms.erase(it);\\n                    cnt+=2;\\n                }\\n                else break;\\n            }\\n            if(cnt==n){\\n                return ans;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580772,
                "title": "c",
                "content": "\\n\\n\"\"\"\\n\\nclass Solution {\\n    \\nprivate:\\n  bool solve(multiset<int>ms,vector<int>&ans,int k){\\n      \\n     while(!ms.empty()){\\n         int low=*ms.begin();\\n         int high=low+2*k;\\n          \\n          if(ms.find(high)==ms.end())return false;\\n          \\n          ans.push_back(low+k);\\n          \\n          ms.erase(ms.begin());\\n          auto it=ms.find(high);\\n          ms.erase(it);   \\n      } \\n      return true;    \\n  }  \\n    \\npublic:\\n    \\n    \\n    vector<int> recoverArray(vector<int>& arr) {\\n    sort(arr.begin(),arr.end());\\n    int n=arr.size();\\n        multiset<int>ms(arr.begin(),arr.end());\\n        \\n    int low=arr[0];\\n        \\n        for(int i=1;i<n;i++){\\n            vector<int>ans;\\n            int high=arr[i];\\n            if((high-low)%2==0){\\n            int k=(high-low)/2;\\n         if(k&&solve(ms,ans,k)){\\n             return ans;\\n         }   \\n   \\n        }\\n        }\\n        \\n        return {};\\n    }\\n    \\n};\\n\\n\"\"\"",
                "solutionTags": [],
                "code": "class Solution {\\n    \\nprivate:\\n  bool solve(multiset<int>ms,vector<int>&ans,int k){\\n      \\n     while(!ms.empty()){\\n         int low=*ms.begin();\\n         int high=low+2*k;\\n          \\n          if(ms.find(high)==ms.end())return false;\\n          \\n          ans.push_back(low+k);\\n          \\n          ms.erase(ms.begin());\\n          auto it=ms.find(high);\\n          ms.erase(it);   \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2580101,
                "title": "c-o-n-2-easy-approach-explained-hashmap",
                "content": "This solution is next level of question : https://leetcode.com/problems/find-original-array-from-doubled-array/\\n\\nLets say we have any arbitary value for K ,\\n* We will first sort the array and store frequency all the element in  a map ;\\n* We will go by each  element and check if that nums[i] and nums[i] +k*2 is present in map if yes we will push  it to answers and subtract 1 value in map for both  nums[i] and nums[i] +k*2 ;\\n*  if condition do not staicify we will break loop and solution is not present for given value of K .\\n* So we will follow above steps for all possible values of k \\n* To get all  possible values of k  we will sutract first elemt in nums from each value present in nums. (as k will be same for all elements including first ).\\n\\ncode : \\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n            int k = nums[i]-nums[0];\\n            if(k%2!=0 || k==0){\\n                continue;\\n            }\\n            unordered_map<int,int> mp;\\n            for(int i=0;i<n;i++){\\n                mp[nums[i]]++;\\n            }\\n            vector<int> ans;\\n            bool gotit=true;\\n            for(int i=0;i<n;i++){\\n                if(mp[nums[i]]!=0){\\n                    if(mp.count(nums[i]+k)!=0 && mp[nums[i]+k]>0){\\n                        ans.push_back(nums[i]+k/2);\\n                        mp[nums[i]]--;\\n                        mp[nums[i]+k]--;\\n                    }\\n                    else{\\n                        gotit=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(gotit){\\n                return ans;\\n            }\\n            \\n        }\\n        return {};\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n            int k = nums[i]-nums[0];\\n            if(k%2!=0 || k==0){\\n                continue;\\n            }\\n            unordered_map<int,int> mp;\\n            for(int i=0;i<n;i++){\\n                mp[nums[i]]++;\\n            }\\n            vector<int> ans;\\n            bool gotit=true;\\n            for(int i=0;i<n;i++){\\n                if(mp[nums[i]]!=0){\\n                    if(mp.count(nums[i]+k)!=0 && mp[nums[i]+k]>0){\\n                        ans.push_back(nums[i]+k/2);\\n                        mp[nums[i]]--;\\n                        mp[nums[i]+k]--;\\n                    }\\n                    else{\\n                        gotit=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(gotit){\\n                return ans;\\n            }\\n            \\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491703,
                "title": "clean-and-well-structured-python3-implementation-top-93-2-very-simple",
                "content": "I found this Github repository with solutions to Leetcode problems https://github.com/AnasImloul/Leetcode-solutions\\nThe ability to find every solution in one location is very helpful, I hope it helps you too\\n```\\nclass Solution(object):\\n    def recoverArray(self, nums):\\n        nums.sort()\\n        mid = len(nums) // 2\\n        # All possible k are (nums[j] - nums[0]) // 2, otherwise there is no num that satisfies nums[0] + k = num - k.\\n        # For nums is sorted, so that any 2 elements (x, y) in nums[1:j] cannot satisfy x + k = y - k.\\n        # In other words, for any x in nums[1:j], it needs to find y from nums[j + 1:] to satisfy x + k = y - k, but\\n        # unfortunately if j > mid, then len(nums[j + 1:]) < mid <= len(nums[1:j]), nums[j + 1:] are not enough.\\n        # The conclusion is j <= mid.\\n\\t\\t# If you think it\\u2019s not easy to understand why mid is enough, len(nums) can also work well\\n\\t\\t# for j in range(1, len(nums)):  \\n        for j in range(1, mid + 1):  # O(N)\\n            if nums[j] - nums[0] > 0 and (nums[j] - nums[0]) % 2 == 0:  # Note the problem described k is positive.\\n                k, counter, ans = (nums[j] - nums[0]) // 2, collections.Counter(nums), []\\n                # For each number in lower, we try to find the corresponding number from higher list.\\n                # Because nums is sorted, current n is always the current lowest num which can only come from lower\\n                # list, so we search the corresponding number of n which equals to n + 2 * k in the left\\n                # if it can not be found, change another k and continue to try.\\n                for n in nums:  # check if n + 2 * k available as corresponding number in higher list of n\\n                    if counter[n] == 0:  # removed by previous num as its corresponding number in higher list\\n                        continue\\n                    if counter[n + 2 * k] == 0:  # not found corresponding number in higher list\\n                        break\\n                    ans.append(n + k)\\n                    counter[n] -= 1  # remove n\\n                    counter[n + 2 * k] -= 1  # remove the corresponding number in higher list\\n                if len(ans) == mid:\\n                    return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverArray(self, nums):\\n        nums.sort()\\n        mid = len(nums) // 2\\n        # All possible k are (nums[j] - nums[0]) // 2, otherwise there is no num that satisfies nums[0] + k = num - k.\\n        # For nums is sorted, so that any 2 elements (x, y) in nums[1:j] cannot satisfy x + k = y - k.\\n        # In other words, for any x in nums[1:j], it needs to find y from nums[j + 1:] to satisfy x + k = y - k, but\\n        # unfortunately if j > mid, then len(nums[j + 1:]) < mid <= len(nums[1:j]), nums[j + 1:] are not enough.\\n        # The conclusion is j <= mid.\\n\\t\\t# If you think it\\u2019s not easy to understand why mid is enough, len(nums) can also work well\\n\\t\\t# for j in range(1, len(nums)):  \\n        for j in range(1, mid + 1):  # O(N)\\n            if nums[j] - nums[0] > 0 and (nums[j] - nums[0]) % 2 == 0:  # Note the problem described k is positive.\\n                k, counter, ans = (nums[j] - nums[0]) // 2, collections.Counter(nums), []\\n                # For each number in lower, we try to find the corresponding number from higher list.\\n                # Because nums is sorted, current n is always the current lowest num which can only come from lower\\n                # list, so we search the corresponding number of n which equals to n + 2 * k in the left\\n                # if it can not be found, change another k and continue to try.\\n                for n in nums:  # check if n + 2 * k available as corresponding number in higher list of n\\n                    if counter[n] == 0:  # removed by previous num as its corresponding number in higher list\\n                        continue\\n                    if counter[n + 2 * k] == 0:  # not found corresponding number in higher list\\n                        break\\n                    ans.append(n + k)\\n                    counter[n] -= 1  # remove n\\n                    counter[n + 2 * k] -= 1  # remove the corresponding number in higher list\\n                if len(ans) == mid:\\n                    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362393,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        \\n        dis = list(set([nums[i] - nums[0] for i in range(1, len(nums) // 2 + 1) if (nums[i] - nums[0]) % 2 == 0]))\\n        rec = OrderedDict()\\n        pos = defaultdict(deque)\\n\\n        res = []\\n        \\n        for i, num in enumerate(nums):\\n            if num not in rec: rec[num] = 1\\n            else: rec[num] += 1\\n            pos[num].append(i)\\n        \\n        for d in dis:\\n            if d == 0: continue\\n            new = rec.copy()\\n            fail = False\\n\\n            for k in rec.keys():\\n                if new[k] == 0: continue\\n                if k + d not in new or new[k + d] < new[k]:\\n                    fail = not fail\\n                    break\\n                new[k + d] -= new[k]\\n                new[k] = 0\\n\\n            if fail: continue\\n\\n            visited = set()\\n            \\n            for i, n in enumerate(nums):\\n                if i in visited: continue\\n                res.append(n + d // 2)\\n                visited.add(pos[n].popleft())\\n                visited.add(pos[n + d].popleft())\\n            break\\n            \\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        \\n        dis = list(set([nums[i] - nums[0] for i in range(1, len(nums) // 2 + 1) if (nums[i] - nums[0]) % 2 == 0]))\\n        rec = OrderedDict()\\n        pos = defaultdict(deque)\\n\\n        res = []\\n        \\n        for i, num in enumerate(nums):\\n            if num not in rec: rec[num] = 1\\n            else: rec[num] += 1\\n            pos[num].append(i)\\n        \\n        for d in dis:\\n            if d == 0: continue\\n            new = rec.copy()\\n            fail = False\\n\\n            for k in rec.keys():\\n                if new[k] == 0: continue\\n                if k + d not in new or new[k + d] < new[k]:\\n                    fail = not fail\\n                    break\\n                new[k + d] -= new[k]\\n                new[k] = 0\\n\\n            if fail: continue\\n\\n            visited = set()\\n            \\n            for i, n in enumerate(nums):\\n                if i in visited: continue\\n                res.append(n + d // 2)\\n                visited.add(pos[n].popleft())\\n                visited.add(pos[n + d].popleft())\\n            break\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2258927,
                "title": "java-try-all-possible-k",
                "content": "```\\n   public int[] recoverArray(int[] nums) {\\n        var count = new HashMap<Integer, Integer>();\\n        int max = 0;\\n        for (int a : nums) {\\n            max = Math.max(max, a);\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        }\\n        var uniques = new ArrayList<Integer>(count.keySet());\\n        Collections.sort(uniques);\\n        \\n        var possibleK = new ArrayList<Integer>();\\n        for (int i = 1, kk; i<uniques.size(); i++) {\\n            kk = uniques.get(i) - uniques.get(0);\\n            if (kk % 2 == 0) {\\n                possibleK.add(kk / 2);\\n            }\\n        }\\n        \\n        for (int k : possibleK) {\\n            var cloneCount = (HashMap<Integer, Integer>) count.clone();\\n            var res = tryK(uniques, cloneCount, k, nums.length/2);\\n            if (res != null) {\\n                return res;\\n            }\\n        }\\n        \\n        return null;\\n\\n    }\\n    \\n    public int[] tryK(List<Integer> uniques, HashMap<Integer, Integer> count, int k, int n) {\\n        var ans = new int[n];\\n        int cur = 0;\\n        for (int a : uniques) {\\n            if (count.getOrDefault(a, 0) == 0) \\n                continue;\\n            int c = count.get(a);\\n            int d = count.getOrDefault(a + 2*k, 0) - c;\\n            if (d < 0)\\n                return null;\\n            while (c-- > 0) {\\n                ans[cur++] = a + k;\\n            }\\n            count.remove(a);\\n            count.put(a+2*k, d);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int[] recoverArray(int[] nums) {\\n        var count = new HashMap<Integer, Integer>();\\n        int max = 0;\\n        for (int a : nums) {\\n            max = Math.max(max, a);\\n            count.put(a, count.getOrDefault(a, 0) + 1);\\n        }\\n        var uniques = new ArrayList<Integer>(count.keySet());\\n        Collections.sort(uniques);\\n        \\n        var possibleK = new ArrayList<Integer>();\\n        for (int i = 1, kk; i<uniques.size(); i++) {\\n            kk = uniques.get(i) - uniques.get(0);\\n            if (kk % 2 == 0) {\\n                possibleK.add(kk / 2);\\n            }\\n        }\\n        \\n        for (int k : possibleK) {\\n            var cloneCount = (HashMap<Integer, Integer>) count.clone();\\n            var res = tryK(uniques, cloneCount, k, nums.length/2);\\n            if (res != null) {\\n                return res;\\n            }\\n        }\\n        \\n        return null;\\n\\n    }\\n    \\n    public int[] tryK(List<Integer> uniques, HashMap<Integer, Integer> count, int k, int n) {\\n        var ans = new int[n];\\n        int cur = 0;\\n        for (int a : uniques) {\\n            if (count.getOrDefault(a, 0) == 0) \\n                continue;\\n            int c = count.get(a);\\n            int d = count.getOrDefault(a + 2*k, 0) - c;\\n            if (d < 0)\\n                return null;\\n            while (c-- > 0) {\\n                ans[cur++] = a + k;\\n            }\\n            count.remove(a);\\n            count.put(a+2*k, d);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2133692,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        \\n        \\n        \\n        nums.sort()\\n        n=len(nums)\\n        if n==2:\\n            return [(nums[0]+nums[-1])//2]\\n        hash={}\\n        \\n        for x in nums:\\n            if x not in hash:\\n                hash[x]=0\\n            hash[x]+=1\\n        mn=nums[0]\\n        mx=nums[-1]\\n        \\n        def check(k,nums,hash1,ans):\\n            for i in range(len(nums)):\\n                if nums[i] in hash1:\\n                    if nums[i]+2*k in hash1:\\n                        z=nums[i]+2*k\\n                        ans.append((nums[i]+z)//2)\\n                        \\n                        if hash1[nums[i]]==1:\\n                            del hash1[nums[i]]\\n                        \\n                        else:\\n                            hash1[nums[i]]-=1\\n                        \\n                        if hash1[z]==1:\\n                            del hash1[z]\\n                        \\n                        else:\\n                            hash1[z]-=1\\n                    else:\\n                        break\\n                     \\n            return len(hash1)==0\\n                        \\n                        \\n                    \\n                    \\n                    \\n        \\n        for i in range(1,n):\\n                        \\n\\n            k=nums[i]-nums[0]\\n            \\n            if k%2==0 and k!=0:\\n                ans=[]\\n                hash1=hash.copy()\\n                if check(k//2,nums,hash1,ans):\\n                    return ans\\n            \\n                        \\n                    \\n                    \\n                    \\n                \\n            \\n        \\n        \\n        \\n        \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        \\n        \\n        \\n        nums.sort()\\n        n=len(nums)\\n        if n==2:\\n            return [(nums[0]+nums[-1])//2]\\n        hash={}\\n        \\n        for x in nums:\\n            if x not in hash:\\n                hash[x]=0\\n            hash[x]+=1\\n        mn=nums[0]\\n        mx=nums[-1]\\n        \\n        def check(k,nums,hash1,ans):\\n            for i in range(len(nums)):\\n                if nums[i] in hash1:\\n                    if nums[i]+2*k in hash1:\\n                        z=nums[i]+2*k\\n                        ans.append((nums[i]+z)//2)\\n                        \\n                        if hash1[nums[i]]==1:\\n                            del hash1[nums[i]]\\n                        \\n                        else:\\n                            hash1[nums[i]]-=1\\n                        \\n                        if hash1[z]==1:\\n                            del hash1[z]\\n                        \\n                        else:\\n                            hash1[z]-=1\\n                    else:\\n                        break\\n                     \\n            return len(hash1)==0\\n                        \\n                        \\n                    \\n                    \\n                    \\n        \\n        for i in range(1,n):\\n                        \\n\\n            k=nums[i]-nums[0]\\n            \\n            if k%2==0 and k!=0:\\n                ans=[]\\n                hash1=hash.copy()\\n                if check(k//2,nums,hash1,ans):\\n                    return ans\\n            \\n                        \\n                    \\n                    \\n                    \\n                \\n            \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046353,
                "title": "python-set-binary-search",
                "content": "Create a set with all possible values of K and iterate over the list for each element to find corresponding high one \\n\\n```\\ndef recoverArray(self, nums):\\n```\\n    \\n        def bsearch(x,nums):\\n            n = len(nums)\\n            low = 0\\n            end = n-1\\n            \\n            while low<=end:\\n                mid = (low+end)//2\\n                if nums[mid] == x:\\n                    return (True,mid)\\n                elif nums[mid]>x:\\n                    end = mid-1\\n                else:\\n                    low = mid+1\\n                    \\n            return (False,-1)    \\n                \\n        \\n        nums.sort()\\n        \\n        k_lis = set([(nums[i]-nums[0])//2 for i in range(1,len(nums)) if (nums[i]-nums[0])%2==0])\\n        if 0 in k_lis:\\n            k_lis.remove(0)\\n        \\n        \\n        for i in k_lis:\\n            temp = [j for j in nums]\\n            k_arr = []\\n            while temp:\\n                x = temp.pop(0)\\n                a,b = bsearch(x+ 2*i,temp)\\n                if not a:\\n                    break\\n                k_arr.append(x+i)    \\n                temp.pop(b)\\n            if not temp:\\n                return k_arr\\n",
                "solutionTags": [
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\ndef recoverArray(self, nums):\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1985043,
                "title": "c-try-out-the-candidates-of-k",
                "content": "\\n\\n```\\n// 2122. Recover the Original Array\\nclass Solution {\\n    static inline bool isEven(int n) {\\n        return (n & 1) == 0;\\n    }\\n\\n    static tuple<bool, vector<int>> isGoodK(const int k, const vector<int>& A) {\\n        unordered_multiset nset(A.begin(), A.end());\\n        vector<int> originals;\\n        originals.reserve(A.size() / 2);\\n        // time complexity: O(n).\\n        // space is also O(n).\\n        for (int i = 0; i < A.size() && nset.size() > 0; ++i) {\\n            const int upper = A[i] + 2 * k;\\n            if (auto iter1 = nset.find(A[i]), iter2 = nset.find(upper);\\n                iter1 != nset.end() && iter2 != nset.end()) {\\n                // successfully paired up A[i] with another number.\\n                originals.emplace_back(A[i] + k);\\n                nset.erase(iter1);\\n                nset.erase(iter2);\\n            } else if (iter1 != nset.end()) {\\n                // A[i] is available for pairing, but cannot find another number to pair it up.\\n                // so, return earlier to indicate the failure.\\n                return {false, {}};\\n            }\\n        }\\n        return {true, originals};\\n    }\\n\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        if (!isEven(nums.size())) {\\n            return {}; // no valid answer.\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        const int smallest = nums.front();\\n        // possible values for k\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            int diff = nums[i] - smallest;\\n            if (isEven(diff) && diff >= 2) { // it should be 2*k, which is an even number\\n                // this step is O(n)\\n                auto [isGood, originalVec] = isGoodK(diff / 2, nums);\\n                if (isGood) {\\n                    return originalVec;\\n                }\\n            }\\n        }\\n        // Overall it\\'s O(n ** 2).\\n        return {}; // no valid answer\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// 2122. Recover the Original Array\\nclass Solution {\\n    static inline bool isEven(int n) {\\n        return (n & 1) == 0;\\n    }\\n\\n    static tuple<bool, vector<int>> isGoodK(const int k, const vector<int>& A) {\\n        unordered_multiset nset(A.begin(), A.end());\\n        vector<int> originals;\\n        originals.reserve(A.size() / 2);\\n        // time complexity: O(n).\\n        // space is also O(n).\\n        for (int i = 0; i < A.size() && nset.size() > 0; ++i) {\\n            const int upper = A[i] + 2 * k;\\n            if (auto iter1 = nset.find(A[i]), iter2 = nset.find(upper);\\n                iter1 != nset.end() && iter2 != nset.end()) {\\n                // successfully paired up A[i] with another number.\\n                originals.emplace_back(A[i] + k);\\n                nset.erase(iter1);\\n                nset.erase(iter2);\\n            } else if (iter1 != nset.end()) {\\n                // A[i] is available for pairing, but cannot find another number to pair it up.\\n                // so, return earlier to indicate the failure.\\n                return {false, {}};\\n            }\\n        }\\n        return {true, originals};\\n    }\\n\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        if (!isEven(nums.size())) {\\n            return {}; // no valid answer.\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        const int smallest = nums.front();\\n        // possible values for k\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            int diff = nums[i] - smallest;\\n            if (isEven(diff) && diff >= 2) { // it should be 2*k, which is an even number\\n                // this step is O(n)\\n                auto [isGood, originalVec] = isGoodK(diff / 2, nums);\\n                if (isGood) {\\n                    return originalVec;\\n                }\\n            }\\n        }\\n        // Overall it\\'s O(n ** 2).\\n        return {}; // no valid answer\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927486,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef recover_array(nums)\\n    nums.sort!\\n    uniques = nums.uniq\\n    start = uniques.shift\\n    tests = []\\n    n = nums.length / 2\\n    for i in 0...uniques.length\\n        tests << (uniques[i] - start) / 2 if (uniques[i] - start) % 2 == 0 \\n    end\\n    \\n    \\n    puts \"start=#{start} tests=#{tests}\"\\n    \\n    while true\\n        test_nums = nums.dup\\n        test_offset = tests.shift\\n        result = []\\n        n.times do\\n            # look for offset match for leftmost value of test_nums. If not found, fail; if found, delete it and leftmost value\\n            test_number = test_nums.shift\\n            found = test_nums.index(test_number + test_offset * 2)\\n            break if found == nil\\n            test_nums.delete_at(found)\\n            result << test_number + test_offset\\n        end\\n        return result if test_nums == []\\n    end\\n    \\n    \\n    [3,7,11]\\n    \\n    \\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef recover_array(nums)\\n    nums.sort!\\n    uniques = nums.uniq\\n    start = uniques.shift\\n    tests = []\\n    n = nums.length / 2\\n    for i in 0...uniques.length\\n        tests << (uniques[i] - start) / 2 if (uniques[i] - start) % 2 == 0 \\n    end\\n    \\n    \\n    puts \"start=#{start} tests=#{tests}\"\\n    \\n    while true\\n        test_nums = nums.dup\\n        test_offset = tests.shift\\n        result = []\\n        n.times do\\n            # look for offset match for leftmost value of test_nums. If not found, fail; if found, delete it and leftmost value\\n            test_number = test_nums.shift\\n            found = test_nums.index(test_number + test_offset * 2)\\n            break if found == nil\\n            test_nums.delete_at(found)\\n            result << test_number + test_offset\\n        end\\n        return result if test_nums == []\\n    end\\n    \\n    \\n    [3,7,11]\\n    \\n    \\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1737254,
                "title": "o-n-2",
                "content": "If we have the lowest value of the lower array and the lowest value of the higher array we can recunstruct it in linear time. We just keep adding the next lowest from the set + k to the result and remove the lowest and the lowest + 2 * k from the set.\\nWe already know the lowest value of the lower array, because it must be the lowest value in nums. So we sort the array and use the first element as the lowest of the lower array, and then we try all possible values in nums as the lowest of the higher array and try to recunstruct it.\\n\\nI used recursion to recunstruct the array. It should also be possile to do it iteratively, but I found it easier doing it backtracking. The recursive function runs in linear time.\\n\\n```\\nclass Solution {\\npublic:\\n    bool recunstruct(int i, int diff, vector<int>& nums, unordered_map<int, int>& freq, vector<int>& res) {\\n        if (i == nums.size()) return true;\\n        if (!freq[nums[i]]) return recunstruct(i + 1, diff, nums, freq, res);\\n        if (!freq[nums[i] + diff]) return false;\\n\\t\\t\\n\\t// remove it from map so we don\\'t use it again\\n        freq[nums[i]]--;\\n        freq[nums[i] + diff]--;\\n        res.push_back(nums[i] + diff / 2);\\n        if (recunstruct(i + 1, diff, nums, freq, res)) return true;\\n        res.pop_back();\\n\\t\\t\\n\\t// add it back to map\\n        freq[nums[i] + diff]++;\\n        freq[nums[i]]++;\\n        return false;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n\\t// map to store the values that are not used yet\\n        unordered_map<int, int>freq;\\n        for (int n : nums) freq[n]++;\\n        vector<int>res;\\n        for (int i = 1; i < nums.size(); i++) {\\n\\t\\t\\n\\t\\t// if we\\'ve already tried this value we can skip it\\n            if (nums[i] == nums[i - 1]) continue;\\n            int diff = nums[i] - nums[0];\\n\\t\\t\\t\\n\\t\\t// if diff is odd or equals zero we can skip it\\n            if (diff & 1 || diff == 0) continue;\\n            if (recunstruct(0, diff, nums, freq, res)) return res;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool recunstruct(int i, int diff, vector<int>& nums, unordered_map<int, int>& freq, vector<int>& res) {\\n        if (i == nums.size()) return true;\\n        if (!freq[nums[i]]) return recunstruct(i + 1, diff, nums, freq, res);\\n        if (!freq[nums[i] + diff]) return false;\\n\\t\\t\\n\\t// remove it from map so we don\\'t use it again\\n        freq[nums[i]]--;\\n        freq[nums[i] + diff]--;\\n        res.push_back(nums[i] + diff / 2);\\n        if (recunstruct(i + 1, diff, nums, freq, res)) return true;\\n        res.pop_back();\\n\\t\\t\\n\\t// add it back to map\\n        freq[nums[i] + diff]++;\\n        freq[nums[i]]++;\\n        return false;\\n    }\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n\\t// map to store the values that are not used yet\\n        unordered_map<int, int>freq;\\n        for (int n : nums) freq[n]++;\\n        vector<int>res;\\n        for (int i = 1; i < nums.size(); i++) {\\n\\t\\t\\n\\t\\t// if we\\'ve already tried this value we can skip it\\n            if (nums[i] == nums[i - 1]) continue;\\n            int diff = nums[i] - nums[0];\\n\\t\\t\\t\\n\\t\\t// if diff is odd or equals zero we can skip it\\n            if (diff & 1 || diff == 0) continue;\\n            if (recunstruct(0, diff, nums, freq, res)) return res;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735327,
                "title": "c-ac-check-if-number-and-number-2-k-exists",
                "content": "checking if the array is valid for K logic is similar to these 2 problems. so **solve these first**\\nhttps://leetcode.com/problems/find-original-array-from-doubled-array/discuss/1735246/c-ac-check-frequencies\\nhttps://leetcode.com/problems/array-of-doubled-pairs/discuss/1735322/C-AC-check-frequencies\\n\\n\\nIf we check every value of k it will time out.  As we know there is a valid output, for nums[0] there should be a value exist in the array for which \\n```\\nnum[i] = nums[0] + 2* k\\nk = (nums[i]-nums[0])/2;\\n```\\n![image](https://assets.leetcode.com/users/images/8c9771e5-fadb-4d9d-8e4e-deea16e14306_1643680705.3570833.png)\\n\\n\\n```\\npublic int[] RecoverArray(int[] nums)\\n{\\n\\tint n = nums.Length;\\n\\tif(n%2 != 0) return new int[0];\\n\\tArray.Sort(nums);\\n\\tint[] result = new int[n/2];\\n\\n\\tDictionary<int, int> counts = new Dictionary<int, int>();\\n\\tforeach (var num in nums)\\n\\t{\\n\\t\\tif (counts.ContainsKey(num)) counts[num]++;\\n\\t\\telse counts.Add(num, 1);\\n\\t}\\n\\n\\tfor (int i = 1; i < n; i++)\\n\\t{\\n\\t\\tint k = nums[i] - nums[0];\\n\\t\\tif(k== 0 || k%2 != 0) continue; \\n\\t\\tk = k/2;\\n\\t\\tif(IsKValid(nums, k, new Dictionary<int, int>(counts), result ))\\n\\t\\t{\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n\\nprivate bool IsKValid(int[] nums, int k, Dictionary<int, int> counts, int[] result)\\n{\\t\\n\\tint carry = 2*k;\\n\\tint index=0;\\n\\tforeach (var num in nums)\\n\\t{\\n\\t\\tif(counts[num]==0) continue;\\n\\t\\t\\n\\t\\t// lower(num) = value-k so value = num+k\\n\\t\\t// higher = num+k+k = 2*k + num\\n\\t\\tint target = carry+num;\\n\\t\\tif(!counts.ContainsKey(target) || counts[target] == 0)\\n\\t\\treturn false;\\n\\t\\t\\n\\t\\tresult[index++] = num+k;\\n\\t\\tcounts[num]--;\\n\\t\\tcounts[target]--;\\n\\t}\\t\\n\\treturn true;\\t\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nnum[i] = nums[0] + 2* k\\nk = (nums[i]-nums[0])/2;\\n```\n```\\npublic int[] RecoverArray(int[] nums)\\n{\\n\\tint n = nums.Length;\\n\\tif(n%2 != 0) return new int[0];\\n\\tArray.Sort(nums);\\n\\tint[] result = new int[n/2];\\n\\n\\tDictionary<int, int> counts = new Dictionary<int, int>();\\n\\tforeach (var num in nums)\\n\\t{\\n\\t\\tif (counts.ContainsKey(num)) counts[num]++;\\n\\t\\telse counts.Add(num, 1);\\n\\t}\\n\\n\\tfor (int i = 1; i < n; i++)\\n\\t{\\n\\t\\tint k = nums[i] - nums[0];\\n\\t\\tif(k== 0 || k%2 != 0) continue; \\n\\t\\tk = k/2;\\n\\t\\tif(IsKValid(nums, k, new Dictionary<int, int>(counts), result ))\\n\\t\\t{\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n\\nprivate bool IsKValid(int[] nums, int k, Dictionary<int, int> counts, int[] result)\\n{\\t\\n\\tint carry = 2*k;\\n\\tint index=0;\\n\\tforeach (var num in nums)\\n\\t{\\n\\t\\tif(counts[num]==0) continue;\\n\\t\\t\\n\\t\\t// lower(num) = value-k so value = num+k\\n\\t\\t// higher = num+k+k = 2*k + num\\n\\t\\tint target = carry+num;\\n\\t\\tif(!counts.ContainsKey(target) || counts[target] == 0)\\n\\t\\treturn false;\\n\\t\\t\\n\\t\\tresult[index++] = num+k;\\n\\t\\tcounts[num]--;\\n\\t\\tcounts[target]--;\\n\\t}\\t\\n\\treturn true;\\t\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713646,
                "title": "using-counter-and-sorted-keys-82-speed",
                "content": "![image](https://assets.leetcode.com/users/images/e744db5f-1f46-4f70-8073-cddfcb335e57_1642960582.2256925.png)\\n```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        half_len_nums = len(nums) // 2\\n        cnt = Counter(nums)\\n        keys = sorted(cnt.keys())\\n        min_key = keys[0]\\n        diffs = [diff for i in range(1, len(keys))\\n                 if not (diff := keys[i] - min_key) % 2]\\n        for d in diffs:\\n            ans = []\\n            cnt_copy = cnt.copy()\\n            for k in keys:\\n                if cnt_copy[k]:\\n                    if k + d in cnt_copy and cnt_copy[k] <= cnt_copy[k + d]:\\n                        ans.extend([k + d // 2] * cnt_copy[k])\\n                        cnt_copy[k + d] -= cnt_copy[k]\\n                    else:\\n                        break\\n                if len(ans) == half_len_nums:\\n                    return ans\\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        half_len_nums = len(nums) // 2\\n        cnt = Counter(nums)\\n        keys = sorted(cnt.keys())\\n        min_key = keys[0]\\n        diffs = [diff for i in range(1, len(keys))\\n                 if not (diff := keys[i] - min_key) % 2]\\n        for d in diffs:\\n            ans = []\\n            cnt_copy = cnt.copy()\\n            for k in keys:\\n                if cnt_copy[k]:\\n                    if k + d in cnt_copy and cnt_copy[k] <= cnt_copy[k + d]:\\n                        ans.extend([k + d // 2] * cnt_copy[k])\\n                        cnt_copy[k + d] -= cnt_copy[k]\\n                    else:\\n                        break\\n                if len(ans) == half_len_nums:\\n                    return ans\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708621,
                "title": "python-hashmap-o-n-2-short-simple",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        def solve(k):\\n            count=collections.Counter(nums)\\n            ans=[]\\n            for num in nums:\\n                if count[num] and count[num+2*k]:\\n                    ans.append(num+k)\\n                    count[num]-=1\\n                    count[num+2*k]-=1\\n            if len(ans)==n//2: return ans\\n            return []\\n        for i in range(n):\\n            if (nums[i]-nums[0])>0 and (nums[i]-nums[0])%2==0:\\n                res=solve((nums[i]-nums[0])//2)\\n                if res:\\n                    return res\\n        return []\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        def solve(k):\\n            count=collections.Counter(nums)\\n            ans=[]\\n            for num in nums:\\n                if count[num] and count[num+2*k]:\\n                    ans.append(num+k)\\n                    count[num]-=1\\n                    count[num+2*k]-=1\\n            if len(ans)==n//2: return ans\\n            return []\\n        for i in range(n):\\n            if (nums[i]-nums[0])>0 and (nums[i]-nums[0])%2==0:\\n                res=solve((nums[i]-nums[0])//2)\\n                if res:\\n                    return res\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705917,
                "title": "java-o-n-2-clean-code",
                "content": "```java\\nclass Solution {\\n  public int[] recoverArray(int[] nums) {\\n    Arrays.sort(nums);\\n\\n    int n = nums.length;\\n\\n    // lower[i]  = arr[i] - k\\n    // higher[i] = arr[i] + k\\n    // \\n    // diff      = higher[i] - lower[i]\\n    //           = 2k          \\n    // \\n    // k         = diff / 2\\n    // \\n    for (int i = 1; i < n; j++) {\\n      int k = (nums[i] - nums[0]) / 2;\\n\\n      // k is a positive integer\\n      if (k == 0) continue;\\n      \\n      if (isValid(nums, k)) {\\n        return build(nums, k);\\n      }\\n    }\\n\\n    return null;\\n  }\\n\\n  private boolean isValid(int[] nums, int k) {\\n    int n = nums.length;\\n    boolean[] used = new boolean[n];\\n\\n    int i = 0, j = 0;\\n    while (true) {\\n      while (i < n && used[i]) i++;\\n\\n      if (i >= n) break;\\n\\n      used[i] = true;\\n\\n      // find higher[i] = lower[i] + 2 * k\\n      while (j < n && (used[j] || nums[j] != nums[i] + 2 * k)) j++;\\n\\n      if (j >= n) return false;\\n\\n      used[j] = true;\\n    }\\n\\n    return true;\\n  }\\n\\n  private int[] build(int[] nums, int k) {\\n    int n = nums.length;\\n    boolean[] used = new boolean[n];\\n\\n    int[] ans = new int[n >> 1];\\n    int len = 0;\\n\\n    int i = 0, j = 0;\\n    while (true) {\\n      while (i < n && used[i]) i++;\\n\\n      if (i >= n) break;\\n\\n      used[i] = true;\\n      ans[len++] = nums[i] + k;\\n\\n      while (j < n && (used[j] || nums[j] != nums[i] + 2 * k)) j++;\\n\\n      used[j] = true;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  public int[] recoverArray(int[] nums) {\\n    Arrays.sort(nums);\\n\\n    int n = nums.length;\\n\\n    // lower[i]  = arr[i] - k\\n    // higher[i] = arr[i] + k\\n    // \\n    // diff      = higher[i] - lower[i]\\n    //           = 2k          \\n    // \\n    // k         = diff / 2\\n    // \\n    for (int i = 1; i < n; j++) {\\n      int k = (nums[i] - nums[0]) / 2;\\n\\n      // k is a positive integer\\n      if (k == 0) continue;\\n      \\n      if (isValid(nums, k)) {\\n        return build(nums, k);\\n      }\\n    }\\n\\n    return null;\\n  }\\n\\n  private boolean isValid(int[] nums, int k) {\\n    int n = nums.length;\\n    boolean[] used = new boolean[n];\\n\\n    int i = 0, j = 0;\\n    while (true) {\\n      while (i < n && used[i]) i++;\\n\\n      if (i >= n) break;\\n\\n      used[i] = true;\\n\\n      // find higher[i] = lower[i] + 2 * k\\n      while (j < n && (used[j] || nums[j] != nums[i] + 2 * k)) j++;\\n\\n      if (j >= n) return false;\\n\\n      used[j] = true;\\n    }\\n\\n    return true;\\n  }\\n\\n  private int[] build(int[] nums, int k) {\\n    int n = nums.length;\\n    boolean[] used = new boolean[n];\\n\\n    int[] ans = new int[n >> 1];\\n    int len = 0;\\n\\n    int i = 0, j = 0;\\n    while (true) {\\n      while (i < n && used[i]) i++;\\n\\n      if (i >= n) break;\\n\\n      used[i] = true;\\n      ans[len++] = nums[i] + k;\\n\\n      while (j < n && (used[j] || nums[j] != nums[i] + 2 * k)) j++;\\n\\n      used[j] = true;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694790,
                "title": "java-explained-commented",
                "content": "\\n    let given array be          [A, B, C]\\n    we have                     [A-k, B-k, C-k, A+k, B+k, C+k]\\n    double diff array is built by substracting each element from the first element, after sorting the array.\\n    After sorting the lowest element should belong to the first half(A-k,B-k or C-k)\\n    doubleDiff array --  [0, B-A-k, C-A-k, 2k, B-A+2k, C-A+2k]\\n    So, any of these can be our ans, we will assume each of the elements to be 2k, and try to find out for that\\n    k, can we build out the ans. \\n    \\n    Logic to find out if we can build the ans.\\n    Build a freqmap- {A-K->1, B-k->-1....... A+k->1, B+k->1... and so on}\\n    Outer loop-- iterate through all possible k\\n    Inner Loop- We will iterate through all the elements of the given array, so first comes A-k, \\n    We will add A-k+2k=A+k, we will check if A+K is present or not in our Hashmap, if present reduce its freq\\n    by 1, {A-k>-0, A+k->0}\\n    and we will find our original elements like this-\\n    A-k+(2k/2)=A\\n    \\n    Point to keep in mind- \\n    1. FLush the map/ reset the map after each iteration of outer loop, if ans \\n    not found.\\n    since we are moditying the map\\n    2. By this logic you might think that k can be the middle of the doubleDiff\\n    array always, but thats not the case always. It will only happen if the elemnts \\n\\tof the array in question(modified array) is of the form A-k,B-k,C-k...A+k,B+k,C+k...\\n\\tBut this does nt happen always.\\n    Take this eg [2,3,7,8,8,9,9,10].\\n    here correct k value is 1.\\n    So if we sort the modified array(given in question) and think that it will NOT\\n\\tbe in the abovementioned form.\\n\\t\\n    Given array- [1, 2, 3, 4, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11]\\n    Original array- [2,3,7,8,8,9,9,10]\\n    k=1\\n\\t\\n    Lets try to check it,\\n    so first element 2-1=1\\n    second element 3-1=2\\n    good so far, all A-K on left side...\\n    now see,\\n    \\n    7-1=6-> should have been before 3+1=4, which is not the case.\\n    \\n    \\n```        \\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] res = new int[n / 2];\\n\\t\\tint resIdx = 0;\\n\\n\\t\\tArrays.sort(nums);\\n\\n\\t\\t// freq map\\n\\t\\tMap<Integer, Integer> freq = new HashMap<>();\\n        \\n\\t\\t// find double diff array\\n\\t\\tint[] doubleDiff = new int[n];\\n\\t\\tint ddIdx = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdoubleDiff[ddIdx++] = nums[i] - nums[0];\\n\\t\\t}\\n\\t\\t// try out for every 2k\\'s which we stored in double diff array\\n\\t\\tfor (int k : doubleDiff) {\\n\\t\\t\\tif (k == 0 || k % 2 != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tresIdx = 0;\\n\\t\\t\\tfreq.replaceAll((key,value) -> 0);\\n\\t\\t\\tfor (int i : nums) {\\n\\t\\t\\t\\tfreq.put(i, freq.getOrDefault(i, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\t// assume the elements to be A-k,B-k,C-k and so on...\\n\\t\\t\\t\\t// A-k+2k = A+k\\n\\t\\t\\t\\t// for it to be valid 2k, both A+k and A-k should exist in the array\\n\\t\\t\\t\\tint numPlusK = nums[i] + k;\\n\\t\\t\\t\\tif (freq.containsKey(numPlusK) && freq.get(numPlusK) > 0 && freq.get(nums[i]) > 0) {\\n\\t\\t\\t\\t\\tfreq.put(numPlusK, freq.get(numPlusK) - 1);\\n\\t\\t\\t\\t\\tfreq.put(nums[i], freq.get(nums[i]) - 1);\\n\\n\\t\\t\\t\\t\\t// build the parent array\\n\\t\\t\\t\\t\\tint originalVal = nums[i] + k / 2;\\n\\t\\t\\t\\t\\tres[resIdx++] = originalVal;\\n\\n\\t\\t\\t\\t\\tif (resIdx == n / 2) {\\n\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new int[0];\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```        \\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] res = new int[n / 2];\\n\\t\\tint resIdx = 0;\\n\\n\\t\\tArrays.sort(nums);\\n\\n\\t\\t// freq map\\n\\t\\tMap<Integer, Integer> freq = new HashMap<>();\\n        \\n\\t\\t// find double diff array\\n\\t\\tint[] doubleDiff = new int[n];\\n\\t\\tint ddIdx = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdoubleDiff[ddIdx++] = nums[i] - nums[0];\\n\\t\\t}\\n\\t\\t// try out for every 2k\\'s which we stored in double diff array\\n\\t\\tfor (int k : doubleDiff) {\\n\\t\\t\\tif (k == 0 || k % 2 != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tresIdx = 0;\\n\\t\\t\\tfreq.replaceAll((key,value) -> 0);\\n\\t\\t\\tfor (int i : nums) {\\n\\t\\t\\t\\tfreq.put(i, freq.getOrDefault(i, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\t// assume the elements to be A-k,B-k,C-k and so on...\\n\\t\\t\\t\\t// A-k+2k = A+k\\n\\t\\t\\t\\t// for it to be valid 2k, both A+k and A-k should exist in the array\\n\\t\\t\\t\\tint numPlusK = nums[i] + k;\\n\\t\\t\\t\\tif (freq.containsKey(numPlusK) && freq.get(numPlusK) > 0 && freq.get(nums[i]) > 0) {\\n\\t\\t\\t\\t\\tfreq.put(numPlusK, freq.get(numPlusK) - 1);\\n\\t\\t\\t\\t\\tfreq.put(nums[i], freq.get(nums[i]) - 1);\\n\\n\\t\\t\\t\\t\\t// build the parent array\\n\\t\\t\\t\\t\\tint originalVal = nums[i] + k / 2;\\n\\t\\t\\t\\t\\tres[resIdx++] = originalVal;\\n\\n\\t\\t\\t\\t\\tif (resIdx == n / 2) {\\n\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new int[0];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691650,
                "title": "straightforward-python-solution-faster-than-98-of-accepted-python-solutions",
                "content": "\\n```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        def check_k_possible(nums,k):\\n            ans = []\\n            while nums:\\n                nxt = nums[0]\\n                nxt_comp = nxt + 2 * k\\n                try:              \\n                    comp_ind = nums.index(nxt_comp)                \\n                    nums.pop(comp_ind)\\n                    ans.append(nums.pop(0)+k)                    \\n                except:\\n                    return None\\n            return ans\\n        \\n        nums.sort()\\n        half_n = len(nums)//2\\n        a_min = nums[0]\\n        possible_k_from_bottom = set()\\n        for a in nums[1:half_n+1]:\\n            if (a + a_min) % 2 == 0:\\n                possible_k_from_bottom.add((a - a_min)//2)\\n        possible_k_from_top = set()\\n        a_max = nums[-1]\\n        for a in nums[-2:-half_n-2:-1]:\\n            if (a + a_max) % 2 == 0:\\n                possible_k_from_top.add((a_max - a)//2)\\n        possible_k = possible_k_from_top.intersection(possible_k_from_bottom)\\n        possible_k.discard(0)\\n        for k in possible_k:\\n            ans = check_k_possible(nums[:],k)\\n            if ans:\\n                return ans\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        def check_k_possible(nums,k):\\n            ans = []\\n            while nums:\\n                nxt = nums[0]\\n                nxt_comp = nxt + 2 * k\\n                try:              \\n                    comp_ind = nums.index(nxt_comp)                \\n                    nums.pop(comp_ind)\\n                    ans.append(nums.pop(0)+k)                    \\n                except:\\n                    return None\\n            return ans\\n        \\n        nums.sort()\\n        half_n = len(nums)//2\\n        a_min = nums[0]\\n        possible_k_from_bottom = set()\\n        for a in nums[1:half_n+1]:\\n            if (a + a_min) % 2 == 0:\\n                possible_k_from_bottom.add((a - a_min)//2)\\n        possible_k_from_top = set()\\n        a_max = nums[-1]\\n        for a in nums[-2:-half_n-2:-1]:\\n            if (a + a_max) % 2 == 0:\\n                possible_k_from_top.add((a_max - a)//2)\\n        possible_k = possible_k_from_top.intersection(possible_k_from_bottom)\\n        possible_k.discard(0)\\n        for k in possible_k:\\n            ans = check_k_possible(nums[:],k)\\n            if ans:\\n                return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1676270,
                "title": "c-hashmap-solution-with-o-n-2-time-and-o-n-space",
                "content": "```\\ntypedef struct node {\\n    int value;\\n    int idx;\\n    struct node* next;\\n} Node;\\n\\ntypedef struct hash {\\n    int size;\\n    Node *nodes;\\n} Hash;\\n\\nstatic void hashAdd(Hash *h, int value, int vIdx)\\n{\\n    const int idx = value % h->size;\\n    Node *cur = &h->nodes[idx];\\n    \\n    while (cur->next != NULL) {\\n        cur = cur->next;\\n    }  \\n\\n    cur->next = calloc(1, sizeof(Node));\\n    cur = cur->next;\\n    cur->value = value;\\n    cur->idx = vIdx;\\n}\\n\\nstatic int hashFind(Hash *h, bool* used, int value)\\n{\\n    const int idx = value % h->size;\\n    Node *cur = h->nodes[idx].next;\\n    \\n    for(; cur != NULL && (cur->value != value || used[cur->idx]); cur = cur->next);\\n    \\n    if (cur == NULL) {\\n        return -1;\\n    } else {\\n        return cur->idx;\\n    }\\n}\\n\\nstatic bool checkValid(Hash *h, bool* used, int* ret, int rIdx, int* nums, int nIdx, int nSize, int k)\\n{\\n    for(; nIdx < nSize && used[nIdx]; nIdx++);\\n\\n    if (nIdx < nSize) {\\n        const int idx = hashFind(h, used, nums[nIdx] + 2*k);\\n\\n        if (idx != -1) {                \\n            ret[rIdx] = nums[nIdx] + k;\\n\\n            used[nIdx] = true;\\n            used[idx] = true;\\n            if (checkValid(h, used, ret, rIdx + 1, nums, nIdx + 1, nSize, k)) {\\n                return true;\\n            }\\n            used[idx] = false;\\n            used[nIdx] = false;\\n        } \\n    \\n        return false;\\n    } else {\\n        return true;\\n    }\\n}\\n\\nstatic int compare(const void* v, const void*z)\\n{\\n    const int a = *(const int*)v;\\n    const int b = *(const int*)z;\\n    \\n    if (a < b) return -1;\\n    else if (a > b) return 1;\\n    else return 0;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* recoverArray(int* nums, int numsSize, int* returnSize){\\n    int *ret = calloc(numsSize/2, sizeof(int));\\n    Hash h = { 0, NULL };\\n    \\n    h.size = numsSize;\\n    h.nodes = calloc(numsSize, sizeof(Node));\\n    *returnSize = numsSize/2;\\n    \\n    qsort(nums, numsSize, sizeof(int), compare);\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        hashAdd(&h, nums[i], i);\\n    }\\n    \\n    for (int i = 1; i <= numsSize/2; i++) {\\n        if (nums[i] == nums[i - 1]) continue;\\n        const int diff = abs(nums[i] - nums[0]);\\n        if (diff == 0 || (diff % 2) == 1) continue;\\n\\n        bool used[numsSize];      \\n        memset(used, 0, sizeof(used));\\n        \\n        if (checkValid(&h, used, ret, 0, nums, 0, numsSize, diff/2)) {\\n            break;\\n        }\\n    }\\n   \\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct node {\\n    int value;\\n    int idx;\\n    struct node* next;\\n} Node;\\n\\ntypedef struct hash {\\n    int size;\\n    Node *nodes;\\n} Hash;\\n\\nstatic void hashAdd(Hash *h, int value, int vIdx)\\n{\\n    const int idx = value % h->size;\\n    Node *cur = &h->nodes[idx];\\n    \\n    while (cur->next != NULL) {\\n        cur = cur->next;\\n    }  \\n\\n    cur->next = calloc(1, sizeof(Node));\\n    cur = cur->next;\\n    cur->value = value;\\n    cur->idx = vIdx;\\n}\\n\\nstatic int hashFind(Hash *h, bool* used, int value)\\n{\\n    const int idx = value % h->size;\\n    Node *cur = h->nodes[idx].next;\\n    \\n    for(; cur != NULL && (cur->value != value || used[cur->idx]); cur = cur->next);\\n    \\n    if (cur == NULL) {\\n        return -1;\\n    } else {\\n        return cur->idx;\\n    }\\n}\\n\\nstatic bool checkValid(Hash *h, bool* used, int* ret, int rIdx, int* nums, int nIdx, int nSize, int k)\\n{\\n    for(; nIdx < nSize && used[nIdx]; nIdx++);\\n\\n    if (nIdx < nSize) {\\n        const int idx = hashFind(h, used, nums[nIdx] + 2*k);\\n\\n        if (idx != -1) {                \\n            ret[rIdx] = nums[nIdx] + k;\\n\\n            used[nIdx] = true;\\n            used[idx] = true;\\n            if (checkValid(h, used, ret, rIdx + 1, nums, nIdx + 1, nSize, k)) {\\n                return true;\\n            }\\n            used[idx] = false;\\n            used[nIdx] = false;\\n        } \\n    \\n        return false;\\n    } else {\\n        return true;\\n    }\\n}\\n\\nstatic int compare(const void* v, const void*z)\\n{\\n    const int a = *(const int*)v;\\n    const int b = *(const int*)z;\\n    \\n    if (a < b) return -1;\\n    else if (a > b) return 1;\\n    else return 0;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* recoverArray(int* nums, int numsSize, int* returnSize){\\n    int *ret = calloc(numsSize/2, sizeof(int));\\n    Hash h = { 0, NULL };\\n    \\n    h.size = numsSize;\\n    h.nodes = calloc(numsSize, sizeof(Node));\\n    *returnSize = numsSize/2;\\n    \\n    qsort(nums, numsSize, sizeof(int), compare);\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        hashAdd(&h, nums[i], i);\\n    }\\n    \\n    for (int i = 1; i <= numsSize/2; i++) {\\n        if (nums[i] == nums[i - 1]) continue;\\n        const int diff = abs(nums[i] - nums[0]);\\n        if (diff == 0 || (diff % 2) == 1) continue;\\n\\n        bool used[numsSize];      \\n        memset(used, 0, sizeof(used));\\n        \\n        if (checkValid(&h, used, ret, 0, nums, 0, numsSize, diff/2)) {\\n            break;\\n        }\\n    }\\n   \\n    return ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1672166,
                "title": "java-brute-force-backtracking",
                "content": "This is the whole explanation for the algo: https://poitevinpm.medium.com/leetcode-2122-recover-the-original-array-647cb42233f9\\n\\nThis is the raw code in Java:\\n\\n```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        // initialize\\n        LinkedList<Integer> lows = new LinkedList<>();\\n        int n = nums.length;\\n        int k = 0;\\n        int kDecided = -1;\\n        char[] hiLow = new char[n];\\n        for (int i = 0; i < n; i++) {\\n            hiLow[i] = \\' \\';\\n        }\\n        int current = 0;\\n        \\n        // sort first\\n        Arrays.sort(nums);\\n        \\n        // brute force and backtrack\\n        while (current < n || !lows.isEmpty()) {\\n            if (current == n) {\\n                current--;\\n                continue;\\n            }\\n            int x = nums[current];\\n            if (hiLow[current] == \\'H\\') {\\n                // we are backtracking\\n                if (kDecided == current) {\\n                    // reset k\\n                    hiLow[current] = \\'L\\';\\n                    lows.add(x);\\n                    lows.addFirst(x - 2*k);\\n                    kDecided = -1;\\n                    k = 0;\\n                    current++;\\n                    continue;\\n                } else {\\n                    // the only reason to have H\\n                    // is to have a matching L,\\n                    // changing the H to L isn\\'t going to solve that problem\\n                    // skip L\\n                    hiLow[current] = \\' \\';\\n                    current--;\\n                    lows.addFirst(x - 2 * k);\\n                    continue;\\n                }\\n            }\\n            if (hiLow[current] == \\'L\\') {\\n                // We tried with L but it didn\\'t work, backtrack more\\n                hiLow[current] = \\' \\';\\n                lows.removeLast();\\n                current--;\\n                continue;\\n            }\\n            if (lows.isEmpty()) {\\n                // need to add a low\\n                lows.add(x);\\n                hiLow[current] = \\'L\\';\\n                current++;\\n                continue;\\n            }\\n            int y = lows.element();\\n            int diff = x - y;\\n            if (diff == 0) {\\n                // has to be low\\n                lows.add(x);\\n                hiLow[current] = \\'L\\';\\n                current++;\\n                continue;\\n            }\\n            if (diff % 2 != 0) {\\n                // odd difference, has to be low\\n                lows.add(x);\\n                hiLow[current] = \\'L\\';\\n                current++;\\n                continue;\\n            }\\n            if (k == 0) {\\n                // we need to set k in this case\\n                // System.out.println(diff + \" = \" + x + \" - \" + y);\\n                k = diff / 2;\\n                kDecided = current;\\n                hiLow[current] = \\'H\\';\\n                lows.remove();\\n                current++;\\n                continue;\\n            }\\n            if (diff < 2 * k) {\\n                // has to be low\\n                lows.add(x);\\n                hiLow[current] = \\'L\\';\\n                current++;\\n                continue;\\n            }\\n            if (diff == 2 * k) {\\n                // matching\\n                hiLow[current] = \\'H\\';\\n                lows.remove();\\n                current++;\\n                continue;\\n            }\\n            // diff > 2 * k\\n            // start backtracking\\n            current--;\\n        }        \\n        // found a solution out of the loop\\n        int[] res = new int[n/2];\\n        int currResIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (hiLow[i] == \\'L\\' && currResIndex < (n/2)) {\\n                res[currResIndex] = nums[i] + k;\\n                currResIndex++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        // initialize\\n        LinkedList<Integer> lows = new LinkedList<>();\\n        int n = nums.length;\\n        int k = 0;\\n        int kDecided = -1;\\n        char[] hiLow = new char[n];\\n        for (int i = 0; i < n; i++) {\\n            hiLow[i] = \\' \\';\\n        }\\n        int current = 0;\\n        \\n        // sort first\\n        Arrays.sort(nums);\\n        \\n        // brute force and backtrack\\n        while (current < n || !lows.isEmpty()) {\\n            if (current == n) {\\n                current--;\\n                continue;\\n            }\\n            int x = nums[current];\\n            if (hiLow[current] == \\'H\\') {\\n                // we are backtracking\\n                if (kDecided == current) {\\n                    // reset k\\n                    hiLow[current] = \\'L\\';\\n                    lows.add(x);\\n                    lows.addFirst(x - 2*k);\\n                    kDecided = -1;\\n                    k = 0;\\n                    current++;\\n                    continue;\\n                } else {\\n                    // the only reason to have H\\n                    // is to have a matching L,\\n                    // changing the H to L isn\\'t going to solve that problem\\n                    // skip L\\n                    hiLow[current] = \\' \\';\\n                    current--;\\n                    lows.addFirst(x - 2 * k);\\n                    continue;\\n                }\\n            }\\n            if (hiLow[current] == \\'L\\') {\\n                // We tried with L but it didn\\'t work, backtrack more\\n                hiLow[current] = \\' \\';\\n                lows.removeLast();\\n                current--;\\n                continue;\\n            }\\n            if (lows.isEmpty()) {\\n                // need to add a low\\n                lows.add(x);\\n                hiLow[current] = \\'L\\';\\n                current++;\\n                continue;\\n            }\\n            int y = lows.element();\\n            int diff = x - y;\\n            if (diff == 0) {\\n                // has to be low\\n                lows.add(x);\\n                hiLow[current] = \\'L\\';\\n                current++;\\n                continue;\\n            }\\n            if (diff % 2 != 0) {\\n                // odd difference, has to be low\\n                lows.add(x);\\n                hiLow[current] = \\'L\\';\\n                current++;\\n                continue;\\n            }\\n            if (k == 0) {\\n                // we need to set k in this case\\n                // System.out.println(diff + \" = \" + x + \" - \" + y);\\n                k = diff / 2;\\n                kDecided = current;\\n                hiLow[current] = \\'H\\';\\n                lows.remove();\\n                current++;\\n                continue;\\n            }\\n            if (diff < 2 * k) {\\n                // has to be low\\n                lows.add(x);\\n                hiLow[current] = \\'L\\';\\n                current++;\\n                continue;\\n            }\\n            if (diff == 2 * k) {\\n                // matching\\n                hiLow[current] = \\'H\\';\\n                lows.remove();\\n                current++;\\n                continue;\\n            }\\n            // diff > 2 * k\\n            // start backtracking\\n            current--;\\n        }        \\n        // found a solution out of the loop\\n        int[] res = new int[n/2];\\n        int currResIndex = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (hiLow[i] == \\'L\\' && currResIndex < (n/2)) {\\n                res[currResIndex] = nums[i] + k;\\n                currResIndex++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670417,
                "title": "java-try-possible-k",
                "content": "The variable map store the index info. Since number might be duplicated, the data structure is: {num, {startPos, endPos}}\\n```\\n    public int[] recoverArray(int[] nums) {\\n        int n2 = nums.length, n = n2 / 2;\\n        int[] res = new int[n];\\n        boolean[] visited = new boolean[n2];\\n        Map<Integer, int[]> map = new HashMap<>();\\n    \\tArrays.sort(nums);\\n    \\tmap.put(nums[0], new int[] {0, 1});\\n    \\tfor (int i = 1; i < n2; i++)\\n    \\t\\tif (nums[i] != nums[i - 1]) {\\n    \\t\\t\\tmap.get(nums[i - 1])[1] = i;\\n\\t    \\t\\tmap.put(nums[i], new int[] {i, i + 1});\\n    \\t\\t}\\n    \\tmap.get(nums[n2 - 1])[1] = n2;\\n    \\tfor (int i = 1; i <= n; i++) {\\n    \\t\\tint k2 = nums[i] - nums[0], k = k2 / 2, idx = 0;\\n    \\t\\tif (k2 == 0 || k2 % 2 != 0)\\n    \\t\\t\\tcontinue;\\n    \\t\\tArrays.fill(visited, false);\\n    \\t\\tfor (int j = 0, itr; j < n2; j++) {\\n    \\t\\t\\tif (visited[j])\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tif (!map.containsKey(nums[j] + k2))\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\tint[] pos = map.get(nums[j] + k2);\\n    \\t\\t\\tfor (itr = pos[0]; itr < pos[1] && visited[itr]; itr++);\\n    \\t\\t\\tif (itr == pos[1])\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\tvisited[j] = visited[itr] = true;\\n    \\t\\t\\tres[idx++] = nums[j] + k;\\n    \\t\\t}\\n    \\t\\tif (idx == n)\\n    \\t\\t\\tbreak;\\n    \\t}\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "The variable map store the index info. Since number might be duplicated, the data structure is: {num, {startPos, endPos}}\\n```\\n    public int[] recoverArray(int[] nums) {\\n        int n2 = nums.length, n = n2 / 2;\\n        int[] res = new int[n];\\n        boolean[] visited = new boolean[n2];\\n        Map<Integer, int[]> map = new HashMap<>();\\n    \\tArrays.sort(nums);\\n    \\tmap.put(nums[0], new int[] {0, 1});\\n    \\tfor (int i = 1; i < n2; i++)\\n    \\t\\tif (nums[i] != nums[i - 1]) {\\n    \\t\\t\\tmap.get(nums[i - 1])[1] = i;\\n\\t    \\t\\tmap.put(nums[i], new int[] {i, i + 1});\\n    \\t\\t}\\n    \\tmap.get(nums[n2 - 1])[1] = n2;\\n    \\tfor (int i = 1; i <= n; i++) {\\n    \\t\\tint k2 = nums[i] - nums[0], k = k2 / 2, idx = 0;\\n    \\t\\tif (k2 == 0 || k2 % 2 != 0)\\n    \\t\\t\\tcontinue;\\n    \\t\\tArrays.fill(visited, false);\\n    \\t\\tfor (int j = 0, itr; j < n2; j++) {\\n    \\t\\t\\tif (visited[j])\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tif (!map.containsKey(nums[j] + k2))\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\tint[] pos = map.get(nums[j] + k2);\\n    \\t\\t\\tfor (itr = pos[0]; itr < pos[1] && visited[itr]; itr++);\\n    \\t\\t\\tif (itr == pos[1])\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\tvisited[j] = visited[itr] = true;\\n    \\t\\t\\tres[idx++] = nums[j] + k;\\n    \\t\\t}\\n    \\t\\tif (idx == n)\\n    \\t\\t\\tbreak;\\n    \\t}\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1664305,
                "title": "using-sets",
                "content": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tset<int> intersection(set<int>q,set<int>r){\\n\\t\\t\\tset<int>p;\\n\\t\\t\\tif(q.size()==0)return r;\\n\\t\\t\\tif(r.size()==0)return q;\\n\\t\\t\\tif(q.size()>r.size()){\\n\\t\\t\\t\\tfor(auto i=r.begin();i!=r.end();i++)if(q.find(*i)!=q.end())p.insert(*i);\\n\\t\\t\\t}\\n\\t\\t\\telse for(auto i=q.begin();i!=q.end();i++)if(r.find(*i)!=r.end())p.insert(*i);\\n\\t\\t\\treturn p;\\n\\n\\t\\t}\\n\\t\\tpair<bool,vector<int>> ck(int k,multiset<int>even,multiset<int>odd){\\n\\t\\t\\tpair<bool,vector<int>> fl;\\n\\t\\t\\tfl.first=false;\\n\\t\\t\\tif(k==0)return fl;\\n\\t\\t\\tvector<int>fina;;        \\n\\t\\t\\tfor(auto x=even.begin();x!=even.end();x++){\\n\\t\\t\\t\\tif(even.find(*x+k+k)==even.end())return fl;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfina.push_back(*x+k);\\n\\t\\t\\t\\t\\teven.erase(even.find(*x+k+k));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto x=odd.begin();x!=odd.end();x++){\\n\\t\\t\\t\\tif(odd.find(*x+k+k)==odd.end())return fl;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfina.push_back(*x+k);\\n\\t\\t\\t\\t\\todd.erase(odd.find(*x+k+k));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfl.first=true;\\n\\t\\t\\tfl.second=fina;\\n\\t\\t\\treturn fl;\\n\\t\\t}\\n\\t\\tvector<int> recoverArray(vector<int>& nums) {\\n\\t\\t\\tmultiset<int>even;\\n\\t\\t\\tmultiset<int>odd;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(nums[i]%2==0)even.insert(nums[i]);\\n\\t\\t\\t\\telse odd.insert(nums[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tset<int>q;\\n\\t\\t\\tset<int>r;\\n\\n\\t\\t\\t\\tint xx;\\n\\t\\t\\t\\tint fl=0;\\n\\t\\t\\t\\tfor(auto x=even.begin();x!=even.end();x++){\\n\\t\\t\\t\\t\\tif(fl==0){\\n\\t\\t\\t\\t\\t\\txx=*x;\\n\\t\\t\\t\\t\\t\\tfl=1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tq.insert(abs(*x-xx)/2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfl=0;\\n\\t\\t\\t\\tfor(auto x=odd.begin();x!=odd.end();x++){\\n\\t\\t\\t\\t\\tif(fl==0){\\n\\t\\t\\t\\t\\t\\txx=*x;\\n\\t\\t\\t\\t\\t\\tfl=1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tr.insert(abs(*x-xx)/2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\tset<int>p=intersection(q,r);\\n\\t\\t\\tfor(auto i=p.begin();i!=p.end();i++){\\n\\t\\t\\t\\tpair<bool,vector<int>>v=ck(*i,even,odd);\\n\\t\\t\\t\\tif(v.first==true){\\n\\t\\t\\t\\t\\treturn v.second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn vector<int>{};\\n\\t\\t}\\n\\t};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tset<int> intersection(set<int>q,set<int>r){\\n\\t\\t\\tset<int>p;\\n\\t\\t\\tif(q.size()==0)return r;\\n\\t\\t\\tif(r.size()==0)return q;\\n\\t\\t\\tif(q.size()>r.size()){\\n\\t\\t\\t\\tfor(auto i=r.begin();i!=r.end();i++)if(q.find(*i)!=q.end())p.insert(*i);\\n\\t\\t\\t}\\n\\t\\t\\telse for(auto i=q.begin();i!=q.end();i++)if(r.find(*i)!=r.end())p.insert(*i);\\n\\t\\t\\treturn p;\\n\\n\\t\\t}\\n\\t\\tpair<bool,vector<int>> ck(int k,multiset<int>even,multiset<int>odd){\\n\\t\\t\\tpair<bool,vector<int>> fl;\\n\\t\\t\\tfl.first=false;\\n\\t\\t\\tif(k==0)return fl;\\n\\t\\t\\tvector<int>fina;;        \\n\\t\\t\\tfor(auto x=even.begin();x!=even.end();x++){\\n\\t\\t\\t\\tif(even.find(*x+k+k)==even.end())return fl;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfina.push_back(*x+k);\\n\\t\\t\\t\\t\\teven.erase(even.find(*x+k+k));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto x=odd.begin();x!=odd.end();x++){\\n\\t\\t\\t\\tif(odd.find(*x+k+k)==odd.end())return fl;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfina.push_back(*x+k);\\n\\t\\t\\t\\t\\todd.erase(odd.find(*x+k+k));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfl.first=true;\\n\\t\\t\\tfl.second=fina;\\n\\t\\t\\treturn fl;\\n\\t\\t}\\n\\t\\tvector<int> recoverArray(vector<int>& nums) {\\n\\t\\t\\tmultiset<int>even;\\n\\t\\t\\tmultiset<int>odd;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(nums[i]%2==0)even.insert(nums[i]);\\n\\t\\t\\t\\telse odd.insert(nums[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tset<int>q;\\n\\t\\t\\tset<int>r;\\n\\n\\t\\t\\t\\tint xx;\\n\\t\\t\\t\\tint fl=0;\\n\\t\\t\\t\\tfor(auto x=even.begin();x!=even.end();x++){\\n\\t\\t\\t\\t\\tif(fl==0){\\n\\t\\t\\t\\t\\t\\txx=*x;\\n\\t\\t\\t\\t\\t\\tfl=1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tq.insert(abs(*x-xx)/2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfl=0;\\n\\t\\t\\t\\tfor(auto x=odd.begin();x!=odd.end();x++){\\n\\t\\t\\t\\t\\tif(fl==0){\\n\\t\\t\\t\\t\\t\\txx=*x;\\n\\t\\t\\t\\t\\t\\tfl=1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tr.insert(abs(*x-xx)/2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\tset<int>p=intersection(q,r);\\n\\t\\t\\tfor(auto i=p.begin();i!=p.end();i++){\\n\\t\\t\\t\\tpair<bool,vector<int>>v=ck(*i,even,odd);\\n\\t\\t\\t\\tif(v.first==true){\\n\\t\\t\\t\\t\\treturn v.second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn vector<int>{};\\n\\t\\t}\\n\\t};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662810,
                "title": "java-solution-with-hashmap",
                "content": "Checking for every possible value of K\\nif we subtract all elements by nums[0] in nums array which essentially is {A-k,B-k,C-k,A+k,B+k,C+k),\\n\\nAfter subtraction this will be { 0 , B-A , C-A , 2k , 2k+B-A, 2k+C-A}\\n\\nAfter this we will check every value in the array as 2k and calculate A,B,C and arrive at our answer\\n\\n```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> li=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            int dk=nums[i]-nums[0];\\n            if(dk>0&&dk%2==0){\\n                li.add(dk);\\n            }\\n        }\\n        \\n        for(int diff:li){\\n            List<Integer> fl=f(nums,diff);\\n            if(fl.size()==nums.length/2){\\n                return fl.stream().mapToInt(Integer::intValue).toArray();\\n            }\\n        }\\n        return new int[]{};  \\n    }\\n    \\n    public List<Integer> f(int[] nums,int diff){\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n        }\\n        List<Integer> a=new ArrayList<>();\\n        for(int val:nums){\\n            if(hm.getOrDefault(val,0)>0&&hm.getOrDefault(val+diff,0)>0){\\n                a.add(val+(diff/2));\\n                hm.put(val,hm.get(val)-1);\\n                hm.put(val+diff,hm.get(val+diff)-1);\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```\\n\\nI hope this helps.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> li=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            int dk=nums[i]-nums[0];\\n            if(dk>0&&dk%2==0){\\n                li.add(dk);\\n            }\\n        }\\n        \\n        for(int diff:li){\\n            List<Integer> fl=f(nums,diff);\\n            if(fl.size()==nums.length/2){\\n                return fl.stream().mapToInt(Integer::intValue).toArray();\\n            }\\n        }\\n        return new int[]{};  \\n    }\\n    \\n    public List<Integer> f(int[] nums,int diff){\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n        }\\n        List<Integer> a=new ArrayList<>();\\n        for(int val:nums){\\n            if(hm.getOrDefault(val,0)>0&&hm.getOrDefault(val+diff,0)>0){\\n                a.add(val+(diff/2));\\n                hm.put(val,hm.get(val)-1);\\n                hm.put(val+diff,hm.get(val+diff)-1);\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657603,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        int[] res = new int[nums.length/2];\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int num : nums)\\n            map.put(num, map.getOrDefault(num, 0)+1);\\n        for(int key : map.keySet())\\n            if(doable(key-nums[0], res, map, nums))\\n                break;\\n        return res;\\n    }\\n    public boolean doable(int k, int[] res, Map<Integer, Integer> map, int[] nums){\\n        if(k==0 || k%2!=0) return false;\\n        int idx = 0;\\n        int i = 0;\\n        while(idx<res.length){\\n            int low = nums[i];\\n            if(map.get(low)>0){\\n                int high = low+k;\\n                if(map.containsKey(high) && map.get(high)>0){\\n                    map.put(low, map.get(low)-1);\\n                    map.put(high, map.get(high)-1);\\n                    res[idx++] = low+k/2;\\n                }else{\\n                    while(--idx>=0){\\n                        map.put(res[idx]+k/2, map.get(res[idx]+k/2)+1);\\n                        map.put(res[idx]-k/2, map.get(res[idx]-k/2)+1);\\n                    }\\n                    return false;\\n                }\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] recoverArray(int[] nums) {\\n        int[] res = new int[nums.length/2];\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int num : nums)\\n            map.put(num, map.getOrDefault(num, 0)+1);\\n        for(int key : map.keySet())\\n            if(doable(key-nums[0], res, map, nums))\\n                break;\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1657517,
                "title": "45ms-two-pointers-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        const int n = nums.size() / 2;\\n        sort(nums.begin(), nums.end());\\n        for (int ii = 1; ii < 2 * n; ++ii) {\\n            int k = nums[ii] - nums[0];\\n            if (k % 2 != 0 || k == 0)\\n                continue;\\n            k /= 2;\\n            vector<int> res;\\n            vector<bool> used(2 * n);\\n            int j = 1;\\n            bool fail = false;\\n            for (int i = 0; i < 2 * n; ++i) {\\n                if (used[i])\\n                    continue;\\n                res.push_back(nums[i] + k);\\n                used[i] = true;\\n                for ( ; j < 2 * n; ++j) {\\n                    if (used[j])\\n                        continue;\\n                    if (nums[j] >= nums[i] + 2 * k)\\n                        break;\\n                }    \\n                if (j >= 2 * n || nums[j] > nums[i] + 2 * k) {\\n                    fail = true;\\n                    break;\\n                }\\n                used[j] = true;\\n            }\\n            if (!fail)\\n                return res;\\n        }\\n        return vector<int>();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        const int n = nums.size() / 2;\\n        sort(nums.begin(), nums.end());\\n        for (int ii = 1; ii < 2 * n; ++ii) {\\n            int k = nums[ii] - nums[0];\\n            if (k % 2 != 0 || k == 0)\\n                continue;\\n            k /= 2;\\n            vector<int> res;\\n            vector<bool> used(2 * n);\\n            int j = 1;\\n            bool fail = false;\\n            for (int i = 0; i < 2 * n; ++i) {\\n                if (used[i])\\n                    continue;\\n                res.push_back(nums[i] + k);\\n                used[i] = true;\\n                for ( ; j < 2 * n; ++j) {\\n                    if (used[j])\\n                        continue;\\n                    if (nums[j] >= nums[i] + 2 * k)\\n                        break;\\n                }    \\n                if (j >= 2 * n || nums[j] > nums[i] + 2 * k) {\\n                    fail = true;\\n                    break;\\n                }\\n                used[j] = true;\\n            }\\n            if (!fail)\\n                return res;\\n        }\\n        return vector<int>();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651849,
                "title": "golang-try-every-possible-k-value-and-construct-the-answer-array",
                "content": "1. Sort the array \\n2. First element must be present in the lower array, so try to make valid k by (nums[i] - nums[0]) \\n3. Difference must be greater than zero and can be divided by 2 \\n4. Target element we want to search will be the first element in the temp array + diff. (Binary search)\\n\\n\\n\\n\\t\\tfunc recoverArray(nums []int) []int {\\n\\t\\t\\tsort.Ints(nums)\\n\\n\\t\\t\\tl := len(nums)\\n\\t\\t\\tfor i := 1; i < l; i++ {\\n\\t\\t\\t\\tdiff := nums[i] - nums[0]\\n\\t\\t\\t\\tif diff%2 == 0 && diff > 0 {\\n\\t\\t\\t\\t\\tcur := make([]int, 0)\\n\\t\\t\\t\\t\\ttemp := make([]int, l)\\n\\t\\t\\t\\t\\tcopy(temp, nums)\\n\\t\\t\\t\\t\\tcur = append(cur, nums[0]+diff/2)\\n\\t\\t\\t\\t\\ttemp = temp[1:]\\n\\t\\t\\t\\t\\ttemp = append(temp[0:i-1], temp[i:]...)\\n\\n\\t\\t\\t\\t\\tfor len(temp) > 0 {\\n\\t\\t\\t\\t\\t\\tfirst := temp[0]\\n\\t\\t\\t\\t\\t\\ttarget := first + diff\\n\\t\\t\\t\\t\\t\\tidx := binarySearch(temp, target)\\n\\t\\t\\t\\t\\t\\tif idx == -1 {\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttemp = temp[1:]\\n\\t\\t\\t\\t\\t\\ttemp = append(temp[0:idx-1], temp[idx:]...)\\n\\t\\t\\t\\t\\t\\tcur = append(cur, first+diff/2)\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif len(temp) == 0 {\\n\\t\\t\\t\\t\\t\\treturn cur\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn []int{}\\n\\t\\t}\\n\\n\\t\\tfunc binarySearch(temp []int, target int) int {\\n\\t\\t\\tl := 0\\n\\t\\t\\tr := len(temp) - 1\\n\\t\\t\\tfor l <= r {\\n\\t\\t\\t\\tm := l + (r-l)/2\\n\\t\\t\\t\\tif temp[m] == target {\\n\\t\\t\\t\\t\\treturn m\\n\\t\\t\\t\\t} else if temp[m] < target {\\n\\t\\t\\t\\t\\tl = m + 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1\\n\\t\\t}",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "1. Sort the array \\n2. First element must be present in the lower array, so try to make valid k by (nums[i] - nums[0]) \\n3. Difference must be greater than zero and can be divided by 2 \\n4. Target element we want to search will be the first element in the temp array + diff. (Binary search)\\n\\n\\n\\n\\t\\tfunc recoverArray(nums []int) []int {\\n\\t\\t\\tsort.Ints(nums)\\n\\n\\t\\t\\tl := len(nums)\\n\\t\\t\\tfor i := 1; i < l; i++ {\\n\\t\\t\\t\\tdiff := nums[i] - nums[0]\\n\\t\\t\\t\\tif diff%2 == 0 && diff > 0 {\\n\\t\\t\\t\\t\\tcur := make([]int, 0)\\n\\t\\t\\t\\t\\ttemp := make([]int, l)\\n\\t\\t\\t\\t\\tcopy(temp, nums)\\n\\t\\t\\t\\t\\tcur = append(cur, nums[0]+diff/2)\\n\\t\\t\\t\\t\\ttemp = temp[1:]\\n\\t\\t\\t\\t\\ttemp = append(temp[0:i-1], temp[i:]...)\\n\\n\\t\\t\\t\\t\\tfor len(temp) > 0 {\\n\\t\\t\\t\\t\\t\\tfirst := temp[0]\\n\\t\\t\\t\\t\\t\\ttarget := first + diff\\n\\t\\t\\t\\t\\t\\tidx := binarySearch(temp, target)\\n\\t\\t\\t\\t\\t\\tif idx == -1 {\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttemp = temp[1:]\\n\\t\\t\\t\\t\\t\\ttemp = append(temp[0:idx-1], temp[idx:]...)\\n\\t\\t\\t\\t\\t\\tcur = append(cur, first+diff/2)\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif len(temp) == 0 {\\n\\t\\t\\t\\t\\t\\treturn cur\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn []int{}\\n\\t\\t}\\n\\n\\t\\tfunc binarySearch(temp []int, target int) int {\\n\\t\\t\\tl := 0\\n\\t\\t\\tr := len(temp) - 1\\n\\t\\t\\tfor l <= r {\\n\\t\\t\\t\\tm := l + (r-l)/2\\n\\t\\t\\t\\tif temp[m] == target {\\n\\t\\t\\t\\t\\treturn m\\n\\t\\t\\t\\t} else if temp[m] < target {\\n\\t\\t\\t\\t\\tl = m + 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1651659,
                "title": "emulate-and-valid-o-n-2",
                "content": "Emulate every posible k.\\nk = value - min(nums), for every values bigger than min(nums).\\n\\n```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        vc_orig = defaultdict(int)\\n        for v in nums:\\n            vc_orig[v] += 1\\n        xs = list(vc_orig.keys())\\n        xs.sort()\\n        \\n        def is_ok(vc, k, res):\\n            # print(f\"vc: {vc}, k:{k}\")\\n            for x in xs:\\n                hi = x + 2*k\\n                if vc[x] == 0:\\n                    continue\\n                if vc[hi] == 0:\\n                    return False\\n                if vc[hi] < vc[x]:\\n                    return False\\n                cnt = vc[x]\\n                res.extend([x+k]*cnt)\\n                vc[hi] -= cnt\\n                vc[x] = 0\\n            # print(f\"vc: {vc}, end\")\\n            if sum(vc.values()) == 0:\\n                return True\\n            return False\\n        \\n        m = len(xs)\\n        lo = xs[0]\\n        for i in range(1,m):\\n            x = xs[i]\\n            diff = x - lo\\n            if diff & 1 == 1:\\n                continue\\n            vc = Counter(nums)\\n            k = diff // 2\\n            res = []\\n            if is_ok(vc, k, res):\\n                return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        vc_orig = defaultdict(int)\\n        for v in nums:\\n            vc_orig[v] += 1\\n        xs = list(vc_orig.keys())\\n        xs.sort()\\n        \\n        def is_ok(vc, k, res):\\n            # print(f\"vc: {vc}, k:{k}\")\\n            for x in xs:\\n                hi = x + 2*k\\n                if vc[x] == 0:\\n                    continue\\n                if vc[hi] == 0:\\n                    return False\\n                if vc[hi] < vc[x]:\\n                    return False\\n                cnt = vc[x]\\n                res.extend([x+k]*cnt)\\n                vc[hi] -= cnt\\n                vc[x] = 0\\n            # print(f\"vc: {vc}, end\")\\n            if sum(vc.values()) == 0:\\n                return True\\n            return False\\n        \\n        m = len(xs)\\n        lo = xs[0]\\n        for i in range(1,m):\\n            x = xs[i]\\n            diff = x - lo\\n            if diff & 1 == 1:\\n                continue\\n            vc = Counter(nums)\\n            k = diff // 2\\n            res = []\\n            if is_ok(vc, k, res):\\n                return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651629,
                "title": "java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<Integer> tried = new HashSet<>();\\n        for(int i = 1; i<nums.length; i++){\\n            if(tried.contains(nums[i])) continue;\\n            tried.add(nums[i]);\\n            \\n            int k2 = nums[i]-nums[0]; // every element in lower array has k*2 difference with higher array \\n            if(k2==0 || k2%2==1) continue; // so k*2 is positive and even\\n            \\n            boolean[] chk = new boolean[nums.length]; // any used element\\n            \\n            boolean flag = true;\\n            int[] rst = new int[nums.length/2];\\n            \\n            _xxx:\\n            for(int j=0; j<nums.length/2; j++){ // for the elements in lower array\\n                for(int k=0; k<chk.length; k++){ // for the elements in higher array \\n\\t\\t\\t\\t    if(chk[k]) continue;\\n                    chk[k]=true;\\n                    int idx = find(nums, chk, nums[k]+k2); // binary seach the element for higher array\\n                    if(idx<0){ // must be found, or the k is invalid\\n                        flag = false;\\n                        break _xxx; \\n                    }else{\\n                        chk[idx]=true;\\n                        rst[j]=nums[k]+k2/2;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag) return rst; // found the solution\\n        }\\n        return null;\\n    }\\n    \\n\\t// binary search the num\\n    int find(int[] nums, boolean[] chk, int n){\\n        int rst = Arrays.binarySearch(nums, n);\\n        if(rst<0) return rst;\\n        if(!chk[rst]) return rst;\\n        for(int i=rst-1; i>=0; i--){\\n            if(nums[i]==n && !chk[i]) return i;\\n        }\\n        for(int i=rst+1; i<nums.length; i++){\\n            if(nums[i]==n && !chk[i]) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] recoverArray(int[] nums) {\\n        Arrays.sort(nums);\\n        Set<Integer> tried = new HashSet<>();\\n        for(int i = 1; i<nums.length; i++){\\n            if(tried.contains(nums[i])) continue;\\n            tried.add(nums[i]);\\n            \\n            int k2 = nums[i]-nums[0]; // every element in lower array has k*2 difference with higher array \\n            if(k2==0 || k2%2==1) continue; // so k*2 is positive and even\\n            \\n            boolean[] chk = new boolean[nums.length]; // any used element\\n            \\n            boolean flag = true;\\n            int[] rst = new int[nums.length/2];\\n            \\n            _xxx:\\n            for(int j=0; j<nums.length/2; j++){ // for the elements in lower array\\n                for(int k=0; k<chk.length; k++){ // for the elements in higher array \\n\\t\\t\\t\\t    if(chk[k]) continue;\\n                    chk[k]=true;\\n                    int idx = find(nums, chk, nums[k]+k2); // binary seach the element for higher array\\n                    if(idx<0){ // must be found, or the k is invalid\\n                        flag = false;\\n                        break _xxx; \\n                    }else{\\n                        chk[idx]=true;\\n                        rst[j]=nums[k]+k2/2;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag) return rst; // found the solution\\n        }\\n        return null;\\n    }\\n    \\n\\t// binary search the num\\n    int find(int[] nums, boolean[] chk, int n){\\n        int rst = Arrays.binarySearch(nums, n);\\n        if(rst<0) return rst;\\n        if(!chk[rst]) return rst;\\n        for(int i=rst-1; i>=0; i--){\\n            if(nums[i]==n && !chk[i]) return i;\\n        }\\n        for(int i=rst+1; i<nums.length; i++){\\n            if(nums[i]==n && !chk[i]) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650182,
                "title": "need-help-in-finding-the-code-bottleneck-o-n-2",
                "content": "The following solution has an amortized time complexity of O(n^2) but the submission is throwing a time exceeded. Either I have analyzed the time complexity of the solution incorrectly or there is some bottleneck in the code. Can you please help me out with this?\\n```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        # find possible candidates for k\\n        track = {}\\n        N = len(nums)\\n        n = N // 2\\n        k_candidates = set()\\n        for i in range(N-1):\\n            for j in range(i+1, N):\\n                diff = abs(nums[i]-nums[j])\\n                if diff not in track:\\n                    track[diff] = 0\\n                track[diff] += 1\\n                if track[diff] >= n and diff % 2 == 0 and diff != 0:\\n                    k_candidates.add(diff)\\n                  \\n        nums.sort()\\n        arr = []\\n        k = 0        \\n        for pos_k in k_candidates:\\n            used = {}\\n            for i, x in enumerate(nums):\\n                if x not in used:\\n                    used[x] = set()\\n                used[x].add(i)\\n            for i, lo in enumerate(nums):\\n                hi = lo + pos_k\\n                if i in used[lo] and hi in used and len(used[hi]) > 0:\\n                    arr.append(lo+(pos_k//2))\\n                    used[lo].remove(i)\\n                    used[hi].remove(list(used[hi])[0])\\n\\n            if len(arr) == n:\\n                return arr\\n            arr=[]\\n                \\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        # find possible candidates for k\\n        track = {}\\n        N = len(nums)\\n        n = N // 2\\n        k_candidates = set()\\n        for i in range(N-1):\\n            for j in range(i+1, N):\\n                diff = abs(nums[i]-nums[j])\\n                if diff not in track:\\n                    track[diff] = 0\\n                track[diff] += 1\\n                if track[diff] >= n and diff % 2 == 0 and diff != 0:\\n                    k_candidates.add(diff)\\n                  \\n        nums.sort()\\n        arr = []\\n        k = 0        \\n        for pos_k in k_candidates:\\n            used = {}\\n            for i, x in enumerate(nums):\\n                if x not in used:\\n                    used[x] = set()\\n                used[x].add(i)\\n            for i, lo in enumerate(nums):\\n                hi = lo + pos_k\\n                if i in used[lo] and hi in used and len(used[hi]) > 0:\\n                    arr.append(lo+(pos_k//2))\\n                    used[lo].remove(i)\\n                    used[hi].remove(list(used[hi])[0])\\n\\n            if len(arr) == n:\\n                return arr\\n            arr=[]\\n                \\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649904,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> helper(int temp, vector<int>& nums){\\n        //temp = 2*k \\n        vector<int> ans;\\n        \\n        unordered_map<int,int> fre;\\n        for(auto &e : nums) fre[e]++;\\n        \\n        for(int e : nums){\\n            if(fre[e]>0 && fre.find(e+temp)!=fre.end() && fre[e+temp]>0){\\n                ans.push_back(e+temp/2);\\n                fre[e]--;\\n                fre[e+temp]--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n\\t\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        set<int> diff;\\n        for(auto &num : nums){\\n            int temp = num - nums[0];\\n            if(temp>0 && (temp&1)==0) diff.insert(temp);\\n        }\\n        \\n        vector<int> ans;\\n        for(auto &temp : diff){\\n             ans = helper(temp, nums);\\n            if(ans.size() == n/2) return ans;\\n        }\\n        return {};\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> helper(int temp, vector<int>& nums){\\n        //temp = 2*k \\n        vector<int> ans;\\n        \\n        unordered_map<int,int> fre;\\n        for(auto &e : nums) fre[e]++;\\n        \\n        for(int e : nums){\\n            if(fre[e]>0 && fre.find(e+temp)!=fre.end() && fre[e+temp]>0){\\n                ans.push_back(e+temp/2);\\n                fre[e]--;\\n                fre[e+temp]--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n\\t\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        set<int> diff;\\n        for(auto &num : nums){\\n            int temp = num - nums[0];\\n            if(temp>0 && (temp&1)==0) diff.insert(temp);\\n        }\\n        \\n        vector<int> ans;\\n        for(auto &temp : diff){\\n             ans = helper(temp, nums);\\n            if(ans.size() == n/2) return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649391,
                "title": "java-solution-using-map-or-two-pointers-run-time-is-very-different-but-don-t-know-why",
                "content": "Below is my solution with Map, the run time is about 300ms, time complexity is O(N^2)\\nclass Solution {\\n     public static int[] recoverArray(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        Set<Integer> possibleDoubleKset = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == min || (nums[i] - min) % 2 != 0) continue;\\n            \\n            possibleDoubleKset.add(nums[i] - min);\\n        }\\n         \\n         for (int doubleK : possibleDoubleKset) {\\n            int[] result = canKWork(doubleK, nums);\\n            if (result != null) {\\n                return result;\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    private static int[] canKWork(int k, int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] result = new int[nums.length / 2];\\n\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        int index = 0;\\n        for (int i = 0; i < nums.length && index < nums.length / 2; i++) {\\n            if (map.get(nums[i]) == 0) continue;\\n            int target = nums[i] + k;\\n\\n             if (!map.containsKey(target) || map.get(target) == 0) {\\n                return null;\\n            }\\n            result[index++] = nums[i] + k / 2;\\n            map.put(target, map.get(target) - 1);\\n            map.put(nums[i], map.get(nums[i]) - 1);\\n        }\\n\\n        return result;\\n    }\\n}\\nThen I see the solution below. The run time is about 17ms. But I think the time complexity is about O(N^2) as well. Can anyone help explin why? Did I misunderstand the time complexity below? Thanks!\\nhttps://leetcode.com/problems/recover-the-original-array/discuss/1648108/18ms-Readable-Java-Code-or-Two-pointer-and-HashSet \\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n     public static int[] recoverArray(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        Set<Integer> possibleDoubleKset = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == min || (nums[i] - min) % 2 != 0) continue;\\n            \\n            possibleDoubleKset.add(nums[i] - min);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1649355,
                "title": "try-every-possible-k-plus-greedy-approach-detailed-explanation",
                "content": "After I read the problem statement, the first thing I did was check the contraints. Since `n <= 1000`, we  need to be looking for an `O(n^2)` solution. If you don\\'t have a habit of reading the constraints, start doing it!\\n\\nSo the logical approach is to write a function to find a solution (if it exists) for a given value of k. After that, just try every possible k and we are done! \\n\\nSo how would we write such a function? Well a reasonable first step would be to sort the array so its nice and organized. Then we pair off each index one by one starting at the beginning. After all, the smallest value needs to be paired with a larger value and so on, so this greedy approach works.\\n\\nLet\\'s use `[2, 10, 6, 4, 8, 12]` as the example.\\n\\nNow we sort it and get `[2, 4, 6, 8, 10, 12]`\\n\\nNow let\\'s guess `k = 1`. And pair off each index starting at the beginning.\\n\\nLet\\'s pair off `arr[0] = 2`. Well that pairs nicely with `arr[1] = 4` and yields a value of 3. Let\\'s cross them off.\\n\\n```\\narr = `[\\'x\\', \\'x\\', 6, 8, 10, 12]`\\nresult = [3]\\n```\\n\\nWe try `arr[1]` but it is crossed off so we skip to `arr[2] = 6`. Well it pairs nicely with `arr[3] = 8` so we cross them off and add 7 to the result.\\n\\n```\\narr = `[\\'x\\', \\'x\\', \\'x\\', \\'x\\', 10, 12]`\\nresult = [3, 7]\\n```\\n\\nWe try `arr[3]` but it is crossed off so we skip to `arr[4] = 10` which pairs up nicely with `ar[5] = 12` and yields 11.\\n```\\narr = `[\\'x\\', \\'x\\', \\'x\\', \\'x\\', \\'x\\', \\'x\\']`\\nresult = [3, 7, 11]\\n```\\n\\nEverything got crosssed off so we found an answer! If hypothetically we had instead guessed a wrong k like `k = 100`. We would have found found a value that couldn\\'t have been paired up so we should just early returned null.\\n\\nSo this algorithm conceptually make sense but how do we implement it efficiently. For example if we do a linear scan when searching for a pair, this will end up being `O(n^2)`. Well your first instinct (as was mine) might be to do binary search. This might work but will make things complicated - for example when there are duplicate values in the array. Also this has a suboptimal time complexity. A better approach is actually to create a mapping from values to the indices where they occur.\\n\\nLet\\'s looks at a different example `arr = [1, 7, 7, 13, 13, 19]`\\n\\nWe can turn this into a map of indices which would look like this:\\n\\n```\\nmap = {\\n\\t1: [0],\\n\\t7: [2, 1],\\n\\t13: [4, 3],\\n\\t19: [5],\\n}\\n```\\n\\nNow let\\'s go through the same algorithm but use this data structure to help us. For this example, let\\'s (correctly) guess `k = 3`.\\n\\nLet\\'s start at `arr[0] = 1`. This means we need to look for a 7 and the map has it at index 1! So we can cross off indices 0 and 1. And add 4 to the result. We also need to pop those two indices off of the map since they are used up.\\n\\n```\\narr = [\\'x\\', \\'x\\', 7, 13, 13, 19]\\nmap = {1: [], 7: [2], 13: [4, 3], 19: [5]}\\nresult = [4]\\n```\\n\\nWe skip `arr[1]` and hit `arr[2] = 7`. This means we are looking for a 13 and we once again find it in the map. Again, we add 10 to the result and pop indices 2 and 3 out of the map. Yielding:\\n\\n```\\narr = [\\'x\\', \\'x\\', \\'x\\', \\'x\\', 13, 19]\\nmap = {1: [], 7: [], 13: [4], 19: [5]}\\nresult = [4, 10]\\n```\\n\\nAnd repeat for the last time and get:\\n\\n```\\narr = [\\'x\\', \\'x\\', \\'x\\', \\'x\\', \\'x\\', \\'x\\']\\nmap = {1: [], 7: [], 13: [], 19: []}\\nresult = [4, 10, 16]\\n```\\n\\nEvery index was reached so we found our answer!\\n\\nLet\\'s turn this algorithm into actual code:\\n\\n```js\\n// nums = [2, 4, 6, 8, 10, 12] and k = 1 returns [3, 7, 11]\\n// nums = [2, 4, 6, 8, 10, 12] and k = 2 returns null\\nfunction solveForGuessedK(nums, k) {\\n\\t// initialize the map\\n\\tconst indicesMap = {}\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\t const n = nums[i];\\n\\t\\t indicesMap[n] = indicesMap[n] || []\\n\\t\\t indicesMap[n].push(i)\\n\\t}\\n\\n\\t// Execute the greedy algorithm which pairs up each number\\n\\tconst visits = new Set(); // crossed out indices\\n\\tconst result = []\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (visits.has(i)) continue;\\n\\t\\tconst n = nums[i];\\n\\t\\tvisits.add(i);\\n\\t\\tconst lookFor = n + k * 2;\\n\\t\\tindicesMap[n].pop();\\n\\t\\tconst list = indicesMap[lookFor];\\n\\t\\tif (!list || list.length === 0) return null;\\n\\t\\tconst jump = list.pop();\\n\\t\\tif (visits.has(jump)) return null;\\n\\t\\tvisits.add(jump);\\n\\t\\tresult.push(nums[i] + k)\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\nNow we have done the hard part. Now we just need to try every possible k until we find one that works. Wait a second... aren\\'t there an infinite number of possible k\\'s? Actually we can rule out out any k which doesn\\'t pair with the first number. This narrows down the possible k\\'s to `n - 1` options. \\n\\nHere\\'s the final solution written in javascript. Its time complexity is `O(n^2)`.\\n\\n```js\\nvar recoverArray = function(nums) {\\n\\t// nums = [2, 4, 6, 8, 10, 12] and k = 1 returns [3, 7, 11]\\n\\t// nums = [2, 4, 6, 8, 10, 12] and k = 2 returns null\\n\\tfunction solveForGuessedK(nums, k) {\\n\\t\\t// initialize the map\\n\\t\\tconst indicesMap = {}\\n\\t\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\t\\t const n = nums[i];\\n\\t\\t\\t indicesMap[n] = indicesMap[n] || []\\n\\t\\t\\t indicesMap[n].push(i)\\n\\t\\t}\\n\\n\\t\\t// Execute the greedy algorithm which pairs up each number\\n\\t\\tconst visits = new Set(); // crossed out indices\\n\\t\\tconst result = []\\n\\t\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (visits.has(i)) continue;\\n\\t\\t\\tconst n = nums[i];\\n\\t\\t\\tvisits.add(i);\\n\\t\\t\\tconst lookFor = n + k * 2;\\n\\t\\t\\tindicesMap[n].pop();\\n\\t\\t\\tconst list = indicesMap[lookFor];\\n\\t\\t\\tif (!list || list.length === 0) return null;\\n\\t\\t\\tconst jump = list.pop();\\n\\t\\t\\tif (visits.has(jump)) return null;\\n\\t\\t\\tvisits.add(jump);\\n\\t\\t\\tresult.push(nums[i] + k)\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\t\\n\\t// Sort in ascending order - this is important when creating the indicesMap\\n\\tnums.sort((a, b) => a - b);\\n\\n    // Try every possible k\\n    for (let i = 1; i < nums.length; i++) {\\n        const k = (nums[i] - nums[0]) / 2;\\n\\t\\t\\n\\t\\t// skip if k is not a positive integer\\n        if (k % 1 !== 0 || k === 0) continue;\\n\\t\\t\\n        if (solveForGuessedK(nums, k) != null) {\\n            return solveForGuessedK(nums, k);\\n        }\\n    }\\n\\tthrow Error(\\'There should always be a solution.\\');\\n};\\n```\\n\\nHope this helped!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\narr = `[\\'x\\', \\'x\\', 6, 8, 10, 12]`\\nresult = [3]\\n```\n```\\narr = `[\\'x\\', \\'x\\', \\'x\\', \\'x\\', 10, 12]`\\nresult = [3, 7]\\n```\n```\\narr = `[\\'x\\', \\'x\\', \\'x\\', \\'x\\', \\'x\\', \\'x\\']`\\nresult = [3, 7, 11]\\n```\n```\\nmap = {\\n\\t1: [0],\\n\\t7: [2, 1],\\n\\t13: [4, 3],\\n\\t19: [5],\\n}\\n```\n```\\narr = [\\'x\\', \\'x\\', 7, 13, 13, 19]\\nmap = {1: [], 7: [2], 13: [4, 3], 19: [5]}\\nresult = [4]\\n```\n```\\narr = [\\'x\\', \\'x\\', \\'x\\', \\'x\\', 13, 19]\\nmap = {1: [], 7: [], 13: [4], 19: [5]}\\nresult = [4, 10]\\n```\n```\\narr = [\\'x\\', \\'x\\', \\'x\\', \\'x\\', \\'x\\', \\'x\\']\\nmap = {1: [], 7: [], 13: [], 19: []}\\nresult = [4, 10, 16]\\n```\n```js\\n// nums = [2, 4, 6, 8, 10, 12] and k = 1 returns [3, 7, 11]\\n// nums = [2, 4, 6, 8, 10, 12] and k = 2 returns null\\nfunction solveForGuessedK(nums, k) {\\n\\t// initialize the map\\n\\tconst indicesMap = {}\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\t const n = nums[i];\\n\\t\\t indicesMap[n] = indicesMap[n] || []\\n\\t\\t indicesMap[n].push(i)\\n\\t}\\n\\n\\t// Execute the greedy algorithm which pairs up each number\\n\\tconst visits = new Set(); // crossed out indices\\n\\tconst result = []\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (visits.has(i)) continue;\\n\\t\\tconst n = nums[i];\\n\\t\\tvisits.add(i);\\n\\t\\tconst lookFor = n + k * 2;\\n\\t\\tindicesMap[n].pop();\\n\\t\\tconst list = indicesMap[lookFor];\\n\\t\\tif (!list || list.length === 0) return null;\\n\\t\\tconst jump = list.pop();\\n\\t\\tif (visits.has(jump)) return null;\\n\\t\\tvisits.add(jump);\\n\\t\\tresult.push(nums[i] + k)\\n\\t}\\n\\treturn result;\\n}\\n```\n```js\\nvar recoverArray = function(nums) {\\n\\t// nums = [2, 4, 6, 8, 10, 12] and k = 1 returns [3, 7, 11]\\n\\t// nums = [2, 4, 6, 8, 10, 12] and k = 2 returns null\\n\\tfunction solveForGuessedK(nums, k) {\\n\\t\\t// initialize the map\\n\\t\\tconst indicesMap = {}\\n\\t\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\t\\t const n = nums[i];\\n\\t\\t\\t indicesMap[n] = indicesMap[n] || []\\n\\t\\t\\t indicesMap[n].push(i)\\n\\t\\t}\\n\\n\\t\\t// Execute the greedy algorithm which pairs up each number\\n\\t\\tconst visits = new Set(); // crossed out indices\\n\\t\\tconst result = []\\n\\t\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (visits.has(i)) continue;\\n\\t\\t\\tconst n = nums[i];\\n\\t\\t\\tvisits.add(i);\\n\\t\\t\\tconst lookFor = n + k * 2;\\n\\t\\t\\tindicesMap[n].pop();\\n\\t\\t\\tconst list = indicesMap[lookFor];\\n\\t\\t\\tif (!list || list.length === 0) return null;\\n\\t\\t\\tconst jump = list.pop();\\n\\t\\t\\tif (visits.has(jump)) return null;\\n\\t\\t\\tvisits.add(jump);\\n\\t\\t\\tresult.push(nums[i] + k)\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\t\\n\\t// Sort in ascending order - this is important when creating the indicesMap\\n\\tnums.sort((a, b) => a - b);\\n\\n    // Try every possible k\\n    for (let i = 1; i < nums.length; i++) {\\n        const k = (nums[i] - nums[0]) / 2;\\n\\t\\t\\n\\t\\t// skip if k is not a positive integer\\n        if (k % 1 !== 0 || k === 0) continue;\\n\\t\\t\\n        if (solveForGuessedK(nums, k) != null) {\\n            return solveForGuessedK(nums, k);\\n        }\\n    }\\n\\tthrow Error(\\'There should always be a solution.\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649333,
                "title": "c-c-java-python-array-try-all-possible-k-higher-0-low-0-32ms-28ms-7ms-vs-628ms",
                "content": "Given: higher[i] - low[i] = 2*k\\nAfter sort input array, then, low[0] = nums[0].   What is the higher[0]?  Could be in range [1...n].\\nThen, we just try all possible higher[i]  in range [1..n] as higher[0] and check higher array are valid.\\n\\nWe can use two pointers i1 and i2 to pick the next number to fill-in lower[] or higher[].  We don\\'t need create lower[] and higher[].  Just simulate the pointer moving forward.  Update the answer array[] accordingly. \\n\\nTime Complexity: O(N^2)\\nSpace Complexity:  O(N) for sort and results\\n\\nC: 32ms\\nC++: 28ms\\nJava: 7ms\\nPython3: 628ms\\n\\n<iframe src=\"https://leetcode.com/playground/U7Eh9GWZ/shared\" frameBorder=\"0\" width=\"700\" height=\"400\"></iframe>",
                "solutionTags": [],
                "code": "Given: higher[i] - low[i] = 2*k\\nAfter sort input array, then, low[0] = nums[0].   What is the higher[0]?  Could be in range [1...n].\\nThen, we just try all possible higher[i]  in range [1..n] as higher[0] and check higher array are valid.\\n\\nWe can use two pointers i1 and i2 to pick the next number to fill-in lower[] or higher[].  We don\\'t need create lower[] and higher[].  Just simulate the pointer moving forward.  Update the answer array[] accordingly. \\n\\nTime Complexity: O(N^2)\\nSpace Complexity:  O(N) for sort and results\\n\\nC: 32ms\\nC++: 28ms\\nJava: 7ms\\nPython3: 628ms\\n\\n<iframe src=\"https://leetcode.com/playground/U7Eh9GWZ/shared\" frameBorder=\"0\" width=\"700\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1648803,
                "title": "javascript-try-all-k-with-hashmap",
                "content": "var recoverArray = function(nums) {\\n    \\n    let getArray=(k, numbers)=>{\\n        let hashMap = new Map()\\n        let res=[]\\n        for(let i =0;i<numbers.length;i++){\\n            if(hashMap.has(numbers[i])){\\n                hashMap.set(numbers[i], hashMap.get(numbers[i])+1)\\n            }else{\\n                hashMap.set(numbers[i],1)\\n            }\\n        }\\n        for(let num of numbers){\\n            if(hashMap.get(num)===0){\\n                continue\\n            }\\n            if(!hashMap.has(num+k) || hashMap.get(num+k)===0){\\n                return [false, res]\\n            }\\n            \\n            hashMap.set(num,hashMap.get(num)-1)\\n            hashMap.set(num+k,hashMap.get(num+k)-1)\\n            res.push(num+k/2)\\n        }\\n        return [true, res]\\n    }\\n    \\n    \\n    \\n    //must have a valid k in nums[i]-nums[j]\\n    nums.sort((a,b)=>a-b)\\n    let k2\\n    let status = false\\n    let ans\\n    for(let i=1;i<nums.length;i++){\\n        k2=nums[i]-nums[0]\\n        if(k2!=0 && Math.abs(k2)%2==0){ \\n            [status, ans] = getArray(k2, nums)\\n        }\\n\\t\\t//must have at least one solution\\n        if(status){\\n            return ans\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "var recoverArray = function(nums) {\\n    \\n    let getArray=(k, numbers)=>{\\n        let hashMap = new Map()\\n        let res=[]\\n        for(let i =0;i<numbers.length;i++){\\n            if(hashMap.has(numbers[i])){\\n                hashMap.set(numbers[i], hashMap.get(numbers[i])+1)\\n            }else{\\n                hashMap.set(numbers[i],1)\\n            }\\n        }\\n        for(let num of numbers){\\n            if(hashMap.get(num)===0){\\n                continue\\n            }\\n            if(!hashMap.has(num+k) || hashMap.get(num+k)===0){\\n                return [false, res]\\n            }\\n            \\n            hashMap.set(num,hashMap.get(num)-1)\\n            hashMap.set(num+k,hashMap.get(num+k)-1)\\n            res.push(num+k/2)\\n        }\\n        return [true, res]\\n    }\\n    \\n    \\n    \\n    //must have a valid k in nums[i]-nums[j]\\n    nums.sort((a,b)=>a-b)\\n    let k2\\n    let status = false\\n    let ans\\n    for(let i=1;i<nums.length;i++){\\n        k2=nums[i]-nums[0]\\n        if(k2!=0 && Math.abs(k2)%2==0){ \\n            [status, ans] = getArray(k2, nums)\\n        }\\n\\t\\t//must have at least one solution\\n        if(status){\\n            return ans\\n        }\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1648740,
                "title": "python-3-hint-solution",
                "content": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n = len(nums)\\n        \\n        def check(k):\\n            cnt = defaultdict(int)\\n            ans = []\\n            for x in nums:\\n                if cnt[x - 2*k] > 0:\\n                    cnt[x - 2*k] -= 1\\n                    ans.append(x - k)\\n                else:\\n                    cnt[x] += 1\\n            if len(ans) == n // 2: return ans\\n            return []\\n                       \\n\\t    # maximum k should not exceed half of the array\\n        cand_k = sorted(set((nums[i] - nums[0]) // 2 for i in range(1, n // 2 + 1) if (nums[i] - nums[0]) % 2 == 0))\\n        for k in cand_k:\\n            if k == 0: continue\\n            ans = check(k)\\n            if ans: return ans\\n\\n\\n```\\n**Updated**\\nBased on https://leetcode.com/problems/recover-the-original-array/discuss/1647452/Python-Short-solution-explained, check function could still be optimized by early stop criteria (1680 ms -->532 ms)\\n\\n```\\n        def check(k):\\n            cnt = Counter(nums)\\n            ans = []\\n            for i, x in enumerate(nums):\\n                if cnt[x] == 0: continue\\n                if cnt[x + 2 * k] == 0: return []\\n                cnt[x] -= 1\\n                cnt[x + 2 * k] -= 1\\n                ans.append(x + k)                \\n            if len(ans) == n // 2: return ans\\n            return []\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n = len(nums)\\n        \\n        def check(k):\\n            cnt = defaultdict(int)\\n            ans = []\\n            for x in nums:\\n                if cnt[x - 2*k] > 0:\\n                    cnt[x - 2*k] -= 1\\n                    ans.append(x - k)\\n                else:\\n                    cnt[x] += 1\\n            if len(ans) == n // 2: return ans\\n            return []\\n                       \\n\\t    # maximum k should not exceed half of the array\\n        cand_k = sorted(set((nums[i] - nums[0]) // 2 for i in range(1, n // 2 + 1) if (nums[i] - nums[0]) % 2 == 0))\\n        for k in cand_k:\\n            if k == 0: continue\\n            ans = check(k)\\n            if ans: return ans\\n\\n\\n```\n```\\n        def check(k):\\n            cnt = Counter(nums)\\n            ans = []\\n            for i, x in enumerate(nums):\\n                if cnt[x] == 0: continue\\n                if cnt[x + 2 * k] == 0: return []\\n                cnt[x] -= 1\\n                cnt[x + 2 * k] -= 1\\n                ans.append(x + k)                \\n            if len(ans) == n // 2: return ans\\n            return []\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1648625,
                "title": "swift",
                "content": "func recoverArray(_ num: [Int]) -> [Int] {\\n        var nums = num\\n        nums.sort()\\n        guard nums.count % 2 == 0 else {\\n            return nums\\n        }\\n        \\n        var first = nums[0]\\n        print(nums)\\n        for i in 1..<nums.count {\\n             var k = (nums[i] - first) / 2\\n            var t = isValidK(k,nums)\\n            if t.0,  k > 0 {\\n                print(k)\\n                return t.1\\n            }\\n            \\n        }\\n       \\n       \\n        return []\\n    }\\n    \\n    func isValidK(_ k: Int, _ nums: [Int]) -> (Bool, [Int]) {\\n        var dict: [Int: Int] = [:]\\n        var first: [Int] = []\\n         for i in 0..<nums.count {\\n             if dict[nums[i]] == nil {\\n                 dict[nums[i]] = 1\\n             } else {\\n                 dict[nums[i]] = dict[nums[i]]! + 1\\n             }\\n         }\\n        var t = 0\\n        for i in 0..<nums.count {\\n             if let a = dict[nums[i]], let b = dict[nums[i]+2*k], a > 0, b > 0 {\\n                 dict[nums[i]] = dict[nums[i]]! - 1\\n                  dict[nums[i]+2*k] = dict[nums[i]+2*k]! - 1\\n                 first.append(nums[i]+k)\\n                 t = t + 1\\n             }\\n         }\\n        \\n        if 2*t == nums.count {\\n            return (true, first)\\n        }\\n        \\n        return (false, [])\\n    }",
                "solutionTags": [],
                "code": "func recoverArray(_ num: [Int]) -> [Int] {\\n        var nums = num\\n        nums.sort()\\n        guard nums.count % 2 == 0 else {\\n            return nums\\n        }\\n        \\n        var first = nums[0]\\n        print(nums)\\n        for i in 1..<nums.count {\\n             var k = (nums[i] - first) / 2\\n            var t = isValidK(k,nums)\\n            if t.0,  k > 0 {\\n                print(k)\\n                return t.1\\n            }\\n            \\n        }\\n       \\n       \\n        return []\\n    }\\n    \\n    func isValidK(_ k: Int, _ nums: [Int]) -> (Bool, [Int]) {\\n        var dict: [Int: Int] = [:]\\n        var first: [Int] = []\\n         for i in 0..<nums.count {\\n             if dict[nums[i]] == nil {\\n                 dict[nums[i]] = 1\\n             } else {\\n                 dict[nums[i]] = dict[nums[i]]! + 1\\n             }\\n         }\\n        var t = 0\\n        for i in 0..<nums.count {\\n             if let a = dict[nums[i]], let b = dict[nums[i]+2*k], a > 0, b > 0 {\\n                 dict[nums[i]] = dict[nums[i]]! - 1\\n                  dict[nums[i]+2*k] = dict[nums[i]+2*k]! - 1\\n                 first.append(nums[i]+k)\\n                 t = t + 1\\n             }\\n         }\\n        \\n        if 2*t == nums.count {\\n            return (true, first)\\n        }\\n        \\n        return (false, [])\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1648212,
                "title": "c-two-pointer-o-2-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n            vector<int> vis(n,0);\\n            ans.clear();\\n            int l=0,r=i,k;\\n            k=nums[r]-nums[l];\\n            if(k%2 || k==0) continue;\\n            while(1){\\n                while(l<n && vis[l])    l++;\\n                while(r<n && (vis[r]||(nums[l]+k)!=nums[r]))    r++;\\n                if(l==n||r==n)    break;\\n                vis[l]=1;vis[r]=1;\\n                ans.emplace_back(nums[l]+k/2);\\n            }\\n            int m=ans.size();\\n            if(2*m==n)  break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n            vector<int> vis(n,0);\\n            ans.clear();\\n            int l=0,r=i,k;\\n            k=nums[r]-nums[l];\\n            if(k%2 || k==0) continue;\\n            while(1){\\n                while(l<n && vis[l])    l++;\\n                while(r<n && (vis[r]||(nums[l]+k)!=nums[r]))    r++;\\n                if(l==n||r==n)    break;\\n                vis[l]=1;vis[r]=1;\\n                ans.emplace_back(nums[l]+k/2);\\n            }\\n            int m=ans.size();\\n            if(2*m==n)  break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648002,
                "title": "c-logic-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        //sort the numbers\\n        sort(nums.begin(), nums.end());\\n        \\n        //insert in a multiset\\n        multiset<int> ms;\\n        for(auto x : nums) \\n            ms.insert(x);\\n        \\n        // try all possible values of k \\n        // k = nums[i]-nums[0], for all i=1 to i=n-1\\n        for(int i = 1; i < nums.size(); i++) \\n        {\\n            int k = nums[i] - nums[0];\\n            if(k == 0 || k % 2) \\n                continue;\\n            k = k / 2;\\n            \\n            //make a copy of the multiset, dont modify the original\\n            auto copySet = ms;\\n            vector<int> result;\\n            \\n            //iterate through the nums , and check if we can find pairs for all values\\n            for(int i = 0; i < nums.size(); i++) {\\n                auto it = copySet.find(nums[i]);\\n                if(it == copySet.end()) \\n                    continue;\\n                auto it2 = copySet.find(nums[i] + 2 * k);\\n                if(it2 == copySet.end()) \\n                    continue;\\n                \\n                // if pair is found, delete them from multiset, and enter the arr value \\n                // of nums[i]+k in result\\n                copySet.erase(it);\\n                copySet.erase(it2);\\n                result.push_back(nums[i] + k);\\n            }\\n            // if all elements had a pair, at the end multiset will be empty\\n            if(copySet.size() == 0) \\n                return result;\\n        }\\n        return {};\\n    \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        //sort the numbers\\n        sort(nums.begin(), nums.end());\\n        \\n        //insert in a multiset\\n        multiset<int> ms;\\n        for(auto x : nums) \\n            ms.insert(x);\\n        \\n        // try all possible values of k \\n        // k = nums[i]-nums[0], for all i=1 to i=n-1\\n        for(int i = 1; i < nums.size(); i++) \\n        {\\n            int k = nums[i] - nums[0];\\n            if(k == 0 || k % 2) \\n                continue;\\n            k = k / 2;\\n            \\n            //make a copy of the multiset, dont modify the original\\n            auto copySet = ms;\\n            vector<int> result;\\n            \\n            //iterate through the nums , and check if we can find pairs for all values\\n            for(int i = 0; i < nums.size(); i++) {\\n                auto it = copySet.find(nums[i]);\\n                if(it == copySet.end()) \\n                    continue;\\n                auto it2 = copySet.find(nums[i] + 2 * k);\\n                if(it2 == copySet.end()) \\n                    continue;\\n                \\n                // if pair is found, delete them from multiset, and enter the arr value \\n                // of nums[i]+k in result\\n                copySet.erase(it);\\n                copySet.erase(it2);\\n                result.push_back(nums[i] + k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1647939,
                "title": "c-using-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& arr) {\\n        int n=(int)arr.size();\\n        sort(arr.begin(),arr.end());\\n        multiset<int>mt;\\n        for(int i=0;i<n;i++){\\n            mt.insert(arr[i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            int d=arr[i]-arr[0];\\n            if(d%2==1||d==0){\\n                continue;\\n            }\\n            multiset<int>mt1=mt;\\n            vector<int>ans;\\n            for(int j=0;j<n;j++){\\n                if(!mt1.count(arr[j])){\\n                    continue;\\n                }\\n                if(!mt1.count(arr[j]+d)){\\n                    break;\\n                }\\n                mt1.erase(mt1.find(arr[j]));\\n                mt1.erase(mt1.find(d+arr[j]));\\n                ans.push_back(arr[j]+d/2);\\n            }\\n            if(mt1.empty()){\\n                return ans;\\n            }\\n        }\\n        return {};   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& arr) {\\n        int n=(int)arr.size();\\n        sort(arr.begin(),arr.end());\\n        multiset<int>mt;\\n        for(int i=0;i<n;i++){\\n            mt.insert(arr[i]);\\n        }\\n        for(int i=1;i<n;i++){\\n            int d=arr[i]-arr[0];\\n            if(d%2==1||d==0){\\n                continue;\\n            }\\n            multiset<int>mt1=mt;\\n            vector<int>ans;\\n            for(int j=0;j<n;j++){\\n                if(!mt1.count(arr[j])){\\n                    continue;\\n                }\\n                if(!mt1.count(arr[j]+d)){\\n                    break;\\n                }\\n                mt1.erase(mt1.find(arr[j]));\\n                mt1.erase(mt1.find(d+arr[j]));\\n                ans.push_back(arr[j]+d/2);\\n            }\\n            if(mt1.empty()){\\n                return ans;\\n            }\\n        }\\n        return {};   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647871,
                "title": "c-68-ms-100-faster-easy-to-understand-o-n-2",
                "content": "* So here the main observation is that we can use the smallest element present in nums to find a K which can recover the original array.\\n\\n* Also an important thing to notice here is that the difference between higher and lower for any index is 2k so using that optimization reduces the Possible k checks.\\n\\n* Possible function explanation:\\n\\n\\t1. Here in the Possible function we try to match every nums[i] with an appropriate number for a given k and once we got a match we mark it visited, so we don\\'t use that again.\\n\\t2. If we don\\'t get any matching index than it is impossible to have that k in that case we return empty array otherwise we return the constructed array.\\n\\nThe code is self-explanatory, But if you still have any doubt you can ask them in comments \\t&#128515;\\n```\\nclass Solution {\\nprivate:\\n    vector<int> Possible(vector<int>& nums,int k) {\\n        vector<int> ans;\\n        vector<bool> visited(nums.size());\\n        for(int i=0,j=0;i<nums.size();i++) {\\n            if(visited[i]) continue;\\n            int required=nums[i]+2*k;\\n            while(j<nums.size() && nums[j]!=required) \\n\\t\\t\\t\\tj++;\\n            if(j<nums.size()) {\\n                visited[j]=1;\\n                ans.push_back((nums[i]+nums[j])/2);\\n                j++;\\n            }\\n        }\\n        if(ans.size()==nums.size()/2) return ans;\\n        else return {};\\n    }\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++) {\\n            if(nums[i]==nums[0] || (nums[i]-nums[0])%2) continue;\\n            vector<int> ans=Possible(nums,(nums[i]-nums[0])/2);\\n            if(!ans.empty()) return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> Possible(vector<int>& nums,int k) {\\n        vector<int> ans;\\n        vector<bool> visited(nums.size());\\n        for(int i=0,j=0;i<nums.size();i++) {\\n            if(visited[i]) continue;\\n            int required=nums[i]+2*k;\\n            while(j<nums.size() && nums[j]!=required) \\n\\t\\t\\t\\tj++;\\n            if(j<nums.size()) {\\n                visited[j]=1;\\n                ans.push_back((nums[i]+nums[j])/2);\\n                j++;\\n            }\\n        }\\n        if(ans.size()==nums.size()/2) return ans;\\n        else return {};\\n    }\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++) {\\n            if(nums[i]==nums[0] || (nums[i]-nums[0])%2) continue;\\n            vector<int> ans=Possible(nums,(nums[i]-nums[0])/2);\\n            if(!ans.empty()) return ans;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647843,
                "title": "c-maps-brute-force",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> recoverArray(vector<int> &nums)\\n    {\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n\\n        map<int, int> mp;\\n        for (int i : nums)\\n        {\\n            mp[i]++;\\n        }\\n        \\n        vector<int> d;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if ((nums[i] - nums[0]) % 2 == 0 && (nums[i] - nums[0]) > 0)\\n                d.push_back(nums[i] - nums[0]);\\n        }\\n\\n        int k = 0;\\n        for (int i = 0; i < d.size(); i++)\\n        {\\n            map<int, int> tmp;\\n            tmp = mp;\\n            int flag = 1;\\n            int dif = d[i];\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (tmp[nums[j]] == 0)\\n                    continue;\\n                if (tmp[nums[j] + dif] <= 0)\\n                {\\n                    flag = 0;\\n                    break;\\n                }\\n                tmp[nums[j]]--;\\n                tmp[nums[j] + dif]--;\\n            }\\n\\n            if (flag)\\n            {\\n                tmp = mp;\\n                vector<int> v;\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (tmp[nums[j]] == 0)\\n                        continue;\\n\\n                    tmp[nums[j]]--;\\n                    tmp[nums[j] + dif]--;\\n                    v.push_back(nums[j] + dif / 2);\\n                }\\n                return v;\\n            }\\n        }\\n        return {};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n    vector<int> recoverArray(vector<int> &nums)\\n    {\\n\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n\\n        map<int, int> mp;\\n        for (int i : nums)\\n        {\\n            mp[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1647766,
                "title": "javascript-greedy-984ms",
                "content": "```\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\nconst removeOneMap = (m, x) => { let occ = m.get(x); occ > 1 ? m.set(x, occ - 1) : m.delete(x); };\\nconst deepCopyMap = (m) => new Map(m);\\n\\nconst recoverArray = (a) => {\\n    a.sort((x, y) => x - y)\\n    let n = a.length, res = [], cnt = counter(a);\\n    for (let i = 1; i < n; i++) {\\n        let k = a[i] - a[0], m = deepCopyMap(cnt);\\n        res = [];\\n        if (ok(k, a, m, res)) return res;\\n    }\\n    return [];\\n};\\n\\n// greedy: check each possible k with lower[i]\\nconst ok = (k, a, m, res) => {\\n    if (k == 0 || k & 1) return false;\\n    for (const low of a) {\\n        if (m.has(low)) {\\n            let mid = low + (k >> 1), high = low + k; // assume the condition\\n            res.push(mid);\\n            removeOneMap(m, low);\\n            if (m.has(high)) {\\n                removeOneMap(m, high);\\n            } else { // high not exist in original array\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\nconst removeOneMap = (m, x) => { let occ = m.get(x); occ > 1 ? m.set(x, occ - 1) : m.delete(x); };\\nconst deepCopyMap = (m) => new Map(m);\\n\\nconst recoverArray = (a) => {\\n    a.sort((x, y) => x - y)\\n    let n = a.length, res = [], cnt = counter(a);\\n    for (let i = 1; i < n; i++) {\\n        let k = a[i] - a[0], m = deepCopyMap(cnt);\\n        res = [];\\n        if (ok(k, a, m, res)) return res;\\n    }\\n    return [];\\n};\\n\\n// greedy: check each possible k with lower[i]\\nconst ok = (k, a, m, res) => {\\n    if (k == 0 || k & 1) return false;\\n    for (const low of a) {\\n        if (m.has(low)) {\\n            let mid = low + (k >> 1), high = low + k; // assume the condition\\n            res.push(mid);\\n            removeOneMap(m, low);\\n            if (m.has(high)) {\\n                removeOneMap(m, high);\\n            } else { // high not exist in original array\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647722,
                "title": "just-try-brute-force-python",
                "content": "```python\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2: return [sum(nums) // 2]\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(1, n):\\n            k = (nums[i] - nums[0]) // 2\\n            tmp = nums[:]\\n            arr = []\\n            while tmp:\\n                a = tmp.pop(0)\\n                b = a + 2 * k\\n                if b in tmp:\\n                    tmp.remove(b)\\n                    arr.append((a + b) // 2)\\n                else: break\\n            if len(arr) == n // 2 and k > 0: return arr\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2: return [sum(nums) // 2]\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(1, n):\\n            k = (nums[i] - nums[0]) // 2\\n            tmp = nums[:]\\n            arr = []\\n            while tmp:\\n                a = tmp.pop(0)\\n                b = a + 2 * k\\n                if b in tmp:\\n                    tmp.remove(b)\\n                    arr.append((a + b) // 2)\\n                else: break\\n            if len(arr) == n // 2 and k > 0: return arr\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647675,
                "title": "python-solution-with-o-n-2-time-complexity-counter-228ms",
                "content": "We can test all the possible k by considering the difference between the minimum number with other numbers. This process can also be optimized by \\nconsidering the maximum number.\\n\\nEach time we have a smallest number x, we can use Counter to consume x+2k. If this process can successfully finish, we return the result.\\n\\nThe interesting thing is that, I get TLE without removing duplicate k using set and constraining the possible k using the maximum number.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        We can test the possible 10^3 k\\n        for each k, we try to build the array\\n        how to build? each time get min x, try to consume x+2k\\n        \"\"\"\\n        possible_k=set()\\n        counter=Counter(nums)\\n        num_min=min(counter)\\n        num_max=max(counter)\\n        for num in nums:\\n            if num>num_min and (num-num_min)%2==0:\\n                pk=(num-num_min)//2\\n                if num_min+2*pk in counter and num_max-2*pk in counter:\\n                    possible_k.add(pk)\\n        \\n        \\n        for k in possible_k:\\n            cnt=counter.copy()\\n            considered=0\\n            inside_break=False\\n            result=[]\\n            while considered<len(nums)//2:\\n                minval=min(cnt)\\n                # print(result,considered,cnt,k,cnt[minval+2*k],cnt[minval])\\n                if cnt[minval+2*k]>=cnt[minval]:\\n                    mincount=cnt.pop(minval)\\n                    cnt[minval+2*k]-=mincount\\n                    if cnt[minval+2*k]==0:\\n                        cnt.pop(minval+2*k)\\n                    considered+=mincount\\n                    result+=[minval+k]*mincount\\n                else:\\n                    inside_break=True\\n                    break\\n                \\n            if not inside_break:\\n                return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        We can test the possible 10^3 k\\n        for each k, we try to build the array\\n        how to build? each time get min x, try to consume x+2k\\n        \"\"\"\\n        possible_k=set()\\n        counter=Counter(nums)\\n        num_min=min(counter)\\n        num_max=max(counter)\\n        for num in nums:\\n            if num>num_min and (num-num_min)%2==0:\\n                pk=(num-num_min)//2\\n                if num_min+2*pk in counter and num_max-2*pk in counter:\\n                    possible_k.add(pk)\\n        \\n        \\n        for k in possible_k:\\n            cnt=counter.copy()\\n            considered=0\\n            inside_break=False\\n            result=[]\\n            while considered<len(nums)//2:\\n                minval=min(cnt)\\n                # print(result,considered,cnt,k,cnt[minval+2*k],cnt[minval])\\n                if cnt[minval+2*k]>=cnt[minval]:\\n                    mincount=cnt.pop(minval)\\n                    cnt[minval+2*k]-=mincount\\n                    if cnt[minval+2*k]==0:\\n                        cnt.pop(minval+2*k)\\n                    considered+=mincount\\n                    result+=[minval+k]*mincount\\n                else:\\n                    inside_break=True\\n                    break\\n                \\n            if not inside_break:\\n                return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647670,
                "title": "c-brute-force-with-comments-130-ms",
                "content": "This question seems to be very interesting but actually not.\\n\\nSome observations:\\n1. the minimum of the array must be from arr[i] - K; similarly, the maximum from arr[i] + K;\\n2. after sorting the array with size of 2n, the possible ks\\' can only be the (arr[i] - arr[0])/2, where i can be from 1 to n. Or i cannot be larger than n. This is easy to prove: if yes, then we cannot find enough pairs which needs to be n pairs exactly.\\n\\nMore details can be found at https://algoadvance.blogspot.com/2021/12/brute-force-question-1.html\\n\\nWith the above observations, we can graudally try every possible k. See the code below:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> res;\\n        for(int i=1; i<=n/2; ++i) {\\n            int k = (nums[i] - nums[0])/2;\\n            if(k==0) continue;\\n            vector<int> used(n, 0);\\n            int j = 0;\\n            bool find = true;\\n            while(res.size()<n/2 && j<n) {\\n                while(j<n&& used[j]) ++j;\\n                if(j<n) {\\n                    res.push_back(nums[j]+k);\\n                    used[j] = 1;\\n\\t\\t\\t\\t\\t// find the first un-used valid element\\n                    int id = lower_bound(nums.begin(), nums.end(), nums[j]+2*k) - nums.begin();\\n                    while(id<n&& used[id]) ++id;\\n\\t\\t\\t\\t\\t// if there is no valid element, break and try another k\\n                    if(id==nums.size() || nums[id] != nums[j]+2*k) {\\n                        find = false;\\n                        res.clear();\\n                        break;\\n                    }\\n                    used[id] = 1;\\n                }\\n            }\\n\\t\\t\\t// when find one, done\\n            if(find) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> res;\\n        for(int i=1; i<=n/2; ++i) {\\n            int k = (nums[i] - nums[0])/2;\\n            if(k==0) continue;\\n            vector<int> used(n, 0);\\n            int j = 0;\\n            bool find = true;\\n            while(res.size()<n/2 && j<n) {\\n                while(j<n&& used[j]) ++j;\\n                if(j<n) {\\n                    res.push_back(nums[j]+k);\\n                    used[j] = 1;\\n\\t\\t\\t\\t\\t// find the first un-used valid element\\n                    int id = lower_bound(nums.begin(), nums.end(), nums[j]+2*k) - nums.begin();\\n                    while(id<n&& used[id]) ++id;\\n\\t\\t\\t\\t\\t// if there is no valid element, break and try another k\\n                    if(id==nums.size() || nums[id] != nums[j]+2*k) {\\n                        find = false;\\n                        res.clear();\\n                        break;\\n                    }\\n                    used[id] = 1;\\n                }\\n            }\\n\\t\\t\\t// when find one, done\\n            if(find) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647665,
                "title": "python-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        possible=[(nums[i]-nums[0])//2 for i in range(1, len(nums)) if (nums[i]-nums[0])%2==0 and nums[i]!=nums[0]]\\n        for i in possible:\\n            cur=SortedList(nums)\\n            memo=[]\\n            while len(cur)>0:\\n                first=cur[0]\\n                cur.remove(first)\\n                if first+i+i not in cur:\\n                    break\\n                memo.append(first+i)\\n                cur.remove(first+i+i)\\n            if len(cur)==0:\\n                return memo\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        possible=[(nums[i]-nums[0])//2 for i in range(1, len(nums)) if (nums[i]-nums[0])%2==0 and nums[i]!=nums[0]]\\n        for i in possible:\\n            cur=SortedList(nums)\\n            memo=[]\\n            while len(cur)>0:\\n                first=cur[0]\\n                cur.remove(first)\\n                if first+i+i not in cur:\\n                    break\\n                memo.append(first+i)\\n                cur.remove(first+i+i)\\n            if len(cur)==0:\\n                return memo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647605,
                "title": "c-brute-force",
                "content": "<strong>Logical Thinking</strong>\\n<p>For this problem, we <strong>greedily</strong> try all possible <code>k</code>s. To do this, we <strong>sort</strong> <code>nums</code>, count and save the frequency of each value in a <strong>hash table</strong> <code>m</code>. Then, we try all differences <code>d = nums[i] - nums[0]</code> for <code>i &gt; 0</code>. The difference needs to be even, i.e. <code>d % 2 == 0</code>, since <code>d == 2 * k</code>. During checking, for each element <code>low</code> in <code>nums</code>, see if we can find the corresponding <code>high = low + d</code>. If so, we need to reduce the frequency of <code>high</code> as well as <code>low</code>, i.e. <code>m[high] -= m[low] && m[low] = 0</code>, since <code>high</code> is already assigned to vector <code>higher</code> and don\\'t need to consider it as a potential element of <code>lower</code>. If we cannot find the pair <code>(low, high)</code>, the current <code>d</code> is not the one we need. </p>\\n\\n\\n<strong>C++</strong>\\n\\n```\\n// Topic     : 2122. Recover the Original Array (https://leetcode.com/problems/recover-the-original-array/)\\n// Author    : YCX\\n// Time      : O(NlogN + N^2)\\n// Space     : O(N)\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> mp;\\n        for (auto& i : nums)\\n            mp[i]++;\\n        int k, n = nums.size();\\n        for (int i = 1; i < n; i++)\\n        {\\n            k = nums[i] - nums[0];\\n            if (k % 2)\\n                continue;\\n            if (success(k, mp, nums, n))\\n                break;\\n        }\\n        k /= 2;\\n        vector<int> ans;\\n        for (auto& low : nums)\\n        {\\n            if (mp[low] == 0)\\n                continue;\\n            int arr = low + k, high = low + 2 * k;\\n            mp[high] -= mp[low];\\n            while (mp[low])\\n            {\\n                ans.push_back(arr);\\n                mp[low]--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    bool success(int k, unordered_map<int, int>& mp, vector<int>& nums, int& n)\\n    {\\n        int l = 0;\\n        auto mq = mp;\\n        for (auto& low : nums)\\n        {\\n            if (mq[low] == 0)\\n                continue;\\n            int high = low + k;\\n            if (!mq.count(high) || mq[high] < mq[low])\\n                return false;\\n            l += (2 * mq[low]);\\n            mq[high] -= mq[low];\\n            mq[low] = 0;\\n        }\\n        return (l == n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Topic     : 2122. Recover the Original Array (https://leetcode.com/problems/recover-the-original-array/)\\n// Author    : YCX\\n// Time      : O(NlogN + N^2)\\n// Space     : O(N)\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> recoverArray(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> mp;\\n        for (auto& i : nums)\\n            mp[i]++;\\n        int k, n = nums.size();\\n        for (int i = 1; i < n; i++)\\n        {\\n            k = nums[i] - nums[0];\\n            if (k % 2)\\n                continue;\\n            if (success(k, mp, nums, n))\\n                break;\\n        }\\n        k /= 2;\\n        vector<int> ans;\\n        for (auto& low : nums)\\n        {\\n            if (mp[low] == 0)\\n                continue;\\n            int arr = low + k, high = low + 2 * k;\\n            mp[high] -= mp[low];\\n            while (mp[low])\\n            {\\n                ans.push_back(arr);\\n                mp[low]--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    bool success(int k, unordered_map<int, int>& mp, vector<int>& nums, int& n)\\n    {\\n        int l = 0;\\n        auto mq = mp;\\n        for (auto& low : nums)\\n        {\\n            if (mq[low] == 0)\\n                continue;\\n            int high = low + k;\\n            if (!mq.count(high) || mq[high] < mq[low])\\n                return false;\\n            l += (2 * mq[low]);\\n            mq[high] -= mq[low];\\n            mq[low] = 0;\\n        }\\n        return (l == n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567092,
                "content": [
                    {
                        "username": "soumit915",
                        "content": "You can\\'t binary Search on K.\\n\\nProof:\\nYou can only binary-search on f(t), if and only if the function is either non-decreasing or non-increasing, more speifically if the function is **monotonous** in nature.\\nIn this problem, you can have k=5, which is true or k=10 which is satisfying, but it doesn\\'t guarantee that k=7 should hold.\\n\\nExample:\\n`[2, 6, 10, 14]`\\n\\nHere,` k=2` holds giving you the original array as `[4, 12]`\\nAnother solution is `k=4`, giving you the answer as `[6, 10]`.\\n\\nBut it doesn\\'t gurantee` k=3` is holds. So, binary-search on k won\\'t work as a result"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I hate Alice"
                    },
                    {
                        "username": "cswartzell",
                        "content": "To speed up some of the brute force-y solutions, we can start with one simple check: As we know k is positive, as are all elements in arr, then we know the minimum number in our array nums *must* be from the lower array, and the maximum value *must* be from the higher array. We can then test a k to see if both the lowest number + 2k is in nums AND highest number -2k is in nums. These are are the only two numbers we can be sure of their positions. This test may save many iterations as the middles being overlapped are more likely to have false psoitives \n\nThe constraints dont give any limits on K, but we can come up with an upper bound. The \"most extreme\" would be a k that completely seperates the two lists so there is no overlap. If this were the case, then when sorted, the n+1 index (right middle) would be the matched num + k to the smallest number. As we now know the smallest number, we can use the difference between this and the n+1 element as an upper bound for 2k:\n \nk < (nums_sorted[len(nums_sorted)] - nums_sorted[0]) // 2\n\nLastly, the question should really be phrased in sets, or permutations. Arrays imply order. We cannot reconstruct the original array as all the information as to order has been lost. We can come up with a permutation of said array at best. "
                    }
                ]
            },
            {
                "id": 1963323,
                "content": [
                    {
                        "username": "soumit915",
                        "content": "You can\\'t binary Search on K.\\n\\nProof:\\nYou can only binary-search on f(t), if and only if the function is either non-decreasing or non-increasing, more speifically if the function is **monotonous** in nature.\\nIn this problem, you can have k=5, which is true or k=10 which is satisfying, but it doesn\\'t guarantee that k=7 should hold.\\n\\nExample:\\n`[2, 6, 10, 14]`\\n\\nHere,` k=2` holds giving you the original array as `[4, 12]`\\nAnother solution is `k=4`, giving you the answer as `[6, 10]`.\\n\\nBut it doesn\\'t gurantee` k=3` is holds. So, binary-search on k won\\'t work as a result"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I hate Alice"
                    },
                    {
                        "username": "cswartzell",
                        "content": "To speed up some of the brute force-y solutions, we can start with one simple check: As we know k is positive, as are all elements in arr, then we know the minimum number in our array nums *must* be from the lower array, and the maximum value *must* be from the higher array. We can then test a k to see if both the lowest number + 2k is in nums AND highest number -2k is in nums. These are are the only two numbers we can be sure of their positions. This test may save many iterations as the middles being overlapped are more likely to have false psoitives \n\nThe constraints dont give any limits on K, but we can come up with an upper bound. The \"most extreme\" would be a k that completely seperates the two lists so there is no overlap. If this were the case, then when sorted, the n+1 index (right middle) would be the matched num + k to the smallest number. As we now know the smallest number, we can use the difference between this and the n+1 element as an upper bound for 2k:\n \nk < (nums_sorted[len(nums_sorted)] - nums_sorted[0]) // 2\n\nLastly, the question should really be phrased in sets, or permutations. Arrays imply order. We cannot reconstruct the original array as all the information as to order has been lost. We can come up with a permutation of said array at best. "
                    }
                ]
            },
            {
                "id": 1869647,
                "content": [
                    {
                        "username": "soumit915",
                        "content": "You can\\'t binary Search on K.\\n\\nProof:\\nYou can only binary-search on f(t), if and only if the function is either non-decreasing or non-increasing, more speifically if the function is **monotonous** in nature.\\nIn this problem, you can have k=5, which is true or k=10 which is satisfying, but it doesn\\'t guarantee that k=7 should hold.\\n\\nExample:\\n`[2, 6, 10, 14]`\\n\\nHere,` k=2` holds giving you the original array as `[4, 12]`\\nAnother solution is `k=4`, giving you the answer as `[6, 10]`.\\n\\nBut it doesn\\'t gurantee` k=3` is holds. So, binary-search on k won\\'t work as a result"
                    },
                    {
                        "username": "stefan1096",
                        "content": "I hate Alice"
                    },
                    {
                        "username": "cswartzell",
                        "content": "To speed up some of the brute force-y solutions, we can start with one simple check: As we know k is positive, as are all elements in arr, then we know the minimum number in our array nums *must* be from the lower array, and the maximum value *must* be from the higher array. We can then test a k to see if both the lowest number + 2k is in nums AND highest number -2k is in nums. These are are the only two numbers we can be sure of their positions. This test may save many iterations as the middles being overlapped are more likely to have false psoitives \n\nThe constraints dont give any limits on K, but we can come up with an upper bound. The \"most extreme\" would be a k that completely seperates the two lists so there is no overlap. If this were the case, then when sorted, the n+1 index (right middle) would be the matched num + k to the smallest number. As we now know the smallest number, we can use the difference between this and the n+1 element as an upper bound for 2k:\n \nk < (nums_sorted[len(nums_sorted)] - nums_sorted[0]) // 2\n\nLastly, the question should really be phrased in sets, or permutations. Arrays imply order. We cannot reconstruct the original array as all the information as to order has been lost. We can come up with a permutation of said array at best. "
                    }
                ]
            }
        ]
    }
]