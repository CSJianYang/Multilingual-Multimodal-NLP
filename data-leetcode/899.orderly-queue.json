[
    {
        "title": "Orderly Queue",
        "question_content": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n&nbsp;\nExample 1:\n\nInput: s = \"cba\", k = 1\nOutput: \"acb\"\nExplanation: \nIn the first move, we move the 1st character 'c' to the end, obtaining the string \"bac\".\nIn the second move, we move the 1st character 'b' to the end, obtaining the final result \"acb\".\n\nExample 2:\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"\nExplanation: \nIn the first move, we move the 1st character 'b' to the end, obtaining the string \"aacab\".\nIn the second move, we move the 3rd character 'c' to the end, obtaining the final result \"aaabc\".\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= s.length <= 1000\n\ts consist of lowercase English letters.",
        "solutions": [
            {
                "id": 165878,
                "title": "c-java-python-sort-string-or-rotate-string",
                "content": "**Intuition**:\\nFirst, this is string rotation.\\n`12345` -> `23451` -> `34512` -> `45123` -> `51234`\\nI use number instead of letters to make it clear.\\n\\nIf `K == 1`, we can only rotate the whole string.\\nThere are `S.length` different states and\\nwe return the lexicographically smallest string.\\n\\nIf `K > 1`, it means we can:\\n1. rotate the whole string,\\n2. rotate the whole string except the first letter.\\n`012345` -> `023451` -> `034512` -> `045123` -> `051234`\\n\\nWe can rotate `i+1`th big letter to the start (method 1),\\nthen rotate `i`th big letter to the end (method 2).\\n`2XXX01` -> `XXX012`\\n\\nIn this way, we can bubble sort the whole string lexicographically.\\nSo just return sorted string.\\n\\n**C++:**\\n```\\n    string orderlyQueue(string S, int K) {\\n        if (K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        string res = S;\\n        for (int i = 1; i < S.length(); i++)\\n            res = min(res, S.substr(i) + S.substr(0, i));\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def orderlyQueue(self, S, K):\\n        return \"\".join(sorted(S)) if K > 1 else min(S[i:] + S[:i] for i in range(len(S)))\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    string orderlyQueue(string S, int K) {\\n        if (K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        string res = S;\\n        for (int i = 1; i < S.length(); i++)\\n            res = min(res, S.substr(i) + S.substr(0, i));\\n        return res;\\n    }\\n```\n```\\n    public String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def orderlyQueue(self, S, K):\\n        return \"\".join(sorted(S)) if K > 1 else min(S[i:] + S[:i] for i in range(len(S)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 165915,
                "title": "when-k-1-you-can-reorder-any-way-you-like-proof",
                "content": "For any String you can move any char to anywhere if you can swap adjacent characters\\n\\nFor any String `abc[XY]def` you can always do following to swap `XY` if k > 1\\n\\n1. `abc[XY]def` original string\\n2. `[XY]defabc` move `a` to the end, `b` to the end, `c` to the end, etc.\\n3. `defabc[YX]` move `Y` to the end, we can do it because k > 1, then move `X` to the end.\\n4. `abc[YX]def` move `d` to the end, `e` to the end, `f` to the end, etc.\\n\\n```\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1) {\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            return String.valueOf(arr);\\n        } else {\\n            String min = s;\\n            for (int i = 0; i < s.length(); i++) {\\n                s = s.substring(1) + s.charAt(0);\\n                min = min.compareTo(s) < 0 ? min : s;\\n            }\\n            return min;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1) {\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            return String.valueOf(arr);\\n        } else {\\n            String min = s;\\n            for (int i = 0; i < s.length(); i++) {\\n                s = s.substring(1) + s.charAt(0);\\n                min = min.compareTo(s) < 0 ? min : s;\\n            }\\n            return min;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782787,
                "title": "python3-one-liner-o-n-2-with-intuitive-explanations-and-proof-of-k-2",
                "content": "(1) The constraint said s.length <= 1000, this means a O(n^2) algorithm would work.\\n(2) If k==1, we have no choice but to rotate the string to find the lexicographically smallest s. This can be done in a brute force way in O(n^2), so no big deal.\\n(3) If k==2, this means we can freely sweep any two adjacent elements any number of times, which means we can simply sort ```s``` to get the lexicographically smallest one.\\n>Doing this naively following the problem description, let\\'s say we have an ```s``` = \\'a,b,...\\', let\\'s put \\'a\\' to the end (\\'b,...,a\\'), then keep \\'b\\' in the front and put everything to the end until we see \\'a\\' again, now ```s``` becomes \\'b,a,...\\'. If this example is still not convincing you, let\\'s say ```s``` = \\'...,a,b,...\\', let\\'s put all elements before \\'a\\' to the end, then do the same process as before to get \\'b,a,......\\' (a,b is now swept)\\n\\n(4) If k>2, this means we just have more freedom when sweeping the adjacent elements than k==2...\\nSo for k>1 we just sort s.\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return \\'\\'.join(sorted(list(s))) if k!=1 else min(s[i:]+s[:i] for i in range(len(s)))\\n```\\n\\nCheck out the Booth\\'s Algorithm for k == 1 case at [\\uD83D\\uDD25 [LeetCode The Hard Way] \\uD83D\\uDD25 Explained Line By Line](https://leetcode.com/problems/orderly-queue/discuss/2782998/LeetCode-The-Hard-Way-Explained-Line-By-Line)\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```s```\n```s```\n```s```\n```s```\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return \\'\\'.join(sorted(list(s))) if k!=1 else min(s[i:]+s[:i] for i in range(len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445733,
                "title": "python-o-n-2-solution-explained",
                "content": "If `K > 1` than we can change any two adjacent elements: first we can rotate our string, such that we have `abX`, where `X` is some string. Then we can put `b` to the end and then `a` to the end, rotate again and we have `baX`. Now we can look at it as an bubble sort: doing these moves we can sort all string. If `K = 1` we allowed only rotate string and goal is to choose smallest one among `n` options.\\n \\n #### Complexity\\nTime complexity is `O(n^2)` for time and `O(n)` for space\\n \\n #### Code\\n ```python\\n class Solution:\\n    def orderlyQueue(self, S, K):\\n        if K > 1: return \"\".join(sorted(S))\\n        return min(S[i:]+S[:i] for i in range(len(S)))\\n ```\\n \\n #### Remark\\n There is also `O(n)` Booth\\'s Algorithm for finding of minimal rotation. Using count sort we can make whole algorithm `O(n)`. However given restrictions it is not needed.\\n \\n If you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\n class Solution:\\n    def orderlyQueue(self, S, K):\\n        if K > 1: return \"\".join(sorted(S))\\n        return min(S[i:]+S[:i] for i in range(len(S)))\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2782761,
                "title": "c-sliding-window-or-sort-fast-0ms",
                "content": "# Approach 1: sliding window or sort\\n\\nDepending on the value of ```k``` we take two different approaches, see inline comments.\\n\\n```cpp\\n    static string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string ans = s;\\n            // Append |s| to itself and look for the smallest string\\n            // that has the same lenght as |s|.\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));\\n\\n            return ans;\\n        }\\n        \\n        // With k > 1 we can reorder |s| how we want, so sorting it\\n        // will yield the lexicographically smallest one.\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n```\\n\\nTo avoid copying the string around for $$k = 1 $$ we use a ```string_view```. For $$k > 1$$ we could use bucket sort, will maybe add this later.\\n\\n```cpp\\n    static string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            // TODO(heder): Use Booth Algorithm instead, see\\n            // https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\\n\\n            // Make sure the string doesn\\'t get relocated when doubling\\n            // below, to ensure the string_view is not invalidated.\\n            s.reserve(size(s) * 2);\\n            string_view ans{s};\\n            // Append |s| to itself and look for the smallest string\\n            // that has the same lenght as |s|.\\n            s += s;\\n            string_view sv{s};\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, sv.substr(i, size(ans)));\\n\\n            return string{ans};\\n        }\\n        \\n        // With k > 1 we can reorder |s| how we want, so sorting it\\n        // will yield the lexicographically smallest one.\\n        // TODO(heder): Use bucket sort.\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n```\\n\\nTurns out there is soc. [Booth Algorithm](https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation) to efficiently compute the solution for the case of $$k = 1$$. Time permitting, I\\'ll add that too.\\n\\n\\n**Complexity Analysis**\\n  * Time Complexity: For $$k = 1$$ it\\'s $$O(n^2)$$ as we are comparing each substring to the best so far, and for $$k > 1$$ its $$O(n \\\\log n)$$ because we are sorting.\\n  * Space Complexity: For $$k = 1$$ it\\'s $$O(n)$$ for the ```ans``` and as we are doubling the string, and for $$k > 1$$ its $$O(1)$$ as we are sorting the input inplace and returning it.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```k```\n```cpp\\n    static string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string ans = s;\\n            // Append |s| to itself and look for the smallest string\\n            // that has the same lenght as |s|.\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));\\n\\n            return ans;\\n        }\\n        \\n        // With k > 1 we can reorder |s| how we want, so sorting it\\n        // will yield the lexicographically smallest one.\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n```\n```string_view```\n```cpp\\n    static string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            // TODO(heder): Use Booth Algorithm instead, see\\n            // https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\\n\\n            // Make sure the string doesn\\'t get relocated when doubling\\n            // below, to ensure the string_view is not invalidated.\\n            s.reserve(size(s) * 2);\\n            string_view ans{s};\\n            // Append |s| to itself and look for the smallest string\\n            // that has the same lenght as |s|.\\n            s += s;\\n            string_view sv{s};\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, sv.substr(i, size(ans)));\\n\\n            return string{ans};\\n        }\\n        \\n        // With k > 1 we can reorder |s| how we want, so sorting it\\n        // will yield the lexicographically smallest one.\\n        // TODO(heder): Use bucket sort.\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n```\n```ans```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782998,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/DeMWxKNt/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Bonus: Booth\\'s Algorithm for k == 1 case.**\\n\\n<iframe src=\"https://leetcode.com/playground/8ehWqJPV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/DeMWxKNt/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Bonus: Booth\\'s Algorithm for k == 1 case.**\\n\\n<iframe src=\"https://leetcode.com/playground/8ehWqJPV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 165907,
                "title": "c-solution-sort-rotate",
                "content": "The main idea is the following:\\nif `K == 1`, then we can only rotate the string. Hence we can just rotate it at every position and get the lexicographically smallest string from that.\\nif `K > 1`, we can achieve swap of adjacent characters using the following steps:\\nAssume the string has the following characters: c[0], c[1], c[2],...,c[n-1] and we want to swap some position i (i >= 0 && i < n - 1) with position i+1, or swap c[i] and c[i+1]. We can start by pushing the first character at the end until c[i-1], after that we can push c[i+1] to the back and then push c[i] to the back and then can again keep pushing first characters to the end till we see rotate the string completely. After we do one full rotation we would have effectively swapped c[i] & c[i+1]. \\nFor example:\\nsay n = 5, k = 2 and we want to swap c[2], c[3]\\nInitial state: `c[0], c[1], c[2], c[3], c[4]`\\n`c[1], c[2], c[3], c[4], c[0]`\\n`c[2], c[3], c[4], c[0], c[1]`\\n`c[2], c[4], c[0], c[1], c[3]`\\n`c[4], c[0], c[1], c[3], c[2]`\\n`c[0], c[1], c[3], c[2], c[4]`\\n\\nThus we have achieved swapping of chars c[2] and c[3] without disturbing ordering of other characters (similarly this can be done for any pair of adjacent indices). Swapping adjacent characters is enough to sort the whole string (using bubble sort). Hence we can just sort the input and return the smallest string.\\n\\n```\\n    string orderlyQueue(string S, int K) {\\n        if(K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        \\n        int n = S.size();\\n        string res = S;\\n        S += S;\\n        for(int i=0;i<n;i++) {\\n            if(S.substr(i, n) < res) res = S.substr(i, n);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string orderlyQueue(string S, int K) {\\n        if(K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        \\n        int n = S.size();\\n        string res = S;\\n        S += S;\\n        for(int i=0;i<n;i++) {\\n            if(S.substr(i, n) < res) res = S.substr(i, n);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165862,
                "title": "k-1-is-bubblesort",
                "content": "Remind what bubble sort eventually is: **swap pairs**\\n\\nSo, you have a buffer of at least 2 when K>1\\nyou can put them back into the queue in different order: swap!\\n\\nSo, K>1 equals bubble sort\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        if (K>1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        string minS=S;\\n        for (int i=0;i<S.size();++i){\\n            S=S.substr(1)+S.substr(0,1);\\n            minS=min(S,minS);\\n        }\\n        return minS;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        if (K>1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        string minS=S;\\n        for (int i=0;i<S.size();++i){\\n            S=S.substr(1)+S.substr(0,1);\\n            minS=min(S,minS);\\n        }\\n        return minS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782871,
                "title": "python-c-java-rotate-or-not-rotate-that-is-the-question-proof-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs string rearrangements (rotations) to find lexicographicall minimum string. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** The proof of the algorithm consists in 3 steps.\\n1. For `k>1` (we just check for `k=2`), any two adjacent characters can be swapped: `abXYZ -> abXYZ -> aXYZb -> XYZba -> YZbaX -> ZbaXY -> baXYZ`. If `ab` are not in the beginning of the string, i.e., `DEabF`, we first rotate the string `DEabF -> EabFD -> abFDE`, then apply the swap algorithm.\\n2. If we can swap adjacent characters then we can swap any characters in the string, thus, completely sorting the string.\\n3. For `k=1`, the best we can do is rotate the sting character by character and search for the lexicographically minimal one.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1 : return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    string orderlyQueue(string s, int k) \\n    {\\n        if (k > 1) { sort(s.begin(), s.end()); return s; }\\n        string ss = s;\\n        for (int i = 1; i < s.length(); ++i)\\n            ss = min(ss, s.substr(i) + s.substr(0,i));\\n        return ss;\\n    }\\n};\\n```\\n\\n**Java.** Ugly... but that\\'s Java.\\n```\\nclass Solution \\n{\\n    public String orderlyQueue(String s, int k) \\n    {\\n        if (k > 1)\\n        {\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n        \\n        String ss = s;\\n        for (int i = 1; i < s.length(); i++) \\n        {\\n            String rot = s.substring(i) + s.substring(0, i);\\n            if (ss.compareTo(rot) > 0) ss = rot;\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1 : return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string orderlyQueue(string s, int k) \\n    {\\n        if (k > 1) { sort(s.begin(), s.end()); return s; }\\n        string ss = s;\\n        for (int i = 1; i < s.length(); ++i)\\n            ss = min(ss, s.substr(i) + s.substr(0,i));\\n        return ss;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public String orderlyQueue(String s, int k) \\n    {\\n        if (k > 1)\\n        {\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n        \\n        String ss = s;\\n        for (int i = 1; i < s.length(); i++) \\n        {\\n            String rot = s.substring(i) + s.substring(0, i);\\n            if (ss.compareTo(rot) > 0) ss = rot;\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541497,
                "title": "real-o-n-solution-for-java",
                "content": "When K>=2, any permutation is possible. So I used counting sort.\\nWhen K==1, find the lexicographically smallest rotated sequence. And I found an O(n) solution for this case. Quite similar to the KMP method.\\nAny comment or counter-example is welcome.\\n```\\nclass Solution {\\n    \\n    public String orderlyQueue(String S, int K) {\\n        \\n        int len=S.length();\\n        \\n        if(len==0)return S;\\n        \\n        // Double S\\n        S=S+S;\\n        char[]cs=S.toCharArray();\\n        \\n        if(K>=2){\\n            int[]cnt=new int[26];\\n            for(int i=0;i<len;i++)cnt[cs[i]-\\'a\\']++;\\n            StringBuilder str=new StringBuilder(len);\\n            for(int i=0;i<26;i++){\\n                int n=cnt[i];\\n                for(int j=0;j<n;j++)str.append((char)(i+\\'a\\'));\\n            }\\n            return str.toString();\\n        }\\n        \\n        \\n        // Now K==1\\n        char[] res=new char[len*2];\\n        res[0]=cs[0];\\n        int[] arr=new int[len*2];//prefix function\\n        arr[0]=-1;\\n        \\n        int x=0;\\n        \\n        for(int i=1;i<len*2;i++){\\n            while(x>=0&&res[arr[x]+1]>cs[i])x=arr[x];\\n            res[x+1]=cs[i];\\n            \\n            //update arr\\n            if(x>=0){\\n                int k=arr[x];\\n                while(k>=0&&res[k+1]!=cs[i])k=arr[k];\\n                if(res[k+1]==cs[i])k++;\\n                arr[x+1]=k;\\n            }\\n            \\n            x++;\\n        }\\n        \\n        return new String(res,0,len);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String orderlyQueue(String S, int K) {\\n        \\n        int len=S.length();\\n        \\n        if(len==0)return S;\\n        \\n        // Double S\\n        S=S+S;\\n        char[]cs=S.toCharArray();\\n        \\n        if(K>=2){\\n            int[]cnt=new int[26];\\n            for(int i=0;i<len;i++)cnt[cs[i]-\\'a\\']++;\\n            StringBuilder str=new StringBuilder(len);\\n            for(int i=0;i<26;i++){\\n                int n=cnt[i];\\n                for(int j=0;j<n;j++)str.append((char)(i+\\'a\\'));\\n            }\\n            return str.toString();\\n        }\\n        \\n        \\n        // Now K==1\\n        char[] res=new char[len*2];\\n        res[0]=cs[0];\\n        int[] arr=new int[len*2];//prefix function\\n        arr[0]=-1;\\n        \\n        int x=0;\\n        \\n        for(int i=1;i<len*2;i++){\\n            while(x>=0&&res[arr[x]+1]>cs[i])x=arr[x];\\n            res[x+1]=cs[i];\\n            \\n            //update arr\\n            if(x>=0){\\n                int k=arr[x];\\n                while(k>=0&&res[k+1]!=cs[i])k=arr[k];\\n                if(res[k+1]==cs[i])k++;\\n                arr[x+1]=k;\\n            }\\n            \\n            x++;\\n        }\\n        \\n        return new String(res,0,len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782816,
                "title": "java-faster-simple-and-easy",
                "content": "**Please upvote if you like this solution**\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){\\n            char tempArray[] = s.toCharArray();\\n            Arrays.sort(tempArray);\\n            return new String(tempArray);\\n        } else {\\n            String ans  = s;\\n            for(int i=0;i< s.length(); i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(ans.compareTo(s) >0){\\n                    ans = s;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){\\n            char tempArray[] = s.toCharArray();\\n            Arrays.sort(tempArray);\\n            return new String(tempArray);\\n        } else {\\n            String ans  = s;\\n            for(int i=0;i< s.length(); i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(ans.compareTo(s) >0){\\n                    ans = s;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783233,
                "title": "python-simple-and-easy-way-to-solve-with-explanation-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        \\n        res = s\\n        for i in range(0,len(s)):\\n            s = s[1:] + s[0]\\n            res = min(res,s)\\n                \\n        return res\\n```\\n\\n**For Detail Explaination Refer this Blog:\\nhttps://www.python-techs.com/2022/11/orderly-queue.html**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        \\n        res = s\\n        for i in range(0,len(s)):\\n            s = s[1:] + s[0]\\n            res = min(res,s)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784359,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n       // for k>1 we can make it fully sorted string after roation because here we are not bound to the roatate first char only.\\n        if (K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        // for k==1 we can rotate whole string any times like-  S=\"cba\" we can get cba, bac,acb so in S+S =\"cbacba\" we need to find only lexicographically smallest string  of size n in S+S.\\n            string tempr=S;\\n            S= S+ S;\\n            for(int i=1;i<tempr.size();i++){\\n                tempr=min(tempr,S.substr(i,tempr.size()));\\n            }\\n            return tempr;\\n    }\\n};\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n       // for k>1 we can make it fully sorted string after roation because here we are not bound to the roatate first char only.\\n        if (K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        // for k==1 we can rotate whole string any times like-  S=\"cba\" we can get cba, bac,acb so in S+S =\"cbacba\" we need to find only lexicographically smallest string  of size n in S+S.\\n            string tempr=S;\\n            S= S+ S;\\n            for(int i=1;i<tempr.size();i++){\\n                tempr=min(tempr,S.substr(i,tempr.size()));\\n            }\\n            return tempr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108744,
                "title": "bubble-sort",
                "content": "1. Basic idea is bubble sort\\n **CASE 1: if K>=2**\\n2. if we can swap any two consecutive character i.e we can do a sort then.\\n  eg: aa**db**ac lets try to swap d and b  k=2\\n      step1 : adbaca\\n      step2:  dbacaa\\n     step 3: dacaab\\n     step 4: acaabd\\n     step5 : caabda\\n     step6 : aa**bd**ac  \\n   if K is greater than equal to 2 we can swap any 2 consecutive character. so we can use sorting then.\\n\\n**CASE2: if K ==1**\\n  now we cannot swap any 2 consecutive characters so we have to check for all combinations and check which is lexographically smallest.\\n  \\n\\n```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if(K>=2){\\n            char[] ch=S.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }else{\\n            String s2=S + S;\\n            for(int i=0;i<S.length();i++){\\n                String temp=s2.substring(i,i+S.length());\\n                S=(S.compareTo(temp)>0)?temp:S;\\n            }\\n        }\\n        return S;\\n    }\\n}\\n```\\n\\n**TIME COMPLEXITY : \\nif K>=2 O(NLogN)**\\n**if K==1 O(N^2) (bcz compareTO O(N))   for every possible combination we are doing  a O(N) operation so time complexity is O(N^2)**\\n\\nSPACE COMPLEXITY : O(1)\\n  \\n\\n  \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if(K>=2){\\n            char[] ch=S.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }else{\\n            String s2=S + S;\\n            for(int i=0;i<S.length();i++){\\n                String temp=s2.substring(i,i+S.length());\\n                S=(S.compareTo(temp)>0)?temp:S;\\n            }\\n        }\\n        return S;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782748,
                "title": "daily-leetcoding-challenge-november-day-6",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **üìå Do you want to learn the problem thoroughly?**\n  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/orderly-queue/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Mathematical\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/orderly-queue/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1446662,
                "title": "c-simple-and-short-solution-0ms-faster-than-100",
                "content": "**Idea:**\\nIf `k==1`, then we can only choose the first letter and append it to the end. This is basically rotating the string. So we can just try rotating and see the smallest result.\\nIf `k>1`, then we can do some amount of moves to always get the string sorted.\\nWe can keep 1 or more numbers in the beginning of the string and take care only of the rest.\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k > 1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        string res = s;\\n        for (int i = 0; i < s.size(); i++)\\n            res = min(res, s.substr(i)+s.substr(0, i));\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k > 1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        string res = s;\\n        for (int i = 0; i < s.size(); i++)\\n            res = min(res, s.substr(i)+s.substr(0, i));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785103,
                "title": "97-faster-short-python-solution-explained-with-proof",
                "content": "This is my longest post. Plese up-vote if you like it.\\n\\nIf k==1, then we are able to produce every possible rotation and nothing else.\\nHowever if k==2 or more, then we can actually generate every permutation, so the answer is actually the sorted text.\\n\\nLets call:\\n  - allowed operation: `op(i)` where `i<=k`, and\\n  - `op(0)` **shifting**, and\\n  - `n := len(text)` \\n  - `swap(i,j)` operation of swapping `text[i]` and `text[j]` \\n\\nIf `k==1` then we can only do shifting. So we only need to find the minimum of `n` options.\\nSmall optimization is to construct once `text+text` and operate on n-long window.\\n\\nFor `k>1` it is more interesting. We can generate every permutation. Why? Because we can generate every possible swap(i, j). Why? Because we can generate `swap(i, i+1)` for every possible `i`. Here is how:\\n1. op(1), folowed by `shift` and followed by `shift` several times we can generate swap(0,1).\\n2.  by sequence of `shift`, then `swap(0,1)` and sequence of `shift` we can generate `swap(i,i+1)` for any `i`.\\n3.  by two sequences of `swap(i,i+1)` we can generate `swap(i,j)` for any `i<j`\\n4.  finally by sequence of `swap(i,j)` we can generate any permutation.\\nSince we know that every possible permutaion can be generated, we do not need to construct them. We can simply sort the input text to pick the best permutation. \\n\\n```python\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            s2 = s+s\\n            n = len(s)\\n            return min(s2[i:i+n] for i in range(n))            \\n        else:\\n            return \"\".join(sorted(s))\\n ```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            s2 = s+s\\n            n = len(s)\\n            return min(s2[i:i+n] for i in range(n))            \\n        else:\\n            return \"\".join(sorted(s))\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 2784607,
                "title": "easy-python-solution-using-queue-tc-o-k-2-nlog-n-sc-o-n",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        st=\"\"\\n        lst=list(s)\\n        lst.sort()\\n        queue=list(s)\\n        flg=defaultdict(lambda :0)\\n        if k==1:\\n            pt=[z for z in range(len(lst)) if s[z]==lst[0]]\\n            mn=s[pt[0]:]+s[:pt[0]]\\n            for p in range(len(pt)):\\n                mn=min(mn,s[pt[p]:]+s[:pt[p]])\\n            return mn\\n        ct=k\\n        if k==len(s):\\n            return \"\".join(lst)\\n        while k>0:\\n            if queue[0][0]==lst[0]:\\n                st+=queue.pop(0)[0]\\n                lst.pop(0)\\n                k-=1\\n                for nm in flg:\\n                    flg[nm]=0\\n            else:\\n                mn=queue[0]\\n                ind=0\\n                for i in range(1,min(ct,len(queue)-1)):\\n                    if queue[i]<mn and queue[i]!=lst[0] and flg[queue[i]]!=1:\\n                        ind=i\\n                x=queue.pop(ind)\\n                queue.append(x)\\n                flg[x]=1\\n        if ct>1:\\n            queue.sort()\\n        return st+\"\".join(queue)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        st=\"\"\\n        lst=list(s)\\n        lst.sort()\\n        queue=list(s)\\n        flg=defaultdict(lambda :0)\\n        if k==1:\\n            pt=[z for z in range(len(lst)) if s[z]==lst[0]]\\n            mn=s[pt[0]:]+s[:pt[0]]\\n            for p in range(len(pt)):\\n                mn=min(mn,s[pt[p]:]+s[:pt[p]])\\n            return mn\\n        ct=k\\n        if k==len(s):\\n            return \"\".join(lst)\\n        while k>0:\\n            if queue[0][0]==lst[0]:\\n                st+=queue.pop(0)[0]\\n                lst.pop(0)\\n                k-=1\\n                for nm in flg:\\n                    flg[nm]=0\\n            else:\\n                mn=queue[0]\\n                ind=0\\n                for i in range(1,min(ct,len(queue)-1)):\\n                    if queue[i]<mn and queue[i]!=lst[0] and flg[queue[i]]!=1:\\n                        ind=i\\n                x=queue.pop(ind)\\n                queue.append(x)\\n                flg[x]=1\\n        if ct>1:\\n            queue.sort()\\n        return st+\"\".join(queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782862,
                "title": "js-beats-100",
                "content": "# Intuition\\nCan I return just smallest string?\\n-> No, when the k is 1, it is limited but it is easy to get smallest one.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWhen the k is 2 or greater, we can get all permutations of s. So, we can return smallest string.\\nWhen the k is 1 and s.length is 3, for example,\\nwe can consider all possible permutation \\nabc, bca, cab\\nNumber of possible permutation is same as s.length.\\nI prefer bruteforce search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n \\tlet res = s;\\n\\n\\tif (k === 1) {\\n\\t\\tlet l = s.length;\\n\\t\\tfor (let i=0; i<l; i++) {\\n\\t\\t\\tlet c = s[0];\\n\\t\\t\\ts = s.substring(1, l) + c;\\n\\t\\t\\tif (s < res)\\n\\t\\t\\t\\tres = s; \\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\treturn [...s].sort().join(\\'\\');\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n \\tlet res = s;\\n\\n\\tif (k === 1) {\\n\\t\\tlet l = s.length;\\n\\t\\tfor (let i=0; i<l; i++) {\\n\\t\\t\\tlet c = s[0];\\n\\t\\t\\ts = s.substring(1, l) + c;\\n\\t\\t\\tif (s < res)\\n\\t\\t\\t\\tres = s; \\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\treturn [...s].sort().join(\\'\\');\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782767,
                "title": "daily-leetcode-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1)\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        else\\n        {\\n            string ans=s;\\n            for(int i=1;i<s.size();i++)\\n            {\\n                ans=min(ans,s.substr(i,s.size()-1)+s.substr(0,i));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1)\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        else\\n        {\\n            string ans=s;\\n            for(int i=1;i<s.size();i++)\\n            {\\n                ans=min(ans,s.substr(i,s.size()-1)+s.substr(0,i));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446689,
                "title": "orderly-queue-w-approach-c-python-java",
                "content": "We can divide the question in two parts \\n* When `k = 1` \\n* When `k > 1`, where we can prove that after some number of moves, the string can always be sorted\\n\\n\\n*Example of String Rotation*\\n`12345 -> 23451 -> 34512 -> 45123 -> 51234`\\n\\n* If `k = 1`, we can only rotate the whole string. There are `s.length()` different states and we return the **lexicographically smallest string**.\\n\\n* If `k > 1`, we have two possible operations-\\n\\t1. Rotate the whole string.\\n\\t2. Rotate the whole string except the first letter.\\n\\t* We can rotate `i+1`th big letter to the start (1), then rotate `i`th big letter to the end (2).\\n* We can look at it as an **bubble sort**: doing these moves we can sort all string, so directly return that.\\n\\n**Time complexity** is `O(n^2)` for `k = 1`, else for `k > 1` it is `O(NlogN)` \\n**Space complexity** is `O(n)`\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n\\t\\t{\\n            string ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n\\t\\t\\t{\\n                ans = min(ans,s.substr(i)+s.substr(0,i)) ;\\n            }\\n            return ans ;\\n        }\\n\\t\\t// k > 1\\n        sort(s.begin(),s.end()) ;\\n        return s ;\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1)\\n        {\\n            String ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                ans = min(ans , s.substring(i) + s.substring(0, i)) ;\\n            }\\n            return ans ;\\n        }\\n        char[] chars = s.toCharArray() ;\\n        Arrays.sort(chars) ;\\n        return new String(chars) ;\\n    }\\n}\\n```\\n\\n`Python One-Liner just for fun :)`\\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n\\t\\t{\\n            string ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n\\t\\t\\t{\\n                ans = min(ans,s.substr(i)+s.substr(0,i)) ;\\n            }\\n            return ans ;\\n        }\\n\\t\\t// k > 1\\n        sort(s.begin(),s.end()) ;\\n        return s ;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1)\\n        {\\n            String ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                ans = min(ans , s.substring(i) + s.substring(0, i)) ;\\n            }\\n            return ans ;\\n        }\\n        char[] chars = s.toCharArray() ;\\n        Arrays.sort(chars) ;\\n        return new String(chars) ;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784761,
                "title": "java-easy-solution-fast-explained-code",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k > 1){\\n            /*if k > 1 then the returned string will be sorted*/\\n            char charArr[] = s.toCharArray();\\n            Arrays.sort(charArr);\\n            return String.valueOf(charArr);\\n        }else{\\n            /* smalled string will be returned starting with char than have smallest value in case of k == 1 as the string wont be sorted...bcoz we can rotate only one char that will result to getting same array after rotation*/\\n            String newStr = s;\\n            for(int i = 0; i < s.length() ; i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(newStr.compareTo(s) > 0){\\n                    newStr = s; \\n                }\\n            }\\n            return newStr;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k > 1){\\n            /*if k > 1 then the returned string will be sorted*/\\n            char charArr[] = s.toCharArray();\\n            Arrays.sort(charArr);\\n            return String.valueOf(charArr);\\n        }else{\\n            /* smalled string will be returned starting with char than have smallest value in case of k == 1 as the string wont be sorted...bcoz we can rotate only one char that will result to getting same array after rotation*/\\n            String newStr = s;\\n            for(int i = 0; i < s.length() ; i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(newStr.compareTo(s) > 0){\\n                    newStr = s; \\n                }\\n            }\\n            return newStr;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572587,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        else:\\n            res = s\\n            for i in range(0,len(s)):\\n                s = s[1:] + s[0]\\n                res = min(res,s)\\n                \\n            return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        else:\\n            res = s\\n            for i in range(0,len(s)):\\n                s = s[1:] + s[0]\\n                res = min(res,s)\\n                \\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445967,
                "title": "orderly-queue-explanation-with-examlpe",
                "content": "For this problem we have two situations:\\n1. k = 1. It means that we can only delete first symbol and append it to the end of the string. We may simulate this process and find answer. For example, we may concatenate s with s and find smallest lexicographically substring with size equals s.size().\\n2. k > 1. Answer will be just sorted string. We may use the next algorithm to prove it:\\n* \\tLet\\'s suppouse that we have several symbols, that sorted lexicographically. For example smallest symbol in string.\\n* \\tFind next smallest symbol and move this symbol on first position in string (just move all symbols before it into the end). \\n* \\tMove second symbol into the end while this symbol is not from our lexicographically sorted string. \\n* \\tMove second symbol into the end while this symbol from our lexicographically sorted string.\\n* \\tMove next smallest symbol (first symbol in string) in the end of the string.\\n* \\tAfter this we increase our lexicographically sorted substring by one symbol. \\n* \\tRepeat this procedure until we get all sybmols in our lexicographically sorted substring.\\n\\tLet\\'s look at the example:\\n\\tabbabcba, k = 2 \\n\\t\\n\\t1. abb**a**bcba - initial state of our string. Let\\'s our smallest substring will be **a**. Next smallest lexicographically symbol is on the first position. \\n\\t2. a**a**bcbabb - move all second symbols into the end while second symbol doesn\\'t equal first symbol from  smallest substring.\\n\\t3. bcbabb**aa** - move smallest substring and first symbol in end of the string.\\n\\t4. abb**aa**bcb - place next smallest symbol in the begining of the string.\\n\\t5. a**aa**bcbbb - move all second symbols in the end while second symbol doesn\\'t equal first symbol from smallest substring. \\n\\t6. bcbbb**aaa** - move smallest substring and first symbol in end of the string.\\n\\t7. b**aaa**cbbb - repeat procedure.\\n\\t8. cbbb**aaab**\\n\\t9. b**aaab**cbb\\n\\t10. cbb**aaabb**\\n\\t11. b**aaabb**cb\\n\\t12. cb**aaabbb**\\n\\t13. b**aaabbb**c\\n\\t14. c**aaabbbb**\\n\\t15. **aaabbbbc**\\nIf we can do it with k = 2, it means, that we can do it with k > 2\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s;\\n        if (k > 1){\\n            sort(ans.begin(), ans.end());\\n        } else {\\n            const string ss = s + s;\\n            for (int i = 0; i < s.size(); ++i){\\n                string tmp = ss.substr(i, s.size());\\n                if (tmp < ans) ans = tmp;\\n            }    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time complexity**: O(n^2)\\n**Space complexity**: O(n)\\n\\nIf you find this post useful upvote it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s;\\n        if (k > 1){\\n            sort(ans.begin(), ans.end());\\n        } else {\\n            const string ss = s + s;\\n            for (int i = 0; i < s.size(); ++i){\\n                string tmp = ss.substr(i, s.size());\\n                if (tmp < ans) ans = tmp;\\n            }    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802903,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String result = s;\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length() - 1; ++i) {\\n                sb.append(sb.charAt(0)).deleteCharAt(0);\\n                if (sb.toString().compareTo(result) < 0) {\\n                    result = sb.toString();\\n                }\\n            }\\n            return result;\\n        }\\n        char[] x = s.toCharArray();\\n        Arrays.sort(x);\\n        return String.valueOf(x);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String result = s;\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length() - 1; ++i) {\\n                sb.append(sb.charAt(0)).deleteCharAt(0);\\n                if (sb.toString().compareTo(result) < 0) {\\n                    result = sb.toString();\\n                }\\n            }\\n            return result;\\n        }\\n        char[] x = s.toCharArray();\\n        Arrays.sort(x);\\n        return String.valueOf(x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786411,
                "title": "python-simple-python-9-line-solution",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k==1:\\n            ans=s\\n            for i in range(len(s)):\\n                if ((s+s)[i:i+len(s)])<ans: ans=((s+s)[i:i+len(s)])\\n            return ans\\n        else:\\n            return \"\".join(sorted(s))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k==1:\\n            ans=s\\n            for i in range(len(s)):\\n                if ((s+s)[i:i+len(s)])<ans: ans=((s+s)[i:i+len(s)])\\n            return ans\\n        else:\\n            return \"\".join(sorted(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784715,
                "title": "concise-and-simple-solution-with-an-explanation",
                "content": "```csharp\\npublic class Solution\\n{\\n    public string OrderlyQueue(string s, int k)\\n    {\\n        if (k > 1) return string.Concat(s.OrderBy(x => x));\\n\\n        string res = s;\\n\\n        foreach (char c in s)\\n        {\\n            s = s[1..] + s[0];\\n            if (s.CompareTo(res) < 0) res = s;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\nThe solution is based on the following observations:\\n\\nIf `k > 1`, we are able to put the characters in any order. In this case, we just sort them in ascending order and return the resulting string right away.\\n\\nIf `k = 1`, we cannot change the order of the characters in the string. We can only move them to the end of the string, one by one. In this case, we return the \"minimum\" string out of all possible `s.Length` candidates.\\n\\nAlso:\\n1. It\\'s not nice to change the object that you are looping over (string `s`) but it does not matter here.\\n2. Btw, we do make one string comparison more that we need here, but I like `foreach (char c in s)` better than `for (int i = 1; i < s.Length; i++)`.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string OrderlyQueue(string s, int k)\\n    {\\n        if (k > 1) return string.Concat(s.OrderBy(x => x));\\n\\n        string res = s;\\n\\n        foreach (char c in s)\\n        {\\n            s = s[1..] + s[0];\\n            if (s.CompareTo(res) < 0) res = s;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782830,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n  func orderlyQueue(_ s: String, _ k: Int) -> String {\\n    k==1 && s.count>1 ? (1..<s.count).reduce((\"{\", Array(s))) { d,i in (min(d.0, String(d.1[i...]+d.1[0..<i])), d.1)}.0 : String(s.sorted())\\n  }\\n}\\n```\\n**NOTE:** This technically qualifies as a one-liner, since `return` keyword was omitted.\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func orderlyQueue(_ s: String, _ k: Int) -> String {\\n        guard s.count > 1 else { return s }\\n        if k == 1 { // when `k` is one, return minimal rotation\\n            return (1..<s.count).reduce((\\n                minString: \"{\",  // brace-character has higher ASCII value than all letters\\n                s: Array(s)  // converts String `s` into array of characters for substring\\n            )) { data,i in \\n                (\\n                    minString: min(data.minString, String(data.s[i...] + data.s[0..<i])), \\n                    s: data.s\\n                )\\n            }.minString \\n        } else {\\n            return String(s.sorted()) // when k>1, then minimal value will always be lexicographical sort\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  func orderlyQueue(_ s: String, _ k: Int) -> String {\\n    k==1 && s.count>1 ? (1..<s.count).reduce((\"{\", Array(s))) { d,i in (min(d.0, String(d.1[i...]+d.1[0..<i])), d.1)}.0 : String(s.sorted())\\n  }\\n}\\n```\n```\\nclass Solution {\\n    func orderlyQueue(_ s: String, _ k: Int) -> String {\\n        guard s.count > 1 else { return s }\\n        if k == 1 { // when `k` is one, return minimal rotation\\n            return (1..<s.count).reduce((\\n                minString: \"{\",  // brace-character has higher ASCII value than all letters\\n                s: Array(s)  // converts String `s` into array of characters for substring\\n            )) { data,i in \\n                (\\n                    minString: min(data.minString, String(data.s[i...] + data.s[0..<i])), \\n                    s: data.s\\n                )\\n            }.minString \\n        } else {\\n            return String(s.sorted()) // when k>1, then minimal value will always be lexicographical sort\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782764,
                "title": "ruby-1-liner",
                "content": "```\\ndef orderly_queue(s, k)\\n  k>1 ? s.chars.sort.join : s.size.times.map{s[_1..]+s[..._1]}.min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef orderly_queue(s, k)\\n  k>1 ? s.chars.sort.join : s.size.times.map{s[_1..]+s[..._1]}.min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2778309,
                "title": "faster-than-100-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is one catch in this problem.\\nIf k>1 then the answer always sorted order, So\\njust sort the string and return that string\\nIf K==1 then you have to traverse string and find lexicographically smallest string, it\\'s not defficult.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n if K==0 then simply return that string.\\n if K>1 sort the string and return that string.\\n if K==1 finds all such combinations and return lexicographically the smallest string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity O(n^2) if k==1\\nand O(nlogn) if k>1\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) \\n    {\\n        if(k==0)\\n        {\\n            return s;\\n        }\\n        if(k>1)\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k==1)\\n        {\\n            string st=s;\\n            for (int i=0;i<s.length()-1;i++)\\n            {\\n                string p=s.substr(i+1,s.length())+s.substr(0,i+1);\\n                if(st>p){\\n                    st=p;\\n                }\\n            }\\n            return st;\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) \\n    {\\n        if(k==0)\\n        {\\n            return s;\\n        }\\n        if(k>1)\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k==1)\\n        {\\n            string st=s;\\n            for (int i=0;i<s.length()-1;i++)\\n            {\\n                string p=s.substr(i+1,s.length())+s.substr(0,i+1);\\n                if(st>p){\\n                    st=p;\\n                }\\n            }\\n            return st;\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446910,
                "title": "easy-af-c-java-golang-solution-explained",
                "content": "Please upvote if you like the solution.\\n\\nThe question is pretty simple. We have two conditions:\\n1. If K>1,that means we can bubble sort the whole string to get the lexicographically smallest string, since bubble sort at a time requires only two indices while comparing.\\n2. If we have k==1, then we just have to find the lexicographically smallest string beginning at any index \\'i\\'. We just compare every substring so formed and keep track of the minimum one. At last we return the minimum string.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(begin(s),end(s));\\n            return s;\\n        }\\n        string mins=s;\\n        for(int i=1;i<s.size();i++){\\n            mins=min(mins,s.substr(i)+s.substr(0,i));\\n        }\\n        return mins;\\n    }\\n};\\n```\\n**Java**\\n```\\npublic String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res;\\n    }\\n```\\n**Golang**\\n```\\nfunc orderlyQueue(s string, k int) string {\\n\\tb := []byte(s)\\n\\tif k > 1 {\\n\\t\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\t\\treturn b[i] < b[j]\\n\\t\\t})\\n\\t\\treturn string(b)\\n\\t} else {\\n\\t\\tmin := []byte(s)\\n\\t\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\t\\tb = append(b[1:], b[0])\\n\\t\\t\\tif bytes.Compare(b, min) < 0 {\\n\\t\\t\\t\\tcopy(min, b)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(min)\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(begin(s),end(s));\\n            return s;\\n        }\\n        string mins=s;\\n        for(int i=1;i<s.size();i++){\\n            mins=min(mins,s.substr(i)+s.substr(0,i));\\n        }\\n        return mins;\\n    }\\n};\\n```\n```\\npublic String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res;\\n    }\\n```\n```\\nfunc orderlyQueue(s string, k int) string {\\n\\tb := []byte(s)\\n\\tif k > 1 {\\n\\t\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\t\\treturn b[i] < b[j]\\n\\t\\t})\\n\\t\\treturn string(b)\\n\\t} else {\\n\\t\\tmin := []byte(s)\\n\\t\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\t\\tb = append(b[1:], b[0])\\n\\t\\t\\tif bytes.Compare(b, min) < 0 {\\n\\t\\t\\t\\tcopy(min, b)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(min)\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446687,
                "title": "c-python-java-with-explanation-string-sort-or-rotate",
                "content": "We can divide the question in two parts \\n* When `k = 1` \\n* When `k > 1`, where we can prove that after some number of moves, the string can always be sorted\\n\\n\\n*Example of String Rotation*\\n`12345 -> 23451 -> 34512 -> 45123 -> 51234`\\n\\n* If `k = 1`, we can only rotate the whole string. There are `s.length()` different states and we return the **lexicographically smallest string**.\\n\\n* If `k > 1`, we have two possible operations-\\n\\t1. Rotate the whole string.\\n\\t2. Rotate the whole string except the first letter.\\n\\t* We can rotate `i+1`th big letter to the start (1), then rotate `i`th big letter to the end (2).\\n* We can look at it as an **bubble sort**: doing these moves we can sort all string, so directly return that.\\n\\n**Time complexity** is `O(n^2)` for `k = 1`, else for `k > 1` it is `O(NlogN)` \\n**Space complexity** is `O(n)`\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n\\t\\t{\\n            string ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n\\t\\t\\t{\\n                ans = min(ans,s.substr(i)+s.substr(0,i)) ;\\n            }\\n            return ans ;\\n        }\\n\\t\\t// k > 1\\n        sort(s.begin(),s.end()) ;\\n        return s ;\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1)\\n        {\\n            String ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                ans = min(ans , s.substring(i) + s.substring(0, i)) ;\\n            }\\n            return ans ;\\n        }\\n        char[] chars = s.toCharArray() ;\\n        Arrays.sort(chars) ;\\n        return new String(chars) ;\\n    }\\n}\\n```\\n\\n`Python One-Liner just for fun :)`\\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n\\t\\t{\\n            string ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n\\t\\t\\t{\\n                ans = min(ans,s.substr(i)+s.substr(0,i)) ;\\n            }\\n            return ans ;\\n        }\\n\\t\\t// k > 1\\n        sort(s.begin(),s.end()) ;\\n        return s ;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1)\\n        {\\n            String ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                ans = min(ans , s.substring(i) + s.substring(0, i)) ;\\n            }\\n            return ans ;\\n        }\\n        char[] chars = s.toCharArray() ;\\n        Arrays.sort(chars) ;\\n        return new String(chars) ;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165857,
                "title": "java-simple-solution-12-ms",
                "content": "When K >= 2, you can swap any two character in the string.\\n```\\n    public String orderlyQueue(String S, int K) {\\n        if(K == 1) return slideString(S);\\n        char[] arr = S.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    \\n    public String slideString(String S) {\\n        String res = S, cur = S;\\n        for(int i = 0; i < S.length(); i ++) {\\n            cur = cur.substring(1) + cur.charAt(0);\\n            if(cur.compareTo(res) < 0) \\n                res = cur;\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "When K >= 2, you can swap any two character in the string.\\n```\\n    public String orderlyQueue(String S, int K) {\\n        if(K == 1) return slideString(S);\\n        char[] arr = S.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    \\n    public String slideString(String S) {\\n        String res = S, cur = S;\\n        for(int i = 0; i < S.length(); i ++) {\\n            cur = cur.substring(1) + cur.charAt(0);\\n            if(cur.compareTo(res) < 0) \\n                res = cur;\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2784333,
                "title": "solution-cpp-o-nlogn",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor k=1, rotate the string clockwise n times and return the smallest string lexographically.\\nFor k>1, sorted string will be the ans. \\nGot intuition while playing with some test cases and the conclusion is we can swap any two elements if k>1, coz number of moves are infinite (as said in the question), so we can also get sorted string accordingly.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.length();\\n        string t=s;\\n\\n        if(k==1){\\n            while(n--){\\n                char c=s[0];\\n                s.erase(s.begin());\\n                s.push_back(c);\\n                if(s<t)t=s;\\n            }\\n            return t;\\n        }\\n\\n        sort(t.begin(),t.end());\\n        return t;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.length();\\n        string t=s;\\n\\n        if(k==1){\\n            while(n--){\\n                char c=s[0];\\n                s.erase(s.begin());\\n                s.push_back(c);\\n                if(s<t)t=s;\\n            }\\n            return t;\\n        }\\n\\n        sort(t.begin(),t.end());\\n        return t;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784330,
                "title": "solution-cpp-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor k=1, rotate the string clockwise n times and return the smallest string lexographically.\\nFor k>1, sorted string will be the ans. \\nGot intuition while playing with some test cases and the conclusion is we can swap any two elements if k>1, coz number of moves are infinite (as said in the question), so we can also get sorted string accordingly.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.length();\\n        string t=s;\\n\\n        if(k==1){\\n            while(n--){\\n                char c=s[0];\\n                s.erase(s.begin());\\n                s.push_back(c);\\n                if(s<t)t=s;\\n            }\\n            return t;\\n        }\\n\\n        sort(t.begin(),t.end());\\n        return t;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.length();\\n        string t=s;\\n\\n        if(k==1){\\n            while(n--){\\n                char c=s[0];\\n                s.erase(s.begin());\\n                s.push_back(c);\\n                if(s<t)t=s;\\n            }\\n            return t;\\n        }\\n\\n        sort(t.begin(),t.end());\\n        return t;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784054,
                "title": "c-easy-beginner-friendly-with-explanation-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        // if k == 1 then we rotate the string and find the lexicographically minimum string\\n        if(k == 1)\\n        {\\n            string ans = s;\\n            int n = s.length();\\n            for(int i = 0 ; i < n;i++)\\n            {\\n                // extracting end char and adding it to the front\\n                char c = s[n - 1];\\n                s.pop_back();\\n                s = c + s;\\n                // minimum of existing string and new string formed\\n                ans = min(s, ans);   \\n            }\\n            return ans;\\n        }\\n        // if k > 1 then we can rearrange the string anyway we like\\n        // so return the sorted string.\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        // if k == 1 then we rotate the string and find the lexicographically minimum string\\n        if(k == 1)\\n        {\\n            string ans = s;\\n            int n = s.length();\\n            for(int i = 0 ; i < n;i++)\\n            {\\n                // extracting end char and adding it to the front\\n                char c = s[n - 1];\\n                s.pop_back();\\n                s = c + s;\\n                // minimum of existing string and new string formed\\n                ans = min(s, ans);   \\n            }\\n            return ans;\\n        }\\n        // if k > 1 then we can rearrange the string anyway we like\\n        // so return the sorted string.\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783767,
                "title": "java-easy-to-understand-sort-or-rotate",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/arrays/OrderlyQueue.java",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1755675,
                "title": "c-o-n-log-n-simple-solution-for-beginners",
                "content": "There are 2 cases in this question :-\\n1. When k=1 : We have to run a loop and store all strings in a vector after sending first character to last. Then simply sort the vector to get lexographically smallest string obtained in the process.\\n2. k>1 : In this case, the answer will always be a sorted string.\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        string s1=s;\\n        int n=s.length();\\n        sort(s1.begin(),s1.end());\\n        char c=s1[0];\\n        vector<string>v;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[0]==c) v.push_back(s);\\n            char c1=s[0];\\n            s.erase(s.begin());\\n            s.push_back(c1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        string s1=s;\\n        int n=s.length();\\n        sort(s1.begin(),s1.end());\\n        char c=s1[0];\\n        vector<string>v;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[0]==c) v.push_back(s);\\n            char c1=s[0];\\n            s.erase(s.begin());\\n            s.push_back(c1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456121,
                "title": "c-simple-solution",
                "content": "```\\nstring orderlyQueue(string s, int k) {\\n        \\n        if(k == 1){\\n            string ans = s;\\n            for(int i=0;i<s.length();i++){\\n                ans = min(ans, s.substr(i)+s.substr(0,i));\\n            }\\n            return ans;\\n        }else{\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        \\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring orderlyQueue(string s, int k) {\\n        \\n        if(k == 1){\\n            string ans = s;\\n            for(int i=0;i<s.length();i++){\\n                ans = min(ans, s.substr(i)+s.substr(0,i));\\n            }\\n            return ans;\\n        }else{\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1446335,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n  // rotate the string one by one, and check which is lexographically smaller\\n  if (k === 1) {\\n    let temp = `${s}`;\\n    let smallest = `${s}`;\\n    let count = 0;\\n    while (count < s.length) {\\n      temp = temp.substring(1, s.length) + temp.charAt(0);\\n      if (temp < smallest) {\\n        smallest = temp;\\n      }\\n      count++;\\n    }\\n    return smallest;\\n  }\\n  \\n  // if k is greater than 1, any permutation is possilbe\\n  // so we simply return the sorted string (convert to array -> sort -> back to string)\\n  if (k > 1) {\\n    return [...s].sort().join(\\'\\');\\n  }\\n  \\n  return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n  // rotate the string one by one, and check which is lexographically smaller\\n  if (k === 1) {\\n    let temp = `${s}`;\\n    let smallest = `${s}`;\\n    let count = 0;\\n    while (count < s.length) {\\n      temp = temp.substring(1, s.length) + temp.charAt(0);\\n      if (temp < smallest) {\\n        smallest = temp;\\n      }\\n      count++;\\n    }\\n    return smallest;\\n  }\\n  \\n  // if k is greater than 1, any permutation is possilbe\\n  // so we simply return the sorted string (convert to array -> sort -> back to string)\\n  if (k > 1) {\\n    return [...s].sort().join(\\'\\');\\n  }\\n  \\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445749,
                "title": "go-simple-code-with-comments",
                "content": "```\\nfunc orderlyQueue(s string, k int) string {\\n    \\n    // Rotate the string if k == 1.\\n    // Record all rotations of s in temp.\\n    // Keep record of the lexicographically smallest rotation (temp) while iterating.\\n    if k == 1 {\\n        answer := s\\n        double := s + s\\n        \\n        for i, _ := range s {\\n            temp := double[i : i + len(s)]\\n            \\n            if temp < answer {\\n                answer = temp\\n            }\\n        }\\n        \\n        return answer\\n    }\\n    \\n    // Sort the string if k > 1.\\n    w := strings.Split(s, \"\")\\n    sort.Strings(w)\\n    return strings.Join(w, \"\")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc orderlyQueue(s string, k int) string {\\n    \\n    // Rotate the string if k == 1.\\n    // Record all rotations of s in temp.\\n    // Keep record of the lexicographically smallest rotation (temp) while iterating.\\n    if k == 1 {\\n        answer := s\\n        double := s + s\\n        \\n        for i, _ := range s {\\n            temp := double[i : i + len(s)]\\n            \\n            if temp < answer {\\n                answer = temp\\n            }\\n        }\\n        \\n        return answer\\n    }\\n    \\n    // Sort the string if k > 1.\\n    w := strings.Split(s, \"\")\\n    sort.Strings(w)\\n    return strings.Join(w, \"\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 759358,
                "title": "javascript-72-speed-100-memory",
                "content": "Intuitions:\\n- if K === 0, no moves can be made\\n- if K >= 2, any permutation of characters is possible with enough steps\\n\\t- The JS Array.sort() method already sorts lexically\\n- If K === 1 then the answer will be a rotation of the string\\n\\t- You can build these strings from splitting and concatenating S, but that would be wasteful when all we are about is the character code values\\n\\nMethod:\\n- if K === 0, return S\\n- if K >= 2, \\n\\t- .split(\\'\\') the string into its characters\\n\\t- .sort() the resulting array (defaults to ascending order anyway)\\n\\t- .join(\\'\\') the characters\\n\\t- return the concatenated string\\n- If K === 1\\n\\t- iterate over all possible rotations of the string, compared to the rotation at 0 (the original string)\\n\\t\\t- iterate over and compare all characters in those strings, once 2 different characters are found: \\n\\t\\t\\t- if the new string character is \"smaller\", update the result to the new starting index\\n\\t\\t\\t- move on to the next rotation\\n\\nInstead of building these rotations for comparison, it is much easier on the memory to store the starting indices and add integers from [0, string.length) when comparing characters.\\n> (Base Index + Number of Same Characters) % String Length = The Index in the \"Rotated\" String\\n\\n```\\nvar orderlyQueue = function(S, K) {\\n\\tif (K === 0) return S;\\n    else if (K > 1) return S.split(\\'\\').sort().join(\\'\\');\\n\\n\\tlet result = 0, L = S.length;\\n\\n\\tfor (let i = 1; i < L; i++) {\\n        for (let j = 0; j < L; j++) {\\n\\t\\t\\tlet d = S.charCodeAt((result + j) % L) - S.charCodeAt((i + j) % L);\\n\\t\\t\\tif (d !== 0)  {\\n\\t\\t\\t\\tif (d > 0) result = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn S.slice(result) + S.slice(0, result);\\n\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar orderlyQueue = function(S, K) {\\n\\tif (K === 0) return S;\\n    else if (K > 1) return S.split(\\'\\').sort().join(\\'\\');\\n\\n\\tlet result = 0, L = S.length;\\n\\n\\tfor (let i = 1; i < L; i++) {\\n        for (let j = 0; j < L; j++) {\\n\\t\\t\\tlet d = S.charCodeAt((result + j) % L) - S.charCodeAt((i + j) % L);\\n\\t\\t\\tif (d !== 0)  {\\n\\t\\t\\t\\tif (d > 0) result = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn S.slice(result) + S.slice(0, result);\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2786171,
                "title": "c-explained-100-fast",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k)\\n    {\\n            string ans;\\n            ans = s;\\n        // when n > 1 then we can have the string sorted , took the example of S = \"aacb\" and k = 2, we can get aabc after some rotations\\n        if (k > 1)\\n        {\\n            sort(s.begin(), s.end());\\n            return (s);\\n        }\\n        else\\n        {\\n            // when k ==1 then we have to see the lexicographically smallest string of size of s in the string s+s\\n            // like if we have s= \"cba\" and k ==1 then s+s = \"cbacba\" then we have the answer acb, this is because we can have only 1 rotation at a time and that too of the first element and we can sent it back only which we can find using s+s \\n            // the relative order of other elements would remain the same, so we can use a string s+s to find the substring with lexicographically smalles first character\\n            string temp = \"\";\\n            temp = s + s;\\n            for (int i = 0; i + s.length() <= temp.length(); i++)\\n            {\\n                ans = min(ans, temp.substr(i, s.length()));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k)\\n    {\\n            string ans;\\n            ans = s;\\n        // when n > 1 then we can have the string sorted , took the example of S = \"aacb\" and k = 2, we can get aabc after some rotations\\n        if (k > 1)\\n        {\\n            sort(s.begin(), s.end());\\n            return (s);\\n        }\\n        else\\n        {\\n            // when k ==1 then we have to see the lexicographically smallest string of size of s in the string s+s\\n            // like if we have s= \"cba\" and k ==1 then s+s = \"cbacba\" then we have the answer acb, this is because we can have only 1 rotation at a time and that too of the first element and we can sent it back only which we can find using s+s \\n            // the relative order of other elements would remain the same, so we can use a string s+s to find the substring with lexicographically smalles first character\\n            string temp = \"\";\\n            temp = s + s;\\n            for (int i = 0; i + s.length() <= temp.length(); i++)\\n            {\\n                ans = min(ans, temp.substr(i, s.length()));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786062,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans=\"\";\\n        if(k==1){\\n       \\n        int n=s.size();\\n        string ans=s;\\n        string dou=s+s;\\n        for(int i=1;i<n;i++){\\n            string str=dou.substr(i,n);\\n            if(str<ans)ans=str;\\n        }\\n        return ans;\\n        }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans=\"\";\\n        if(k==1){\\n       \\n        int n=s.size();\\n        string ans=s;\\n        string dou=s+s;\\n        for(int i=1;i<n;i++){\\n            string str=dou.substr(i,n);\\n            if(str<ans)ans=str;\\n        }\\n        return ans;\\n        }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785561,
                "title": "very-simple-approach-beginner-friendly",
                "content": "# Intuition\\nThe questions seems to be very tricky at first but its all about recognizing the pattern. My initial thoughts were to sort the string for k > 1 and think of a way to write a solution for k == 1.\\n\\n# Approach\\n1. for k == 1 we can try generating all the variations and store it in a set until the strings being generated starts repeating. Once you encounter such situation simply return the min from set. That will be our answer.\\n2. For k > 1, we can simply sort the string and return our answer\\n\\n# Complexity\\n- Time complexity:\\nO(N ^ 2) # NOT SURE\\n\\n- Space complexity:\\nO(len(visited))\\n\\n# Code\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        visited = set()\\n        if k == 1:\\n            arr = list(s)\\n\\n            while \"\".join(arr) not in visited:\\n                visited.add(\"\".join(arr))\\n                ele = arr.pop(0)\\n                arr.append(ele)\\n                \\n            \\n\\n            return min(visited)\\n\\n        ans = sorted(s)\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        visited = set()\\n        if k == 1:\\n            arr = list(s)\\n\\n            while \"\".join(arr) not in visited:\\n                visited.add(\"\".join(arr))\\n                ele = arr.pop(0)\\n                arr.append(ele)\\n                \\n            \\n\\n            return min(visited)\\n\\n        ans = sorted(s)\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784929,
                "title": "smallest-and-easiest-java-soln-with-comments",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\\n             String str2=new String(s);\\n             for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\\n                    str2=s;                     //store smaller lexo combo\\n                } \\n             }\\n             return str2;\\n        }     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\\n             String str2=new String(s);\\n             for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\\n                    str2=s;                     //store smaller lexo combo\\n                } \\n             }\\n             return str2;\\n        }     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784504,
                "title": "c-beginner-friendly-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i=1;i<ans.size();i++) {\\n                ans = min(ans, s.substr(i, ans.size()));\\n            }\\n            return ans;\\n        }\\n        \\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i=1;i<ans.size();i++) {\\n                ans = min(ans, s.substr(i, ans.size()));\\n            }\\n            return ans;\\n        }\\n        \\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784079,
                "title": "golang-solution",
                "content": "If k = 1, only rotations of s are possible, and the answer is the lexicographically smallest rotation.\\n\\nIf k > 1, any permutation of s is possible, and the answer is the letters of s written in lexicographic order.\\n\\n```\\nfunc orderlyQueue(S string, K int) string {\\n\\ts := []byte(S)\\n\\tif K>1 {\\n\\t\\tsort.Slice(s, func(i int, j int) bool { return s[i] < s[j] })\\n\\t\\treturn string(s)\\n\\t} else {\\n\\t\\treturn findSmallest(s)\\n\\t}\\n}\\nfunc findSmallest(s []byte) string {\\n\\tres := s\\n\\tfor i:=1; i<len(s); i++ {\\n\\t\\ttmp := append(s[i:],s[:i]...)\\n\\t\\tif strings.Compare(string(res), string(tmp)) > 0 {\\n\\t\\t\\tres = tmp\\n\\t\\t}\\n\\t}\\n\\treturn string(res)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc orderlyQueue(S string, K int) string {\\n\\ts := []byte(S)\\n\\tif K>1 {\\n\\t\\tsort.Slice(s, func(i int, j int) bool { return s[i] < s[j] })\\n\\t\\treturn string(s)\\n\\t} else {\\n\\t\\treturn findSmallest(s)\\n\\t}\\n}\\nfunc findSmallest(s []byte) string {\\n\\tres := s\\n\\tfor i:=1; i<len(s); i++ {\\n\\t\\ttmp := append(s[i:],s[:i]...)\\n\\t\\tif strings.Compare(string(res), string(tmp)) > 0 {\\n\\t\\t\\tres = tmp\\n\\t\\t}\\n\\t}\\n\\treturn string(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783940,
                "title": "i-wouldn-t-say-it-s-hard-it-s-eeaassyy",
                "content": "Hello folks!... So, today\\'s question is **Orderly Queue**\\n\\nSo, first of all let\\'s see what will happen if our k value is greater than 1, \\nTry to take as much examples as you can and think, is there any chance by taking k value greater than 1 and we don\\'t get sorted string (i.e. lexographically smallest string).\\n\\nYeah, you found it correct, if we have a value of k greater than 1, then we are definitely going to end up on sorted string.\\n\\nNow, the question is just a small trickier here, what if k value is equal to 1???\\n\\nSo, if you\\'ve done questions based on string where you have to take substring of string, then I guess you\\'ll get it what I meant to say.\\n\\nYeah, all you have to do is take the original string, append it to itself and then check for each string (of original size) that whether is this the smallest lexographically string or not. And, then at the end, you will have your solution.\\n\\nApproach:\\n\\n1. For value of k == 1, take size of string **s** in some variable (say **n**) and store it. And then append string **s** to itself.\\n2. Now, run a loop till size of **s** (size after appending itself) - **n**. Because, you have to check every string of actual size to be lexographically small or not.\\n3. Keep checking those string if they are smallest lexographically string or not, and at the end you\\'ll have your desired string.\\n4. Now, for k\\'s value greater than 1, just simply find the sorted string and return it. (Why so? Explanation is above).\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n        {\\n            string sol = s;\\n            int n = s.size();\\n            s += s;\\n            for(int i=0; i<s.size()-n; i++)\\n            {\\n                string lexo = s.substr(i, n);\\n                sol = min(sol, lexo);\\n            }\\n            \\n            return sol;\\n        }\\n        \\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\\n\\nI hope you found this approach and solution helpful. If yes, then why not UPVOTE it. Do it :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n        {\\n            string sol = s;\\n            int n = s.size();\\n            s += s;\\n            for(int i=0; i<s.size()-n; i++)\\n            {\\n                string lexo = s.substr(i, n);\\n                sol = min(sol, lexo);\\n            }\\n            \\n            return sol;\\n        }\\n        \\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783678,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are required to keep pushing the first element of the string to its last and popping the very first element untill we are with the lexicographically smallest string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile going with intution of the problem there would be three cases:\\n\\n- k=0 : In this case, return the string as it is.\\n- k=1 : In this case, first of all get the smallest letter in the given string. After this, for all the occurences of smallest letter in the string partition the string starting from that letter(suppose in first partition there are all the elements that come before the smallest letter in that string and in second partition there are all the elements that come after the smallest letter, including itself). Form a string combining partition 2 + partition 1. Get all such strings possible from the given string and return the lexicographically smallest string.\\n- k>1 : In this case, just sort the given array and return it \\n\\nAttached code will make it more clear.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(n*n)$$\\n        \\n    $${n=Given-string-size}$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       string res;\\n       if(k==0)\\n        return s;\\n       if(k>1){\\n           res=s;\\n           sort(s.begin(),s.end());\\n       }\\n       else{\\n           char ch=\\'z\\';\\n\\n           for(int i=0;i<s.size();i++)\\n                ch=(ch<s[i])?ch:s[i];\\n            vector<string> str;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==ch){\\n                    string temp;\\n                    \\n                    temp=(s.substr(i,s.size()));\\n                    temp=temp+s.substr(0,i);\\n                    str.push_back(temp);\\n                }\\n            }\\n            sort(str.begin(),str.end());\\n            s=str[0];\\n       }\\n            \\n\\n       \\n       return s; \\n    }\\n};\\n```\\n**If you like it then please upvote it \\uD83D\\uDD3C**\\n**Happy Coding \\uD83D\\uDCBB**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       string res;\\n       if(k==0)\\n        return s;\\n       if(k>1){\\n           res=s;\\n           sort(s.begin(),s.end());\\n       }\\n       else{\\n           char ch=\\'z\\';\\n\\n           for(int i=0;i<s.size();i++)\\n                ch=(ch<s[i])?ch:s[i];\\n            vector<string> str;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==ch){\\n                    string temp;\\n                    \\n                    temp=(s.substr(i,s.size()));\\n                    temp=temp+s.substr(0,i);\\n                    str.push_back(temp);\\n                }\\n            }\\n            sort(str.begin(),str.end());\\n            s=str[0];\\n       }\\n            \\n\\n       \\n       return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783600,
                "title": "java-easy-96-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n        String ss = s;\\n        for (int i = 1; i < s.length(); i++) {\\n            String rot = s.substring(i) + s.substring(0, i);\\n            if (ss.compareTo(rot) > 0) \\n                ss = rot;\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n        String ss = s;\\n        for (int i = 1; i < s.length(); i++) {\\n            String rot = s.substring(i) + s.substring(0, i);\\n            if (ss.compareTo(rot) > 0) \\n                ss = rot;\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782758,
                "title": "python-one-line",
                "content": "```python []\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return (\\n            \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n        )\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return (\\n            \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n        )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161822,
                "title": "java-very-easy-beginner-level-solution-o-nlogn-98-faster",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k==1){\\n            String t=s;\\n            for(int i=0,n=s.length();i<n;i++){\\n                String a=s.substring(i)+s.substring(0,i);\\n                if(a.compareTo(t)<0)\\n                    t=a;\\n            }\\n            return t;\\n        }else{\\n            char[] ch=s.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k==1){\\n            String t=s;\\n            for(int i=0,n=s.length();i<n;i++){\\n                String a=s.substring(i)+s.substring(0,i);\\n                if(a.compareTo(t)<0)\\n                    t=a;\\n            }\\n            return t;\\n        }else{\\n            char[] ch=s.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557469,
                "title": "java-short-and-simple-solution",
                "content": "\\nIf you observe the different test cases then you will see **If k > 1,** any permutation of s is possible, and the answer is the letters of s written in lexicographic order.\\nSo in this we have to just sort the string \\n\\n\\nIf k = 1, only rotations of s are possible, and the answer is the lexicographically smallest rotation.\\n\\nSo just find the minimum character from the string and find out the indexes at which this min character exists\\n\\nNow iterate the string again check whether swapping around the min character and find the lexicographically smallest string.\\n```\\npublic String orderlyQueue(String s, int k) {\\n        if(k>1){\\n            char[] ans = s.toCharArray();\\n            Arrays.sort(ans);\\n            return String.valueOf(ans);\\n        }\\n        \\n        char min = \\'z\\';\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            char cc = s.charAt(i);\\n            if(cc<min){\\n                min=cc;\\n            }\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==min)\\n                list.add(i);\\n        }\\n        \\n        String ans =s;\\n        for(int i=0;i<list.size();i++){\\n            String after = s.substring(0,list.get(i));\\n            String before = s.substring(list.get(i));\\n            String f = before+after;\\n            \\n            if(f.compareTo(ans)<0){\\n                ans=f;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String orderlyQueue(String s, int k) {\\n        if(k>1){\\n            char[] ans = s.toCharArray();\\n            Arrays.sort(ans);\\n            return String.valueOf(ans);\\n        }\\n        \\n        char min = \\'z\\';\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            char cc = s.charAt(i);\\n            if(cc<min){\\n                min=cc;\\n            }\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==min)\\n                list.add(i);\\n        }\\n        \\n        String ans =s;\\n        for(int i=0;i<list.size();i++){\\n            String after = s.substring(0,list.get(i));\\n            String before = s.substring(list.get(i));\\n            String f = before+after;\\n            \\n            if(f.compareTo(ans)<0){\\n                ans=f;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447886,
                "title": "best-1ms-java-solution-tc-o-n-sc-o-1-time-and-space-better-than-100-with-detailed-explanation",
                "content": "**Given a string xbqca and k =1.**\\nthe choices we have are xbqca,  bqcax, qcaxb, caxbq, axbqc\\nthe only option we have is to take the first char and append it to last because k is 1 so we are only allowed to chose form the first 1 characters of the string, so we are not having much choice there other that taking the first char.\\n\\nOne way to find the lexographically smallest is by finding all the rotations of string xbqca and and comparing with each other this would take TC O(n^2)  because of n strings and n-1 comparisons resulting in\\n n*(n-1) => O(n)\\n\\nCan we do the same in a better way?\\nFor the given string xbqca the lexographically smallest rotation is axbqc \\nFor cba it is acb\\n\\nnotice the ans starts with the  smallest character \\nSo if we find the smallest character in string then we can find the ans.\\ngiven string \"bcaqd\" with length n smallest char is a at index 2 now, \\nsubstring(2, n)+ substring(0, 2) gives \"aqdbc\" which is the answer.\\nthis can be done in O(n)\\n\\nwhat if there is character repetition? we need to account for that\\nGiven string \"bdatuaz\" of length 7, smallest char a is at index 2 and 5, \\nIn this case we have to finalize on an index by checking the character next to index\\nIn this case we check  the character at index 3 \\'t\\' and index 6 \\'z\\' , as char \\'t\\' at index 2+1 is less than char \\'z\\' at index 5+1 we take the smallest index as 2 and ignore 5.\\nnow answer would be  substring(2, n)+ substring(0, 2)\\n                                         \"atuaz\"       +  \"bd\"     = \"atuazbd\"\\n\\n**For the case k> 1.**\\nLet \"xbqca\" be the given string and k = 2\\n\"xbqca\"  we take \\'b\\' from first 2 characters and append to end =>    \"xqcab\"\\n\"xqcab\"   take q                                                                         =>    \"xcabq\"\\n\"xcabq\"   take c                                                                         =>     \"xabqc\"\\n\"xabqc\"   take x                                                                         =>     \"abqcx\"\\n \"abqcx\"  take a                                                                        =>       \"bqcxa\"\\n \"bqcxa\"   take b                                                                         =>     \"qcxab\"\\n \"qcxab\"  take c                                                                        =>       \"qxabc\"\\n  \"qxabc\"  take q                                                                        =>       \"xabcq\"\\n   \"xabcq\"  take x                                                                        =>       \"abcqx\"\\n\\nfinally we end up with a string sorted by its characters. which is the lexographically smallest possible.\\nNow consider same string \"xbqca\" with k = 3\\n\"xbqca\"  we take \\'b\\' from first 3 characters and append to end =>    \"xqcab\"\\n\"xqcab\"   take c                                                                         =>    \"xqabc\"\\n\"xqabc\"   take q                                                                         =>    \"xabcq\"\\n\"xabcq\"   take x                                                                         =>    \"abcqx\"\\n\\nagain we end up with a string sorted by its chars which is the lexographically smallest.\\n\\nso fro any k>1 we can reach the lexographically smallest string possible (sorted string).\\nThis is possible because we are allowed to make the append operation any number of times.\\n\\nSo for inputs with k>1 ans is simply the sorted string.\\nnow the TC of sorting normally is O(nlogn) but here it given characters can only be lower case letters \\nwhich is total 26.\\n\\nto sort string \"debbc\" we create an  array arr of size 26 \\nitereate the string for each char ch  arr[ch]++;\\nafter first iteration we get a frequency arr   a b c d e f -  - - z\\n                                                                    0 2 1 1 10        0\\nnow we create ans =\"\" and iterrate arr form i =0 to 26\\nwe append each char \\'a\\'+i  arr[i] number of times\\n\\nans would be \"\"+b+b+c+d+e = \"bbcde\"\\nSorting also done in O(n) and constant space\\n\\n```\\nclass Solution {  //O(n) time and O(1) space\\n    public String orderlyQueue(String s, int k) {\\n        int n = s.length();\\n        if(k ==1)\\n            return smallestRotated(s);\\n        return sorted(s);\\n    }\\n    \\n    //O(n) time, O(1) space\\n    public String smallestRotated(String s){\\n        char smallest = s.charAt(0);\\n        int smallIndex = 0;\\n        int n = s.length();\\n        for(int i =0; i<s.length(); i++){\\n            if(s.charAt(i)< smallest){         // new smallest found\\n                smallest = s.charAt(i);\\n                smallIndex = i;\\n            }else if(s.charAt(i) == smallest){   // already existing smallest with a different index (repetition)\\n                int j = 0;\\n                for(j =1; j<s.length(); j++){\\n                    char next1 = s.charAt((i+j)%n);                              // trying to compare next chars \\n                    char next2 = s.charAt((smallIndex+j)%n);\\n                    if(next1< smallest){                                            // the next char happens to be the smaller than\\n                        smallest = s.charAt(i+j);                                // current smallest then updating it as smallest\\n                        smallIndex = i+j;\\n                        break;\\n                    }\\n                    if(next1< next2){                                               // comparing next chars of two index\\n                        smallIndex = i;                                              \\n                        break;\\n                    }else if(next2< next1)\\n                        break;\\n                }\\n                i = i+j;  \\n            }\\n        }\\n        return s.substring(smallIndex, n)+s.substring(0, smallIndex);\\n    }\\n    \\n    //O(n) time, O(1) space only constant space used\\n    public String sorted(String s){\\n        int[] arr = new int[26];\\n        for(char ch: s.toCharArray()){                                                   // creating char freq table\\n            arr[ch-\\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char ch = \\'a\\';\\n        for(int val: arr){                                                                       // using char freq table to get the sorted array\\n            while(val-- >0)\\n                sb.append(ch);\\n            ch++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {  //O(n) time and O(1) space\\n    public String orderlyQueue(String s, int k) {\\n        int n = s.length();\\n        if(k ==1)\\n            return smallestRotated(s);\\n        return sorted(s);\\n    }\\n    \\n    //O(n) time, O(1) space\\n    public String smallestRotated(String s){\\n        char smallest = s.charAt(0);\\n        int smallIndex = 0;\\n        int n = s.length();\\n        for(int i =0; i<s.length(); i++){\\n            if(s.charAt(i)< smallest){         // new smallest found\\n                smallest = s.charAt(i);\\n                smallIndex = i;\\n            }else if(s.charAt(i) == smallest){   // already existing smallest with a different index (repetition)\\n                int j = 0;\\n                for(j =1; j<s.length(); j++){\\n                    char next1 = s.charAt((i+j)%n);                              // trying to compare next chars \\n                    char next2 = s.charAt((smallIndex+j)%n);\\n                    if(next1< smallest){                                            // the next char happens to be the smaller than\\n                        smallest = s.charAt(i+j);                                // current smallest then updating it as smallest\\n                        smallIndex = i+j;\\n                        break;\\n                    }\\n                    if(next1< next2){                                               // comparing next chars of two index\\n                        smallIndex = i;                                              \\n                        break;\\n                    }else if(next2< next1)\\n                        break;\\n                }\\n                i = i+j;  \\n            }\\n        }\\n        return s.substring(smallIndex, n)+s.substring(0, smallIndex);\\n    }\\n    \\n    //O(n) time, O(1) space only constant space used\\n    public String sorted(String s){\\n        int[] arr = new int[26];\\n        for(char ch: s.toCharArray()){                                                   // creating char freq table\\n            arr[ch-\\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char ch = \\'a\\';\\n        for(int val: arr){                                                                       // using char freq table to get the sorted array\\n            while(val-- >0)\\n                sb.append(ch);\\n            ch++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447710,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    string orderlyQueue(string s, int k) \\n    {\\n        string ans = s; \\n        if (k == 1) \\n            for (int i = 1; i < s.size(); ++i) \\n                ans = min(ans, s.substr(i) + s.substr(0, i)); \\n        else \\n            sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    string orderlyQueue(string s, int k) \\n    {\\n        string ans = s; \\n        if (k == 1) \\n            for (int i = 1; i < s.size(); ++i) \\n                ans = min(ans, s.substr(i) + s.substr(0, i)); \\n        else \\n            sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447560,
                "title": "c-solution",
                "content": "**Intuition**\\nwhen ```k >= 2```, when can swap any two adjancent letters. For example, we want to swap ```C``` and ```D```in string ```ABCDEDF```. then we can do:  ```ABCDEDF``` => ```CDEDFAB``` =>  ```CEDFABD``` => =>  ```EDFABDC``` => ```ABDCEDF```\\n\\nwhen ```k = 1```, when can only append the first letter to the end every time.\\n**Implementation**\\n```\\npublic class Solution {\\n    public string OrderlyQueue(string s, int k) {\\n        \\n        if(k >= 2)\\n        {\\n            char[] arr = s.ToCharArray();\\n            Array.Sort(arr);\\n            return new string(arr);\\n        }\\n        else\\n        {\\n            string min = s;\\n            for(int i = 0; i < s.Length; i++)\\n            {\\n                s = s.Substring(1, s.Length - 1) + s[0];\\n                if(s.CompareTo(min) < 0)\\n                    min = s;\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```k >= 2```\n```C```\n```D```\n```ABCDEDF```\n```ABCDEDF```\n```CDEDFAB```\n```CEDFABD```\n```EDFABDC```\n```ABDCEDF```\n```k = 1```\n```\\npublic class Solution {\\n    public string OrderlyQueue(string s, int k) {\\n        \\n        if(k >= 2)\\n        {\\n            char[] arr = s.ToCharArray();\\n            Array.Sort(arr);\\n            return new string(arr);\\n        }\\n        else\\n        {\\n            string min = s;\\n            for(int i = 0; i < s.Length; i++)\\n            {\\n                s = s.Substring(1, s.Length - 1) + s[0];\\n                if(s.CompareTo(min) < 0)\\n                    min = s;\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446403,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic string OrderlyQueue(string s, int k) => k == 1\\n    ? Enumerable.Range(0, s.Length).Min(i => s[i..] + s[..i])\\n    : string.Concat(s.OrderBy(c => c));\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic string OrderlyQueue(string s, int k) => k == 1\\n    ? Enumerable.Range(0, s.Length).Min(i => s[i..] + s[..i])\\n    : string.Concat(s.OrderBy(c => c));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446243,
                "title": "c-linear-solution-explained-100-time-90-space",
                "content": "This problem is really interesting and might seem overwhelmingly complicated, but if you run a few tests (or just notice things), you will notice that for `k > 1` each possible permutation can be (eventually) obtained, thus the smaller one is the right one and that is easy to sort.\\n\\nCuriously in this problem the \"base\" case is then for almost every possible variable, if you wish, while the edge case comes with a rather different logic, since with `k == 1`, no matter how many times we can try, we can only get rotations of the original string, so we have to go and find the smaller one.\\n\\nSo, first of all let\\'s get the easier case done; for `k > 1` we will just:\\n* `sort` `s`;\\n* `return` `s`.\\n\\nThe case of `k == 1` is actually a much funnier challenge and while we might be tempted to just generate and compare a bunch of substrings, we can definitely do better.\\n\\nAssuming initially our input string might be the smallest, we will set `pivot` to be `0`, then we will iterate with `i` from `1` to the size of `s` and using also `j` and the pointers `s1` and `s2` we will:\\n* initialise the variables for the next inner loop, with `j` = `lmt`, `s1` getting the value of our `pivot` and `s2` matching initially `i`;\\n* we will then loop `j` times and have three cases:\\n\\t* our pivot is still matching the smallest rotation (`s[s1] < s[s2]`), so no point in continuing and we can `break`;\\n\\t* specularly, our pivot is no longer matching the smallest rotation (`s[s1] > s[s2]`), so no point in continuing again, we update the value of `pivot` with `i` and we can `break`;\\n\\t* if both `s1` and `s2` point to the same character, we will then just have to:\\n\\t* increase both of them;\\n\\t* check if they overflow and in case reset them to `0` for the next loop.\\n\\nOnce done, if we discovered that the best rotation was with `pivot == 0` (ie: no rotation needed), we can just `return` `s`.\\n\\nAlternatively, in most case, we can save maybe a bit of memory and:\\n* create `res` as `s.substr(pivot)`;\\n* resize `s` to be only `pivot` characters (which might or might not cause a reallocation, I guess);\\n* `return` `res + s` and be done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        // general case: k > 1 so that we can get any possibly permutation\\n        if (k > 1) {\\n            sort(begin(s), end(s));\\n            return s;\\n        }\\n        // edge case: k == 1\\n        int pivot = 0;\\n        for (int i = 1, lmt = s.size(), j, s1, s2; i < lmt; i++) {\\n            // comparing character by character\\n            j = lmt, s1 = pivot, s2 = i;\\n            while (j--) {\\n                // first case: current pivot is still smaller\\n                if (s[s1] < s[s2]) break;\\n                // second case: i is smaller\\n                else if (s[s1] > s[s2]) {\\n                    pivot = i;\\n                    break;\\n                }\\n                // third case: we advance the pointers\\n                else {\\n                    s1++, s2++;\\n                    if (s2 == lmt) s2 = 0;\\n                    else if (s1 == lmt) s1 = 0;\\n                }\\n            }\\n        }\\n        // edge case: no rotation needed\\n        if (!pivot) return s;\\n        // computing the rotated string\\n        string res = s.substr(pivot);\\n        s.resize(pivot);\\n        return res + s;\\n    }\\n};\\n```\\n\\nBut, wait a moment: did I title this discussion as a linear solution, then I go and non-chalantly `sort` my string in linearithmic time?\\n\\nNot cool, not cool at all!\\n\\nLuckily, we can come up with a kind of bucket sorting and go actually with a linear approach, changing the base case code to this, ending up even saving a bit of memory (and probably doing much better with longer strings overall):\\n\\n```cpp\\n        if (k > 1) {\\n            // support variables\\n            char chars[123];\\n            // getting the frequency of each letter\\n            for (int i = \\'a\\'; i <= \\'z\\'; i++) chars[i] = 0;\\n            for (char c: s) chars[c]++;\\n            // replacing the content of s with the information stored in chars\\n            for (int i = \\'a\\', j, pos = 0; i <=\\'z\\'; i++) {\\n                if (chars[i]) {\\n                    j = chars[i];\\n                    while (j--) s[pos++] = i;\\n                }\\n            }\\n            return s;\\n        }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        // general case: k > 1 so that we can get any possibly permutation\\n        if (k > 1) {\\n            sort(begin(s), end(s));\\n            return s;\\n        }\\n        // edge case: k == 1\\n        int pivot = 0;\\n        for (int i = 1, lmt = s.size(), j, s1, s2; i < lmt; i++) {\\n            // comparing character by character\\n            j = lmt, s1 = pivot, s2 = i;\\n            while (j--) {\\n                // first case: current pivot is still smaller\\n                if (s[s1] < s[s2]) break;\\n                // second case: i is smaller\\n                else if (s[s1] > s[s2]) {\\n                    pivot = i;\\n                    break;\\n                }\\n                // third case: we advance the pointers\\n                else {\\n                    s1++, s2++;\\n                    if (s2 == lmt) s2 = 0;\\n                    else if (s1 == lmt) s1 = 0;\\n                }\\n            }\\n        }\\n        // edge case: no rotation needed\\n        if (!pivot) return s;\\n        // computing the rotated string\\n        string res = s.substr(pivot);\\n        s.resize(pivot);\\n        return res + s;\\n    }\\n};\\n```\n```cpp\\n        if (k > 1) {\\n            // support variables\\n            char chars[123];\\n            // getting the frequency of each letter\\n            for (int i = \\'a\\'; i <= \\'z\\'; i++) chars[i] = 0;\\n            for (char c: s) chars[c]++;\\n            // replacing the content of s with the information stored in chars\\n            for (int i = \\'a\\', j, pos = 0; i <=\\'z\\'; i++) {\\n                if (chars[i]) {\\n                    j = chars[i];\\n                    while (j--) s[pos++] = i;\\n                }\\n            }\\n            return s;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446177,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        \\n        if(k==1){\\n            String res = s;\\n            \\n            for(int i=0;i<s.length();++i){\\n                String temp = s.substring(i) + s.substring(0, i);\\n                \\n                if(temp.compareTo(res)<0){\\n                    res = temp;\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        \\n        if(k==1){\\n            String res = s;\\n            \\n            for(int i=0;i<s.length();++i){\\n                String temp = s.substring(i) + s.substring(0, i);\\n                \\n                if(temp.compareTo(res)<0){\\n                    res = temp;\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446055,
                "title": "c-sorting-rotating",
                "content": "Let us keep the explanation simple.\\n\\n**If k == 1** then we can only **remove the first character** from the string and **append it to the string** i.e **Rotating the string** .  While rotating **compare all the combinations** and **find** the **smallest Lexicographic String**.\\n\\n**if  k > 1**  then we can **swap the adjacent characters** and that is the requirement for **sorting**. So just simply sort the string.\\n\\n\\tstring orderlyQueue(string s, int k) \\n\\t{        \\n\\t\\tif (k > 1)  sort(s.begin(), s.end());\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tstring result = s;\\n\\t\\t\\t\\tfor (int i=0; i<s.length(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts = s.substr(1) + s[0];\\n\\t\\t\\t\\t\\tresult = min(result, s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "Let us keep the explanation simple.\\n\\n**If k == 1** then we can only **remove the first character** from the string and **append it to the string** i.e **Rotating the string** .  While rotating **compare all the combinations** and **find** the **smallest Lexicographic String**.\\n\\n**if  k > 1**  then we can **swap the adjacent characters** and that is the requirement for **sorting**. So just simply sort the string.\\n\\n\\tstring orderlyQueue(string s, int k) \\n\\t{        \\n\\t\\tif (k > 1)  sort(s.begin(), s.end());\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tstring result = s;\\n\\t\\t\\t\\tfor (int i=0; i<s.length(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts = s.substr(1) + s[0];\\n\\t\\t\\t\\t\\tresult = min(result, s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1445680,
                "title": "c-100-easy-to-understand-with-proper-explanation",
                "content": "/*\\n\\nBefore Jump to the problem let\\'s discuss some cases which may tell us how to proceed to this problem.\\n\\nEXAMPLE->1: s=\"bcabc\"  k=1\\n-----------\\n now pick index 0 character \\'b\\' and append at the end of the string. s=\"cabcb\"\\n \\n again pick index 0 character \\'c\\' and append it then s=\"abcbc\".\\n \\n This modified string is the lexicographically smallest among all the permutations possible by k-moves any number of times.\\n \\n So,when k is given k=1  , Then we observe that \\n \\n we are allowed to rotate the string any number of time by 1 character [Left Rotation]\\n \\n So just apply brute force method to check which rotated string gives us the desired output.\\n \\n \\n EXAMPLE->2: s=\"bcaaaaa\"  k=2\\n ----------\\n \\n When we are given k==2 in other word it gives us the freedom to swap any two adjacent characters . And obvoiusly for our sake we sort two characters lexicographically at each move . As a result, second smallest character comes after smallest character and the third one comes after second smallest character. \\n \\n So required transformation looks like---->\\n \\n \"bcaaaaa\" ---  \"caaaaab\"  ---  \"aaaaabc\".\\n \\n So as a whole Just we can sort the string and return it.\\n \\n In a same manner for k>2 alse we can do the above mentioned steps (because the steps we follow for k==2 , we can repeat the same for k>2 also).\\n \\n \\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        \\n        \\n        if(k==1){\\n            \\n            string temp=s;\\n            \\n            for(int i=0;i<s.length();i++){\\n                \\n                string sub=s.substr(i)+s.substr(0,i);\\n                \\n                if(min(temp,sub)==sub){\\n                    temp=sub;\\n                }\\n                \\n            }\\n            \\n            return temp;\\n        }\\n        \\n        else{\\n            \\n            sort(s.begin(),s.end());\\n            \\n            return s;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        \\n        \\n        if(k==1){\\n            \\n            string temp=s;\\n            \\n            for(int i=0;i<s.length();i++){\\n                \\n                string sub=s.substr(i)+s.substr(0,i);\\n                \\n                if(min(temp,sub)==sub){\\n                    temp=sub;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1445678,
                "title": "python-simple-solution",
                "content": "For the fact that we can change the order of any 2 characters in the string if k >= 2, \\n\\ne.g. a, b are chars, A, B are substrings\\naAbB -> abBA -> BAab or BAba\\nWe can put ab together with either order. \\n\\nThe answer is pretty simple as sorting just works. \\n\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            return min([s[i:] + s[:i] for i in range(len(s))])\\n        return \\'\\'.join(sorted(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            return min([s[i:] + s[:i] for i in range(len(s))])\\n        return \\'\\'.join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350877,
                "title": "c-899-orderly-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s; \\n        if (k == 1) \\n            for (int i = 1; i < s.size(); ++i) \\n                ans = min(ans, s.substr(i) + s.substr(0, i)); \\n        else \\n            sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s; \\n        if (k == 1) \\n            for (int i = 1; i < s.size(); ++i) \\n                ans = min(ans, s.substr(i) + s.substr(0, i)); \\n        else \\n            sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350871,
                "title": "python3-rotation-or-sorting",
                "content": "\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1: return min(s[i:] + s[:i] for i in range(len(s)))\\n        return \"\".join(sorted(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1: return min(s[i:] + s[:i] for i in range(len(s)))\\n        return \"\".join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193649,
                "title": "c-easiest-solution-with-detailed-explanation-beats-100-time-complexity",
                "content": "# Explanation\\n ***This question is similar to array rotation***\\n1.  (k==1), we can rotate the array everytime and get the lexicographically Smallest string\\n2.  k>1), this means that we can swap any adjacent two characters in the string\\n\\t*     Actually, when K>=2, we can prove that we can use the first 2 elements as a buffer to swap any two adjacent    characters. \\n\\t*     Assume that we want to swap S[i] and S[i+1], we can first pop first i-1 characters to the end, then pop i+1              and i, finally pop i+2~end.\\n3. Since we can reach any permutation by swapping adjacent characters (like bubble sort), in this case the minimal reachable permutation is the sorted String. So when k>1 , solution is sorted string\\n\\n```\\nstring orderlyQueue(string S, int K) {\\n        if(K==1){ //rotate string to get all permutations and take lexographically smallest string\\n            int n=S.size();\\n            string smallest=S;\\n            for(int i=1;i<n;i++){\\n                char ch=S[0];\\n                S.erase(S.begin());\\n                S.push_back(ch);\\n                \\n                if(S<smallest)\\n                    smallest=S;\\n                               \\n            }\\n            return smallest;\\n        }\\n        //else\\n        //k>1 means we can swap any two adjacent characters(as mentioned in step 2). \\n        //We can sort the entire string (as we have infinite moves ),similar to what we do in BUBBLE SORT\\n        //So final answer will be sortedString\\n            \\n        sort(S.begin(),S.end());\\n        return S;\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstring orderlyQueue(string S, int K) {\\n        if(K==1){ //rotate string to get all permutations and take lexographically smallest string\\n            int n=S.size();\\n            string smallest=S;\\n            for(int i=1;i<n;i++){\\n                char ch=S[0];\\n                S.erase(S.begin());\\n                S.push_back(ch);\\n                \\n                if(S<smallest)\\n                    smallest=S;\\n                               \\n            }\\n            return smallest;\\n        }\\n        //else\\n        //k>1 means we can swap any two adjacent characters(as mentioned in step 2). \\n        //We can sort the entire string (as we have infinite moves ),similar to what we do in BUBBLE SORT\\n        //So final answer will be sortedString\\n            \\n        sort(S.begin(),S.end());\\n        return S;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615325,
                "title": "c-complete-code-with-explanation-4-ms-reason-of-sort-and-rotate",
                "content": "***INTUITION:-***\\nWe should think this question considering k = 1 first.\\nSo given a string with k = 1, then by removing first k characters and putting them at string end, you are effectively rotating the string. Here in different moves you will be generating the rotated string.\\n\\nThus for k = 1, we rotate the given string character by character until we got original string back. At every move we put the rotated string into a vector of string. After getting all rotated string into vector of string, we sort the vector and the string at index 0 will be our required string.\\n\\nNow the second case to be considered is that if K is greater than 1.\\nIf you take any string with k greater than 1, you will find that you are able to generate all the permutation of the string. Among all the permutaion we will return the smallest string.\\nNo need to generate all the permutation just sort the given string and return it.\\n\\n***Example for k > 1***\\nlet string s = \"rao\", and k = 2\\nthe possible string that can be obtained using the given rule are, rao->aor->oar->ora->aro->roa\\nwhich all are permutaion of the given string.\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        int n = S.length();\\n        \\n        if(n == 0){\\n            return \"\";\\n        }\\n        \\n        if(K > 1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        \\n        vector<string> v;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            char curr = S[0];\\n            S.erase(S.begin());\\n            S += curr;\\n            v.push_back(S);\\n            \\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        return v[0];\\n    }\\n};\\n```\\n\\nhope it helps!!!\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        int n = S.length();\\n        \\n        if(n == 0){\\n            return \"\";\\n        }\\n        \\n        if(K > 1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        \\n        vector<string> v;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            char curr = S[0];\\n            S.erase(S.begin());\\n            S += curr;\\n            v.push_back(S);\\n            \\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566310,
                "title": "golang-solution-sort-rotate-string-100-time-space-with-explanation",
                "content": "Explaination:\\nCase 1( k==1):\\nwe can just rotate the string by one position every time, hence find the lexicographically smallest of all possible rotations and return it. This can be done by finding the lexicographically smallest character in the string and moving all the characters before it to the last.\\n\\nCase 2(k>1):\\nAll the cases where k>1 are equivalent. This is because, if say k=4, we can even rotate the characters only from a window of 3 characters, or 2 charaters. Hence, case k=4 is same as k=2 or k=3. But do we get the same lexicographically smallest string from all values of k>. Let\\'s check.\\n```\\ns: ebdacbg, k=2\\nsince \"a\" is the smallest character, let\\'s try bringing it to front. \\nTo get the lexicographically smallest permutation, we\\'ll move the smallest character from window to the last.\\n[]-> current window\\ns: [eb]dacbg\\ns: [ed]acbgb\\ns: [ea]cbgbd\\ns1: [ac]bgbde\\n```\\nIf you see now, all charaters before the smallest character( \"a\") got to the last in sorted order (\"bde\"). Let\\'s run another iteration and try to bring back (\"a\") to the front: \\n```\\ns: [cb]gbdea\\ns: [cg]bdeab\\ns: [gb]deabc\\ns: [gd]eabcb\\ns: [ge]abcbd\\ns: [ga]bcbde\\ns2: [ab]cbdeg\\n```\\nSo we see we got a smaller string( lexicographically) than what we got after first iteration(`s1`). How?\\nThis is because what we are essentially doing here is bubble sort, we are comparing the elements in the window and removing the smaller element and moving forward with the larger element. Like this, the largest element would stay in the window till the very last and will finally get placed in the last position.\\n\\nHence, if you see, with every `ith` iteration, last `i` elements of the string will be in sorted order.\\n\\nAnd since we know, bubble sort eventually leads to a sorted array, the solution will be the sorted array, `sort(s)`.\\n\\nCode: \\n```\\nimport (\\n    \"sort\"\\n)\\nfunc orderlyQueue(S string, K int) string {\\n    s := []byte(S)\\n    if K>1 {\\n        sort.Slice(s, func(i int, j int) bool { return s[i] < s[j] })\\n        return string(s)        \\n    } else {\\n        i:=findSmallest(s)\\n        return string(append(s[i:],s[:i]...))\\n    }\\n}\\nfunc findSmallest(s []byte) int {\\n    smallest:=0\\n    for i:=1; i<len(s); i++ {\\n        if s[i]<s[smallest] {\\n            smallest=i\\n        } else if s[i]==s[smallest] {\\n            j, k:= smallest+1, i+1\\n            for k<len(s) {\\n                if s[j]<s[k] {\\n                    break\\n                } else if s[j]==s[k] {\\n                    j++; k++\\n                } else {\\n                    smallest=i\\n                    break\\n                }\\n            }\\n            if k==len(s) {\\n                smallest=i\\n            }\\n        }\\n    }\\n    return smallest\\n}\\n```\\nComplexity: \\nTime: O(n^2) -> due to `findSmallest()` which is n^2 in worst case\\nSpace: O(n) -> for auxiliary byte slice for the string",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ns: ebdacbg, k=2\\nsince \"a\" is the smallest character, let\\'s try bringing it to front. \\nTo get the lexicographically smallest permutation, we\\'ll move the smallest character from window to the last.\\n[]-> current window\\ns: [eb]dacbg\\ns: [ed]acbgb\\ns: [ea]cbgbd\\ns1: [ac]bgbde\\n```\n```\\ns: [cb]gbdea\\ns: [cg]bdeab\\ns: [gb]deabc\\ns: [gd]eabcb\\ns: [ge]abcbd\\ns: [ga]bcbde\\ns2: [ab]cbdeg\\n```\n```\\nimport (\\n    \"sort\"\\n)\\nfunc orderlyQueue(S string, K int) string {\\n    s := []byte(S)\\n    if K>1 {\\n        sort.Slice(s, func(i int, j int) bool { return s[i] < s[j] })\\n        return string(s)        \\n    } else {\\n        i:=findSmallest(s)\\n        return string(append(s[i:],s[:i]...))\\n    }\\n}\\nfunc findSmallest(s []byte) int {\\n    smallest:=0\\n    for i:=1; i<len(s); i++ {\\n        if s[i]<s[smallest] {\\n            smallest=i\\n        } else if s[i]==s[smallest] {\\n            j, k:= smallest+1, i+1\\n            for k<len(s) {\\n                if s[j]<s[k] {\\n                    break\\n                } else if s[j]==s[k] {\\n                    j++; k++\\n                } else {\\n                    smallest=i\\n                    break\\n                }\\n            }\\n            if k==len(s) {\\n                smallest=i\\n            }\\n        }\\n    }\\n    return smallest\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 220864,
                "title": "java-super-easy-and-fast-10ms-9-line-solution-beats-95",
                "content": "```\\n    public String orderlyQueue(String S, int K) {\\n        if(K>1) {\\n            char[] temp=S.toCharArray();\\n            Arrays.sort(temp);\\n            return new String(temp);\\n        }\\n        String res=S;\\n        for(int i=1;i<S.length();i++) {\\n            String temp=S.substring(i)+S.substring(0, i);\\n            if(temp.compareTo(res)<0) res=temp;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public String orderlyQueue(String S, int K) {\\n        if(K>1) {\\n            char[] temp=S.toCharArray();\\n            Arrays.sort(temp);\\n            return new String(temp);\\n        }\\n        String res=S;\\n        for(int i=1;i<S.length();i++) {\\n            String temp=S.substring(i)+S.substring(0, i);\\n            if(temp.compareTo(res)<0) res=temp;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 165871,
                "title": "javascript-a-trap-question",
                "content": "In fact when `K>1`, we can totally sort the string.\\n\\nBy swapping two neighbors, we can sort a string -- this is the way how **bubble sorting** works.\\nAnd by choosing one of two neighbors and place it at the end, we can rearrange/swap these two elements -- therefore we can sort the string when `K>=2`.\\n\\nSo the only part we need to deal with is when `K===1`.\\n```\\nvar orderlyQueue = function(S, K) {\\n    if(K>1) return S.split(\\'\\').sort().join(\\'\\');\\n    else{\\n    \\tlet small = S.split(\\'\\').sort()[0];\\n    \\tlet ops = [];\\n    \\tfor(let i=0; i<S.length; i++){\\n    \\t\\tif(S[i]===small) ops.push(S.slice(i)+S.slice(0,i));\\n    \\t}\\n    \\treturn ops.sort()[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar orderlyQueue = function(S, K) {\\n    if(K>1) return S.split(\\'\\').sort().join(\\'\\');\\n    else{\\n    \\tlet small = S.split(\\'\\').sort()[0];\\n    \\tlet ops = [];\\n    \\tfor(let i=0; i<S.length; i++){\\n    \\t\\tif(S[i]===small) ops.push(S.slice(i)+S.slice(0,i));\\n    \\t}\\n    \\treturn ops.sort()[0];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922725,
                "title": "c-javascript-easy-solution",
                "content": "# Complexity\\n- Time complexity:  O(n log n) when k > 1, O(n^2) when k = 1\\n\\n- Space complexity: : O(1)\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k>1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string res = s;\\n        for (int i = 1; i < s.size(); i++)\\n            res = min(res, s.substr(i) + s.substr(0, i));\\n        return res;\\n    }\\n};\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n    if (k > 1) {\\n        return s.split(\"\").sort().join(\"\");\\n    }\\n\\n    let res = s;\\n    for (let i = 1; i < s.length; i++) {\\n            const newStr = s.substr(i) + s.substr(0, i);\\n            if (newStr < res) {\\n            res = newStr;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Math",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k>1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string res = s;\\n        for (int i = 1; i < s.size(); i++)\\n            res = min(res, s.substr(i) + s.substr(0, i));\\n        return res;\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n    if (k > 1) {\\n        return s.split(\"\").sort().join(\"\");\\n    }\\n\\n    let res = s;\\n    for (let i = 1; i < s.length; i++) {\\n            const newStr = s.substr(i) + s.substr(0, i);\\n            if (newStr < res) {\\n            res = newStr;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861988,
                "title": "0ms-easy-approch-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==0) return s;\\n        if(k>1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k==1){\\n            string new_var=s;\\n            for(int i=0;i<s.length();i++){\\n                s=s.substr(1)+s[0];\\n                if(new_var>s)new_var=s;\\n            }\\n            return new_var;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==0) return s;\\n        if(k>1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k==1){\\n            string new_var=s;\\n            for(int i=0;i<s.length();i++){\\n                s=s.substr(1)+s[0];\\n                if(new_var>s)new_var=s;\\n            }\\n            return new_var;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513911,
                "title": "solution",
                "content": "```C++ []\\n#pragma once\\n#include <algorithm>\\n#include <string>\\n\\nclass Solution {\\nprivate:\\n  static bool less(const std::string &s, size_t l, size_t r) {\\n    for (size_t i = 0; i < s.size(); ++i) {\\n      const auto s1 = s[(l + i) % s.size()];\\n      const auto s2 = s[(r + i) % s.size()];\\n      if (s1 != s2) {\\n        return s1 < s2;\\n      }\\n    }\\n    return true;\\n  }\\n  static size_t min_position(const std::string &s) {\\n    size_t i = 0;\\n    for (size_t j = 1; j < s.size(); ++j) {\\n      if (less(s, j, i)) {\\n        i = j;\\n      }\\n    }\\n    return i;\\n  }\\npublic:\\n  static std::string orderlyQueue(std::string s, int k) {\\n    if (k == 1) {\\n      std::rotate(s.begin(), s.begin() + min_position(s), s.end());\\n    } else {\\n      std::sort(s.begin(), s.end());\\n    }\\n    return s;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            return min(s[i:]+s[:i] for i in range(len(s)))\\n\\n        else :\\n            return \\'\\'.join(sorted(s))\\n```\\n\\n```Java []\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        int[] countChar = new int[26];\\n        int length = s.length();\\n        for(int i = 0 ; i < length ; ++i) {\\n            countChar[s.charAt(i) - \\'a\\']++;\\n        }\\n        if(k > 1) {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0 ; i < 26 ; ++i) {\\n                int appearance = countChar[i];\\n                char c = (char)(\\'a\\' + i);\\n                for(int r = 0 ; r < appearance ; ++r) {\\n                    sb.append(c);\\n                }\\n            }\\n            return sb.toString();\\n        }\\n        char startChar = \\'a\\';\\n        for(int i = 0 ; i < 26 ; ++i) {\\n            if(countChar[i] > 0) {\\n                startChar = (char)(\\'a\\' + i);\\n                break;\\n            }\\n        }\\n        List<String> beginWithStartChar = new ArrayList<>();\\n        for(int i = 0 ; i < length ; ++i) {\\n            if(s.charAt(i) == startChar) {\\n                beginWithStartChar.add(s.substring(i) + s.substring(0, i));\\n            }\\n        }\\n        String min = beginWithStartChar.get(0);\\n        for(String strBeginWithStartChar : beginWithStartChar) {\\n            if(strBeginWithStartChar.compareTo(min) < 0) min = strBeginWithStartChar;\\n        }\\n        return min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#pragma once\\n#include <algorithm>\\n#include <string>\\n\\nclass Solution {\\nprivate:\\n  static bool less(const std::string &s, size_t l, size_t r) {\\n    for (size_t i = 0; i < s.size(); ++i) {\\n      const auto s1 = s[(l + i) % s.size()];\\n      const auto s2 = s[(r + i) % s.size()];\\n      if (s1 != s2) {\\n        return s1 < s2;\\n      }\\n    }\\n    return true;\\n  }\\n  static size_t min_position(const std::string &s) {\\n    size_t i = 0;\\n    for (size_t j = 1; j < s.size(); ++j) {\\n      if (less(s, j, i)) {\\n        i = j;\\n      }\\n    }\\n    return i;\\n  }\\npublic:\\n  static std::string orderlyQueue(std::string s, int k) {\\n    if (k == 1) {\\n      std::rotate(s.begin(), s.begin() + min_position(s), s.end());\\n    } else {\\n      std::sort(s.begin(), s.end());\\n    }\\n    return s;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            return min(s[i:]+s[:i] for i in range(len(s)))\\n\\n        else :\\n            return \\'\\'.join(sorted(s))\\n```\n```Java []\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        int[] countChar = new int[26];\\n        int length = s.length();\\n        for(int i = 0 ; i < length ; ++i) {\\n            countChar[s.charAt(i) - \\'a\\']++;\\n        }\\n        if(k > 1) {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0 ; i < 26 ; ++i) {\\n                int appearance = countChar[i];\\n                char c = (char)(\\'a\\' + i);\\n                for(int r = 0 ; r < appearance ; ++r) {\\n                    sb.append(c);\\n                }\\n            }\\n            return sb.toString();\\n        }\\n        char startChar = \\'a\\';\\n        for(int i = 0 ; i < 26 ; ++i) {\\n            if(countChar[i] > 0) {\\n                startChar = (char)(\\'a\\' + i);\\n                break;\\n            }\\n        }\\n        List<String> beginWithStartChar = new ArrayList<>();\\n        for(int i = 0 ; i < length ; ++i) {\\n            if(s.charAt(i) == startChar) {\\n                beginWithStartChar.add(s.substring(i) + s.substring(0, i));\\n            }\\n        }\\n        String min = beginWithStartChar.get(0);\\n        for(String strBeginWithStartChar : beginWithStartChar) {\\n            if(strBeginWithStartChar.compareTo(min) < 0) min = strBeginWithStartChar;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3420578,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){  \\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{ \\n            String str2=new String(s);\\n            for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); \\n                if(str2.compareTo(s)>0){        \\n                    str2=s;                     \\n                } \\n            }\\n            return str2;\\n        }     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){  \\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{ \\n            String str2=new String(s);\\n            for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); \\n                if(str2.compareTo(s)>0){        \\n                    str2=s;                     \\n                } \\n            }\\n            return str2;\\n        }     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307594,
                "title": "easy-solution-explanation-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought that comes in mind is that you should append letters such that we attain string closest to sorted string.\\nAnd if we see that for k = 1 we can only rotate whole string but for k > 1 we can do other things and change its order of letters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Case 1 --> k = 1\\n-> we will rotate string and find the smallest string.\\n##### Execution\\n=> append the whole string s, so that it is easy to access rotated elements.\\n=> check for each substring of size n in s for smallest sub string.\\n```\\neg) cbaad -> 0 - index\\n=> cbaadcbaad.\\n=> for i = 2 we have substring aadcb which is smalles substring.\\n=> it can be obtained by appending b and then c.\\n```\\n\\n### Case 2 --> k > 1\\n-> we can change order of adjacent letters by using first 2 letters as a buffer.\\n-> fix the first letter\\n-> rotate string from i = 1. (0 - index string s)\\n-> rotate till adjacent letter is not at the last position.\\n-> when adjacent letter is at the last position we have order of adjacent letters reversed.\\n-> similarly we can just sort the string.\\n##### Execution\\n=> sort the string\\n```\\neg) cbaad\\n=> fix c and rotate from b.\\n=> finally obtain => cdaab.\\n=> rotate => bcdaa. (order changed => cb -> bc)\\n```\\n# Complexity\\n- Time complexity:- O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n = s.size();\\n        string sorted = s;\\n        sort(sorted.begin(), sorted.end());\\n        if(k > 1)\\n        {\\n            return sorted;\\n        }\\n        string ans = s;\\n        s += s;\\n        for(int i = 0; i < n; i ++)\\n        {\\n            ans = min(ans, s.substr(i, n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\neg) cbaad -> 0 - index\\n=> cbaadcbaad.\\n=> for i = 2 we have substring aadcb which is smalles substring.\\n=> it can be obtained by appending b and then c.\\n```\n```\\neg) cbaad\\n=> fix c and rotate from b.\\n=> finally obtain => cdaab.\\n=> rotate => bcdaa. (order changed => cb -> bc)\\n```\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n = s.size();\\n        string sorted = s;\\n        sort(sorted.begin(), sorted.end());\\n        if(k > 1)\\n        {\\n            return sorted;\\n        }\\n        string ans = s;\\n        s += s;\\n        for(int i = 0; i < n; i ++)\\n        {\\n            ans = min(ans, s.substr(i, n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987218,
                "title": "easy-c-solution-beats-92-online-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMath Problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k > 1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n\\n        string ans = s;\\n\\n        for(int i = 0;i < s.length();i++){\\n            s = s.substr(1,s.length()-1) + s.substr(0,1);\\n            cout<<s<<endl;\\n            ans = min(ans,s);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k > 1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n\\n        string ans = s;\\n\\n        for(int i = 0;i < s.length();i++){\\n            s = s.substr(1,s.length()-1) + s.substr(0,1);\\n            cout<<s<<endl;\\n            ans = min(ans,s);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2812777,
                "title": "python-easy-solution-expalined",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            return \\'\\'.join(sorted(s))\\n        n=len(s)\\n        t=s*2 # t=cbacba\\n        ans=s # ans=cba\\n        for i in range(1,n):\\n            s1=t[i:i+n]          # 1st move : s1=t[1:1+3] = bac\\n            ans=min(ans,s1)      # 2nd move : s1=t[2:2+3] = acb\\n        return ans\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            return \\'\\'.join(sorted(s))\\n        n=len(s)\\n        t=s*2 # t=cbacba\\n        ans=s # ans=cba\\n        for i in range(1,n):\\n            s1=t[i:i+n]          # 1st move : s1=t[1:1+3] = bac\\n            ans=min(ans,s1)      # 2nd move : s1=t[2:2+3] = acb\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793378,
                "title": "java-easiest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788451,
                "title": "cpp-solution-o-n-2-simple-approach",
                "content": "Well if you observe carefully if k > 1 let\\'s say 2\\nIt\\'s somthing like selection sort let\\'s see one example\\n\\nwe will compare first n-i elements and find minimum element and at last append it at the end rest of the string will remain same!\\nand do same for i 0 to n - 1\\n\\nlet\\'s try one example\\n\\ns = \"fedcba\" \\ni = 0 : s =  \"fedcba\" : found a as minimum from f to a or index 0 to 5 stored it at first pos and append it at the end\\ni = 1 : s = \"fedcab\"  : found b as minimum from f to b or index 0 to 4 \\ni = 2 : s = \"fedabc\"  : found c as minimum from f to a or index 0 to 3\\ni = 3 : s = \"feabcd\"  : found d as minimum from f to a or index 0 to 2 \\ni = 4 : s = \"fabcde\"  : found e as minimum from f to a or index 0 to 1 \\ni = 5 : s = \"abcdef\"  : found f as minimum from f to a or index 0 to 0 \\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k > 1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        s += s;\\n        string res = s;\\n        for(int i = 0; i < (int)s.size()/2; i++) {\\n            string t = s.substr(i, (int)s.size()/2);\\n            if(t < res) res = t;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k > 1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        s += s;\\n        string res = s;\\n        for(int i = 0; i < (int)s.size()/2; i++) {\\n            string t = s.substr(i, (int)s.size()/2);\\n            if(t < res) res = t;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786295,
                "title": "java-clean-and-simple",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String ans = s;\\n\\n            for (int i = 0; i < s.length(); i++) {\\n                String reordered = s.substring(i) + s.substring(0, i);\\n                if (ans.compareTo(reordered) > 0) {\\n                    ans = reordered;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        char[] arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String ans = s;\\n\\n            for (int i = 0; i < s.length(); i++) {\\n                String reordered = s.substring(i) + s.substring(0, i);\\n                if (ans.compareTo(reordered) > 0) {\\n                    ans = reordered;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        char[] arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786172,
                "title": "sorting-c",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans;\\n        if(k>1){ \\n            sort(s.begin(),s.end());\\n            ans = s;\\n        }else{\\n            int n = s.size();\\n            ans = s;\\n            s+=s;\\n            for(int i=1; i<n;i++){\\n                ans = min(ans,s.substr(i, n));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans;\\n        if(k>1){ \\n            sort(s.begin(),s.end());\\n            ans = s;\\n        }else{\\n            int n = s.size();\\n            ans = s;\\n            s+=s;\\n            for(int i=1; i<n;i++){\\n                ans = min(ans,s.substr(i, n));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786003,
                "title": "hard-easy-solution-c",
                "content": "# Intuition\\nif value of k>1, we can always find the sorted string.\\n\\n# Approach\\nif k>1, we can just sort the string and return it.\\notherwise, we can append every ith char of s to end and find smallest string.\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        //if k>1 , sort the string \\n        if(k>1){\\n            sort(s.begin(),s.end()); \\n            return s;\\n        }\\n        string ans=s;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            s+=s[i]; //append char to the end\\n            string str=s.substr(i+1);\\n            if(str<ans) ans=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        //if k>1 , sort the string \\n        if(k>1){\\n            sort(s.begin(),s.end()); \\n            return s;\\n        }\\n        string ans=s;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            s+=s[i]; //append char to the end\\n            string str=s.substr(i+1);\\n            if(str<ans) ans=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785682,
                "title": "python-easy-solution",
                "content": "Please star and upvote if you liked the solution\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            return \"\".join(sorted(s))\\n        ans,l=s,len(s)\\n        for i in range(l):\\n            s=s[1:]+s[0]\\n            ans=min(ans,s)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            return \"\".join(sorted(s))\\n        ans,l=s,len(s)\\n        for i in range(l):\\n            s=s[1:]+s[0]\\n            ans=min(ans,s)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785600,
                "title": "c-doubly-linked-list",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1)\\n        {\\n            deque<char> smallest(s.begin(), s.end());\\n            deque<char> rotate = smallest;\\n\\n            int n = s.size();\\n            while (n > 0)\\n            {\\n                rotate.push_back(rotate.front());\\n                rotate.pop_front();\\n                if (rotate < smallest)\\n                {\\n                    smallest = rotate;\\n                }\\n                n --;\\n            }\\n            return string(smallest.begin(), smallest.end());\\n        }\\n        else\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1)\\n        {\\n            deque<char> smallest(s.begin(), s.end());\\n            deque<char> rotate = smallest;\\n\\n            int n = s.size();\\n            while (n > 0)\\n            {\\n                rotate.push_back(rotate.front());\\n                rotate.pop_front();\\n                if (rotate < smallest)\\n                {\\n                    smallest = rotate;\\n                }\\n                n --;\\n            }\\n            return string(smallest.begin(), smallest.end());\\n        }\\n        else\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785498,
                "title": "java-solution-3ms-runtime-faster-than-96",
                "content": "```java \\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        String res;\\n        if(k==1){\\n            res=s;\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String temp = s.substring(i,s.length())+s.substring(0,i);\\n                if(temp.compareTo(res)<0)\\n                    res=temp;\\n            }\\n        }\\n        else{\\n            int[] a = new int[26];\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                a[s.charAt(i)-\\'a\\']++;\\n            }\\n            \\n            res=\"\";\\n            for(int i=0;i<a.length;i++)\\n            {\\n                res+=((char)(i+\\'a\\')+\"\").repeat(a[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n    public String orderlyQueue(String s, int k) {\\n        String res;\\n        if(k==1){\\n            res=s;\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String temp = s.substring(i,s.length())+s.substring(0,i);\\n                if(temp.compareTo(res)<0)\\n                    res=temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2785302,
                "title": "intuitive-apporach",
                "content": "//here we will be finding the pattern for which we can swap the two character present anywhere \\n if we are ablle to do it then ok simpy sort the array and return \\nif not then we have to apply the greedy way to find the lowest or ascending order arrr\\njust observe the pattern  \\npublic String orderlyQueue(String s, int k) {\\n        char arr[]=s.toCharArray();\\n\\t\\t\\n        if(k>1)\\n        { Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        }\\n        String ans=s;\\n        for(int i=0;i<s.length();i++){\\n            rotate(arr);\\n            int dif=ans.compareTo(String.valueOf(arr));\\n            if(dif>0)\\n                ans=String.valueOf(arr);\\n        }\\n        return ans;\\n    }\\n    public void  rotate(char arr[]){\\n        char temp=arr[0];\\n        for(int i=0;i<arr.length-1;i++){\\n            arr[i]=arr[i+1];\\n        }\\n        arr[arr.length-1]=temp;\\n    }\\n\\t\\n\\t\\n\\tAll thanks to summit sir\\nhttps://www.youtube.com/watch?v=6cODUSGmYD4",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "//here we will be finding the pattern for which we can swap the two character present anywhere \\n if we are ablle to do it then ok simpy sort the array and return \\nif not then we have to apply the greedy way to find the lowest or ascending order arrr\\njust observe the pattern  \\npublic String orderlyQueue(String s, int k) {\\n        char arr[]=s.toCharArray();\\n\\t\\t\\n        if(k>1)\\n        { Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        }\\n        String ans=s;\\n        for(int i=0;i<s.length();i++){\\n            rotate(arr);\\n            int dif=ans.compareTo(String.valueOf(arr));\\n            if(dif>0)\\n                ans=String.valueOf(arr);\\n        }\\n        return ans;\\n    }\\n    public void  rotate(char arr[]){\\n        char temp=arr[0];\\n        for(int i=0;i<arr.length-1;i++){\\n            arr[i]=arr[i+1];\\n        }\\n        arr[arr.length-1]=temp;\\n    }\\n\\t\\n\\t\\n\\tAll thanks to summit sir\\nhttps://www.youtube.com/watch?v=6cODUSGmYD4",
                "codeTag": "Unknown"
            },
            {
                "id": 2785198,
                "title": "cp-c-small-and-consize-solution",
                "content": "\\t\\tstring orderlyQueue(string s, int k) {\\n\\t\\t\\tif (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));\\n            return ans;\\n\\t\\t\\t}\\n\\t\\t\\tsort(begin(s), end(s));\\n\\t\\t\\treturn s;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Orderly Queue.\\nMemory Usage: 8.3 MB, less than 74.71% of C++ online submissions for Orderly Queue.",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\tstring orderlyQueue(string s, int k) {\\n\\t\\t\\tif (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));\\n            return ans;\\n\\t\\t\\t}\\n\\t\\t\\tsort(begin(s), end(s));\\n\\t\\t\\treturn s;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Orderly Queue.\\nMemory Usage: 8.3 MB, less than 74.71% of C++ online submissions for Orderly Queue.",
                "codeTag": "Unknown"
            },
            {
                "id": 2785194,
                "title": "c-sort",
                "content": "string orderlyQueue(string s, int k) {\\n\\n\\n         if (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));return ans;\\n        }\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "string orderlyQueue(string s, int k) {\\n\\n\\n         if (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));return ans;\\n        }\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2785042,
                "title": "c-sorting-faster-easy-to-understand",
                "content": "* ***Using Sorting***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string str, int k) {\\n\\n        int n = str.size();\\n\\n        // if k == 1, then check for lexicographically smallest str, after appending starting character to the end\\n\\n        if(k == 1)\\n        {\\n            string ans = str;\\n\\n            for(int i = 0; i < n; i++)\\n            {\\n                string temp = str.substr(i) + str.substr(0, i);\\n\\n                // update ans\\n\\n                if(temp < ans)\\n                {\\n                    ans = temp;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        // if k > 1, then simply sort the str\\n\\n        sort(str.begin(), str.end());\\n\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string str, int k) {\\n\\n        int n = str.size();\\n\\n        // if k == 1, then check for lexicographically smallest str, after appending starting character to the end\\n\\n        if(k == 1)\\n        {\\n            string ans = str;\\n\\n            for(int i = 0; i < n; i++)\\n            {\\n                string temp = str.substr(i) + str.substr(0, i);\\n\\n                // update ans\\n\\n                if(temp < ans)\\n                {\\n                    ans = temp;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        // if k > 1, then simply sort the str\\n\\n        sort(str.begin(), str.end());\\n\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784943,
                "title": "a-short-rust-solution-with-100-less-memory-100-less-time",
                "content": "```rust\\nuse std::str::from_utf8_unchecked;\\n\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        let mut s = s.into_bytes();\\n        if k == 1 {\\n            let mut r = s.clone();\\n            for _ in 1..s.len() {\\n                r.rotate_left(1);\\n                if r < s {\\n                    s = r.clone();\\n                }\\n            }\\n        } else {\\n            s.sort_unstable();\\n        }\\n        unsafe { from_utf8_unchecked(&s).to_owned() }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::str::from_utf8_unchecked;\\n\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        let mut s = s.into_bytes();\\n        if k == 1 {\\n            let mut r = s.clone();\\n            for _ in 1..s.len() {\\n                r.rotate_left(1);\\n                if r < s {\\n                    s = r.clone();\\n                }\\n            }\\n        } else {\\n            s.sort_unstable();\\n        }\\n        unsafe { from_utf8_unchecked(&s).to_owned() }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784616,
                "title": "simple-solution-beats-97",
                "content": "# Code\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1: return \\'\\'.join(sorted(s))\\n        m = s\\n        for i in range(1, len(s)):\\n            # print(s[i: ]+s[: i])\\n            m = min(m, s[i: ]+s[: i])\\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1: return \\'\\'.join(sorted(s))\\n        m = s\\n        for i in range(1, len(s)):\\n            # print(s[i: ]+s[: i])\\n            m = min(m, s[i: ]+s[: i])\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784578,
                "title": "c-when-k-1-sort-else-check-by-reordering-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       if(k == 1)\\n       {\\n           int n = s.size();\\n           string doublestring = s+s;\\n           string ans = s;\\n           for(int i=1;i<n;i++){\\n               string str = doublestring.substr(i,n);\\n               if(str < ans)\\n               {\\n                   ans = str;\\n               }\\n           }\\n           return ans;\\n       }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       if(k == 1)\\n       {\\n           int n = s.size();\\n           string doublestring = s+s;\\n           string ans = s;\\n           for(int i=1;i<n;i++){\\n               string str = doublestring.substr(i,n);\\n               if(str < ans)\\n               {\\n                   ans = str;\\n               }\\n           }\\n           return ans;\\n       }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784536,
                "title": "simple-8ms-c-solution-clean-code",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        string orderlyQueue(string s, int k)\\n        {\\n            string ans = \"\";\\n            if (k > 1)\\n            {\\n                sort(s.begin(), s.end());\\n                return s;\\n            }\\n            int n = s.size();\\n            ans = s;\\n            s += s;\\n            cout << s << endl;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (s.substr(i, n) < ans)\\n                {\\n                    ans = s.substr(i, n);\\n                    cout << ans << endl;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string orderlyQueue(string s, int k)\\n        {\\n            string ans = \"\";\\n            if (k > 1)\\n            {\\n                sort(s.begin(), s.end());\\n                return s;\\n            }\\n            int n = s.size();\\n            ans = s;\\n            s += s;\\n            cout << s << endl;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (s.substr(i, n) < ans)\\n                {\\n                    ans = s.substr(i, n);\\n                    cout << ans << endl;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2784492,
                "title": "python-concise-two-cases-only",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            n = len(s)\\n            ss = s + s\\n            lex_min_str = s\\n            for i in range(n):\\n                lex_min_str = min(lex_min_str, ss[i:i + n])\\n            return lex_min_str\\n        \\n        return \"\".join(sorted(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            n = len(s)\\n            ss = s + s\\n            lex_min_str = s\\n            for i in range(n):\\n                lex_min_str = min(lex_min_str, ss[i:i + n])\\n            return lex_min_str\\n        \\n        return \"\".join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784425,
                "title": "c-most-easy-solution-using-simple-sorting",
                "content": "if k=1 then only we have to check otherwise for values of k>1 simple soting the string would do this can be checked by taking examples for different values of k for k=1 we have to check and find which resulting string would give us the lexiographically smaleest string.\\n```\\nclass Solution {\\npublic:\\n     string orderlyQueue(string s, int k) {\\n        if(k==1)\\n        {\\n            string prev=s;\\n            string ans=s;\\n            for(int i=0;i<s.size();i++)\\n            {\\n               string temp=s.substr(i,s.size()-i)+s.substr(0,i);\\n                if(temp<prev)// we check by putting every character in front and therby\\n\\t\\t\\t\\t//seeing that which resuting string gives us the lexicographically most smallest string\\n                {\\n                    ans=temp;\\n                    prev=temp;\\n                }\\n            }\\n            return ans;\\n        }\\n       sort(s.begin(),s.end());\\n         return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string orderlyQueue(string s, int k) {\\n        if(k==1)\\n        {\\n            string prev=s;\\n            string ans=s;\\n            for(int i=0;i<s.size();i++)\\n            {\\n               string temp=s.substr(i,s.size()-i)+s.substr(0,i);\\n                if(temp<prev)// we check by putting every character in front and therby\\n\\t\\t\\t\\t//seeing that which resuting string gives us the lexicographically most smallest string\\n                {\\n                    ans=temp;\\n                    prev=temp;\\n                }\\n            }\\n            return ans;\\n        }\\n       sort(s.begin(),s.end());\\n         return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784289,
                "title": "c-easy-approach-fast-solution-0ms",
                "content": "Approach\\nif K==0 then simply return that string.\\nif K>1 sort the string and return that string.\\nif K==1 finds all such combinations and return lexicographically the smallest string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==0)return s;  // for  k==0 simply return the string back.\\n        if(k>1)           //  for  k>1 sort the string and return ans\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k == 1){    // for(k==1)  find all the smallest string \\n            string ans = s;\\n            for(int i=0;i<s.length();i++){\\n                s = s.substr(1) + s[0];\\n                ans = min(s,ans);\\n            }\\n            return ans;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==0)return s;  // for  k==0 simply return the string back.\\n        if(k>1)           //  for  k>1 sort the string and return ans\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k == 1){    // for(k==1)  find all the smallest string \\n            string ans = s;\\n            for(int i=0;i<s.length();i++){\\n                s = s.substr(1) + s[0];\\n                ans = min(s,ans);\\n            }\\n            return ans;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784145,
                "title": "javascript-solution-easy-approach",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(S, K) {\\n    if( K > 1) {\\n        return S.split(\\'\\').sort().join(\\'\\');\\n    } else {\\n    \\tlet small = S.split(\\'\\').sort()[0];\\n    \\tlet newQueue = [];\\n    \\tfor(let i=0; i<S.length; i++){\\n    \\t\\tif(S[i]===small) {\\n                newQueue.push(S.slice(i)+S.slice(0,i));\\n            }\\n    \\t}\\n    \\treturn newQueue.sort()[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(S, K) {\\n    if( K > 1) {\\n        return S.split(\\'\\').sort().join(\\'\\');\\n    } else {\\n    \\tlet small = S.split(\\'\\').sort()[0];\\n    \\tlet newQueue = [];\\n    \\tfor(let i=0; i<S.length; i++){\\n    \\t\\tif(S[i]===small) {\\n                newQueue.push(S.slice(i)+S.slice(0,i));\\n            }\\n    \\t}\\n    \\treturn newQueue.sort()[0];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784103,
                "title": "most-easy-c-solution-beginner-friendly-very-easy-to-understand",
                "content": "**Please Upvote if you find the solution helpful**\\n\\nclass Solution {\\npublic:\\n\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1) {                            // for k == 1 we have to check \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// for each and every possible rotation.\\n            string str = s;\\n            for(int i = 0 ; i  <s.size() ;++i){\\n                char t = s[0];\\n                for(int j = 0  ; j <s.size()-1 ;++j){\\n                    s[j] = s[j+1];\\n                }\\n                s[s.size()-1] = t;\\n                str = min(str,s);\\n            }\\n            return str;\\n        } \\n        sort(s.begin(),s.end());            // For k > 1 we can simply sort the array as we will be able to get \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//  most smalllest Lexicographically smallest string.\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1) {                            // for k == 1 we have to check \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// for each and every possible rotation.\\n            string str = s;\\n            for(int i = 0 ; i  <s.size() ;++i){\\n                char t = s[0];\\n                for(int j = 0  ; j <s.size()-1 ;++j){\\n                    s[j] = s[j+1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2783754,
                "title": "python-simple-python-solution-using-sorting",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 61 ms, faster than 53.57% of Python3 online submissions for Orderly Queue.\\n# Memory Usage: 14 MB, less than 14.29% of Python3 online submissions for Orderly Queue.\\n\\tclass Solution:\\n\\t\\tdef orderlyQueue(self, s: str, k: int) -> str:\\n\\n\\t\\t\\tnew_s = s\\n\\n\\t\\t\\tif k == 1:\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\ts = s[1:]+s[0]\\n\\t\\t\\t\\t\\tnew_s = min(new_s, s) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_s = sorted(list(s))\\n\\n\\t\\t\\tresult = \\'\\'.join(new_s)\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 61 ms, faster than 53.57% of Python3 online submissions for Orderly Queue.\\n# Memory Usage: 14 MB, less than 14.29% of Python3 online submissions for Orderly Queue.\\n\\tclass Solution:\\n\\t\\tdef orderlyQueue(self, s: str, k: int) -> str:\\n\\n\\t\\t\\tnew_s = s\\n\\n\\t\\t\\tif k == 1:\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\ts = s[1:]+s[0]\\n\\t\\t\\t\\t\\tnew_s = min(new_s, s) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_s = sorted(list(s))\\n\\n\\t\\t\\tresult = \\'\\'.join(new_s)\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2783633,
                "title": "rust-0ms-solution",
                "content": "Rust [0ms](https://leetcode.com/submissions/detail/837833448/) Solution:\\n```rust\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        let mut s: Vec<char> = s.chars().collect();\\n        if k > 1 {\\n            s.sort_unstable();\\n            return s.iter().collect::<String>();\\n        }\\n        let mut min = s.clone();\\n        for _ in 0..s.len() {\\n            s.rotate_left(1);\\n            if s < min {\\n                min = s.clone();\\n            }\\n        }\\n        min.iter().collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        let mut s: Vec<char> = s.chars().collect();\\n        if k > 1 {\\n            s.sort_unstable();\\n            return s.iter().collect::<String>();\\n        }\\n        let mut min = s.clone();\\n        for _ in 0..s.len() {\\n            s.rotate_left(1);\\n            if s < min {\\n                min = s.clone();\\n            }\\n        }\\n        min.iter().collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783577,
                "title": "c-short-clean-code-with-detailed-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the value of k>1, no matter what the string is, it is possible to sort the entire string and return it.\\nLet\\'s say, for eg:\\n```\\nString: baaca k=2\\n```\\nWe can make the following transitions:\\n```\\nbacaa\\nbcaaa\\ncaaab\\naaabc\\n```\\nThus if k>1, just sort the string and return it.\\nOtherwise, if k=1, send each character one by one, at the end of the string and check if the resultant string formed is lexicographically smallest string or not.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1)\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string str=s;\\n        for(int i=0;i<s.length();i++)\\n            str=min(str, s.substr(i)+s.substr(0,i));\\n        return str;\\n    }\\n};\\n```\\n**PLEASE UPVOTE IF IT HELPS!!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nString: baaca k=2\\n```\n```\\nbacaa\\nbcaaa\\ncaaab\\naaabc\\n```\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1)\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string str=s;\\n        for(int i=0;i<s.length();i++)\\n            str=min(str, s.substr(i)+s.substr(0,i));\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783456,
                "title": "c-clean-code-easiest-to-understand",
                "content": "The only caviat is when k==1,else we can simply sort the string and return the particular string.\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       if(k==1){\\n           string ok=s;\\n           for(int i=0;i<s.length();i++){\\n               string temp=s.substr(i)+s.substr(0,i);\\n               if(temp.compare(ok)<0){\\n                   ok=temp;\\n               }\\n           }\\n           return ok;\\n       }\\n        else{\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       if(k==1){\\n           string ok=s;\\n           for(int i=0;i<s.length();i++){\\n               string temp=s.substr(i)+s.substr(0,i);\\n               if(temp.compare(ok)<0){\\n                   ok=temp;\\n               }\\n           }\\n           return ok;\\n       }\\n        else{\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783436,
                "title": "c-sorting-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==1)\\n        {\\n            string res=s;\\n            for(int i=0;i<s.length();i++)\\n            {\\n               string t=\"\";\\n               t+=s[s.length()-1];\\n               s.pop_back();\\n               t+=s;\\n               if(t<res)\\n                   res=t;\\n               s=t;\\n            }\\n            return res;\\n        }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==1)\\n        {\\n            string res=s;\\n            for(int i=0;i<s.length();i++)\\n            {\\n               string t=\"\";\\n               t+=s[s.length()-1];\\n               s.pop_back();\\n               t+=s;\\n               if(t<res)\\n                   res=t;\\n               s=t;\\n            }\\n            return res;\\n        }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782906,
                "title": "c-simple-solution-efficient-string-handling-reduced-rotations",
                "content": "When k>1 we can just completely sort the string since we can effectively swap any two characters. \\xA0 By choosing other characters until both characters to be swapped are at the top.  Then we choose the second and then the first which will put them at the bottom but swapped in order. If you can swap any two characters, then you can sort. \\xA0Here is a sequence to swap two arbitrary characters in a string X and Y in the K=2 When i state \\'move abcd\\' it means move a then b then c then d from the front 2 to back\\n\\n1) move the characters abcd to the end to bring Y to the start.\\n2) move efg to bring X to second position.\\n3) move Y\\n4) move abcd\\n5) move X\\n6) move efgY\\n\\nabcdYefgX -> YefgXabcd -> YXabcdefg -> XabcdefgY -> XefgYabcd -> efgYabcdX -> abcdXefgY\\n\\nFor k==1, we ned to find the the lowest string we can get from rotation.  Rather than rotating though every combination, we can concentrate on strings that begin with the lowest char avalable in the string using min_element and find_if.  We should consider a string when the lowest character found is the same or less than the first character of the current string.\\n\\nWe can use string_view to avoid actually forming these strings to compare the current to the propsoed string.  If the new prefix is lower, it is a lower string, If it is the same, we need to compare the new proposed suffix to the beginning of the current string, since that will be the suffix of the new string.\\n\\nFor instance, consider:  `\"abcdefabc\"`\\nThe only character we need to consider is the second \\'a\\'.  However, the prefix will be `\"abc\"` for both the original string and proposed string.  But we can compare `\"defabc\"` to `\"abcdef\"` to see that we should choose the proposed string. ` \"abcdefabc\" > \"abcabcdef\"`\\n\\nWhen a new string is accepted as lower, we calculate a new value for en so that we don\\'t go past the end of the original string when comparing.\\n\\n    string orderlyQueue(string s, int k) {\\n        int N = s.size();\\n        if(k!=1) {\\n            sort(begin(s),end(s));\\n        } else\\n        {\\n            auto it = begin(s);\\n            auto en = end(s);\\n            auto it2 = min_element(it+1,en);            \\n            while(it2!=en && *it2<=*it)\\n            {\\n                int len = N- (it2 - begin(s));\\n                // &*it2 is a hack since the iterator version of the \\n                // C++20 string_view constructor is not supported on this platform\\n                string_view curprefix(&*it, len), cursuffix(&*(it+len),N-len),\\n                            newprefix(&*it2,len), newsuffix(&*it, N-len);\\n                //cout << curprefix << cursuffix << endl;\\n                //cout << newprefix << newsuffix << endl;\\n                if(tie(newprefix,newsuffix) < tie(curprefix,cursuffix))\\n                {\\n                    rotate(begin(s),it2,end(s));\\n                    it = begin(s);\\n                    it2 = it+1;\\n                    en = it+len;\\n                } else it2++;\\n                it2 = find_if(it2,en,[it](char a){return a<=*it;});\\n            } \\n        }\\n        return s;\\n    }\\n\\t\\nAs others have pointed out, there is an O(N) solution to solving the k==1 part of the problem.  It is called [Booth\\'s Algorithm](https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation).\\n\\nHere is an implementation if you want to try it.  It runs in O(N) time but requires O(N) space for the failure function results to be stored.\\n\\n            vector<int> f(N*2,-1);\\n            int k=0;\\n            for(int j=1;j<N*2;j++) {\\n                char sj = s[j%N];\\n                int i = f[j-k-1];\\n                while(i!=-1 && sj != s[(k+i+1)%N]) {\\n                    if(sj < s[(k+i+1)%N]) k = j-i-1;\\n                    i = f[i];\\n                }\\n                if(i==-1 && sj != s[(k+i+1)%N])\\n                {\\n                    if(sj < s[(k+i+1)%N]) k = j;\\n                    f[j-k] = -1;\\n                } else {\\n                    f[j-k] = i+1;\\n                }\\n            }\\n            rotate(begin(s),begin(s)+k,end(s));",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "When k>1 we can just completely sort the string since we can effectively swap any two characters. \\xA0 By choosing other characters until both characters to be swapped are at the top.  Then we choose the second and then the first which will put them at the bottom but swapped in order. If you can swap any two characters, then you can sort. \\xA0Here is a sequence to swap two arbitrary characters in a string X and Y in the K=2 When i state \\'move abcd\\' it means move a then b then c then d from the front 2 to back\\n\\n1) move the characters abcd to the end to bring Y to the start.\\n2) move efg to bring X to second position.\\n3) move Y\\n4) move abcd\\n5) move X\\n6) move efgY\\n\\nabcdYefgX -> YefgXabcd -> YXabcdefg -> XabcdefgY -> XefgYabcd -> efgYabcdX -> abcdXefgY\\n\\nFor k==1, we ned to find the the lowest string we can get from rotation.  Rather than rotating though every combination, we can concentrate on strings that begin with the lowest char avalable in the string using min_element and find_if.  We should consider a string when the lowest character found is the same or less than the first character of the current string.\\n\\nWe can use string_view to avoid actually forming these strings to compare the current to the propsoed string.  If the new prefix is lower, it is a lower string, If it is the same, we need to compare the new proposed suffix to the beginning of the current string, since that will be the suffix of the new string.\\n\\nFor instance, consider:  `\"abcdefabc\"`\\nThe only character we need to consider is the second \\'a\\'.  However, the prefix will be `\"abc\"` for both the original string and proposed string.  But we can compare `\"defabc\"` to `\"abcdef\"` to see that we should choose the proposed string. ` \"abcdefabc\" > \"abcabcdef\"`\\n\\nWhen a new string is accepted as lower, we calculate a new value for en so that we don\\'t go past the end of the original string when comparing.\\n\\n    string orderlyQueue(string s, int k) {\\n        int N = s.size();\\n        if(k!=1) {\\n            sort(begin(s),end(s));\\n        } else\\n        {\\n            auto it = begin(s);\\n            auto en = end(s);\\n            auto it2 = min_element(it+1,en);            \\n            while(it2!=en && *it2<=*it)\\n            {\\n                int len = N- (it2 - begin(s));\\n                // &*it2 is a hack since the iterator version of the \\n                // C++20 string_view constructor is not supported on this platform\\n                string_view curprefix(&*it, len), cursuffix(&*(it+len),N-len),\\n                            newprefix(&*it2,len), newsuffix(&*it, N-len);\\n                //cout << curprefix << cursuffix << endl;\\n                //cout << newprefix << newsuffix << endl;\\n                if(tie(newprefix,newsuffix) < tie(curprefix,cursuffix))\\n                {\\n                    rotate(begin(s),it2,end(s));\\n                    it = begin(s);\\n                    it2 = it+1;\\n                    en = it+len;\\n                } else it2++;\\n                it2 = find_if(it2,en,[it](char a){return a<=*it;});\\n            } \\n        }\\n        return s;\\n    }\\n\\t\\nAs others have pointed out, there is an O(N) solution to solving the k==1 part of the problem.  It is called [Booth\\'s Algorithm](https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation).\\n\\nHere is an implementation if you want to try it.  It runs in O(N) time but requires O(N) space for the failure function results to be stored.\\n\\n            vector<int> f(N*2,-1);\\n            int k=0;\\n            for(int j=1;j<N*2;j++) {\\n                char sj = s[j%N];\\n                int i = f[j-k-1];\\n                while(i!=-1 && sj != s[(k+i+1)%N]) {\\n                    if(sj < s[(k+i+1)%N]) k = j-i-1;\\n                    i = f[i];\\n                }\\n                if(i==-1 && sj != s[(k+i+1)%N])\\n                {\\n                    if(sj < s[(k+i+1)%N]) k = j;\\n                    f[j-k] = -1;\\n                } else {\\n                    f[j-k] = i+1;\\n                }\\n            }\\n            rotate(begin(s),begin(s)+k,end(s));",
                "codeTag": "C++"
            },
            {
                "id": 2782878,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  string orderlyQueue(string &s, const int k) {\\n    if (k > 1) {\\n      sort(s.begin(), s.end());\\n      return s;\\n    }\\n\\n    const int n = static_cast<int>(s.size());\\n    char min_letter = numeric_limits<char>::max();\\n    vector<int> min_letter_indices;\\n    for (int i = 0; i < n; ++i) {\\n      if (s[i] < min_letter) {\\n        min_letter = s[i];\\n        min_letter_indices.clear();\\n      }\\n      if (s[i] <= min_letter) {\\n        min_letter_indices.emplace_back(i);\\n      }\\n    }\\n\\n    string ret;\\n    for (const int separator_index : min_letter_indices) {\\n      const string candidate = s.substr(separator_index) + s.substr(0, separator_index);\\n      if (ret.empty() || candidate < ret) {\\n        ret = move(candidate);\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  string orderlyQueue(string &s, const int k) {\\n    if (k > 1) {\\n      sort(s.begin(), s.end());\\n      return s;\\n    }\\n\\n    const int n = static_cast<int>(s.size());\\n    char min_letter = numeric_limits<char>::max();\\n    vector<int> min_letter_indices;\\n    for (int i = 0; i < n; ++i) {\\n      if (s[i] < min_letter) {\\n        min_letter = s[i];\\n        min_letter_indices.clear();\\n      }\\n      if (s[i] <= min_letter) {\\n        min_letter_indices.emplace_back(i);\\n      }\\n    }\\n\\n    string ret;\\n    for (const int separator_index : min_letter_indices) {\\n      const string candidate = s.substr(separator_index) + s.substr(0, separator_index);\\n      if (ret.empty() || candidate < ret) {\\n        ret = move(candidate);\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782847,
                "title": "this-is-not-a-hard-problem-no-ds-or-algorithm-applied",
                "content": "# Intuition\\nI posted this so that you don\\'t waste time, as I did behind this problem using heapq or any fancy algorithm.\\n\\n# Approach\\nJust return sorted string if k > 1: yes, they should remove \"hard\" badge!\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            ans = s\\n            for _ in range(len(s)):\\n                s = s[1:] + s[0]\\n                ans = min(ans, s)\\n            return ans\\n        else:\\n            return \\'\\'.join(sorted(s))\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            ans = s\\n            for _ in range(len(s)):\\n                s = s[1:] + s[0]\\n                ans = min(ans, s)\\n            return ans\\n        else:\\n            return \\'\\'.join(sorted(s))\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782838,
                "title": "javascript-solution-easiest-o-n-2-time-o-n-space",
                "content": "```\\nconst orderlyQueue = function(s, k) {\\n    if(k > 1) return s.split(\"\").sort().join(\"\");\\n    let res = s;\\n    const n = s.length;\\n    \\n    for(let i = 0; i < n; i++) {\\n        s = s.slice(1) + s[0];\\n        res = res.localeCompare(s) < 0? res:s;\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nconst orderlyQueue = function(s, k) {\\n    if(k > 1) return s.split(\"\").sort().join(\"\");\\n    let res = s;\\n    const n = s.length;\\n    \\n    for(let i = 0; i < n; i++) {\\n        s = s.slice(1) + s[0];\\n        res = res.localeCompare(s) < 0? res:s;\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782831,
                "title": "c-simple-solution",
                "content": "It can be observed that for k > 1, we can always sort s such that it\\'s the lexographically smallest string. All that\\'s left to do is to consider k == 1 where we just rotate string and find the smallest one. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string best = s;\\n            for (int i = 0; i < s.size(); i++) {\\n                s = s.substr(1, s.size() - 1) + s[0];\\n                best = min(s, best);\\n            }\\n            return best;\\n        }\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string best = s;\\n            for (int i = 0; i < s.size(); i++) {\\n                s = s.substr(1, s.size() - 1) + s[0];\\n                best = min(s, best);\\n            }\\n            return best;\\n        }\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782819,
                "title": "o-nlogn-with-buble-sorting-style-examples",
                "content": "**Main Idea**:\\n+ k=1: there is only a rotation:\\n  [1] rotate the whole string:\\n```\\n1|2345 -> 2345|1  -> 345|12 -> 45|123 -> 5|1234\\n```\\n+ k>1: there are two string rotations:\\n   [1] rotate the whole string\\n   [2] rotate the whole string except the first letter\\n\\nWe can move the next min value a[k] to first place and keep the minimum interval (a[0], a[1], ..., a[k-1]) using the rotation [1]\\n```\\n......a[k].....(a[0],a[1],...,a[k-1]) -> rotation [1] -> a[k]....(a[0],a[1],...,a[k-1])...\\n```\\nAfter that, we can apply the roration [2] to move the minimum interval (a[0], a[1], ..., a[k-1]) to last place.\\n```\\na[k]....(a[0],a[1],...,a[k-1])... -> rotation [2] -> a[k]....(a[0],a[1],...,a[k-1])\\n```\\nFinally, we move a[k] to last place.\\n```\\na[k]....(a[0],a[1],...,a[k-1]) -> rotation [1] -> ....(a[0],a[1],...,a[k-1], a[k])\\n```\\nFrom there, we receive a sorted string from the original string using bubble sort technique as above explaination.\\n\\n**Examples**:\\n```\\nExample 1: s=\"361524\", k=1\\nans = 152436\\n\\nExample 2: s=\"361524\", k>1\\n[1]52436\\n52436<1>\\n\\n[2]436<1>5\\n[2]5436<1>\\n5436<12>\\n\\n[3]6<12>54\\n[3]546<12>\\n546<123>\\n\\n[4]6<123>5\\n[4]56<123>\\n56<1234>\\n\\n[5]6<1234>\\n6<12345>\\n\\n[6]<12345>\\n<123456>\\nans = \"123456\"\\n```\\n\\n**Code**:\\n+ C++\\n```C++\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s;\\n        if(k>1)\\n            std::sort(ans.begin(), ans.end());\\n        else {\\n            for(int i=0; i<s.size(); i++){\\n                ans = min(ans, s.substr(i) + s.substr(0, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n+ Python:\\n```python\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            ans = \"\".join(sorted(s))\\n        else:\\n            ans = s\\n            for i in range(1, len(s)):\\n                ans = min(ans, s[i:] + s[:i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n1|2345 -> 2345|1  -> 345|12 -> 45|123 -> 5|1234\\n```\n```\\n......a[k].....(a[0],a[1],...,a[k-1]) -> rotation [1] -> a[k]....(a[0],a[1],...,a[k-1])...\\n```\n```\\na[k]....(a[0],a[1],...,a[k-1])... -> rotation [2] -> a[k]....(a[0],a[1],...,a[k-1])\\n```\n```\\na[k]....(a[0],a[1],...,a[k-1]) -> rotation [1] -> ....(a[0],a[1],...,a[k-1], a[k])\\n```\n```\\nExample 1: s=\"361524\", k=1\\nans = 152436\\n\\nExample 2: s=\"361524\", k>1\\n[1]52436\\n52436<1>\\n\\n[2]436<1>5\\n[2]5436<1>\\n5436<12>\\n\\n[3]6<12>54\\n[3]546<12>\\n546<123>\\n\\n[4]6<123>5\\n[4]56<123>\\n56<1234>\\n\\n[5]6<1234>\\n6<12345>\\n\\n[6]<12345>\\n<123456>\\nans = \"123456\"\\n```\n```C++\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s;\\n        if(k>1)\\n            std::sort(ans.begin(), ans.end());\\n        else {\\n            for(int i=0; i<s.size(); i++){\\n                ans = min(ans, s.substr(i) + s.substr(0, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            ans = \"\".join(sorted(s))\\n        else:\\n            ans = s\\n            for i in range(1, len(s)):\\n                ans = min(ans, s[i:] + s[:i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782799,
                "title": "java-solution-faster-than-100-of-java-submissions",
                "content": "```\\nclass Solution {\\n    private static String sortString (String s){\\n        char tempArray[] = s.toCharArray();\\n        Arrays.sort(tempArray);\\n        return new String(tempArray);\\n    }\\n    \\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            return this.sortString(s);\\n        } \\n        \\n        String minString = s;\\n        String sTwoTimes = s + s;\\n        int len = s.length();\\n        for (int index = 1; index < len; index++){\\n            String temp = sTwoTimes.substring(index, index + len);\\n            if (temp.compareTo(minString) < 0)\\n                minString = temp;\\n        }\\n        return minString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    private static String sortString (String s){\\n        char tempArray[] = s.toCharArray();\\n        Arrays.sort(tempArray);\\n        return new String(tempArray);\\n    }\\n    \\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            return this.sortString(s);\\n        } \\n        \\n        String minString = s;\\n        String sTwoTimes = s + s;\\n        int len = s.length();\\n        for (int index = 1; index < len; index++){\\n            String temp = sTwoTimes.substring(index, index + len);\\n            if (temp.compareTo(minString) < 0)\\n                minString = temp;\\n        }\\n        return minString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782788,
                "title": "c-tc-o-nlogn-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.size();\\n       if(k>1){\\n            string ns;\\n            ns=s;\\n            sort(ns.begin(),ns.end());\\n\\n            return ns;\\n       }\\n        \\n        string ns=s+s;\\n        string temp=s;\\n        for(int i=0;i<n;i++){\\n            string ss=ns.substr(i,n);\\n            if(ss<temp){\\n                temp=ss;\\n            }\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.size();\\n       if(k>1){\\n            string ns;\\n            ns=s;\\n            sort(ns.begin(),ns.end());\\n\\n            return ns;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2768559,
                "title": "readable-and-fast-scala-single-if-else",
                "content": "```\\n  def orderlyQueue(s: String, k: Int): String = {\\n    if (k == 1) \\n\\t\\t// from all the possible rotations, getting the lexicographical minimum\\n\\t\\t//Example: s+s = cbacba\\n\\t\\t//Sliding collection:\\n\\t\\t//#1 cba\\n\\t\\t//#2 bac \\n\\t\\t//#3 acb //Smallest sliding window string, min will return this\\n\\t\\t//#4 cba //.drop(1) if you wanna save some computation\\n\\t\\t(s + s).sliding(s.length).min \\n\\telse \\n\\t\\ts.sorted\\n  }",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def orderlyQueue(s: String, k: Int): String = {\\n    if (k == 1) \\n\\t\\t// from all the possible rotations, getting the lexicographical minimum\\n\\t\\t//Example: s+s = cbacba\\n\\t\\t//Sliding collection:\\n\\t\\t//#1 cba\\n\\t\\t//#2 bac \\n\\t\\t//#3 acb //Smallest sliding window string, min will return this\\n\\t\\t//#4 cba //.drop(1) if you wanna save some computation\\n\\t\\t(s + s).sliding(s.length).min \\n\\telse \\n\\t\\ts.sorted\\n  }",
                "codeTag": "Python3"
            },
            {
                "id": 2603624,
                "title": "c-using-substr-90-faster-than-all",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        else{\\n            int len = s.size();\\n            s = s + s;\\n            int index = 0;\\n            for(int i=0; i<len; i++){\\n                if(s.substr(index, len) > s.substr(i, len)) index = i;\\n            }\\n            return s.substr(index, len);\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(s.begin(), s.end());\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2596218,
                "title": "python3-sorting-queue-approach-explained-with-example",
                "content": "When k >=2 , then we have the option to stock the smallest character in frontand send the largest character to the end continuosly.\\nThis alows us to create a sorted string after certain number of operations\\nEg: \\n```\\n(az)zzaza and k=2\\n(az)zaza|z\\n(az)aza|zz\\n(aa)za|zzz\\n```\\n\\nWhen k=1, we got option to either send the top of q to the back or stop and no option to stock lexicographically smaller character.\\nHence we need to do brute force and find the smallest character\\n\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        \\n        #is new str smaller than old\\n        def compare(a,b):\\n            for i in range(len(a)):\\n                if a[i]<b[i]:\\n                    return True\\n                elif a[i]>b[i]:\\n                    return False\\n            return False\\n        \\n        if k == 1:\\n            smallest = s\\n            s = deque(s)\\n            \\n            for _ in range(len(s)-1):\\n                s.append(s.popleft())\\n                \\n                if compare(s,smallest):\\n                    smallest = \\'\\'.join(s)\\n                \\n            return smallest\\n        \\n        else:\\n            return \"\".join(sorted(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n(az)zzaza and k=2\\n(az)zaza|z\\n(az)aza|zz\\n(aa)za|zzz\\n```\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        \\n        #is new str smaller than old\\n        def compare(a,b):\\n            for i in range(len(a)):\\n                if a[i]<b[i]:\\n                    return True\\n                elif a[i]>b[i]:\\n                    return False\\n            return False\\n        \\n        if k == 1:\\n            smallest = s\\n            s = deque(s)\\n            \\n            for _ in range(len(s)-1):\\n                s.append(s.popleft())\\n                \\n                if compare(s,smallest):\\n                    smallest = \\'\\'.join(s)\\n                \\n            return smallest\\n        \\n        else:\\n            return \"\".join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485077,
                "title": "hard-question-with-easy-approach-c-intuition-explained",
                "content": "```\\n  string orderlyQueue(string s, int k) {\\n        \\n        int n=s.size();\\n        \\n        //for k=1 hume har case check krna pdega har kisi ko piche dalke dekho kaunsi sbse choti string bnri\\n        if(k==1)  \\n        {\\n            string ans=\"zzzzzzzzzzzzzzzz\";\\n            for(int idx=0;idx<n;idx++)\\n            {\\n                int i=(idx+1)%n;\\n                string str=\"\";\\n                \\n                while(i!=idx)\\n                {\\n                    str+=s[i];\\n                    i=(i+1)%n;\\n                }\\n                str+=s[i];\\n                ans=min(ans,str);               \\n            }\\n            return ans;\\n        }\\n        \\n//agar ek se zda hai k to hmesha sorted string hi answer hoga INSERTION sort me hum kya krte the 2 adjacent cahracter ko swap krte the . yaha hum 2 adjacent char swap kr skte through some n moves so it is possible to do so.\\n        \\n        sort(s.begin(),s.end());\\n        return s;        \\n    }",
                "solutionTags": [],
                "code": "```\\n  string orderlyQueue(string s, int k) {\\n        \\n        int n=s.size();\\n        \\n        //for k=1 hume har case check krna pdega har kisi ko piche dalke dekho kaunsi sbse choti string bnri\\n        if(k==1)  \\n        {\\n            string ans=\"zzzzzzzzzzzzzzzz\";\\n            for(int idx=0;idx<n;idx++)\\n            {\\n                int i=(idx+1)%n;\\n                string str=\"\";\\n                \\n                while(i!=idx)\\n                {\\n                    str+=s[i];\\n                    i=(i+1)%n;\\n                }\\n                str+=s[i];\\n                ans=min(ans,str);               \\n            }\\n            return ans;\\n        }\\n        \\n//agar ek se zda hai k to hmesha sorted string hi answer hoga INSERTION sort me hum kya krte the 2 adjacent cahracter ko swap krte the . yaha hum 2 adjacent char swap kr skte through some n moves so it is possible to do so.\\n        \\n        sort(s.begin(),s.end());\\n        return s;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2224276,
                "title": "orderly-queue-string-builder-trick-o-nlogn",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){ //for k>1, the result string will always be sorted, it works like adjacent swapping in insertion sort\\n            char []ch=s.toCharArray();\\n            Arrays.sort(ch);\\n            String snew=new String(ch);\\n            return snew;\\n        }\\n        \\n        String ans=s;\\n        StringBuilder sb=new StringBuilder(s);\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch=sb.charAt(0);\\n            sb.deleteCharAt(0);\\n            sb.append(ch);\\n            String snew=sb.toString();\\n            \\n            if(ans.compareTo(snew)>0){\\n                ans=snew;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){ //for k>1, the result string will always be sorted, it works like adjacent swapping in insertion sort\\n            char []ch=s.toCharArray();\\n            Arrays.sort(ch);\\n            String snew=new String(ch);\\n            return snew;\\n        }\\n        \\n        String ans=s;\\n        StringBuilder sb=new StringBuilder(s);\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch=sb.charAt(0);\\n            sb.deleteCharAt(0);\\n            sb.append(ch);\\n            String snew=sb.toString();\\n            \\n            if(ans.compareTo(snew)>0){\\n                ans=snew;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446934,
                "title": "php-solution",
                "content": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String  $s\\n     * @param Integer $k\\n     *\\n     * @return String\\n     */\\n    function orderlyQueue($s, $k)\\n    {\\n        if ($k > 1) {\\n            $s = str_split($s);\\n            sort($s);\\n\\n            return join($s);\\n        }\\n        \\n        $strlen = strlen($s);\\n        for ($min = $s[0], $i = 1; $i < $strlen; $i++) {\\n            $min = min($min, $s[$i]);\\n        }\\n\\n        for ($curLen = 0, $i = $strlen - 1; $i >= 0 && $min === $s[$i]; $i--, $curLen++) {\\n        }\\n\\n        if ($curLen === $strlen) {\\n            return $s;\\n        }\\n        if ($curLen) {\\n            for ($i = 0; $min === $s[$i]; $i++, $curLen++) {\\n            }\\n            $ans = str_repeat($min, $curLen).substr($s, $i, $strlen - $curLen);\\n            $maxLen = $curLen;\\n        } else {\\n            $ans = $s;\\n            $maxLen = 0;\\n        }\\n\\n        for ($curLen = $i = 0; $i < $strlen; $i++) {\\n            if ($min === $s[$i]) {\\n                $curLen++;\\n            } else {\\n                if ($curLen > $maxLen) {\\n                    $maxLen = $curLen;\\n                    $ans = str_repeat($min, $curLen).substr($s, $i).substr($s, 0, $i - $curLen);\\n                } elseif ($curLen === $maxLen) {\\n                    $ans = min($ans, str_repeat($min, $curLen).substr($s, $i).substr($s, 0, $i - $curLen));\\n                }\\n\\n                $curLen = 0;\\n            }\\n        }\\n\\n        return $ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String  $s\\n     * @param Integer $k\\n     *\\n     * @return String\\n     */\\n    function orderlyQueue($s, $k)\\n    {\\n        if ($k > 1) {\\n            $s = str_split($s);\\n            sort($s);\\n\\n            return join($s);\\n        }\\n        \\n        $strlen = strlen($s);\\n        for ($min = $s[0], $i = 1; $i < $strlen; $i++) {\\n            $min = min($min, $s[$i]);\\n        }\\n\\n        for ($curLen = 0, $i = $strlen - 1; $i >= 0 && $min === $s[$i]; $i--, $curLen++) {\\n        }\\n\\n        if ($curLen === $strlen) {\\n            return $s;\\n        }\\n        if ($curLen) {\\n            for ($i = 0; $min === $s[$i]; $i++, $curLen++) {\\n            }\\n            $ans = str_repeat($min, $curLen).substr($s, $i, $strlen - $curLen);\\n            $maxLen = $curLen;\\n        } else {\\n            $ans = $s;\\n            $maxLen = 0;\\n        }\\n\\n        for ($curLen = $i = 0; $i < $strlen; $i++) {\\n            if ($min === $s[$i]) {\\n                $curLen++;\\n            } else {\\n                if ($curLen > $maxLen) {\\n                    $maxLen = $curLen;\\n                    $ans = str_repeat($min, $curLen).substr($s, $i).substr($s, 0, $i - $curLen);\\n                } elseif ($curLen === $maxLen) {\\n                    $ans = min($ans, str_repeat($min, $curLen).substr($s, $i).substr($s, 0, $i - $curLen));\\n                }\\n\\n                $curLen = 0;\\n            }\\n        }\\n\\n        return $ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446796,
                "title": "go-solution-beats-100",
                "content": "```\\nfunc orderlyQueue(s string, k int) string {\\n\\tb := []byte(s)\\n\\tif k == 1 {\\n\\t\\tmin := []byte(s)\\n\\t\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\t\\tb = append(b[1:], b[0])\\n\\t\\t\\tif bytes.Compare(b, min) < 0 {\\n\\t\\t\\t\\tcopy(min, b)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(min)\\n\\t} else {\\n\\t\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\t\\treturn b[i] < b[j]\\n\\t\\t})\\n\\t\\treturn string(b)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc orderlyQueue(s string, k int) string {\\n\\tb := []byte(s)\\n\\tif k == 1 {\\n\\t\\tmin := []byte(s)\\n\\t\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\t\\tb = append(b[1:], b[0])\\n\\t\\t\\tif bytes.Compare(b, min) < 0 {\\n\\t\\t\\t\\tcopy(min, b)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(min)\\n\\t} else {\\n\\t\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\t\\treturn b[i] < b[j]\\n\\t\\t})\\n\\t\\treturn string(b)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446763,
                "title": "c-sort-when-k-1-or-using-suffix-array-to-find-smallest-cyclic-shift-k-1",
                "content": "Suffix Array based smallest cyclic shift taken from https://cp-algorithms.com/string/suffix-array.html#toc-tgt-5\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k >= 2) {\\n            std::sort(s.begin(), s.end());\\n            return s;\\n        }\\n        const int idx = sort_cyclic_shifts(s).front();\\n        return s.substr(idx) + s.substr(0, idx);\\n    }\\nprivate:\\n    std::vector<int> sort_cyclic_shifts(std::string const& s) {\\n        const int n = s.size();\\n        constexpr int ALPHABET = 256;\\n        \\n        vector<int> p(n), c(n), cnt(max(ALPHABET, n), 0);\\n        for (int i = 0; i < n; ++i) {\\n            cnt[s[i]]++;\\n        }\\n        for (int i = 1; i < ALPHABET; ++i) {\\n            cnt[i] += cnt[i-1];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            p[--cnt[s[i]]] = i;\\n        }\\n        \\n        c[p[0]] = 0;\\n        int classes = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (s[p[i]] != s[p[i-1]]) {\\n                classes++;\\n            }\\n            c[p[i]] = classes - 1;\\n        }\\n        \\n        std::vector<int> pn(n), cn(n);\\n        for (int h = 0; (1 << h) < n; ++h) {\\n            for (int i = 0; i < n; i++) {\\n                pn[i] = p[i] - (1 << h);\\n                if (pn[i] < 0)\\n                    pn[i] += n;\\n            }\\n            std::fill(cnt.begin(), cnt.begin() + classes, 0);\\n            for (int i = 0; i < n; i++) {\\n                cnt[c[pn[i]]]++;\\n            }\\n            for (int i = 1; i < classes; i++) {\\n                cnt[i] += cnt[i-1];\\n            }\\n            for (int i = n-1; i >= 0; i--) {\\n                p[--cnt[c[pn[i]]]] = pn[i];\\n            }\\n            cn[p[0]] = 0;\\n            classes = 1;\\n            for (int i = 1; i < n; i++) {\\n                std::pair<int, int> curr = {\\n                    c[p[i]], c[(p[i] + (1 << h)) % n]\\n                };\\n                std::pair<int, int> prev = {\\n                    c[p[i-1]], c[(p[i-1] + (1 << h)) % n]\\n                };\\n                if (curr != prev) {\\n                    ++classes;\\n                }\\n                cn[p[i]] = classes - 1;\\n            }\\n            c.swap(cn);\\n        }\\n        return p;        \\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k >= 2) {\\n            std::sort(s.begin(), s.end());\\n            return s;\\n        }\\n        const int idx = sort_cyclic_shifts(s).front();\\n        return s.substr(idx) + s.substr(0, idx);\\n    }\\nprivate:\\n    std::vector<int> sort_cyclic_shifts(std::string const& s) {\\n        const int n = s.size();\\n        constexpr int ALPHABET = 256;\\n        \\n        vector<int> p(n), c(n), cnt(max(ALPHABET, n), 0);\\n        for (int i = 0; i < n; ++i) {\\n            cnt[s[i]]++;\\n        }\\n        for (int i = 1; i < ALPHABET; ++i) {\\n            cnt[i] += cnt[i-1];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            p[--cnt[s[i]]] = i;\\n        }\\n        \\n        c[p[0]] = 0;\\n        int classes = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (s[p[i]] != s[p[i-1]]) {\\n                classes++;\\n            }\\n            c[p[i]] = classes - 1;\\n        }\\n        \\n        std::vector<int> pn(n), cn(n);\\n        for (int h = 0; (1 << h) < n; ++h) {\\n            for (int i = 0; i < n; i++) {\\n                pn[i] = p[i] - (1 << h);\\n                if (pn[i] < 0)\\n                    pn[i] += n;\\n            }\\n            std::fill(cnt.begin(), cnt.begin() + classes, 0);\\n            for (int i = 0; i < n; i++) {\\n                cnt[c[pn[i]]]++;\\n            }\\n            for (int i = 1; i < classes; i++) {\\n                cnt[i] += cnt[i-1];\\n            }\\n            for (int i = n-1; i >= 0; i--) {\\n                p[--cnt[c[pn[i]]]] = pn[i];\\n            }\\n            cn[p[0]] = 0;\\n            classes = 1;\\n            for (int i = 1; i < n; i++) {\\n                std::pair<int, int> curr = {\\n                    c[p[i]], c[(p[i] + (1 << h)) % n]\\n                };\\n                std::pair<int, int> prev = {\\n                    c[p[i-1]], c[(p[i-1] + (1 << h)) % n]\\n                };\\n                if (curr != prev) {\\n                    ++classes;\\n                }\\n                cn[p[i]] = classes - 1;\\n            }\\n            c.swap(cn);\\n        }\\n        return p;        \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446576,
                "title": "c-orderly-queue-simple-solution-with-explanation-for-k-1",
                "content": "We can divide the question in two parts - one when `k = 1` and second otherwise ( `k>1`).\\nFor the second case, we can prove that after some number of moves, the string can always be sorted. \\n\\n**1. K > 1**\\nWe can sort the string by following a greedy approach: \\nTake the minimum character in Si to Si+k. Then in the next move, we perform the comparison with larger character of first step with the next character. In this step either the character from first step will be larger and stay here or will go to the end of string. \\n\\nWe can think of this like bubble sort. Instead of swapping two elements, we are moving the element to the end if it is smaller. \\n\\nLet\\'s take an example to show this is true:\\nLet `S = kghda`\\n```\\nkhdag -> kdagh -> kaghd -> aghdk\\naghdk -> ghdka -> hdkag -> hkagd -> kagdh ->kgdha -> gdhak -> ghakd ->hakdg -> akdgh\\nakdgh -> kdgha -> kghad -> khadg -> kadgh -> adghk\\nadghk    // In the last step we move largest element to the end\\n```\\n\\n**2. K=1**\\nWhen K=1, we need to find the smallest lexographic suffix. We can the append the prefix at the end of the suffix. \\nThe minimum of all such strings will be the answer. \\n\\n\\nFor eg,  Let `S = \"cbabaab\"`\\nWe can find the minimum lexographic character and find all suffix starting with it, then the smallest string formed by appending the suffix and prefix will be the answer. \\nHere, `S1 = abaabcb` and `S2 = aabcbab`, out of these S2 is smaller. So we return it. \\n\\n```c++\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k==1){\\n                auto minchar = min_element(s.begin(), s.end());\\n                string ans = s;\\n                for (int i=0; i<s.size(); i++){\\n                    if (s[i]==*minchar){\\n                        auto suffix = string(s.begin()+i, s.end());\\n                        auto temp = suffix + string(s.begin(), s.begin()+i);\\n                        ans = min(temp, ans);\\n                    }\\n                }\\n\\n                return ans;\\n        }\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nkhdag -> kdagh -> kaghd -> aghdk\\naghdk -> ghdka -> hdkag -> hkagd -> kagdh ->kgdha -> gdhak -> ghakd ->hakdg -> akdgh\\nakdgh -> kdgha -> kghad -> khadg -> kadgh -> adghk\\nadghk    // In the last step we move largest element to the end\\n```\n```c++\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k==1){\\n                auto minchar = min_element(s.begin(), s.end());\\n                string ans = s;\\n                for (int i=0; i<s.size(); i++){\\n                    if (s[i]==*minchar){\\n                        auto suffix = string(s.begin()+i, s.end());\\n                        auto temp = suffix + string(s.begin(), s.begin()+i);\\n                        ans = min(temp, ans);\\n                    }\\n                }\\n\\n                return ans;\\n        }\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446452,
                "title": "rust-o-n-0ms-suffix-array-solution",
                "content": "I googled a suffix array crate and copied and pasted.\\n\\nmy idea is that if the string is:\\ns = part1-part2,\\nwe can join the string to itself to get\\npart1-part2-part1-part2\\nand lets say the solution is part2-part1-part2. (we don\\'t know what the parts are yet).\\nMy intuition is that if we find the smallest suffix that starts in the first half of this combined string, then that suffix must be part2-part1-part2, so the solution is part2-part1.\\n```\\nimpl Solution {\\n    // @robertkingnz\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        if k >= 2 {\\n            let mut v: Vec<char> = s.chars().collect();\\n            v.sort();\\n            return v.iter().map(|x| *x).collect();\\n        }\\n        let sa = SuffixTable::new(format!(\"{}{}\",s,s)); // O(N)\\n        let t = sa.table(); \\n\\t\\t// table[i] gives the suffix in order, like in https://en.wikipedia.org/wiki/Suffix_array so we just want the first suffix we find that\\'s in the first half.\\n        for j in 0..t.len() {\\n            let i = t[j] as usize;\\n            if i < s.len() {\\n                let mut it = sa.suffix(j).chars();\\n                return (0..s.len()).map(|_| it.next().unwrap()).collect();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    // @robertkingnz\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        if k >= 2 {\\n            let mut v: Vec<char> = s.chars().collect();\\n            v.sort();\\n            return v.iter().map(|x| *x).collect();\\n        }\\n        let sa = SuffixTable::new(format!(\"{}{}\",s,s)); // O(N)\\n        let t = sa.table(); \\n\\t\\t// table[i] gives the suffix in order, like in https://en.wikipedia.org/wiki/Suffix_array so we just want the first suffix we find that\\'s in the first half.\\n        for j in 0..t.len() {\\n            let i = t[j] as usize;\\n            if i < s.len() {\\n                let mut it = sa.suffix(j).chars();\\n                return (0..s.len()).map(|_| it.next().unwrap()).collect();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446287,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        if k == 1 {\\n            let ss = s.chars().chain(s.chars()).collect::<Vec<_>>();\\n            let mut v = ss.windows(s.len()).collect::<Vec<_>>();\\n            v.sort();\\n            v[0].iter().copied().collect()\\n        } else {\\n            let mut v = s.chars().collect::<Vec<_>>();\\n            v.sort();\\n            v.iter().collect()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        if k == 1 {\\n            let ss = s.chars().chain(s.chars()).collect::<Vec<_>>();\\n            let mut v = ss.windows(s.len()).collect::<Vec<_>>();\\n            v.sort();\\n            v[0].iter().copied().collect()\\n        } else {\\n            let mut v = s.chars().collect::<Vec<_>>();\\n            v.sort();\\n            v.iter().collect()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446225,
                "title": "kotlin-clean-short-solution",
                "content": "```\\nclass Solution {\\n    fun orderlyQueue(s: String, k: Int): String {\\n        return when {\\n            k > 1 -> String(s.toCharArray().apply { sort() })\\n            else -> {\\n                val ss = s + s\\n                var res = ss.substring(0, s.length)\\n                for (start in 1 until s.length) {\\n                    res = minOf(res, ss.substring(start, start + s.length))\\n                }\\n                res\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun orderlyQueue(s: String, k: Int): String {\\n        return when {\\n            k > 1 -> String(s.toCharArray().apply { sort() })\\n            else -> {\\n                val ss = s + s\\n                var res = ss.substring(0, s.length)\\n                for (start in 1 until s.length) {\\n                    res = minOf(res, ss.substring(start, start + s.length))\\n                }\\n                res\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446133,
                "title": "kotlin-easy-solution",
                "content": "```\\nclass Solution {\\n    fun orderlyQueue(s: String, k: Int): String {\\n        var arr=s.toCharArray()\\n        if(k!=1){\\n            arr.sort()\\n            return String(arr)\\n        }\\n         var temp=s\\n        for(i in 1.. s.length){\\n        val curr=s.substring(i)+s.substring(0,i)\\n        \\n        if(temp.compareTo(curr)>0){\\n            temp=curr\\n        }\\n    }\\n        \\n        return temp\\n    }\\n}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    fun orderlyQueue(s: String, k: Int): String {\\n        var arr=s.toCharArray()\\n        if(k!=1){\\n            arr.sort()\\n            return String(arr)\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1446122,
                "title": "c-simple-solution-explanation",
                "content": "**Idea:**  \\n**For K>1 :** If we try with few numbers of strings we can easily see for K>1 we can always get the sorted substring as anwer.(lexicographically smallest substring).\\n**For K==1 :** We can not get the smallest possible substring as the relative position of character matter and we can not change that(1st test case:In case of \"cba\" it is not possible to get \"bc\" as substring by any number of operations).\\n\\n**Solution:**\\n**For K>1 :** Simply sort the string.\\n**For K==1 :** We know for sure the we can always get smallest character at the front then( s[smallest....]+s[....smallest] will be answer), but if we have more than occurance of smallest character then we need to check for all possible string which will start with smallest charcter.\\n\\n**Code :**\\n```\\nstring orderlyQueue(string s, int k)\\n    {\\n        if (k > 1)\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        else\\n        {\\n            string ans = s;\\n            // Get the smallest character\\n            char ch = *min_element(s.begin(), s.end());\\n            for (int i = 0; i < s.size(); i++)\\n            {\\n                // Checking for each possible string which can start with current smallest element\\n                if (s[i] == ch)\\n                {\\n                    string st = s.substr(i);\\n                    string en = s.substr(0, i);\\n                    if (st + en < ans)\\n                        ans = st + en;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n    }\\n\\t",
                "solutionTags": [],
                "code": "**Idea:**  \\n**For K>1 :** If we try with few numbers of strings we can easily see for K>1 we can always get the sorted substring as anwer.(lexicographically smallest substring).\\n**For K==1 :** We can not get the smallest possible substring as the relative position of character matter and we can not change that(1st test case:In case of \"cba\" it is not possible to get \"bc\" as substring by any number of operations).\\n\\n**Solution:**\\n**For K>1 :** Simply sort the string.\\n**For K==1 :** We know for sure the we can always get smallest character at the front then( s[smallest....]+s[....smallest] will be answer), but if we have more than occurance of smallest character then we need to check for all possible string which will start with smallest charcter.\\n\\n**Code :**\\n```\\nstring orderlyQueue(string s, int k)\\n    {\\n        if (k > 1)\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        else\\n        {\\n            string ans = s;\\n            // Get the smallest character\\n            char ch = *min_element(s.begin(), s.end());\\n            for (int i = 0; i < s.size(); i++)\\n            {\\n                // Checking for each possible string which can start with current smallest element\\n                if (s[i] == ch)\\n                {\\n                    string st = s.substr(i);\\n                    string en = s.substr(0, i);\\n                    if (st + en < ans)\\n                        ans = st + en;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1446052,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return min(s[i:]+s[:i] for i in range(len(s))) if k==1 else \\'\\'.join(sorted(s))\\n```",
                "solutionTags": [
                    "Math",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return min(s[i:]+s[:i] for i in range(len(s))) if k==1 else \\'\\'.join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446018,
                "title": "my-java-solution-using-concept-of-whether-k-1-or-k-1",
                "content": "If K == 1, then rotate until we get the best result\\nelse, just sort the string and return the result\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (s == null || s.length() == 0) {\\n            return \"\";\\n        }\\n        int length = s.length();\\n        if (k == 1) {\\n            String answer = s;\\n            for (int i=0; i<length; i++) {\\n                String rotatedOneCharacter = s.substring(i) + s.substring(0, i);\\n                if (rotatedOneCharacter.compareTo(answer) < 0) {\\n                    answer = rotatedOneCharacter;\\n                }\\n            }\\n            return answer;\\n        }\\n        else {\\n            char [] convertedToArray = s.toCharArray();\\n            Arrays.sort(convertedToArray);\\n            return new String(convertedToArray);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (s == null || s.length() == 0) {\\n            return \"\";\\n        }\\n        int length = s.length();\\n        if (k == 1) {\\n            String answer = s;\\n            for (int i=0; i<length; i++) {\\n                String rotatedOneCharacter = s.substring(i) + s.substring(0, i);\\n                if (rotatedOneCharacter.compareTo(answer) < 0) {\\n                    answer = rotatedOneCharacter;\\n                }\\n            }\\n            return answer;\\n        }\\n        else {\\n            char [] convertedToArray = s.toCharArray();\\n            Arrays.sort(convertedToArray);\\n            return new String(convertedToArray);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445958,
                "title": "java-easy-1-ms",
                "content": "The Simple idea is that if k = 1, then you can only rotate the string. But when k > 1, You can create any permutation of the string. So you can just sort the string.\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1) {\\n            StringBuilder sb = new StringBuilder(s), ans = new StringBuilder(sb);\\n            for(int i = 0; i < s.length(); i++) {\\n                char ch = sb.charAt(0);\\n                sb = sb.deleteCharAt(0);\\n                sb.append(ch);\\n                if(ans.compareTo(sb) > 1)\\n                    ans = new StringBuilder(sb);\\n            }\\n            return new String(ans);\\n        }\\n        else {\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            return new String(arr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1) {\\n            StringBuilder sb = new StringBuilder(s), ans = new StringBuilder(sb);\\n            for(int i = 0; i < s.length(); i++) {\\n                char ch = sb.charAt(0);\\n                sb = sb.deleteCharAt(0);\\n                sb.append(ch);\\n                if(ans.compareTo(sb) > 1)\\n                    ans = new StringBuilder(sb);\\n            }\\n            return new String(ans);\\n        }\\n        else {\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            return new String(arr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445919,
                "title": "a-little-better-version-of-the-o-n-2-approach-100-time-and-space",
                "content": "**In case of K>=2** the answer is obvious , Sort the String . \\n**In case of K=1;**\\n* if (k == 1) {\\n\\xA0\\xA0String ans = s;\\n           \\xA0\\xA0 for (int i = 0; i < s.length(); ++i) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0 String temp = s.substring(i) + s.substring(0, i);\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (temp.compareTo(ans) < 0) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0\\xA0  ans = temp;\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n**i did this**\\n**better solution is** \\n* if (k == 1) {\\n           \\xA0\\xA0 **String ans = s;\\n           \\xA0\\xA0 char ch=s.charAt(0);\\n           \\xA0\\xA0 for (int i = 1; i < s.length(); ++i) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0if(s.charAt(i)<ch){\\n                   \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0ch=s.charAt(i);\\n              \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n           \\xA0\\xA0\\xA0 }\\n           \\xA0\\xA0\\xA0\\xA0ArrayList<Integer> al=new ArrayList<>();\\n           \\xA0\\xA0\\xA0\\xA0for(int i=0;i<s.length();i++){\\n           \\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 if(s.charAt(i)==ch){\\n           \\xA0\\xA0\\xA0\\xA0        \\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0al.add(i);\\n           \\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 }\\n           \\xA0\\xA0\\xA0\\xA0}**\\n           \\xA0\\xA0\\xA0 **for (int i :al) {**\\n               \\xA0\\xA0\\xA0\\xA0\\xA0String temp = s.substring(i) + s.substring(0, i);\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0if (temp.compareTo(ans) < 0) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 ans = temp;\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n           \\xA0\\xA0\\xA0 }\\n            return ans;\\n        }\\n\\t\\t\\nInstead of seaching through all elements , we know for lexicographically smallest we need the smallest character, at the front of our new String.\\n\\t\\tso just find all occurences of the smallest character and compare (each one assumed as front). \\n\\t\\t**Eg:      \"bbcdaac\"**\\n\\t\\twe know that the  answer will only include **a** in the front  ---  **aacbbcd     or    acbbcda** are the only 2 possiblity for the best answer.   So we just compare them.\\n\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "**In case of K>=2** the answer is obvious , Sort the String . \\n**In case of K=1;**\\n* if (k == 1) {\\n\\xA0\\xA0String ans = s;\\n           \\xA0\\xA0 for (int i = 0; i < s.length(); ++i) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0 String temp = s.substring(i) + s.substring(0, i);\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (temp.compareTo(ans) < 0) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0\\xA0  ans = temp;\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n**i did this**\\n**better solution is** \\n* if (k == 1) {\\n           \\xA0\\xA0 **String ans = s;\\n           \\xA0\\xA0 char ch=s.charAt(0);\\n           \\xA0\\xA0 for (int i = 1; i < s.length(); ++i) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0if(s.charAt(i)<ch){\\n                   \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0ch=s.charAt(i);\\n              \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n           \\xA0\\xA0\\xA0 }\\n           \\xA0\\xA0\\xA0\\xA0ArrayList<Integer> al=new ArrayList<>();\\n           \\xA0\\xA0\\xA0\\xA0for(int i=0;i<s.length();i++){\\n           \\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 if(s.charAt(i)==ch){\\n           \\xA0\\xA0\\xA0\\xA0        \\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0al.add(i);\\n           \\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 }\\n           \\xA0\\xA0\\xA0\\xA0}**\\n           \\xA0\\xA0\\xA0 **for (int i :al) {**\\n               \\xA0\\xA0\\xA0\\xA0\\xA0String temp = s.substring(i) + s.substring(0, i);\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0if (temp.compareTo(ans) < 0) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 ans = temp;\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n           \\xA0\\xA0\\xA0 }\\n            return ans;\\n        }\\n\\t\\t\\nInstead of seaching through all elements , we know for lexicographically smallest we need the smallest character, at the front of our new String.\\n\\t\\tso just find all occurences of the smallest character and compare (each one assumed as front). \\n\\t\\t**Eg:      \"bbcdaac\"**\\n\\t\\twe know that the  answer will only include **a** in the front  ---  **aacbbcd     or    acbbcda** are the only 2 possiblity for the best answer.   So we just compare them.\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1445861,
                "title": "python-3-clean-concise-solution-with-detail-explanation",
                "content": "The main intuition of this problem is finding that we can achieve the sorted form of the string if value of k is greater than 2\\n\\n![image](https://assets.leetcode.com/users/images/64ab1e04-296a-4e65-8768-056f6e7cb451_1630834404.4791017.png)\\n\\nTherefore, for every string s , if **k >= 2** . The final answer will be the sorted order of that string\\n\\nFor **k == 1**, we can consider every possible ways and find the solution \\n\\n![image](https://assets.leetcode.com/users/images/107307f7-b999-4fd3-988f-1ea8fa617fee_1630834518.059623.png)\\n\\n***Time complexity :*** O(n + n log n)\\n***Space complexity :*** O(1)\\n\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k==1:\\n            best = s\\n            for i in range(len(s)):\\n                cur = s[i:]+s[:i] \\n                if cur<best : best = cur\\n            return best\\n                        \\n        return \"\".join(sorted(s))\\n```\\n\\n**One liner :**\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n            return min(s[i:]+s[:i] for i in range(len(s))) if k==1 else \"\".join(sorted(s))\\n                        \\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k==1:\\n            best = s\\n            for i in range(len(s)):\\n                cur = s[i:]+s[:i] \\n                if cur<best : best = cur\\n            return best\\n                        \\n        return \"\".join(sorted(s))\\n```\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n            return min(s[i:]+s[:i] for i in range(len(s))) if k==1 else \"\".join(sorted(s))\\n                        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445795,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        // if the window(k) size is greater than 1 then just sort the string and return \\n        if(K>=2){\\n            char[] ch=S.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }else{\\n            // else form a secondary string and run a loop for the length of the original string\\n            // if the new formed string is less then update the output string\\n            String s2=S + S;\\n            for(int i=0;i<S.length();i++){\\n                String temp=s2.substring(i,i+S.length());\\n                if(S.compareTo(temp)>0)\\n                    S = temp;\\n            }\\n        }\\n        return S;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        // if the window(k) size is greater than 1 then just sort the string and return \\n        if(K>=2){\\n            char[] ch=S.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }else{\\n            // else form a secondary string and run a loop for the length of the original string\\n            // if the new formed string is less then update the output string\\n            String s2=S + S;\\n            for(int i=0;i<S.length();i++){\\n                String temp=s2.substring(i,i+S.length());\\n                if(S.compareTo(temp)>0)\\n                    S = temp;\\n            }\\n        }\\n        return S;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445646,
                "title": "python-brute-force",
                "content": "```\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \\'\\'.join(sorted(s))\\n        else:\\n            seen = set()\\n            while(s not in seen):\\n                seen.add(s)\\n                s = s[k:] + s[:k]\\n                \\n            return min(seen)\\n```",
                "solutionTags": [],
                "code": "```\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \\'\\'.join(sorted(s))\\n        else:\\n            seen = set()\\n            while(s not in seen):\\n                seen.add(s)\\n                s = s[k:] + s[:k]\\n                \\n            return min(seen)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1159319,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        string ans=S;\\n        int n=S.size()-1;\\n        if(K>1)\\n        {\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        else\\n        {\\n            for(int i=0;i<S.size();i++)\\n            {\\n                ans = min(ans , S.substr(i+1)+S.substr(0,i+1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        string ans=S;\\n        int n=S.size()-1;\\n        if(K>1)\\n        {\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        else\\n        {\\n            for(int i=0;i<S.size();i++)\\n            {\\n                ans = min(ans , S.substr(i+1)+S.substr(0,i+1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094402,
                "title": "python-o-n",
                "content": "Reverse of https://leetcode.com/problems/last-substring-in-lexicographical-order/ for K == 1\\n```\\nclass Solution:\\n    def least_rotation(self, S: str) -> int:\\n        i = 0\\n        j = 1\\n        n = len(S)\\n        S += S # avoid mod\\n        k = 0\\n        while k < n and j < n:\\n            if S[i+k] == S[j+k]:\\n                k += 1\\n                continue\\n            elif S[i+k] < S[j+k]:\\n                j = j+k+1\\n            else:\\n                i = max(j, i+k+1)\\n                j = j+1\\n            k = 0\\n        return S[i:i+n]\\n    \\n    def orderlyQueue(self, S: str, K: int) -> str:\\n        if K == 1:\\n            return self.least_rotation(S)\\n        count = Counter(S) # only english alphabets\\n        res = []\\n        for c in sorted(count):\\n            res.extend(c * count[c])\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def least_rotation(self, S: str) -> int:\\n        i = 0\\n        j = 1\\n        n = len(S)\\n        S += S # avoid mod\\n        k = 0\\n        while k < n and j < n:\\n            if S[i+k] == S[j+k]:\\n                k += 1\\n                continue\\n            elif S[i+k] < S[j+k]:\\n                j = j+k+1\\n            else:\\n                i = max(j, i+k+1)\\n                j = j+1\\n            k = 0\\n        return S[i:i+n]\\n    \\n    def orderlyQueue(self, S: str, K: int) -> str:\\n        if K == 1:\\n            return self.least_rotation(S)\\n        count = Counter(S) # only english alphabets\\n        res = []\\n        for c in sorted(count):\\n            res.extend(c * count[c])\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801049,
                "title": "4-ms-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        if(K>=2){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        string ans = S.substr(1) + S.substr(0,1);\\n        string mini = S;\\n        while(ans!=S){\\n            cout<<ans<<endl;\\n            mini = min(ans,mini);\\n            ans = ans.substr(1) + ans.substr(0,1);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        if(K>=2){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        string ans = S.substr(1) + S.substr(0,1);\\n        string mini = S;\\n        while(ans!=S){\\n            cout<<ans<<endl;\\n            mini = min(ans,mini);\\n            ans = ans.substr(1) + ans.substr(0,1);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645124,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        int n = S.length();\\n        \\n        if(n == 0){\\n            return \"\";\\n        }else if(K > 1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        \\n        vector<string> v;\\n        for(int i=0;i<n;i++){\\n            char curr = S[0];\\n            S.erase(S.begin());\\n            S += curr;\\n            v.push_back(S);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        int n = S.length();\\n        \\n        if(n == 0){\\n            return \"\";\\n        }else if(K > 1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        \\n        vector<string> v;\\n        for(int i=0;i<n;i++){\\n            char curr = S[0];\\n            S.erase(S.begin());\\n            S += curr;\\n            v.push_back(S);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601207,
                "title": "ultra-ez-c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k, string res = \"\") {\\n        if(s.size() == 1 || k == 0) return s;\\n        if(k > 1){\\n            vector<int> l(26);\\n            for(auto i : s) l[i - \\'a\\']++;\\n            for(int i = 0;i < 26;i++)\\n                for(int j = 0;j < l[i];j++)\\n                    res += i + \\'a\\';\\n            return res;\\n        }\\n        res = s;\\n        for(int i = 0;i < s.size();i++){\\n            std::rotate(s.begin(), s.begin() + 1, s.end());\\n            res = min(res, s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k, string res = \"\") {\\n        if(s.size() == 1 || k == 0) return s;\\n        if(k > 1){\\n            vector<int> l(26);\\n            for(auto i : s) l[i - \\'a\\']++;\\n            for(int i = 0;i < 26;i++)\\n                for(int j = 0;j < l[i];j++)\\n                    res += i + \\'a\\';\\n            return res;\\n        }\\n        res = s;\\n        for(int i = 0;i < s.size();i++){\\n            std::rotate(s.begin(), s.begin() + 1, s.end());\\n            res = min(res, s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475735,
                "title": "c-with-actual-string-rotations-for-k-1-and-explanation",
                "content": "/***********\\n    For any String you can move any char to anywhere if you can swap adjacent characters\\nFor any String xxx[ab]xxx you can always do\\n\\nxxx[ab]xxx\\n[ab]xxxxxx\\nxxxxxx[ba]\\nxxx[ba]xxx\\n\\nSo when we have K which is more than 1, we can possibly swap any adjacent pair of character in the string.\\nif that is possible then ascending ordered string will always be lexographically shortest string.\\nAs bubble sort relies of swapping of adjacent characters.\\n\\nTechincally we can just write function which can take any 2 adjacent character and using some kind of roatation swap them,  Thus using swap we can bubble out the largest one to the end, which is nothing but 1 step of bubble sort. Doing n square iteration we can sort them all so technically we can get the sorted string at the end\\n*****************/\\n\\n\\n\\n```\\n//Implemented using rotation of string for swapping and bubble sort\\n    void swapStr(string &S, int i) {\\n        int limit = S.length()-1;\\n        if (i-1 >= 0) {\\n            rotate(S.begin(), S.begin()+i, S.end());\\n        }\\n        rotate(S.begin()+1,S.begin()+2, S.end());\\n        rotate(S.begin(), S.begin()+1, S.end());\\n        rotate(S.begin(), S.begin()+(limit-(i+1)), S.end());\\n    }\\n    string orderlyQueue(string S, int K) {\\n         if(K > 1) {\\n            //sort(S.begin(), S.end());\\n             \\n            // Swap using bubble sort\\n            for (int i = 0; i < S.length(); i++) {\\n                bool swapDone = false;\\n                for (int j = 1; j < S.length()-i; j++) {\\n                    if (S[j-1] > S[j]) {\\n                        //swap(S[j-1],S[j]);\\n                        swapStr(S, j-1);\\n                        swapDone = true;\\n                    }\\n                }\\n                if (!swapDone) break;\\n            }\\n        } else {\\n             // rotate for all combination and pick the smallest one.\\n             // abcd will become abcdabcd , by shifting the window from b to d of size 4 \\n             // we will get all rotated variants of abcd.\\n             string allCombo = S+S;\\n             string ans = S;\\n             for (int i = 1; i < S.length(); i++) {\\n                 string rotStr = allCombo.substr(i,S.length());\\n                 if (rotStr.compare(ans) < 0) {\\n                     ans = rotStr;\\n                 }\\n             }\\n             S = ans;\\n         }\\n        return S;\\n    }",
                "solutionTags": [],
                "code": "/***********\\n    For any String you can move any char to anywhere if you can swap adjacent characters\\nFor any String xxx[ab]xxx you can always do\\n\\nxxx[ab]xxx\\n[ab]xxxxxx\\nxxxxxx[ba]\\nxxx[ba]xxx\\n\\nSo when we have K which is more than 1, we can possibly swap any adjacent pair of character in the string.\\nif that is possible then ascending ordered string will always be lexographically shortest string.\\nAs bubble sort relies of swapping of adjacent characters.\\n\\nTechincally we can just write function which can take any 2 adjacent character and using some kind of roatation swap them,  Thus using swap we can bubble out the largest one to the end, which is nothing but 1 step of bubble sort. Doing n square iteration we can sort them all so technically we can get the sorted string at the end\\n*****************/\\n\\n\\n\\n```\\n//Implemented using rotation of string for swapping and bubble sort\\n    void swapStr(string &S, int i) {\\n        int limit = S.length()-1;\\n        if (i-1 >= 0) {\\n            rotate(S.begin(), S.begin()+i, S.end());\\n        }\\n        rotate(S.begin()+1,S.begin()+2, S.end());\\n        rotate(S.begin(), S.begin()+1, S.end());\\n        rotate(S.begin(), S.begin()+(limit-(i+1)), S.end());\\n    }\\n    string orderlyQueue(string S, int K) {\\n         if(K > 1) {\\n            //sort(S.begin(), S.end());\\n             \\n            // Swap using bubble sort\\n            for (int i = 0; i < S.length(); i++) {\\n                bool swapDone = false;\\n                for (int j = 1; j < S.length()-i; j++) {\\n                    if (S[j-1] > S[j]) {\\n                        //swap(S[j-1],S[j]);\\n                        swapStr(S, j-1);\\n                        swapDone = true;\\n                    }\\n                }\\n                if (!swapDone) break;\\n            }\\n        } else {\\n             // rotate for all combination and pick the smallest one.\\n             // abcd will become abcdabcd , by shifting the window from b to d of size 4 \\n             // we will get all rotated variants of abcd.\\n             string allCombo = S+S;\\n             string ans = S;\\n             for (int i = 1; i < S.length(); i++) {\\n                 string rotStr = allCombo.substr(i,S.length());\\n                 if (rotStr.compare(ans) < 0) {\\n                     ans = rotStr;\\n                 }\\n             }\\n             S = ans;\\n         }\\n        return S;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 474642,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public string OrderlyQueue(string S, int K) \\n    {\\n        if(K > 1)\\n        {\\n            var charArray = S.ToCharArray();\\n            Array.Sort(charArray);\\n            return new string(charArray);\\n        }\\n        \\n        var result = S;\\n        for(int i = 0; i < S.Length; i++)\\n        {\\n            var newString = S.Substring(i) + S.Substring(0, i);\\n            if(newString.CompareTo(result) < 0)\\n                result = newString;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public string OrderlyQueue(string S, int K) \\n    {\\n        if(K > 1)\\n        {\\n            var charArray = S.ToCharArray();\\n            Array.Sort(charArray);\\n            return new string(charArray);\\n        }\\n        \\n        var result = S;\\n        for(int i = 0; i < S.Length; i++)\\n        {\\n            var newString = S.Substring(i) + S.Substring(0, i);\\n            if(newString.CompareTo(result) < 0)\\n                result = newString;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328417,
                "title": "better-explanation-java-beat-100-from-every-aspects",
                "content": "Please follow the code for explanation \\n\\n```\\n  public String orderlyQueue(String S, int K) {\\n        return beat100Percent(S, K);\\n\\n    }\\n\\n\\n    private String bitSlow(String S, int K) {\\n        if (K == 1) {\\n            String res = S;\\n            for (int i = 0; i < S.length(); ++i) {\\n                String t = S.substring(i) + S.substring(0, i);\\n                if (t.compareTo(res) < 0) res = t;\\n            }\\n            return res;\\n        } else {\\n            char[] ca = S.toCharArray();\\n            Arrays.sort(ca);\\n            return new String(ca);\\n        }\\n    }\\n\\n    private String beat100Percent(String S, int K) {\\n        if (S == null || S.isEmpty())\\n            return S;\\n\\n        if (K == 1)\\n            //This is nothing but finding the string after each rotation and comparing it with best so far\\n            return lexicographicallySmallestRotatedSequence(S);\\n        else {\\n            /**\\n             Lets understand this case when we can choose any of the first k letter;\\n             lets take a example to understand:\\n             bdac ; k=2\\n             bdac, select d (second letter)\\n             bacd, select a (second letter)\\n             bcda, select b (first letter)\\n             cdab, select c (first letter)\\n             dabc, select d (first letter)\\n             abcd\\n\\n             So what we were essentially doing above? can you notice any pattern?\\n             Yes, we are somewhat sorting the letters, why? because we have capbability to push any\\n             first k character to end of the string.\\n             This makes generating all the combination/permutation of given string by choosing any of the                 first k letters.\\n             To understand better, please try k=3 in above example; you\\'ll notice in somewhat it won\\'t matter\\n             because at the end you\\'ll reach sorted order of chars to make smallest string\\n             **/\\n            char c[] = S.toCharArray();\\n            Arrays.sort(c);\\n            return new String(c);\\n        }\\n    }\\n\\n    /**\\n     * O(n^2 )\\n     *\\n     * @param str\\n     * @return\\n     */\\n    private String lexicographicallySmallestRotatedSequence(String str) {\\n        if (str == null || str.isEmpty())\\n            return str;\\n\\n        int smallestStringIndex = 0;\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            if (isSmallest(str, smallestStringIndex, i)) smallestStringIndex = i;\\n\\n        }\\n        if (smallestStringIndex == 0)\\n            return str;\\n\\n        return str.substring(smallestStringIndex) + str.substring(0, smallestStringIndex);\\n    }\\n\\n    /**\\n     * This guy makes things faster, notice it\\n     * if we use inbuilt string comparision, then it will iterate whole string regardless, but this will\\n     * throw answer as quick as possible\\n     * check string start from x and string start from y; find the smallest between them\\n     *\\n     * @param str\\n     * @param x\\n     * @param y\\n     * @return\\n     */\\n    private boolean isSmallest(String str, int x, int y) {\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            if (str.charAt(x) < str.charAt(y))\\n                return false;\\n\\n            if (str.charAt(x) > str.charAt(y))\\n                return true;\\n\\n            x = (x + 1) % str.length();\\n            y = (y + 1) % str.length();\\n\\n\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String orderlyQueue(String S, int K) {\\n        return beat100Percent(S, K);\\n\\n    }\\n\\n\\n    private String bitSlow(String S, int K) {\\n        if (K == 1) {\\n            String res = S;\\n            for (int i = 0; i < S.length(); ++i) {\\n                String t = S.substring(i) + S.substring(0, i);\\n                if (t.compareTo(res) < 0) res = t;\\n            }\\n            return res;\\n        } else {\\n            char[] ca = S.toCharArray();\\n            Arrays.sort(ca);\\n            return new String(ca);\\n        }\\n    }\\n\\n    private String beat100Percent(String S, int K) {\\n        if (S == null || S.isEmpty())\\n            return S;\\n\\n        if (K == 1)\\n            //This is nothing but finding the string after each rotation and comparing it with best so far\\n            return lexicographicallySmallestRotatedSequence(S);\\n        else {\\n            /**\\n             Lets understand this case when we can choose any of the first k letter;\\n             lets take a example to understand:\\n             bdac ; k=2\\n             bdac, select d (second letter)\\n             bacd, select a (second letter)\\n             bcda, select b (first letter)\\n             cdab, select c (first letter)\\n             dabc, select d (first letter)\\n             abcd\\n\\n             So what we were essentially doing above? can you notice any pattern?\\n             Yes, we are somewhat sorting the letters, why? because we have capbability to push any\\n             first k character to end of the string.\\n             This makes generating all the combination/permutation of given string by choosing any of the                 first k letters.\\n             To understand better, please try k=3 in above example; you\\'ll notice in somewhat it won\\'t matter\\n             because at the end you\\'ll reach sorted order of chars to make smallest string\\n             **/\\n            char c[] = S.toCharArray();\\n            Arrays.sort(c);\\n            return new String(c);\\n        }\\n    }\\n\\n    /**\\n     * O(n^2 )\\n     *\\n     * @param str\\n     * @return\\n     */\\n    private String lexicographicallySmallestRotatedSequence(String str) {\\n        if (str == null || str.isEmpty())\\n            return str;\\n\\n        int smallestStringIndex = 0;\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            if (isSmallest(str, smallestStringIndex, i)) smallestStringIndex = i;\\n\\n        }\\n        if (smallestStringIndex == 0)\\n            return str;\\n\\n        return str.substring(smallestStringIndex) + str.substring(0, smallestStringIndex);\\n    }\\n\\n    /**\\n     * This guy makes things faster, notice it\\n     * if we use inbuilt string comparision, then it will iterate whole string regardless, but this will\\n     * throw answer as quick as possible\\n     * check string start from x and string start from y; find the smallest between them\\n     *\\n     * @param str\\n     * @param x\\n     * @param y\\n     * @return\\n     */\\n    private boolean isSmallest(String str, int x, int y) {\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            if (str.charAt(x) < str.charAt(y))\\n                return false;\\n\\n            if (str.charAt(x) > str.charAt(y))\\n                return true;\\n\\n            x = (x + 1) % str.length();\\n            y = (y + 1) % str.length();\\n\\n\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167251,
                "title": "2-lines-python-solution",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, S, K):\\n        if K > 1: return \\'\\'.join(sorted(S))\\n        else: return \\'\\'.join(min([S[i:] + S[:i] for i in range(len(S))]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, S, K):\\n        if K > 1: return \\'\\'.join(sorted(S))\\n        else: return \\'\\'.join(min([S[i:] + S[:i] for i in range(len(S))]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165938,
                "title": "really-tricky",
                "content": "When `K > 1`, we can always get the maximum lexicographically order.\\n\\n```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if (K == 1) {\\n            String result = S;\\n            for (int i = 1; i < S.length(); i++) {\\n                String temp = S.substring(i) + S.substring(0, i);\\n                if (temp.compareTo(result) < 0) {\\n                    result = temp;\\n                }\\n            }\\n            return result;\\n        } else {\\n            char[] cs = S.toCharArray();\\n            Arrays.sort(cs);\\n            return new String(cs);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if (K == 1) {\\n            String result = S;\\n            for (int i = 1; i < S.length(); i++) {\\n                String temp = S.substring(i) + S.substring(0, i);\\n                if (temp.compareTo(result) < 0) {\\n                    result = temp;\\n                }\\n            }\\n            return result;\\n        } else {\\n            char[] cs = S.toCharArray();\\n            Arrays.sort(cs);\\n            return new String(cs);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081230,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String result = s;\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length() - 1; ++i) {\\n                sb.append(sb.charAt(0)).deleteCharAt(0);\\n                if (sb.toString().compareTo(result) < 0) {\\n                    result = sb.toString();\\n                }\\n            }\\n            return result;\\n        }\\n        char[] x = s.toCharArray();\\n        Arrays.sort(x);\\n        return String.valueOf(x);\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        //if k>1 , sort the string \\n        if(k>1){\\n            sort(s.begin(),s.end()); \\n            return s;\\n        }\\n        string ans=s;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            s+=s[i]; //append char to the end\\n            string str=s.substr(i+1);\\n            if(str<ans) ans=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String result = s;\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length() - 1; ++i) {\\n                sb.append(sb.charAt(0)).deleteCharAt(0);\\n                if (sb.toString().compareTo(result) < 0) {\\n                    result = sb.toString();\\n                }\\n            }\\n            return result;\\n        }\\n        char[] x = s.toCharArray();\\n        Arrays.sort(x);\\n        return String.valueOf(x);\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        //if k>1 , sort the string \\n        if(k>1){\\n            sort(s.begin(),s.end()); \\n            return s;\\n        }\\n        string ans=s;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            s+=s[i]; //append char to the end\\n            string str=s.substr(i+1);\\n            if(str<ans) ans=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060643,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function (s, k) {\\n    // initialize string s to str\\n    let str = s;\\n\\n    // if k is equal to 1\\n    if (k === 1) {\\n\\n        // initialize length len to length of string s\\n        let len = s.length;\\n\\n        // loop through the 0 to length len\\n        for (let i = 0; i < len; i++) {\\n\\n            // initialize firstChar to the first character of string s\\n            let firstChar = s[0];\\n\\n            // copy all character of string s except first character using subString() and add first character at last and assign the string to s\\n            s = s.substring(1, len) + firstChar;\\n\\n            // if string s is less than string str then assign string s to string str\\n            if (s < str) {\\n                str = s;\\n            }\\n\\n        }\\n\\n        // return string str\\n        return str;\\n    }\\n\\n    // return sort value of string s by using split(), sort() and join()\\n    return s.split(\\'\\').sort().join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function (s, k) {\\n    // initialize string s to str\\n    let str = s;\\n\\n    // if k is equal to 1\\n    if (k === 1) {\\n\\n        // initialize length len to length of string s\\n        let len = s.length;\\n\\n        // loop through the 0 to length len\\n        for (let i = 0; i < len; i++) {\\n\\n            // initialize firstChar to the first character of string s\\n            let firstChar = s[0];\\n\\n            // copy all character of string s except first character using subString() and add first character at last and assign the string to s\\n            s = s.substring(1, len) + firstChar;\\n\\n            // if string s is less than string str then assign string s to string str\\n            if (s < str) {\\n                str = s;\\n            }\\n\\n        }\\n\\n        // return string str\\n        return str;\\n    }\\n\\n    // return sort value of string s by using split(), sort() and join()\\n    return s.split(\\'\\').sort().join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016739,
                "title": "beats-100-easy-to-understand-c",
                "content": "This question can be solved by bifurcating it in 2 cases:\\n* When K = 1, then traverse the whole string removing the 1st element and appending it to the last. After each iteration compare the strings, the smallest lexicographically string would be our answer. \\n* For K > 1, You can always arrive at the sorted string. Think of it using an example. We can choose one of the first **k** letters of **s** and append it at the end of the string. We will always choose the smallest letter and append it to the end so that after the rotation it would become the first element. The string might take more than one pass to get sorted.\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n = s.size();\\n        if(k > 1){\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string ans = s;\\n        for(int i = 0; i < n; i++){\\n            char a = s[0];\\n            s.erase(s.begin());\\n            s += a;\\n            ans = min(ans, s);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThanks for reading and Happy Coding!!!",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n = s.size();\\n        if(k > 1){\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string ans = s;\\n        for(int i = 0; i < n; i++){\\n            char a = s[0];\\n            s.erase(s.begin());\\n            s += a;\\n            ans = min(ans, s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929732,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){\\n        char []arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        }\\n            String str=s;\\n            for(int i=0;i<s.length();i++){\\n                String st=s.substring(i)+s.substring(0,i);\\n                if(str.compareTo(st)>0){\\n                    str=st;\\n                }\\n            }\\n        \\n\\n        return str;\\n    }\\n    \\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){\\n        char []arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        }\\n            String str=s;\\n            for(int i=0;i<s.length();i++){\\n                String st=s.substring(i)+s.substring(0,i);\\n                if(str.compareTo(st)>0){\\n                    str=st;\\n                }\\n            }\\n        \\n\\n        return str;\\n    }\\n    \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866577,
                "title": "python-easy-solution",
                "content": "# Intuition\\nThink like selecting any two elements and sorting\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        # basically if we have k > 1 it means we have to sort the sting as final result after all\\n        # moveement will be same as sorting.\\n        # question can be also treated as swap any two elements\\n        s_list = list(s)\\n        if k > 1:\\n            s_list.sort()\\n            return \"\".join(s_list)\\n\\n        result = s\\n        if k == 1: # we have to move all the elements ony by one and return min of all\\n            for i in range(1,len(s)+1):\\n                temp_str = s[i:] + s[0:i]\\n                print(temp_str)\\n                result = min(result,temp_str)\\n                print\\n        return result\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        # basically if we have k > 1 it means we have to sort the sting as final result after all\\n        # moveement will be same as sorting.\\n        # question can be also treated as swap any two elements\\n        s_list = list(s)\\n        if k > 1:\\n            s_list.sort()\\n            return \"\".join(s_list)\\n\\n        result = s\\n        if k == 1: # we have to move all the elements ony by one and return min of all\\n            for i in range(1,len(s)+1):\\n                temp_str = s[i:] + s[0:i]\\n                print(temp_str)\\n                result = min(result,temp_str)\\n                print\\n        return result\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832074,
                "title": "java-easy-solution-beat-99",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1)\\n        {\\n            char []dee = s.toCharArray();\\n            Arrays.sort(dee);\\n            return new String(dee);\\n        }\\n        String ans = s ;\\n        for(int i=0;i<s.length();i++)\\n        {\\n             s=s.substring(1)+s.substring(0,1);\\n            if(ans.compareTo(s)>0)\\n            {\\n                ans=s;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1)\\n        {\\n            char []dee = s.toCharArray();\\n            Arrays.sort(dee);\\n            return new String(dee);\\n        }\\n        String ans = s ;\\n        for(int i=0;i<s.length();i++)\\n        {\\n             s=s.substring(1)+s.substring(0,1);\\n            if(ans.compareTo(s)>0)\\n            {\\n                ans=s;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767461,
                "title": "ez-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1) {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        string s_min = s;\\n        for(int i = 0 ;i<s.length();i++){\\n            s =  s.substr(1) + s[0];\\n            s_min = min(s_min,s);\\n        }\\n        return s_min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1) {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        string s_min = s;\\n        for(int i = 0 ;i<s.length();i++){\\n            s =  s.substr(1) + s[0];\\n            s_min = min(s_min,s);\\n        }\\n        return s_min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764557,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        \\n        if(k>1){\\n            char chararr[] = s.toCharArray();\\n            Arrays.sort(chararr);\\n            return new String(chararr);\\n        }\\n\\n        else{\\n            String str = s;\\n\\n            for(int i=0; i<s.length(); i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(str.compareTo(s)>0){\\n                    str = s;\\n                }\\n            }\\n\\n            return str;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        \\n        if(k>1){\\n            char chararr[] = s.toCharArray();\\n            Arrays.sort(chararr);\\n            return new String(chararr);\\n        }\\n\\n        else{\\n            String str = s;\\n\\n            for(int i=0; i<s.length(); i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(str.compareTo(s)>0){\\n                    str = s;\\n                }\\n            }\\n\\n            return str;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1673166,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673181,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1572119,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1674194,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1569287,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673742,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1572854,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1569286,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1867848,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1675184,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673166,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673181,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1572119,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1674194,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1569287,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673742,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1572854,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1569286,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1867848,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1675184,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            }
        ]
    }
]